<!DOCTYPE html>
<html>
<head>
<title>Rust Compiler Error Index</title>
<meta charset="utf-8">
<!-- Include rust.css after main.css so its rules take priority. -->
<link rel="stylesheet" type="text/css" href="main.css"/>
<link rel="stylesheet" type="text/css" href="rust.css"/>
<style>
.error-undescribed {
    display: none;
}
</style>
</head>
<body>
<h1>Rust Compiler Error Index</h1>
<div class="error-described error-used"><h2 id="E0001" class="section-header"><a href="#E0001">E0001</a></h2>
<p>This error suggests that the expression arm corresponding to the noted pattern
will never be reached as for all possible values of the expression being
matched, one of the preceding patterns will match.</p>

<p>This means that perhaps some of the preceding patterns are too general, this one
is too specific or the ordering is incorrect.</p>
</div>
<div class="error-described error-used"><h2 id="E0002" class="section-header"><a href="#E0002">E0002</a></h2>
<p>This error indicates that an empty match expression is illegal because the type
it is matching on is non-empty (there exist values of this type). In safe code
it is impossible to create an instance of an empty type, so empty match
expressions are almost never desired.  This error is typically fixed by adding
one or more cases to the match expression.</p>

<p>An example of an empty type is <code>enum Empty { }</code>.</p>
</div>
<div class="error-described error-used"><h2 id="E0003" class="section-header"><a href="#E0003">E0003</a></h2>
<p>Not-a-Number (NaN) values cannot be compared for equality and hence can never
match the input to a match expression. To match against NaN values, you should
instead use the <code>is_nan</code> method in a guard, as in: <code>x if x.is_nan() =&gt; ...</code></p>
</div>
<div class="error-described error-used"><h2 id="E0004" class="section-header"><a href="#E0004">E0004</a></h2>
<p>This error indicates that the compiler cannot guarantee a matching pattern for
one or more possible inputs to a match expression. Guaranteed matches are
required in order to assign values to match expressions, or alternatively,
determine the flow of execution.</p>

<p>If you encounter this error you must alter your patterns so that every possible
value of the input type is matched. For types with a small number of variants
(like enums) you should probably cover all cases explicitly. Alternatively, the
underscore <code>_</code> wildcard pattern can be added after all other patterns to match
&quot;anything else&quot;.</p>
</div>
<div class="error-described error-used"><h2 id="E0005" class="section-header"><a href="#E0005">E0005</a></h2>
<p>Patterns used to bind names must be irrefutable, that is, they must guarantee
that a name will be extracted in all cases. If you encounter this error you
probably need to use a <code>match</code> or <code>if let</code> to deal with the possibility of
failure.</p>
</div>
<div class="error-described error-used"><h2 id="E0006" class="section-header"><a href="#E0006">E0006</a></h2>
<p>Patterns used to bind names must be irrefutable, that is, they must guarantee
that a name will be extracted in all cases. If you encounter this error you
probably need to use a <code>match</code> or <code>if let</code> to deal with the possibility of
failure.</p>
</div>
<div class="error-described error-used"><h2 id="E0007" class="section-header"><a href="#E0007">E0007</a></h2>
<p>This error indicates that the bindings in a match arm would require a value to
be moved into more than one location, thus violating unique ownership. Code like
the following is invalid as it requires the entire <code>Option&lt;String&gt;</code> to be moved
into a variable called <code>op_string</code> while simultaneously requiring the inner
String to be moved into a variable called <code>s</code>.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>(<span class='string'>&quot;s&quot;</span>.<span class='ident'>to_string</span>());
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='ident'>op_string</span> <span class='kw-2'>@</span> <span class='prelude-val'>Some</span>(<span class='ident'>s</span>) <span class='op'>=&gt;</span> ...
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> ...
}
</pre>

<p>See also Error 303.</p>
</div>
<div class="error-described error-used"><h2 id="E0008" class="section-header"><a href="#E0008">E0008</a></h2>
<p>Names bound in match arms retain their type in pattern guards. As such, if a
name is bound by move in a pattern, it should also be moved to wherever it is
referenced in the pattern guard code. Doing so however would prevent the name
from being available in the body of the match arm. Consider the following:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(<span class='string'>&quot;hi&quot;</span>.<span class='ident'>to_string</span>()) {
    <span class='prelude-val'>Some</span>(<span class='ident'>s</span>) <span class='kw'>if</span> <span class='ident'>s</span>.<span class='ident'>len</span>() <span class='op'>==</span> <span class='number'>0</span> <span class='op'>=&gt;</span> <span class='comment'>// use s.</span>
    ...
}
</pre>

<p>The variable <code>s</code> has type <code>String</code>, and its use in the guard is as a variable of
type <code>String</code>. The guard code effectively executes in a separate scope to the
body of the arm, so the value would be moved into this anonymous scope and
therefore become unavailable in the body of the arm. Although this example seems
innocuous, the problem is most clear when considering functions that take their
argument by value.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(<span class='string'>&quot;hi&quot;</span>.<span class='ident'>to_string</span>()) {
    <span class='prelude-val'>Some</span>(<span class='ident'>s</span>) <span class='kw'>if</span> { <span class='ident'>drop</span>(<span class='ident'>s</span>); <span class='boolval'>false</span> } <span class='op'>=&gt;</span> (),
    <span class='prelude-val'>Some</span>(<span class='ident'>s</span>) <span class='op'>=&gt;</span> <span class='comment'>// use s.</span>
    ...
}
</pre>

<p>The value would be dropped in the guard then become unavailable not only in the
body of that arm but also in all subsequent arms! The solution is to bind by
reference when using guards or refactor the entire expression, perhaps by
putting the condition inside the body of the arm.</p>
</div>
<div class="error-described error-used"><h2 id="E0009" class="section-header"><a href="#E0009">E0009</a></h2>
<p>In a pattern, all values that don&#39;t implement the <code>Copy</code> trait have to be bound
the same way. The goal here is to avoid binding simultaneously by-move and
by-ref.</p>

<p>This limitation may be removed in a future version of Rust.</p>

<p>Wrong example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>X</span> { <span class='ident'>x</span>: (), }

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>((<span class='ident'>X</span> { <span class='ident'>x</span>: () }, <span class='ident'>X</span> { <span class='ident'>x</span>: () }));
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='prelude-val'>Some</span>((<span class='ident'>y</span>, <span class='kw-2'>ref</span> <span class='ident'>z</span>)) <span class='op'>=&gt;</span> {},
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>()
}
</pre>

<p>You have two solutions:</p>

<p>Solution #1: Bind the pattern&#39;s values the same way.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>X</span> { <span class='ident'>x</span>: (), }

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>((<span class='ident'>X</span> { <span class='ident'>x</span>: () }, <span class='ident'>X</span> { <span class='ident'>x</span>: () }));
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='prelude-val'>Some</span>((<span class='kw-2'>ref</span> <span class='ident'>y</span>, <span class='kw-2'>ref</span> <span class='ident'>z</span>)) <span class='op'>=&gt;</span> {},
    <span class='comment'>// or Some((y, z)) =&gt; {}</span>
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>()
}
</pre>

<p>Solution #2: Implement the <code>Copy</code> trait for the <code>X</code> structure.</p>

<p>However, please keep in mind that the first solution should be preferred.</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Clone</span>, <span class='ident'>Copy</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>X</span> { <span class='ident'>x</span>: (), }

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>((<span class='ident'>X</span> { <span class='ident'>x</span>: () }, <span class='ident'>X</span> { <span class='ident'>x</span>: () }));
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='prelude-val'>Some</span>((<span class='ident'>y</span>, <span class='kw-2'>ref</span> <span class='ident'>z</span>)) <span class='op'>=&gt;</span> {},
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>()
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0010" class="section-header"><a href="#E0010">E0010</a></h2>
<p>The value of statics and constants must be known at compile time, and they live
for the entire lifetime of a program. Creating a boxed value allocates memory on
the heap at runtime, and therefore cannot be done at compile time.</p>
</div>
<div class="error-described error-used"><h2 id="E0011" class="section-header"><a href="#E0011">E0011</a></h2>
<p>Initializers for constants and statics are evaluated at compile time.
User-defined operators rely on user-defined functions, which cannot be evaluated
at compile time.</p>

<p>Bad example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Index</span>;

<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>: <span class='ident'>u8</span> }

<span class='kw'>impl</span> <span class='ident'>Index</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>u8</span>;

    <span class='kw'>fn</span> <span class='ident'>index</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='self'>self</span>, <span class='ident'>idx</span>: <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>u8</span> { <span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>a</span> }
}

<span class='kw'>const</span> <span class='ident'>a</span>: <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>: <span class='number'>0u8</span> };
<span class='kw'>const</span> <span class='ident'>b</span>: <span class='ident'>u8</span> <span class='op'>=</span> <span class='ident'>a</span>[<span class='number'>0</span>]; <span class='comment'>// Index trait is defined by the user, bad!</span>
</pre>

<p>Only operators on builtin types are allowed.</p>

<p>Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>a</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> [<span class='ident'>i32</span>] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>const</span> <span class='ident'>b</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>a</span>[<span class='number'>0</span>]; <span class='comment'>// Good!</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0013" class="section-header"><a href="#E0013">E0013</a></h2>
<p>Static and const variables can refer to other const variables. But a const
variable cannot refer to a static variable. For example, <code>Y</code> cannot refer to <code>X</code>
here:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>static</span> <span class='ident'>X</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>const</span> <span class='ident'>Y</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>X</span>;
</pre>

<p>To fix this, the value can be extracted as a const and then used:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>A</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>static</span> <span class='ident'>X</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>A</span>;
<span class='kw'>const</span> <span class='ident'>Y</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>A</span>;
</pre>
</div>
<div class="error-described error-used"><h2 id="E0014" class="section-header"><a href="#E0014">E0014</a></h2>
<p>Constants can only be initialized by a constant value or, in a future
version of Rust, a call to a const function. This error indicates the use
of a path (like a::b, or x) denoting something other than one of these
allowed items. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>i32</span> <span class='op'>=</span> { <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='ident'>x</span> }; <span class='comment'>// &#39;x&#39; isn&#39;t a constant nor a function!</span>
</pre>

<p>To avoid it, you have to replace the non-constant value:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>i32</span> <span class='op'>=</span> { <span class='kw'>const</span> <span class='ident'>X</span> : <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='ident'>X</span> };
<span class='comment'>// or even:</span>
<span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>i32</span> <span class='op'>=</span> { <span class='number'>0</span> }; <span class='comment'>// but brackets are useless here</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0015" class="section-header"><a href="#E0015">E0015</a></h2>
<p>The only functions that can be called in static or constant expressions are
<code>const</code> functions. Rust currently does not support more general compile-time
function execution.</p>

<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md">RFC 911</a> for more details on the design of <code>const fn</code>s.</p>
</div>
<div class="error-described error-used"><h2 id="E0016" class="section-header"><a href="#E0016">E0016</a></h2>
<p>Blocks in constants may only contain items (such as constant, function
definition, etc...) and a tail expression. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>i32</span> <span class='op'>=</span> { <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='ident'>x</span> }; <span class='comment'>// &#39;x&#39; isn&#39;t an item!</span>
</pre>

<p>To avoid it, you have to replace the non-item object:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>i32</span> <span class='op'>=</span> { <span class='kw'>const</span> <span class='ident'>X</span> : <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='ident'>X</span> };
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0017" class="section-header"><a href="#E0017">E0017</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0018" class="section-header"><a href="#E0018">E0018</a></h2>
<p>The value of static and const variables must be known at compile time. You
can&#39;t cast a pointer as an integer because we can&#39;t know what value the
address will take.</p>

<p>However, pointers to other constants&#39; addresses are allowed in constants,
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>50</span>;
<span class='kw'>const</span> <span class='ident'>Y</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>X</span>;
</pre>

<p>Therefore, casting one of these non-constant pointers to an integer results
in a non-constant integer which lead to this error. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>1</span>;
<span class='kw'>const</span> <span class='ident'>Y</span>: <span class='ident'>usize</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>X</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span> <span class='kw'>as</span> <span class='ident'>usize</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>Y</span>);
</pre>
</div>
<div class="error-described error-used"><h2 id="E0019" class="section-header"><a href="#E0019">E0019</a></h2>
<p>A function call isn&#39;t allowed in the const&#39;s initialization expression
because the expression&#39;s value must be known at compile-time. Example of
erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Test</span> {
    <span class='ident'>V1</span>
}

<span class='kw'>impl</span> <span class='ident'>Test</span> {
    <span class='kw'>fn</span> <span class='ident'>test</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
        <span class='number'>12</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>Test</span> <span class='op'>=</span> <span class='ident'>Test</span>::<span class='ident'>V1</span>;

    <span class='kw'>const</span> <span class='ident'>A</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>FOO</span>.<span class='ident'>test</span>(); <span class='comment'>// You can&#39;t call Test::func() here !</span>
}
</pre>

<p>Remember: you can&#39;t use a function call inside a const&#39;s initialization
expression! However, you can totally use it elsewhere you want:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>Test</span> <span class='op'>=</span> <span class='ident'>Test</span>::<span class='ident'>V1</span>;

    <span class='ident'>FOO</span>.<span class='ident'>func</span>(); <span class='comment'>// here is good</span>
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>FOO</span>.<span class='ident'>func</span>(); <span class='comment'>// or even here!</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0020" class="section-header"><a href="#E0020">E0020</a></h2>
<p>This error indicates that an attempt was made to divide by zero (or take the
remainder of a zero divisor) in a static or constant expression.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0022" class="section-header"><a href="#E0022">E0022</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0023" class="section-header"><a href="#E0023">E0023</a></h2>
<p>A pattern used to match against an enum variant must provide a sub-pattern for
each field of the enum variant. This error indicates that a pattern attempted to
extract an incorrect number of fields from a variant.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Fruit</span> {
    <span class='ident'>Apple</span>(<span class='ident'>String</span>, <span class='ident'>String</span>)
    <span class='ident'>Pear</span>(<span class='ident'>u32</span>)
}
</pre>

<p>Here the <code>Apple</code> variant has two fields, and should be matched against like so:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Correct.</span>
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='ident'>Apple</span>(<span class='ident'>a</span>, <span class='ident'>b</span>) <span class='op'>=&gt;</span> ...
}
</pre>

<p>Matching with the wrong number of fields has no sensible interpretation:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Incorrect.</span>
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='ident'>Apple</span>(<span class='ident'>a</span>) <span class='op'>=&gt;</span> ...,
    <span class='ident'>Apple</span>(<span class='ident'>a</span>, <span class='ident'>b</span>, <span class='ident'>c</span>) <span class='op'>=&gt;</span> ...
}
</pre>

<p>Check how many fields the enum was declared with and ensure that your pattern
uses the same number.</p>
</div>
<div class="error-described error-used"><h2 id="E0024" class="section-header"><a href="#E0024">E0024</a></h2>
<p>This error indicates that a pattern attempted to extract the fields of an enum
variant with no fields. Here&#39;s a tiny example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// This enum has two variants.</span>
<span class='kw'>enum</span> <span class='ident'>Number</span> {
    <span class='comment'>// This variant has no fields.</span>
    <span class='ident'>Zero</span>,
    <span class='comment'>// This variant has one field.</span>
    <span class='ident'>One</span>(<span class='ident'>u32</span>)
}

<span class='comment'>// Assuming x is a Number we can pattern match on its contents.</span>
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='ident'>Zero</span>(<span class='ident'>inside</span>) <span class='op'>=&gt;</span> ...,
    <span class='ident'>One</span>(<span class='ident'>inside</span>) <span class='op'>=&gt;</span> ...
}
</pre>

<p>The pattern match <code>Zero(inside)</code> is incorrect because the <code>Zero</code> variant
contains no fields, yet the <code>inside</code> name attempts to bind the first field of
the enum.</p>
</div>
<div class="error-described error-used"><h2 id="E0025" class="section-header"><a href="#E0025">E0025</a></h2>
<p>Each field of a struct can only be bound once in a pattern. Each occurrence of a
field name binds the value of that field, so to fix this error you will have to
remove or alter the duplicate uses of the field name. Perhaps you misspelt
another field name?</p>
</div>
<div class="error-described error-used"><h2 id="E0026" class="section-header"><a href="#E0026">E0026</a></h2>
<p>This error indicates that a struct pattern attempted to extract a non-existant
field from a struct. Struct fields are identified by the name used before the
colon <code>:</code> so struct patterns should resemble the declaration of the struct type
being matched.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Correct matching.</span>
<span class='kw'>struct</span> <span class='ident'>Thing</span> {
    <span class='ident'>x</span>: <span class='ident'>u32</span>,
    <span class='ident'>y</span>: <span class='ident'>u32</span>
}

<span class='kw'>let</span> <span class='ident'>thing</span> <span class='op'>=</span> <span class='ident'>Thing</span> { <span class='ident'>x</span>: <span class='number'>1</span>, <span class='ident'>y</span>: <span class='number'>2</span> };
<span class='kw'>match</span> <span class='ident'>thing</span> {
    <span class='ident'>Thing</span> { <span class='ident'>x</span>: <span class='ident'>xfield</span>, <span class='ident'>y</span>: <span class='ident'>yfield</span> } <span class='op'>=&gt;</span> ...
}
</pre>

<p>If you are using shorthand field patterns but want to refer to the struct field
by a different name, you should rename it explicitly.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Change this:</span>
<span class='kw'>match</span> <span class='ident'>thing</span> {
    <span class='ident'>Thing</span> { <span class='ident'>x</span>, <span class='ident'>z</span> } <span class='op'>=&gt;</span> ...
}

<span class='comment'>// To this:</span>
<span class='kw'>match</span> <span class='ident'>thing</span> {
    <span class='ident'>Thing</span> { <span class='ident'>x</span>, <span class='ident'>y</span>: <span class='ident'>z</span> } <span class='op'>=&gt;</span> ...
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0027" class="section-header"><a href="#E0027">E0027</a></h2>
<p>This error indicates that a pattern for a struct fails to specify a sub-pattern
for every one of the struct&#39;s fields. Ensure that each field from the struct&#39;s
definition is mentioned in the pattern, or use <code>..</code> to ignore unwanted fields.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Dog</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
    <span class='ident'>age</span>: <span class='ident'>u32</span>
}

<span class='kw'>let</span> <span class='ident'>d</span> <span class='op'>=</span> <span class='ident'>Dog</span> { <span class='ident'>name</span>: <span class='string'>&quot;Rusty&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>8</span> };

<span class='comment'>// This is incorrect.</span>
<span class='kw'>match</span> <span class='ident'>d</span> {
    <span class='ident'>Dog</span> { <span class='ident'>age</span>: <span class='ident'>x</span> } <span class='op'>=&gt;</span> ...
}

<span class='comment'>// This is correct (explicit).</span>
<span class='kw'>match</span> <span class='ident'>d</span> {
    <span class='ident'>Dog</span> { <span class='ident'>name</span>: <span class='ident'>n</span>, <span class='ident'>age</span>: <span class='ident'>x</span> } <span class='op'>=&gt;</span> ...
}

<span class='comment'>// This is also correct (ignore unused fields).</span>
<span class='kw'>match</span> <span class='ident'>d</span> {
    <span class='ident'>Dog</span> { <span class='ident'>age</span>: <span class='ident'>x</span>, .. } <span class='op'>=&gt;</span> ...
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0029" class="section-header"><a href="#E0029">E0029</a></h2>
<p>In a match expression, only numbers and characters can be matched against a
range. This is because the compiler checks that the range is non-empty at
compile-time, and is unable to evaluate arbitrary comparison functions. If you
want to capture values of an orderable type between two end-points, you can use
a guard.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// The ordering relation for strings can&#39;t be evaluated at compile time,</span>
<span class='comment'>// so this doesn&#39;t work:</span>
<span class='kw'>match</span> <span class='ident'>string</span> {
    <span class='string'>&quot;hello&quot;</span> ... <span class='string'>&quot;world&quot;</span> <span class='op'>=&gt;</span> ...
    _ <span class='op'>=&gt;</span> ...
}

<span class='comment'>// This is a more general version, using a guard:</span>
<span class='kw'>match</span> <span class='ident'>string</span> {
    <span class='ident'>s</span> <span class='kw'>if</span> <span class='ident'>s</span> <span class='op'>&gt;=</span> <span class='string'>&quot;hello&quot;</span> <span class='op'>&amp;&amp;</span> <span class='ident'>s</span> <span class='op'>&lt;=</span> <span class='string'>&quot;world&quot;</span> <span class='op'>=&gt;</span> ...
    _ <span class='op'>=&gt;</span> ...
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0030" class="section-header"><a href="#E0030">E0030</a></h2>
<p>When matching against a range, the compiler verifies that the range is
non-empty.  Range patterns include both end-points, so this is equivalent to
requiring the start of the range to be less than or equal to the end of the
range.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='number'>5u32</span> {
    <span class='comment'>// This range is ok, albeit pointless.</span>
    <span class='number'>1</span> ... <span class='number'>1</span> <span class='op'>=&gt;</span> ...
    <span class='comment'>// This range is empty, and the compiler can tell.</span>
    <span class='number'>1000</span> ... <span class='number'>5</span> <span class='op'>=&gt;</span> ...
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0033" class="section-header"><a href="#E0033">E0033</a></h2>
<p>This error indicates that a pointer to a trait type cannot be implicitly
dereferenced by a pattern. Every trait defines a type, but because the
size of trait implementors isn&#39;t fixed, this type has no compile-time size.
Therefore, all accesses to trait types must be through pointers. If you
encounter this error you should try to avoid dereferencing the pointer.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>trait_obj</span>: <span class='kw-2'>&amp;</span><span class='ident'>SomeTrait</span> <span class='op'>=</span> ...;

<span class='comment'>// This tries to implicitly dereference to create an unsized local variable.</span>
<span class='kw'>let</span> <span class='kw-2'>&amp;</span><span class='ident'>invalid</span> <span class='op'>=</span> <span class='ident'>trait_obj</span>;

<span class='comment'>// You can call methods without binding to the value being pointed at.</span>
<span class='ident'>trait_obj</span>.<span class='ident'>method_one</span>();
<span class='ident'>trait_obj</span>.<span class='ident'>method_two</span>();
</pre>

<p>You can read more about trait objects in the Trait Object section of the
Reference:</p>

<p><a href="http://doc.rust-lang.org/reference.html#trait-objects">http://doc.rust-lang.org/reference.html#trait-objects</a></p>
</div>
<div class="error-described error-used"><h2 id="E0034" class="section-header"><a href="#E0034">E0034</a></h2>
<p>The compiler doesn&#39;t know what method to call because more than one method
has the same prototype. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>trait</span> <span class='ident'>Trait1</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>trait</span> <span class='ident'>Trait2</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>impl</span> <span class='ident'>Trait1</span> <span class='kw'>for</span> <span class='ident'>Test</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>() {} }
<span class='kw'>impl</span> <span class='ident'>Trait2</span> <span class='kw'>for</span> <span class='ident'>Test</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>() {} }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>Test</span>::<span class='ident'>foo</span>() <span class='comment'>// error, which foo() to call?</span>
}
</pre>

<p>To avoid this error, you have to keep only one of them and remove the others.
So let&#39;s take our example and fix it:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>trait</span> <span class='ident'>Trait1</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>impl</span> <span class='ident'>Trait1</span> <span class='kw'>for</span> <span class='ident'>Test</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>() {} }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>Test</span>::<span class='ident'>foo</span>() <span class='comment'>// and now that&#39;s good!</span>
}
</pre>

<p>However, a better solution would be using fully explicit naming of type and
trait:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>trait</span> <span class='ident'>Trait1</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>trait</span> <span class='ident'>Trait2</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>impl</span> <span class='ident'>Trait1</span> <span class='kw'>for</span> <span class='ident'>Test</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>() {} }
<span class='kw'>impl</span> <span class='ident'>Trait2</span> <span class='kw'>for</span> <span class='ident'>Test</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>() {} }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='op'>&lt;</span><span class='ident'>Test</span> <span class='kw'>as</span> <span class='ident'>Trait1</span><span class='op'>&gt;</span>::<span class='ident'>foo</span>()
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0035" class="section-header"><a href="#E0035">E0035</a></h2>
<p>You tried to give a type parameter where it wasn&#39;t needed. Bad example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>impl</span> <span class='ident'>Test</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {}
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Test</span>;

    <span class='ident'>x</span>.<span class='ident'>method</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>(); <span class='comment'>// Error: Test::method doesn&#39;t need type parameter!</span>
}
</pre>

<p>To fix this error, just remove the type parameter:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>impl</span> <span class='ident'>Test</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {}
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Test</span>;

    <span class='ident'>x</span>.<span class='ident'>method</span>(); <span class='comment'>// OK, we&#39;re good!</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0036" class="section-header"><a href="#E0036">E0036</a></h2>
<p>This error occurrs when you pass too many or not enough type parameters to
a method. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>impl</span> <span class='ident'>Test</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>v</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>]) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
        <span class='ident'>v</span>.<span class='ident'>len</span>()
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Test</span>;
    <span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0i32</span>];

    <span class='ident'>x</span>.<span class='ident'>method</span>::<span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>i32</span><span class='op'>&gt;</span>(<span class='ident'>v</span>); <span class='comment'>// error: only one type parameter is expected!</span>
}
</pre>

<p>To fix it, just specify a correct number of type parameters:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>impl</span> <span class='ident'>Test</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>v</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>]) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
        <span class='ident'>v</span>.<span class='ident'>len</span>()
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Test</span>;
    <span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0i32</span>];

    <span class='ident'>x</span>.<span class='ident'>method</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>(<span class='ident'>v</span>); <span class='comment'>// OK, we&#39;re good!</span>
}
</pre>

<p>Please note on the last example that we could have called <code>method</code> like this:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>x</span>.<span class='ident'>method</span>(<span class='ident'>v</span>);
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0038" class="section-header"><a href="#E0038">E0038</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0040" class="section-header"><a href="#E0040">E0040</a></h2>
<p>It is not allowed to manually call destructors in Rust. It is also not
necessary to do this since <code>drop</code> is called automatically whenever a value goes
out of scope.</p>

<p>Here&#39;s an example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
}

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;kaboom&quot;</span>);
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='op'>-</span><span class='number'>7</span> };
    <span class='ident'>x</span>.<span class='ident'>drop</span>(); <span class='comment'>// error: explicit use of destructor method</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0044" class="section-header"><a href="#E0044">E0044</a></h2>
<p>You can&#39;t use type parameters on foreign items. Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> { <span class='kw'>fn</span> <span class='ident'>some_func</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>); }
</pre>

<p>To fix this, replace the type parameter with the specializations that you
need:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> { <span class='kw'>fn</span> <span class='ident'>some_func_i32</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>); }
<span class='kw'>extern</span> { <span class='kw'>fn</span> <span class='ident'>some_func_i64</span>(<span class='ident'>x</span>: <span class='ident'>i64</span>); }
</pre>
</div>
<div class="error-described error-used"><h2 id="E0045" class="section-header"><a href="#E0045">E0045</a></h2>
<p>Rust only supports variadic parameters for interoperability with C code in its
FFI. As such, variadic parameters can only be used with functions which are
using the C ABI. Examples of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='string'>&quot;rust-call&quot;</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>u8</span>, ...); }
<span class='comment'>// or</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>u8</span>, ...) {}
</pre>

<p>To fix such code, put them in an extern &quot;C&quot; block:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> <span class='kw'>fn</span> <span class='ident'>foo</span> (<span class='ident'>x</span>: <span class='ident'>u8</span>, ...);
<span class='comment'>// or:</span>
<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span> (<span class='ident'>x</span>: <span class='ident'>u8</span>, ...);
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0046" class="section-header"><a href="#E0046">E0046</a></h2>
<p>When trying to make some type implement a trait <code>Foo</code>, you must, at minimum,
provide implementations for all of <code>Foo</code>&#39;s required methods (meaning the
methods that do not have default implementations), as well as any required
trait items like associated types or constants.</p>
</div>
<div class="error-described error-used"><h2 id="E0049" class="section-header"><a href="#E0049">E0049</a></h2>
<p>This error indicates that an attempted implementation of a trait method
has the wrong number of type parameters.</p>

<p>For example, the trait below has a method <code>foo</code> with a type parameter <code>T</code>,
but the implementation of <code>foo</code> for the type <code>Bar</code> is missing this parameter:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Default</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='kw'>Self</span>;
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='comment'>// error: method `foo` has 0 type parameters but its trait declaration has 1</span>
<span class='comment'>// type parameter</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>bool</span>) <span class='op'>-&gt;</span> <span class='kw'>Self</span> { <span class='ident'>Bar</span> }
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0050" class="section-header"><a href="#E0050">E0050</a></h2>
<p>This error indicates that an attempted implementation of a trait method
has the wrong number of function parameters.</p>

<p>For example, the trait below has a method <code>foo</code> with two function parameters
(<code>&amp;self</code> and <code>u8</code>), but the implementation of <code>foo</code> for the type <code>Bar</code> omits
the <code>u8</code> parameter:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>x</span>: <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='comment'>// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`</span>
<span class='comment'>// has 2</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='boolval'>true</span> }
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0053" class="section-header"><a href="#E0053">E0053</a></h2>
<p>The parameters of any trait method must match between a trait implementation
and the trait definition.</p>

<p>Here are a couple examples of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>u16</span>);
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='comment'>// error, expected u16, found i16</span>
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i16</span>) { }

    <span class='comment'>// error, values differ in mutability</span>
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) { }
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0054" class="section-header"><a href="#E0054">E0054</a></h2>
<p>It is not allowed to cast to a bool. If you are trying to cast a numeric type
to a bool, you can compare it with zero instead:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

<span class='comment'>// Ok</span>
<span class='kw'>let</span> <span class='ident'>x_is_nonzero</span> <span class='op'>=</span> <span class='ident'>x</span> <span class='op'>!=</span> <span class='number'>0</span>;

<span class='comment'>// Not allowed, won&#39;t compile</span>
<span class='kw'>let</span> <span class='ident'>x_is_nonzero</span> <span class='op'>=</span> <span class='ident'>x</span> <span class='kw'>as</span> <span class='ident'>bool</span>;
</pre>
</div>
<div class="error-described error-used"><h2 id="E0055" class="section-header"><a href="#E0055">E0055</a></h2>
<p>During a method call, a value is automatically dereferenced as many times as
needed to make the value&#39;s type match the method&#39;s receiver. The catch is that
the compiler will only attempt to dereference a number of times up to the
recursion limit (which can be set via the <code>recursion_limit</code> attribute).</p>

<p>For a somewhat artificial example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>recursion_limit</span><span class='op'>=</span><span class='string'>&quot;2&quot;</span>]</span>

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {}
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='ident'>Foo</span>;
    <span class='kw'>let</span> <span class='ident'>ref_foo</span> <span class='op'>=</span> <span class='op'>&amp;&amp;</span><span class='ident'>Foo</span>;

    <span class='comment'>// error, reached the recursion limit while auto-dereferencing &amp;&amp;Foo</span>
    <span class='ident'>ref_foo</span>.<span class='ident'>foo</span>();
}
</pre>

<p>One fix may be to increase the recursion limit. Note that it is possible to
create an infinite recursion of dereferencing, in which case the only fix is to
somehow break the recursion.</p>
</div>
<div class="error-described error-used"><h2 id="E0057" class="section-header"><a href="#E0057">E0057</a></h2>
<p>When invoking closures or other implementations of the function traits <code>Fn</code>,
<code>FnMut</code> or <code>FnOnce</code> using call notation, the number of parameters passed to the
function must match its definition.</p>

<p>An example using a closure:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>3</span>;
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>f</span>();        <span class='comment'>// invalid, too few parameters</span>
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>4</span>);       <span class='comment'>// this works!</span>
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>2</span>, <span class='number'>3</span>);    <span class='comment'>// invalid, too many parameters</span>
</pre>

<p>A generic function must be treated similarly:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span>()<span class='op'>&gt;</span>(<span class='ident'>f</span>: <span class='ident'>F</span>) {
    <span class='ident'>f</span>(); <span class='comment'>// this is valid, but f(3) would not work</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0059" class="section-header"><a href="#E0059">E0059</a></h2>
<p>The built-in function traits are generic over a tuple of the function arguments.
If one uses angle-bracket notation (<code>Fn&lt;(T,), Output=U&gt;</code>) instead of parentheses
(<code>Fn(T) -&gt; U</code>) to denote the function trait, the type parameter should be a
tuple. Otherwise function call notation cannot be used and the trait will not be
implemented by closures.</p>

<p>The most likely source of this error is using angle-bracket notation without
wrapping the function argument type into a tuple, for example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;&gt;</span>(<span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>F</span>::<span class='ident'>Output</span> { <span class='ident'>f</span>(<span class='number'>3</span>) }
</pre>

<p>It can be fixed by adjusting the trait bound like this:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span><span class='op'>&lt;</span>(<span class='ident'>i32</span>,)<span class='op'>&gt;&gt;</span>(<span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>F</span>::<span class='ident'>Output</span> { <span class='ident'>f</span>(<span class='number'>3</span>) }
</pre>

<p>Note that <code>(T,)</code> always denotes the type of a 1-tuple containing an element of
type <code>T</code>. The comma is necessary for syntactic disambiguation.</p>
</div>
<div class="error-described error-used"><h2 id="E0060" class="section-header"><a href="#E0060">E0060</a></h2>
<p>External C functions are allowed to be variadic. However, a variadic function
takes a minimum number of arguments. For example, consider C&#39;s variadic <code>printf</code>
function:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;
<span class='kw'>use</span> <span class='ident'>libc</span>::{ <span class='ident'>c_char</span>, <span class='ident'>c_int</span> };

<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>printf</span>(_: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>c_char</span>, ...) <span class='op'>-&gt;</span> <span class='ident'>c_int</span>;
}
</pre>

<p>Using this declaration, it must be called with at least one argument, so
simply calling <code>printf()</code> is illegal. But the following uses are allowed:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>unsafe</span> {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ffi</span>::<span class='ident'>CString</span>;

    <span class='ident'>printf</span>(<span class='ident'>CString</span>::<span class='ident'>new</span>(<span class='string'>&quot;test\n&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>as_ptr</span>());
    <span class='ident'>printf</span>(<span class='ident'>CString</span>::<span class='ident'>new</span>(<span class='string'>&quot;number = %d\n&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>as_ptr</span>(), <span class='number'>3</span>);
    <span class='ident'>printf</span>(<span class='ident'>CString</span>::<span class='ident'>new</span>(<span class='string'>&quot;%d, %d\n&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>as_ptr</span>(), <span class='number'>10</span>, <span class='number'>5</span>);
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0061" class="section-header"><a href="#E0061">E0061</a></h2>
<p>The number of arguments passed to a function must match the number of arguments
specified in the function signature.</p>

<p>For example, a function like</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>f</span>(<span class='ident'>a</span>: <span class='ident'>u16</span>, <span class='ident'>b</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {}
</pre>

<p>must always be called with exactly two arguments, e.g. <code>f(2, &quot;test&quot;)</code>.</p>

<p>Note, that Rust does not have a notion of optional function arguments or
variadic functions (except for its C-FFI).</p>
</div>
<div class="error-described error-used"><h2 id="E0062" class="section-header"><a href="#E0062">E0062</a></h2>
<p>This error indicates that during an attempt to build a struct or struct-like
enum variant, one of the fields was specified more than once. Each field should
be specified exactly one time.</p>
</div>
<div class="error-described error-used"><h2 id="E0063" class="section-header"><a href="#E0063">E0063</a></h2>
<p>This error indicates that during an attempt to build a struct or struct-like
enum variant, one of the fields was not provided. Each field should be
specified exactly once.</p>
</div>
<div class="error-described error-used"><h2 id="E0066" class="section-header"><a href="#E0066">E0066</a></h2>
<p>Box placement expressions (like C++&#39;s &quot;placement new&quot;) do not yet support any
place expression except the exchange heap (i.e. <code>std::boxed::HEAP</code>).
Furthermore, the syntax is changing to use <code>in</code> instead of <code>box</code>. See <a href="https://github.com/rust-lang/rfcs/pull/470">RFC 470</a>
and <a href="https://github.com/rust-lang/rfcs/pull/809">RFC 809</a> for more details.</p>
</div>
<div class="error-described error-used"><h2 id="E0067" class="section-header"><a href="#E0067">E0067</a></h2>
<p>The left-hand side of a compound assignment expression must be an lvalue
expression. An lvalue expression represents a memory location and includes
item paths (ie, namespaced variables), dereferences, indexing expressions,
and field references.</p>

<p>Let&#39;s start with some bad examples:
```
use std::collections::LinkedList;</p>

<p>// Bad: assignment to non-lvalue expression
LinkedList::new() += 1;</p>

<p>// ...</p>

<p>fn some_func(i: &amp;mut i32) {
    i += 12; // Error : &#39;+=&#39; operation cannot be applied on a reference !
}</p>

<p>And now some good examples:
```
let mut i : i32 = 0;</p>

<p>i += 12; // Good !</p>

<p>// ...</p>

<p>fn some_func(i: &amp;mut i32) {
    *i += 12; // Good !
}</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0068" class="section-header"><a href="#E0068">E0068</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0069" class="section-header"><a href="#E0069">E0069</a></h2>
<p>The compiler found a function whose body contains a <code>return;</code> statement but
whose return type is not <code>()</code>. An example of this is:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>u8</span> {
    <span class='kw'>return</span>;
}
</pre>

<p>Since <code>return;</code> is just like <code>return ();</code>, there is a mismatch between the
function&#39;s return type and the value being returned.</p>
</div>
<div class="error-described error-used"><h2 id="E0070" class="section-header"><a href="#E0070">E0070</a></h2>
<p>The left-hand side of an assignment operator must be an lvalue expression. An
lvalue expression represents a memory location and can be a variable (with
optional namespacing), a dereference, an indexing expression or a field
reference.</p>

<p>More details can be found here:
<a href="https://doc.rust-lang.org/reference.html#lvalues,-rvalues-and-temporaries">https://doc.rust-lang.org/reference.html#lvalues,-rvalues-and-temporaries</a></p>

<p>Now, we can go further. Here are some bad examples:
```
struct SomeStruct {
    x: i32,
    y: i32
}
const SOME_CONST : i32 = 12;</p>

<p>fn some_other_func() {}</p>

<p>fn some_function() {
    SOME_CONST = 14; // error : a constant value cannot be changed!
    1 = 3; // error : 1 isn&#39;t a valid lvalue!
    some_other_func() = 4; // error : we can&#39;t assign value to a function!
    SomeStruct.x = 12; // error : SomeStruct a structure name but it is used
                       // like a variable!
}
```</p>

<p>And now let&#39;s give good examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>SomeStruct</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>
}
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>SomeStruct</span> {<span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span>};

<span class='ident'>s</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>; <span class='comment'>// that&#39;s good !</span>

<span class='comment'>// ...</span>

<span class='kw'>fn</span> <span class='ident'>some_func</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>i32</span>) {
    <span class='op'>*</span><span class='ident'>x</span> <span class='op'>=</span> <span class='number'>12</span>; <span class='comment'>// that&#39;s good !</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0071" class="section-header"><a href="#E0071">E0071</a></h2>
<p>You tried to use a structure initialization with a non-structure type.
Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> { <span class='ident'>FirstValue</span> };

<span class='kw'>let</span> <span class='ident'>u</span> <span class='op'>=</span> <span class='ident'>Foo</span>::<span class='ident'>FirstValue</span> { <span class='ident'>value</span>: <span class='number'>0i32</span> }; <span class='comment'>// error: Foo::FirstValue</span>
                                         <span class='comment'>// isn&#39;t a structure!</span>
<span class='comment'>// or even simpler, if the structure wasn&#39;t defined at all:</span>
<span class='kw'>let</span> <span class='ident'>u</span> <span class='op'>=</span> <span class='ident'>RandomName</span> { <span class='ident'>random_field</span>: <span class='number'>0i32</span> }; <span class='comment'>// error: RandomName</span>
                                           <span class='comment'>// isn&#39;t a structure!</span>
</pre>

<p>To fix this, please check:
 * Did you spell it right?
 * Did you accidentaly used an enum as a struct?
 * Did you accidentaly make an enum when you intended to use a struct?</p>

<p>Here is the previous code with all missing information:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Inner</span> {
    <span class='ident'>value</span>: <span class='ident'>i32</span>
}

<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>FirstValue</span>(<span class='ident'>Inner</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>u</span> <span class='op'>=</span> <span class='ident'>Foo</span>::<span class='ident'>FirstValue</span>(<span class='ident'>Inner</span> { <span class='ident'>value</span>: <span class='number'>0i32</span> });

    <span class='kw'>let</span> <span class='ident'>t</span> <span class='op'>=</span> <span class='ident'>Inner</span> { <span class='ident'>value</span>: <span class='number'>0i32</span> };
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0072" class="section-header"><a href="#E0072">E0072</a></h2>
<p>When defining a recursive struct or enum, any use of the type being defined
from inside the definition must occur behind a pointer (like <code>Box</code> or <code>&amp;</code>).
This is because structs and enums must have a well-defined size, and without
the pointer the size of the type would need to be unbounded.</p>

<p>Consider the following erroneous definition of a type for a list of bytes:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error, illegal recursive struct type</span>
<span class='kw'>struct</span> <span class='ident'>ListNode</span> {
    <span class='ident'>head</span>: <span class='ident'>u8</span>,
    <span class='ident'>tail</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>ListNode</span><span class='op'>&gt;</span>,
}
</pre>

<p>This type cannot have a well-defined size, because it needs to be arbitrarily
large (since we would be able to nest <code>ListNode</code>s to any depth). Specifically,</p>

<pre><code class="language-plain">size of `ListNode` = 1 byte for `head`
                   + 1 byte for the discriminant of the `Option`
                   + size of `ListNode`
</code></pre>

<p>One way to fix this is by wrapping <code>ListNode</code> in a <code>Box</code>, like so:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>ListNode</span> {
    <span class='ident'>head</span>: <span class='ident'>u8</span>,
    <span class='ident'>tail</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>ListNode</span><span class='op'>&gt;&gt;</span>,
}
</pre>

<p>This works because <code>Box</code> is a pointer, so its size is well-known.</p>
</div>
<div class="error-described error-used"><h2 id="E0073" class="section-header"><a href="#E0073">E0073</a></h2>
<p>You cannot define a struct (or enum) <code>Foo</code> that requires an instance of <code>Foo</code>
in order to make a new <code>Foo</code> value. This is because there would be no way a
first instance of <code>Foo</code> could be made to initialize another instance!</p>

<p>Here&#39;s an example of a struct that has this problem:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Foo</span><span class='op'>&gt;</span> } <span class='comment'>// error</span>
</pre>

<p>One fix is to use <code>Option</code>, like so:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Foo</span><span class='op'>&gt;&gt;</span> }
</pre>

<p>Now it&#39;s possible to create at least one instance of <code>Foo</code>: <code>Foo { x: None }</code>.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0074" class="section-header"><a href="#E0074">E0074</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0075" class="section-header"><a href="#E0075">E0075</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0076" class="section-header"><a href="#E0076">E0076</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0077" class="section-header"><a href="#E0077">E0077</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0079" class="section-header"><a href="#E0079">E0079</a></h2>
<p>Enum variants which contain no data can be given a custom integer
representation. This error indicates that the value provided is not an
integer literal and is therefore invalid.</p>
</div>
<div class="error-described error-used"><h2 id="E0080" class="section-header"><a href="#E0080">E0080</a></h2>
<p>This error indicates that the compiler was unable to sensibly evaluate an
integer expression provided as an enum discriminant. Attempting to divide by 0
or causing integer overflow are two ways to induce this error. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Enum</span> {
    <span class='ident'>X</span> <span class='op'>=</span> (<span class='number'>1</span> <span class='op'>&lt;&lt;</span> <span class='number'>500</span>),
    <span class='ident'>Y</span> <span class='op'>=</span> (<span class='number'>1</span> <span class='op'>/</span> <span class='number'>0</span>)
}
</pre>

<p>Ensure that the expressions given can be evaluated as the desired integer type.
See the FFI section of the Reference for more information about using a custom
integer type:</p>

<p><a href="https://doc.rust-lang.org/reference.html#ffi-attributes">https://doc.rust-lang.org/reference.html#ffi-attributes</a></p>
</div>
<div class="error-described error-used"><h2 id="E0081" class="section-header"><a href="#E0081">E0081</a></h2>
<p>Enum discriminants are used to differentiate enum variants stored in memory.
This error indicates that the same value was used for two or more variants,
making them impossible to tell apart.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Good.</span>
<span class='kw'>enum</span> <span class='ident'>Enum</span> {
    <span class='ident'>P</span>,
    <span class='ident'>X</span> <span class='op'>=</span> <span class='number'>3</span>,
    <span class='ident'>Y</span> <span class='op'>=</span> <span class='number'>5</span>
}

<span class='comment'>// Bad.</span>
<span class='kw'>enum</span> <span class='ident'>Enum</span> {
    <span class='ident'>P</span> <span class='op'>=</span> <span class='number'>3</span>,
    <span class='ident'>X</span> <span class='op'>=</span> <span class='number'>3</span>,
    <span class='ident'>Y</span> <span class='op'>=</span> <span class='number'>5</span>
}
</pre>

<p>Note that variants without a manually specified discriminant are numbered from
top to bottom starting from 0, so clashes can occur with seemingly unrelated
variants.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Bad</span> {
    <span class='ident'>X</span>,
    <span class='ident'>Y</span> <span class='op'>=</span> <span class='number'>0</span>
}
</pre>

<p>Here <code>X</code> will have already been assigned the discriminant 0 by the time <code>Y</code> is
encountered, so a conflict occurs.</p>
</div>
<div class="error-described error-used"><h2 id="E0082" class="section-header"><a href="#E0082">E0082</a></h2>
<p>The default type for enum discriminants is <code>isize</code>, but it can be adjusted by
adding the <code>repr</code> attribute to the enum declaration. This error indicates that
an integer literal given as a discriminant is not a member of the discriminant
type. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>u8</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>Thing</span> {
    <span class='ident'>A</span> <span class='op'>=</span> <span class='number'>1024</span>,
    <span class='ident'>B</span> <span class='op'>=</span> <span class='number'>5</span>
}
</pre>

<p>Here, 1024 lies outside the valid range for <code>u8</code>, so the discriminant for <code>A</code> is
invalid. You may want to change representation types to fix this, or else change
invalid discriminant values so that they fit within the existing type.</p>

<p>Note also that without a representation manually defined, the compiler will
optimize by using the smallest integer type possible.</p>
</div>
<div class="error-described error-used"><h2 id="E0083" class="section-header"><a href="#E0083">E0083</a></h2>
<p>At present, it&#39;s not possible to define a custom representation for an enum with
a single variant. As a workaround you can add a <code>Dummy</code> variant.</p>

<p>See: <a href="https://github.com/rust-lang/rust/issues/10292">https://github.com/rust-lang/rust/issues/10292</a></p>
</div>
<div class="error-described error-used"><h2 id="E0084" class="section-header"><a href="#E0084">E0084</a></h2>
<p>It is impossible to define an integer type to be used to represent zero-variant
enum values because there are no zero-variant enum values. There is no way to
construct an instance of the following type using only safe code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Empty</span> {}
</pre>
</div>
<div class="error-undescribed error-unused"><h2 id="E0085" class="section-header"><a href="#E0085">E0085</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0086" class="section-header"><a href="#E0086">E0086</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0087" class="section-header"><a href="#E0087">E0087</a></h2>
<p>Too many type parameters were supplied for a function. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>foo</span>::<span class='op'>&lt;</span><span class='ident'>f64</span>, <span class='ident'>bool</span><span class='op'>&gt;</span>(); <span class='comment'>// error, expected 1 parameter, found 2 parameters</span>
}
</pre>

<p>The number of supplied parameters much exactly match the number of defined type
parameters.</p>
</div>
<div class="error-described error-used"><h2 id="E0088" class="section-header"><a href="#E0088">E0088</a></h2>
<p>You gave too many lifetime parameters. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>f</span>() {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>f</span>::<span class='op'>&lt;</span><span class='lifetime'>&#39;static</span><span class='op'>&gt;</span>() <span class='comment'>// error: too many lifetime parameters provided</span>
}
</pre>

<p>Please check you give the right number of lifetime parameters. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>f</span>() {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>f</span>() <span class='comment'>// ok!</span>
}
</pre>

<p>It&#39;s also important to note that the Rust compiler can generally
determine the lifetime by itself. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>value</span>: <span class='ident'>String</span>
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='comment'>// it can be written like this</span>
    <span class='kw'>fn</span> <span class='ident'>get_value</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span> { <span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>value</span> }
    <span class='comment'>// but the compiler works fine with this too:</span>
    <span class='kw'>fn</span> <span class='ident'>without_lifetime</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> { <span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>value</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>value</span>: <span class='string'>&quot;hello&quot;</span>.<span class='ident'>to_owned</span>() };

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>f</span>.<span class='ident'>get_value</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>f</span>.<span class='ident'>without_lifetime</span>());
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0089" class="section-header"><a href="#E0089">E0089</a></h2>
<p>Not enough type parameters were supplied for a function. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>U</span><span class='op'>&gt;</span>() {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>foo</span>::<span class='op'>&lt;</span><span class='ident'>f64</span><span class='op'>&gt;</span>(); <span class='comment'>// error, expected 2 parameters, found 1 parameter</span>
}
</pre>

<p>Note that if a function takes multiple type parameters but you want the compiler
to infer some of them, you can use type placeholders:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>U</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>bool</span> <span class='op'>=</span> <span class='boolval'>true</span>;
    <span class='ident'>foo</span>::<span class='op'>&lt;</span><span class='ident'>f64</span><span class='op'>&gt;</span>(<span class='ident'>x</span>);    <span class='comment'>// error, expected 2 parameters, found 1 parameter</span>
    <span class='ident'>foo</span>::<span class='op'>&lt;</span>_, <span class='ident'>f64</span><span class='op'>&gt;</span>(<span class='ident'>x</span>); <span class='comment'>// same as `foo::&lt;bool, f64&gt;(x)`</span>
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0090" class="section-header"><a href="#E0090">E0090</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0091" class="section-header"><a href="#E0091">E0091</a></h2>
<p>You gave an unnecessary type parameter in a type alias. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>u32</span>; <span class='comment'>// error: type parameter `T` is unused</span>
<span class='comment'>// or:</span>
<span class='kw'>type</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>A</span>,<span class='ident'>B</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span>; <span class='comment'>// error: type parameter `B` is unused</span>
</pre>

<p>Please check you didn&#39;t write too many type parameters. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>u32</span>; <span class='comment'>// ok!</span>
<span class='kw'>type</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span>; <span class='comment'>// ok!</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0092" class="section-header"><a href="#E0092">E0092</a></h2>
<p>You tried to declare an undefined atomic operation function.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>atomic_foo</span>(); <span class='comment'>// error: unrecognized atomic operation</span>
                     <span class='comment'>//        function</span>
}
</pre>

<p>Please check you didn&#39;t make a mistake in the function&#39;s name. All intrinsic
functions are defined in librustc_trans/trans/intrinsic.rs and in
libcore/intrinsics.rs in the Rust source code. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>atomic_fence</span>(); <span class='comment'>// ok!</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0093" class="section-header"><a href="#E0093">E0093</a></h2>
<p>You declared an unknown intrinsic function. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(); <span class='comment'>// error: unrecognized intrinsic function: `foo`</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> {
        <span class='ident'>foo</span>();
    }
}
</pre>

<p>Please check you didn&#39;t make a mistake in the function&#39;s name. All intrinsic
functions are defined in librustc_trans/trans/intrinsic.rs and in
libcore/intrinsics.rs in the Rust source code. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>atomic_fence</span>(); <span class='comment'>// ok!</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> {
        <span class='ident'>atomic_fence</span>();
    }
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0094" class="section-header"><a href="#E0094">E0094</a></h2>
<p>You gave an invalid number of type parameters to an intrinsic function.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>size_of</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>U</span><span class='op'>&gt;</span>() <span class='op'>-&gt;</span> <span class='ident'>usize</span>; <span class='comment'>// error: intrinsic has wrong number</span>
                                 <span class='comment'>//        of type parameters</span>
}
</pre>

<p>Please check that you provided the right number of lifetime parameters
and verify with the function declaration in the Rust source code.
Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>size_of</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() <span class='op'>-&gt;</span> <span class='ident'>usize</span>; <span class='comment'>// ok!</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0101" class="section-header"><a href="#E0101">E0101</a></h2>
<p>You hit this error because the compiler the compiler lacks information
to determine a type for this expression. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='op'>|</span>_<span class='op'>|</span> {}; <span class='comment'>// error: cannot determine a type for this expression</span>
}
</pre>

<p>You have two possibilities to solve this situation:
 * Give an explicit definition of the expression
 * Infer the expression</p>

<p>Examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='op'>|</span>_ : <span class='ident'>u32</span><span class='op'>|</span> {}; <span class='comment'>// ok!</span>
    <span class='comment'>// or:</span>
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='op'>|</span>_<span class='op'>|</span> {};
    <span class='ident'>x</span>(<span class='number'>0u32</span>);
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0102" class="section-header"><a href="#E0102">E0102</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0103" class="section-header"><a href="#E0103">E0103</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0104" class="section-header"><a href="#E0104">E0104</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0106" class="section-header"><a href="#E0106">E0106</a></h2>
<p>This error indicates that a lifetime is missing from a type. If it is an error
inside a function signature, the problem may be with failing to adhere to the
lifetime elision rules (see below).</p>

<p>Here are some simple examples of where you&#39;ll run into this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>bool</span> }        <span class='comment'>// error</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> { <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>bool</span> } <span class='comment'>// correct</span>

<span class='kw'>enum</span> <span class='ident'>Bar</span> { <span class='ident'>A</span>(<span class='ident'>u8</span>), <span class='ident'>B</span>(<span class='kw-2'>&amp;</span><span class='ident'>bool</span>), }        <span class='comment'>// error</span>
<span class='kw'>enum</span> <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> { <span class='ident'>A</span>(<span class='ident'>u8</span>), <span class='ident'>B</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>bool</span>), } <span class='comment'>// correct</span>

<span class='kw'>type</span> <span class='ident'>MyStr</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span>;        <span class='comment'>// error</span>
<span class='kw'>type</span> <span class='ident'>MyStr</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>; <span class='comment'>//correct</span>
</pre>

<p>Lifetime elision is a special, limited kind of inference for lifetimes in
function signatures which allows you to leave out lifetimes in certain cases.
For more background on lifetime elision see <a href="http://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision">the book</a>.</p>

<p>The lifetime elision rules require that any function signature with an elided
output lifetime must either have</p>

<ul>
<li>exactly one input lifetime</li>
<li>or, multiple input lifetimes, but the function must also be a method with a
<code>&amp;self</code> or <code>&amp;mut self</code> receiver</li>
</ul>

<p>In the first case, the output lifetime is inferred to be the same as the unique
input lifetime. In the second case, the lifetime is instead inferred to be the
same as the lifetime on <code>&amp;self</code> or <code>&amp;mut self</code>.</p>

<p>Here are some examples of elision errors:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error, no input lifetimes</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> { ... }

<span class='comment'>// error, `x` and `y` have distinct lifetimes inferred</span>
<span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> { ... }

<span class='comment'>// error, `y`&#39;s lifetime is inferred to be distinct from `x`&#39;s</span>
<span class='kw'>fn</span> <span class='ident'>baz</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> { ... }
</pre>
</div>
<div class="error-described error-used"><h2 id="E0107" class="section-header"><a href="#E0107">E0107</a></h2>
<p>This error means that an incorrect number of lifetime parameters were provided
for a type (like a struct or enum) or trait.</p>

<p>Some basic examples include:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>);
<span class='kw'>enum</span> <span class='ident'>Bar</span> { <span class='ident'>A</span>, <span class='ident'>B</span>, <span class='ident'>C</span> }

<span class='kw'>struct</span> <span class='ident'>Baz</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>foo</span>: <span class='ident'>Foo</span>,     <span class='comment'>// error: expected 1, found 0</span>
    <span class='ident'>bar</span>: <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>, <span class='comment'>// error: expected 0, found 1</span>
}
</pre>

<p>Here&#39;s an example that is currently an error, but may work in a future version
of Rust:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>);

<span class='kw'>trait</span> <span class='ident'>Quux</span> { }
<span class='kw'>impl</span> <span class='ident'>Quux</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { } <span class='comment'>// error: expected 1, found 0</span>
</pre>

<p>Lifetime elision in implementation headers was part of the lifetime elision
RFC. It is, however, <a href="https://github.com/rust-lang/rust/issues/15872">currently unimplemented</a>.</p>
</div>
<div class="error-described error-used"><h2 id="E0109" class="section-header"><a href="#E0109">E0109</a></h2>
<p>You tried to give a type parameter to a type which doesn&#39;t need it. Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>X</span> <span class='op'>=</span> <span class='ident'>u32</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>; <span class='comment'>// error: type parameters are not allowed on this type</span>
</pre>

<p>Please check that you used the correct type and recheck its definition. Perhaps
it doesn&#39;t need the type parameter.
Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>X</span> <span class='op'>=</span> <span class='ident'>u32</span>; <span class='comment'>// ok!</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0110" class="section-header"><a href="#E0110">E0110</a></h2>
<p>You tried to give a lifetime parameter to a type which doesn&#39;t need it.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>X</span> <span class='op'>=</span> <span class='ident'>u32</span><span class='op'>&lt;</span><span class='lifetime'>&#39;static</span><span class='op'>&gt;</span>; <span class='comment'>// error: lifetime parameters are not allowed on</span>
                       <span class='comment'>//        this type</span>
</pre>

<p>Please check that you used the correct type and recheck its definition,
perhaps it doesn&#39;t need the lifetime parameter. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>X</span> <span class='op'>=</span> <span class='ident'>u32</span>; <span class='comment'>// ok!</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0116" class="section-header"><a href="#E0116">E0116</a></h2>
<p>You can only define an inherent implementation for a type in the same crate
where the type was defined. For example, an <code>impl</code> block as below is not allowed
since <code>Vec</code> is defined in the standard library:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> { ... } <span class='comment'>// error</span>
</pre>

<p>To fix this problem, you can do either of these things:</p>

<ul>
<li>define a trait that has the desired associated functions/types/constants and
implement the trait for the type in question</li>
<li>define a new type wrapping the type and define an implementation on the new
type</li>
</ul>

<p>Note that using the <code>type</code> keyword does not work here because <code>type</code> only
introduces a type alias:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Bytes</span> <span class='op'>=</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>;

<span class='kw'>impl</span> <span class='ident'>Bytes</span> { ... } <span class='comment'>// error, same as above</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0117" class="section-header"><a href="#E0117">E0117</a></h2>
<p>You got this error because because you tried to implement a foreign
trait for a foreign type (with maybe a foreign type parameter). Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>u32</span> {}
</pre>

<p>The type, trait or the type parameter (or all of them) has to be defined
in your crate. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span>; <span class='comment'>// you define your type in your crate</span>

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { <span class='comment'>// and you can implement the trait on it!</span>
    <span class='comment'>// code of trait implementation here</span>
}

<span class='kw'>trait</span> <span class='ident'>Bar</span> { <span class='comment'>// or define your trait in your crate</span>
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span>;
}

<span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>u32</span> { <span class='comment'>// and then you implement it on a foreign type</span>
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='number'>0</span> }
}

<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>Foo</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>i32</span> { <span class='comment'>// or you use a type from your crate as</span>
                         <span class='comment'>// a type parameter</span>
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>i</span>: <span class='ident'>Foo</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
        <span class='number'>0</span>
    }
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0118" class="section-header"><a href="#E0118">E0118</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0119" class="section-header"><a href="#E0119">E0119</a></h2>
<p>There are conflicting trait implementations for the same type.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span>;
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='number'>0</span> }
}

<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>value</span>: <span class='ident'>usize</span>
}

<span class='kw'>impl</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { <span class='comment'>// error: conflicting implementations for trait</span>
                       <span class='comment'>//        `MyTrait`</span>
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='self'>self</span>.<span class='ident'>value</span> }
}
</pre>

<p>When you write:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='number'>0</span> }
}
</pre>

<p>This makes the trait implemented on all types in the scope. So if you
try to implement it on another one after that, the implementations will
conflict. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span>;
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='number'>0</span> }
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Foo</span>;

    <span class='ident'>f</span>.<span class='ident'>get</span>(); <span class='comment'>// the trait is implemented so we can use it</span>
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0120" class="section-header"><a href="#E0120">E0120</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0121" class="section-header"><a href="#E0121">E0121</a></h2>
<p>In order to be consistent with Rust&#39;s lack of global type inference, type
placeholders are disallowed by design in item signatures.</p>

<p>Examples of this error include:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> _ { <span class='number'>5</span> } <span class='comment'>// error, explicitly write out the return type instead</span>

<span class='kw'>static</span> <span class='ident'>BAR</span>: _ <span class='op'>=</span> <span class='string'>&quot;test&quot;</span>; <span class='comment'>// error, explicitly write out the type instead</span>
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0122" class="section-header"><a href="#E0122">E0122</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0123" class="section-header"><a href="#E0123">E0123</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0124" class="section-header"><a href="#E0124">E0124</a></h2>
<p>You declared two fields of a struct with the same name. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>field1</span>: <span class='ident'>i32</span>,
    <span class='ident'>field1</span>: <span class='ident'>i32</span> <span class='comment'>// error: field is already declared</span>
}
</pre>

<p>Please verify that the field names have been correctly spelled. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>field1</span>: <span class='ident'>i32</span>,
    <span class='ident'>field2</span>: <span class='ident'>i32</span> <span class='comment'>// ok!</span>
}
</pre>
</div>
<div class="error-undescribed error-unused"><h2 id="E0127" class="section-header"><a href="#E0127">E0127</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0128" class="section-header"><a href="#E0128">E0128</a></h2>
<p>Type parameter defaults can only use parameters that occur before them.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>=</span><span class='ident'>U</span>, <span class='ident'>U</span><span class='op'>=</span>()<span class='op'>&gt;</span> {
    <span class='ident'>field1</span>: <span class='ident'>T</span>,
    <span class='ident'>filed2</span>: <span class='ident'>U</span>,
}
<span class='comment'>// error: type parameters with a default cannot use forward declared</span>
<span class='comment'>// identifiers</span>
</pre>

<p>Since type parameters are evaluated in-order, you may be able to fix this issue
by doing:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>U</span><span class='op'>=</span>(), <span class='ident'>T</span><span class='op'>=</span><span class='ident'>U</span><span class='op'>&gt;</span> {
    <span class='ident'>field1</span>: <span class='ident'>T</span>,
    <span class='ident'>filed2</span>: <span class='ident'>U</span>,
}
</pre>

<p>Please also verify that this wasn&#39;t because of a name-clash and rename the type
parameter if so.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0129" class="section-header"><a href="#E0129">E0129</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0130" class="section-header"><a href="#E0130">E0130</a></h2>
<p>You declared a pattern as an argument in a foreign function declaration.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>((<span class='ident'>a</span>, <span class='ident'>b</span>): (<span class='ident'>u32</span>, <span class='ident'>u32</span>)); <span class='comment'>// error: patterns aren&#39;t allowed in foreign</span>
                                <span class='comment'>//        function declarations</span>
}
</pre>

<p>Please replace the pattern argument with a regular one. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>SomeStruct</span> {
    <span class='ident'>a</span>: <span class='ident'>u32</span>,
    <span class='ident'>b</span>: <span class='ident'>u32</span>,
}

<span class='kw'>extern</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>s</span>: <span class='ident'>SomeStruct</span>); <span class='comment'>// ok!</span>
}
<span class='comment'>// or</span>
<span class='kw'>extern</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>a</span>: (<span class='ident'>u32</span>, <span class='ident'>u32</span>)); <span class='comment'>// ok!</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0131" class="section-header"><a href="#E0131">E0131</a></h2>
<p>It is not possible to define <code>main</code> with type parameters, or even with function
parameters. When <code>main</code> is present, it must take no arguments and return <code>()</code>.</p>
</div>
<div class="error-described error-used"><h2 id="E0132" class="section-header"><a href="#E0132">E0132</a></h2>
<p>It is not possible to declare type parameters on a function that has the <code>start</code>
attribute. Such a function must have the following type signature:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span>(<span class='ident'>isize</span>, <span class='op'>*</span><span class='kw'>const</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>isize</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0133" class="section-header"><a href="#E0133">E0133</a></h2>
<p>Using unsafe functionality, such as dereferencing raw pointers and calling
functions via FFI or marked as unsafe, is potentially dangerous and disallowed
by safety checks. These safety checks can be relaxed for a section of the code
by wrapping the unsafe instructions with an <code>unsafe</code> block. For instance:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>f</span>() { <span class='kw'>return</span>; }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> { <span class='ident'>f</span>(); }
}
</pre>

<p>See also <a href="https://doc.rust-lang.org/book/unsafe.html">https://doc.rust-lang.org/book/unsafe.html</a></p>
</div>
<div class="error-undescribed error-used"><h2 id="E0136" class="section-header"><a href="#E0136">E0136</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0137" class="section-header"><a href="#E0137">E0137</a></h2>
<p>This error indicates that the compiler found multiple functions with the
<code>#[main]</code> attribute. This is an error because there must be a unique entry
point into a Rust program.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0138" class="section-header"><a href="#E0138">E0138</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0139" class="section-header"><a href="#E0139">E0139</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0141" class="section-header"><a href="#E0141">E0141</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0152" class="section-header"><a href="#E0152">E0152</a></h2>
<p>Lang items are already implemented in the standard library. Unless you are
writing a free-standing application (e.g. a kernel), you do not need to provide
them yourself.</p>

<p>You can build a free-standing crate by adding <code>#![no_std]</code> to the crate
attributes:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>no_std</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span>
</pre>

<p>See also <a href="https://doc.rust-lang.org/book/no-stdlib.html">https://doc.rust-lang.org/book/no-stdlib.html</a></p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0153" class="section-header"><a href="#E0153">E0153</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0154" class="section-header"><a href="#E0154">E0154</a></h2>
<p>Imports (<code>use</code> statements) are not allowed after non-item statements, such as
variable declarations and expression statements.</p>

<p>Here is an example that demonstrates the error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>f</span>() {
    <span class='comment'>// Variable declaration before import</span>
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0</span>;
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
    ...
}
</pre>

<p>The solution is to declare the imports at the top of the block, function, or
file.</p>

<p>Here is the previous example again, with the correct order:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>f</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0</span>;
    ...
}
</pre>

<p>See the Declaration Statements section of the reference for more information
about what constitutes an Item declaration and what does not:</p>

<p><a href="http://doc.rust-lang.org/reference.html#statements">http://doc.rust-lang.org/reference.html#statements</a></p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0157" class="section-header"><a href="#E0157">E0157</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0158" class="section-header"><a href="#E0158">E0158</a></h2>
<p><code>const</code> and <code>static</code> mean different things. A <code>const</code> is a compile-time
constant, an alias for a literal value. This property means you can match it
directly within a pattern.</p>

<p>The <code>static</code> keyword, on the other hand, guarantees a fixed location in memory.
This does not always mean that the value is constant. For example, a global
mutex can be declared <code>static</code> as well.</p>

<p>If you want to match against a <code>static</code>, consider using a guard instead:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>static</span> <span class='ident'>FORTY_TWO</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(<span class='number'>42</span>) {
    <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>FORTY_TWO</span> <span class='op'>=&gt;</span> ...
    ...
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0159" class="section-header"><a href="#E0159">E0159</a></h2>
<p>You tried to use a trait as a struct constructor. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>TraitNotAStruct</span> {}

<span class='ident'>TraitNotAStruct</span>{ <span class='ident'>value</span>: <span class='number'>0</span> }; <span class='comment'>// error: use of trait `TraitNotAStruct` as a</span>
                             <span class='comment'>//        struct constructor</span>
</pre>

<p>Please verify you used the correct type name or please implement the trait
on a struct and use this struct constructor. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>TraitNotAStruct</span> {}

<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>value</span>: <span class='ident'>i32</span>
}

<span class='ident'>Foo</span>{ <span class='ident'>value</span>: <span class='number'>0</span> }; <span class='comment'>// ok!</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0161" class="section-header"><a href="#E0161">E0161</a></h2>
<p>In Rust, you can only move a value when its size is known at compile time.</p>

<p>To work around this restriction, consider &quot;hiding&quot; the value behind a reference:
either <code>&amp;x</code> or <code>&amp;mut x</code>. Since a reference has a fixed size, this lets you move
it around as usual.</p>
</div>
<div class="error-described error-used"><h2 id="E0162" class="section-header"><a href="#E0162">E0162</a></h2>
<p>An if-let pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular <code>let</code>-binding instead. For instance:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Irrefutable</span>(<span class='ident'>i32</span>);
<span class='kw'>let</span> <span class='ident'>irr</span> <span class='op'>=</span> <span class='ident'>Irrefutable</span>(<span class='number'>0</span>);

<span class='comment'>// This fails to compile because the match is irrefutable.</span>
<span class='kw'>if</span> <span class='kw'>let</span> <span class='ident'>Irrefutable</span>(<span class='ident'>x</span>) <span class='op'>=</span> <span class='ident'>irr</span> {
    <span class='comment'>// This body will always be executed.</span>
    <span class='ident'>foo</span>(<span class='ident'>x</span>);
}

<span class='comment'>// Try this instead:</span>
<span class='kw'>let</span> <span class='ident'>Irrefutable</span>(<span class='ident'>x</span>) <span class='op'>=</span> <span class='ident'>irr</span>;
<span class='ident'>foo</span>(<span class='ident'>x</span>);
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0163" class="section-header"><a href="#E0163">E0163</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0164" class="section-header"><a href="#E0164">E0164</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0165" class="section-header"><a href="#E0165">E0165</a></h2>
<p>A while-let pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular <code>let</code>-binding inside a <code>loop</code> instead. For instance:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Irrefutable</span>(<span class='ident'>i32</span>);
<span class='kw'>let</span> <span class='ident'>irr</span> <span class='op'>=</span> <span class='ident'>Irrefutable</span>(<span class='number'>0</span>);

<span class='comment'>// This fails to compile because the match is irrefutable.</span>
<span class='kw'>while</span> <span class='kw'>let</span> <span class='ident'>Irrefutable</span>(<span class='ident'>x</span>) <span class='op'>=</span> <span class='ident'>irr</span> {
    ...
}

<span class='comment'>// Try this instead:</span>
<span class='kw'>loop</span> {
    <span class='kw'>let</span> <span class='ident'>Irrefutable</span>(<span class='ident'>x</span>) <span class='op'>=</span> <span class='ident'>irr</span>;
    ...
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0166" class="section-header"><a href="#E0166">E0166</a></h2>
<p>This error means that the compiler found a return expression in a function
marked as diverging. A function diverges if it has <code>!</code> in the place of the
return type in its signature. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> { <span class='kw'>return</span>; } <span class='comment'>// error</span>
</pre>

<p>For a function that diverges, every control path in the function must never
return, for example with a <code>loop</code> that never breaks or a call to another
diverging function (such as <code>panic!()</code>).</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0167" class="section-header"><a href="#E0167">E0167</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0168" class="section-header"><a href="#E0168">E0168</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0170" class="section-header"><a href="#E0170">E0170</a></h2>
<p>Enum variants are qualified by default. For example, given this type:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Method</span> {
    <span class='ident'>GET</span>,
    <span class='ident'>POST</span>
}
</pre>

<p>you would match it using:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='ident'>m</span> {
    <span class='ident'>Method</span>::<span class='ident'>GET</span> <span class='op'>=&gt;</span> ...
    <span class='ident'>Method</span>::<span class='ident'>POST</span> <span class='op'>=&gt;</span> ...
}
</pre>

<p>If you don&#39;t qualify the names, the code will bind new variables named &quot;GET&quot; and
&quot;POST&quot; instead. This behavior is likely not what you want, so <code>rustc</code> warns when
that happens.</p>

<p>Qualified names are good practice, and most code works well with them. But if
you prefer them unqualified, you can import the variants into scope:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>Method</span>::<span class='op'>*</span>;
<span class='kw'>enum</span> <span class='ident'>Method</span> { <span class='ident'>GET</span>, <span class='ident'>POST</span> }
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0172" class="section-header"><a href="#E0172">E0172</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0173" class="section-header"><a href="#E0173">E0173</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0174" class="section-header"><a href="#E0174">E0174</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0178" class="section-header"><a href="#E0178">E0178</a></h2>
<p>In types, the <code>+</code> type operator has low precedence, so it is often necessary
to use parentheses.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {}

<span class='kw'>struct</span> <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>w</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>Foo</span> <span class='op'>+</span> <span class='ident'>Copy</span>,   <span class='comment'>// error, use &amp;&#39;a (Foo + Copy)</span>
    <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>Foo</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span>,     <span class='comment'>// error, use &amp;&#39;a (Foo + &#39;a)</span>
    <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Foo</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span>, <span class='comment'>// error, use &amp;&#39;a mut (Foo + &#39;a)</span>
    <span class='ident'>z</span>: <span class='kw'>fn</span>() <span class='op'>-&gt;</span> <span class='ident'>Foo</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span>, <span class='comment'>// error, use fn() -&gt; (Foo + &#39;a)</span>
}
</pre>

<p>More details can be found in <a href="https://github.com/rust-lang/rfcs/pull/438">RFC 438</a>.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0182" class="section-header"><a href="#E0182">E0182</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0183" class="section-header"><a href="#E0183">E0183</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0184" class="section-header"><a href="#E0184">E0184</a></h2>
<p>Explicitly implementing both Drop and Copy for a type is currently disallowed.
This feature can make some sense in theory, but the current implementation is
incorrect and can lead to memory unsafety (see <a href="https://github.com/rust-lang/rust/issues/20126">issue #20126</a>), so
it has been disabled for now.</p>
</div>
<div class="error-described error-used"><h2 id="E0185" class="section-header"><a href="#E0185">E0185</a></h2>
<p>An associated function for a trait was defined to be static, but an
implementation of the trait declared the same function to be a method (i.e. to
take a <code>self</code> parameter).</p>

<p>Here&#39;s an example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='comment'>// error, method `foo` has a `&amp;self` declaration in the impl, but not in</span>
    <span class='comment'>// the trait</span>
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {}
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0186" class="section-header"><a href="#E0186">E0186</a></h2>
<p>An associated function for a trait was defined to be a method (i.e. to take a
<code>self</code> parameter), but an implementation of the trait declared the same function
to be static.</p>

<p>Here&#39;s an example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='comment'>// error, method `foo` has a `&amp;self` declaration in the trait, but not in</span>
    <span class='comment'>// the impl</span>
    <span class='kw'>fn</span> <span class='ident'>foo</span>() {}
}
</pre>
</div>
<div class="error-undescribed error-unused"><h2 id="E0187" class="section-header"><a href="#E0187">E0187</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0188" class="section-header"><a href="#E0188">E0188</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0189" class="section-header"><a href="#E0189">E0189</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0190" class="section-header"><a href="#E0190">E0190</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0191" class="section-header"><a href="#E0191">E0191</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0192" class="section-header"><a href="#E0192">E0192</a></h2>
<p>Negative impls are only allowed for traits with default impls. For more
information see the <a href="https://github.com/rust-lang/%0Arfcs/blob/master/text/0019-opt-in-builtin-traits.md">opt-in builtin traits RFC</a>.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0193" class="section-header"><a href="#E0193">E0193</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0194" class="section-header"><a href="#E0194">E0194</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0195" class="section-header"><a href="#E0195">E0195</a></h2>
<p>Your method&#39;s lifetime parameters do not match the trait declaration.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>,<span class='lifetime'>&#39;b</span>:<span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span>);
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>,<span class='lifetime'>&#39;b</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span>) {
    <span class='comment'>// error: lifetime parameters or bounds on method `bar`</span>
    <span class='comment'>// do not match the trait declaration</span>
    }
}
</pre>

<p>The lifetime constraint <code>&#39;b</code> for bar() implementation does not match the
trait declaration. Ensure lifetime declarations match exactly in both trait
declaration and implementation. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>fn</span> <span class='ident'>t</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>,<span class='lifetime'>&#39;b</span>:<span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span>);
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>t</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>,<span class='lifetime'>&#39;b</span>:<span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span>) { <span class='comment'>// ok!</span>
    }
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0196" class="section-header"><a href="#E0196">E0196</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0197" class="section-header"><a href="#E0197">E0197</a></h2>
<p>Inherent implementations (one that do not implement a trait but provide
methods associated with a type) are always safe because they are not
implementing an unsafe trait. Removing the <code>unsafe</code> keyword from the inherent
implementation will resolve this error.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='comment'>// this will cause this error</span>
<span class='kw'>unsafe</span> <span class='kw'>impl</span> <span class='ident'>Foo</span> { }
<span class='comment'>// converting it to this will fix it</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> { }
</pre>
</div>
<div class="error-described error-used"><h2 id="E0198" class="section-header"><a href="#E0198">E0198</a></h2>
<p>A negative implementation is one that excludes a type from implementing a
particular trait. Not being able to use a trait is always a safe operation,
so negative implementations are always safe and never need to be marked as
unsafe.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='comment'>// unsafe is unnecessary</span>
<span class='kw'>unsafe</span> <span class='kw'>impl</span> <span class='op'>!</span><span class='ident'>Clone</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }
<span class='comment'>// this will compile</span>
<span class='kw'>impl</span> <span class='op'>!</span><span class='ident'>Clone</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }
</pre>
</div>
<div class="error-described error-used"><h2 id="E0199" class="section-header"><a href="#E0199">E0199</a></h2>
<p>Safe traits should not have unsafe implementations, therefore marking an
implementation for a safe trait unsafe will cause a compiler error. Removing the
unsafe marker on the trait noted in the error will resolve this problem.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>trait</span> <span class='ident'>Bar</span> { }

<span class='comment'>// this won&#39;t compile because Bar is safe</span>
<span class='kw'>unsafe</span> <span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }
<span class='comment'>// this will compile</span>
<span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }
</pre>
</div>
<div class="error-described error-used"><h2 id="E0200" class="section-header"><a href="#E0200">E0200</a></h2>
<p>Unsafe traits must have unsafe implementations. This error occurs when an
implementation for an unsafe trait isn&#39;t marked as unsafe. This may be resolved
by marking the unsafe implementation as unsafe.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>unsafe</span> <span class='kw'>trait</span> <span class='ident'>Bar</span> { }

<span class='comment'>// this won&#39;t compile because Bar is unsafe and impl isn&#39;t unsafe</span>
<span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }
<span class='comment'>// this will compile</span>
<span class='kw'>unsafe</span> <span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }
</pre>
</div>
<div class="error-described error-used"><h2 id="E0201" class="section-header"><a href="#E0201">E0201</a></h2>
<p>It is an error to define an associated function more than once.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>(<span class='ident'>u8</span>);

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='self'>self</span>.<span class='number'>0</span> <span class='op'>&gt;</span> <span class='number'>5</span> }

    <span class='comment'>// error: duplicate associated function</span>
    <span class='kw'>fn</span> <span class='ident'>bar</span>() {}
}

<span class='kw'>trait</span> <span class='ident'>Baz</span> {
    <span class='kw'>fn</span> <span class='ident'>baz</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
}

<span class='kw'>impl</span> <span class='ident'>Baz</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>baz</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='boolval'>true</span> }

    <span class='comment'>// error: duplicate method</span>
    <span class='kw'>fn</span> <span class='ident'>baz</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='self'>self</span>.<span class='number'>0</span> <span class='op'>&gt;</span> <span class='number'>5</span> }
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0202" class="section-header"><a href="#E0202">E0202</a></h2>
<p>Inherent associated types were part of <a href="https://github.com/rust-lang/rfcs/pull/195">RFC 195</a> but are not yet implemented.
See <a href="https://github.com/rust-lang/rust/issues/8995">the tracking issue</a> for the status of this implementation.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0203" class="section-header"><a href="#E0203">E0203</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0204" class="section-header"><a href="#E0204">E0204</a></h2>
<p>An attempt to implement the <code>Copy</code> trait for a struct failed because one of the
fields does not implement <code>Copy</code>. To fix this, you must implement <code>Copy</code> for the
mentioned field. Note that this may not be possible, as in the example of</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>foo</span> : <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span>,
}

<span class='kw'>impl</span> <span class='ident'>Copy</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }
</pre>

<p>This fails because <code>Vec&lt;T&gt;</code> does not implement <code>Copy</code> for any <code>T</code>.</p>

<p>Here&#39;s another example that will fail:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Copy</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>ty</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>bool</span>,
}
</pre>

<p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this
differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>
</div>
<div class="error-described error-used"><h2 id="E0205" class="section-header"><a href="#E0205">E0205</a></h2>
<p>An attempt to implement the <code>Copy</code> trait for an enum failed because one of the
variants does not implement <code>Copy</code>. To fix this, you must implement <code>Copy</code> for
the mentioned variant. Note that this may not be possible, as in the example of</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>Bar</span>(<span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span>),
    <span class='ident'>Baz</span>,
}

<span class='kw'>impl</span> <span class='ident'>Copy</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }
</pre>

<p>This fails because <code>Vec&lt;T&gt;</code> does not implement <code>Copy</code> for any <code>T</code>.</p>

<p>Here&#39;s another example that will fail:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Copy</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>Bar</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>bool</span>),
    <span class='ident'>Baz</span>
}
</pre>

<p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this
differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>
</div>
<div class="error-described error-used"><h2 id="E0206" class="section-header"><a href="#E0206">E0206</a></h2>
<p>You can only implement <code>Copy</code> for a struct or enum. Both of the following
examples will fail, because neither <code>i32</code> (primitive type) nor <code>&amp;&#39;static Bar</code>
(reference to <code>Bar</code>) is a struct or enum:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>i32</span>;
<span class='kw'>impl</span> <span class='ident'>Copy</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { } <span class='comment'>// error</span>

<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Copy</span>, <span class='ident'>Clone</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Bar</span>;
<span class='kw'>impl</span> <span class='ident'>Copy</span> <span class='kw'>for</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>Bar</span> { } <span class='comment'>// error</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0207" class="section-header"><a href="#E0207">E0207</a></h2>
<p>You declared an unused type parameter when implementing a trait on an object.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span>;
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
        <span class='number'>0</span>
    }
}
</pre>

<p>Please check your object definition and remove unused type
parameter(s). Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span>;
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
        <span class='number'>0</span>
    }
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0208" class="section-header"><a href="#E0208">E0208</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0209" class="section-header"><a href="#E0209">E0209</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0210" class="section-header"><a href="#E0210">E0210</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0211" class="section-header"><a href="#E0211">E0211</a></h2>
<p>You used an intrinsic function which doesn&#39;t correspond to its
definition. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>size_of</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(); <span class='comment'>// error: intrinsic has wrong type</span>
}
</pre>

<p>Please check the function definition. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>size_of</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() <span class='op'>-&gt;</span> <span class='ident'>usize</span>;
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0212" class="section-header"><a href="#E0212">E0212</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0213" class="section-header"><a href="#E0213">E0213</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0214" class="section-header"><a href="#E0214">E0214</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0215" class="section-header"><a href="#E0215">E0215</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0216" class="section-header"><a href="#E0216">E0216</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0217" class="section-header"><a href="#E0217">E0217</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0218" class="section-header"><a href="#E0218">E0218</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0219" class="section-header"><a href="#E0219">E0219</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0220" class="section-header"><a href="#E0220">E0220</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0221" class="section-header"><a href="#E0221">E0221</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0223" class="section-header"><a href="#E0223">E0223</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0224" class="section-header"><a href="#E0224">E0224</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0225" class="section-header"><a href="#E0225">E0225</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0226" class="section-header"><a href="#E0226">E0226</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0227" class="section-header"><a href="#E0227">E0227</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0228" class="section-header"><a href="#E0228">E0228</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0229" class="section-header"><a href="#E0229">E0229</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0230" class="section-header"><a href="#E0230">E0230</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0231" class="section-header"><a href="#E0231">E0231</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0232" class="section-header"><a href="#E0232">E0232</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0233" class="section-header"><a href="#E0233">E0233</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0234" class="section-header"><a href="#E0234">E0234</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0235" class="section-header"><a href="#E0235">E0235</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0236" class="section-header"><a href="#E0236">E0236</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0237" class="section-header"><a href="#E0237">E0237</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0238" class="section-header"><a href="#E0238">E0238</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0239" class="section-header"><a href="#E0239">E0239</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0240" class="section-header"><a href="#E0240">E0240</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0241" class="section-header"><a href="#E0241">E0241</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0242" class="section-header"><a href="#E0242">E0242</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0243" class="section-header"><a href="#E0243">E0243</a></h2>
<p>This error indicates that not enough type parameters were found in a type or
trait.</p>

<p>For example, the <code>Foo</code> struct below is defined to be generic in <code>T</code>, but the
type parameter is missing in the definition of <code>Bar</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='ident'>x</span>: <span class='ident'>T</span> }

<span class='kw'>struct</span> <span class='ident'>Bar</span> { <span class='ident'>x</span>: <span class='ident'>Foo</span> }
</pre>
</div>
<div class="error-described error-used"><h2 id="E0244" class="section-header"><a href="#E0244">E0244</a></h2>
<p>This error indicates that too many type parameters were found in a type or
trait.</p>

<p>For example, the <code>Foo</code> struct below has no type parameters, but is supplied
with two in the definition of <code>Bar</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='ident'>bool</span> }

<span class='kw'>struct</span> <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='ident'>S</span>, <span class='ident'>T</span><span class='op'>&gt;</span> { <span class='ident'>x</span>: <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>S</span>, <span class='ident'>T</span><span class='op'>&gt;</span> }
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0245" class="section-header"><a href="#E0245">E0245</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0246" class="section-header"><a href="#E0246">E0246</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0247" class="section-header"><a href="#E0247">E0247</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0248" class="section-header"><a href="#E0248">E0248</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0249" class="section-header"><a href="#E0249">E0249</a></h2>
<p>This error indicates a constant expression for the array length was found, but
it was not an integer (signed or unsigned) expression.</p>

<p>Some examples of code that produces this error are:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>A</span>: [<span class='ident'>u32</span>; <span class='string'>&quot;hello&quot;</span>] <span class='op'>=</span> []; <span class='comment'>// error</span>
<span class='kw'>const</span> <span class='ident'>B</span>: [<span class='ident'>u32</span>; <span class='boolval'>true</span>] <span class='op'>=</span> []; <span class='comment'>// error</span>
<span class='kw'>const</span> <span class='ident'>C</span>: [<span class='ident'>u32</span>; <span class='number'>0.0</span>] <span class='op'>=</span> []; <span class='comment'>// error</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0250" class="section-header"><a href="#E0250">E0250</a></h2>
<p>There was an error while evaluating the expression for the length of a fixed-
size array type.</p>

<p>Some examples of this error are:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// divide by zero in the length expression</span>
<span class='kw'>const</span> <span class='ident'>A</span>: [<span class='ident'>u32</span>; <span class='number'>1</span><span class='op'>/</span><span class='number'>0</span>] <span class='op'>=</span> [];

<span class='comment'>// Rust currently will not evaluate the function `foo` at compile time</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='number'>12</span> }
<span class='kw'>const</span> <span class='ident'>B</span>: [<span class='ident'>u32</span>; <span class='ident'>foo</span>()] <span class='op'>=</span> [];

<span class='comment'>// it is an error to try to add `u8` and `f64`</span>
<span class='kw'>use</span> <span class='ident'>std</span>::{<span class='ident'>f64</span>, <span class='ident'>u8</span>};
<span class='kw'>const</span> <span class='ident'>C</span>: [<span class='ident'>u32</span>; <span class='ident'>u8</span>::<span class='ident'>MAX</span> <span class='op'>+</span> <span class='ident'>f64</span>::<span class='ident'>EPSILON</span>] <span class='op'>=</span> [];
</pre>
</div>
<div class="error-described error-used"><h2 id="E0251" class="section-header"><a href="#E0251">E0251</a></h2>
<p>Two items of the same name cannot be imported without rebinding one of the
items under a new local name.</p>

<p>An example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>baz</span>;
<span class='kw'>use</span> <span class='ident'>bar</span>::<span class='op'>*</span>; <span class='comment'>// error, do `use foo::baz as quux` instead on the previous line</span>

<span class='kw'>fn</span> <span class='ident'>main</span>() {}

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>baz</span>;
}

<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>baz</span> {}
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0252" class="section-header"><a href="#E0252">E0252</a></h2>
<p>Two items of the same name cannot be imported without rebinding one of the
items under a new local name.</p>

<p>An example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>baz</span>;
<span class='kw'>use</span> <span class='ident'>bar</span>::<span class='ident'>baz</span>; <span class='comment'>// error, do `use bar::baz as quux` instead</span>

<span class='kw'>fn</span> <span class='ident'>main</span>() {}

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>baz</span>;
}

<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>baz</span> {}
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0253" class="section-header"><a href="#E0253">E0253</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0254" class="section-header"><a href="#E0254">E0254</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0255" class="section-header"><a href="#E0255">E0255</a></h2>
<p>You can&#39;t import a value whose name is the same as another value defined in the
module.</p>

<p>An example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>bar</span>::<span class='ident'>foo</span>; <span class='comment'>// error, do `use bar::foo as baz` instead</span>

<span class='kw'>fn</span> <span class='ident'>foo</span>() {}

<span class='kw'>mod</span> <span class='ident'>bar</span> {
     <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>() {}
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0256" class="section-header"><a href="#E0256">E0256</a></h2>
<p>You can&#39;t import a type or module when the name of the item being imported is
the same as another type or submodule defined in the module.</p>

<p>An example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>Bar</span>; <span class='comment'>// error</span>

<span class='kw'>type</span> <span class='ident'>Bar</span> <span class='op'>=</span> <span class='ident'>u32</span>;

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>Bar</span> { }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {}
</pre>
</div>
<div class="error-undescribed error-unused"><h2 id="E0257" class="section-header"><a href="#E0257">E0257</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0258" class="section-header"><a href="#E0258">E0258</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0259" class="section-header"><a href="#E0259">E0259</a></h2>
<p>The name chosen for an external crate conflicts with another external crate that
has been imported into the current module.</p>

<p>Wrong example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>a</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>crate_a</span> <span class='kw'>as</span> <span class='ident'>a</span>;
</pre>

<p>The solution is to choose a different name that doesn&#39;t conflict with any
external crate imported into the current module.</p>

<p>Correct example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>a</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>crate_a</span> <span class='kw'>as</span> <span class='ident'>other_name</span>;
</pre>
</div>
<div class="error-described error-used"><h2 id="E0260" class="section-header"><a href="#E0260">E0260</a></h2>
<p>The name for an item declaration conflicts with an external crate&#39;s name.</p>

<p>For instance,</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>abc</span>;

<span class='kw'>struct</span> <span class='ident'>abc</span>;
</pre>

<p>There are two possible solutions:</p>

<p>Solution #1: Rename the item.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>abc</span>;

<span class='kw'>struct</span> <span class='ident'>xyz</span>;
</pre>

<p>Solution #2: Import the crate with a different name.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>abc</span> <span class='kw'>as</span> <span class='ident'>xyz</span>;

<span class='kw'>struct</span> <span class='ident'>abc</span>;
</pre>

<p>See the Declaration Statements section of the reference for more information
about what constitutes an Item declaration and what does not:</p>

<p><a href="http://doc.rust-lang.org/reference.html#statements">http://doc.rust-lang.org/reference.html#statements</a></p>
</div>
<div class="error-described error-used"><h2 id="E0261" class="section-header"><a href="#E0261">E0261</a></h2>
<p>When using a lifetime like <code>&#39;a</code> in a type, it must be declared before being
used.</p>

<p>These two examples illustrate the problem:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error, use of undeclared lifetime name `&#39;a`</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>) { }

<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='comment'>// error, use of undeclared lifetime name `&#39;a`</span>
    <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>,
}
</pre>

<p>These can be fixed by declaring lifetime parameters:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>) { }

<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>,
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0262" class="section-header"><a href="#E0262">E0262</a></h2>
<p>Declaring certain lifetime names in parameters is disallowed. For example,
because the <code>&#39;static</code> lifetime is a special built-in lifetime name denoting
the lifetime of the entire program, this is an error:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error, illegal lifetime parameter name `&#39;static`</span>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;static</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span>) { }
</pre>
</div>
<div class="error-described error-used"><h2 id="E0263" class="section-header"><a href="#E0263">E0263</a></h2>
<p>A lifetime name cannot be declared more than once in the same scope. For
example:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error, lifetime name `&#39;a` declared twice in the same scope</span>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='lifetime'>&#39;b</span>, <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span>) { }
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0264" class="section-header"><a href="#E0264">E0264</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0265" class="section-header"><a href="#E0265">E0265</a></h2>
<p>This error indicates that a static or constant references itself.
All statics and constants need to resolve to a value in an acyclic manner.</p>

<p>For example, neither of the following can be sensibly compiled:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>X</span>;
</pre>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>Y</span>;
<span class='kw'>const</span> <span class='ident'>Y</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>X</span>;
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0266" class="section-header"><a href="#E0266">E0266</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0267" class="section-header"><a href="#E0267">E0267</a></h2>
<p>This error indicates the use of a loop keyword (<code>break</code> or <code>continue</code>) inside a
closure but outside of any loop. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>w</span> <span class='op'>=</span> <span class='op'>||</span> { <span class='kw'>break</span>; }; <span class='comment'>// error: `break` inside of a closure</span>
</pre>

<p><code>break</code> and <code>continue</code> keywords can be used as normal inside closures as long as
they are also contained within a loop. To halt the execution of a closure you
should instead use a return statement. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>w</span> <span class='op'>=</span> <span class='op'>||</span> {
    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='kw'>break</span>;
    }
};

<span class='ident'>w</span>();
</pre>
</div>
<div class="error-described error-used"><h2 id="E0268" class="section-header"><a href="#E0268">E0268</a></h2>
<p>This error indicates the use of a loop keyword (<code>break</code> or <code>continue</code>) outside
of a loop. Without a loop to break out of or continue in, no sensible action can
be taken. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>some_func</span>() {
    <span class='kw'>break</span>; <span class='comment'>// error: `break` outside of loop</span>
}
</pre>

<p>Please verify that you are using <code>break</code> and <code>continue</code> only in loops. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>some_func</span>() {
    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='kw'>break</span>; <span class='comment'>// ok!</span>
    }
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0269" class="section-header"><a href="#E0269">E0269</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0270" class="section-header"><a href="#E0270">E0270</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0271" class="section-header"><a href="#E0271">E0271</a></h2>
<p>This is because of a type mismatch between the associated type of some
trait (e.g. <code>T::Bar</code>, where <code>T</code> implements <code>trait Quux { type Bar; }</code>)
and another type <code>U</code> that is required to be equal to <code>T::Bar</code>, but is not.
Examples follow.</p>

<p>Here is a basic example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span>; }
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>t</span>: <span class='ident'>T</span>) <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Trait</span><span class='op'>&lt;</span><span class='ident'>AssociatedType</span><span class='op'>=</span><span class='ident'>u32</span><span class='op'>&gt;</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;in foo&quot;</span>);
}
<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>i8</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span>; }
<span class='ident'>foo</span>(<span class='number'>3_i8</span>);
</pre>

<p>Here is that same example again, with some explanatory comments:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span>; }

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>t</span>: <span class='ident'>T</span>) <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Trait</span><span class='op'>&lt;</span><span class='ident'>AssociatedType</span><span class='op'>=</span><span class='ident'>u32</span><span class='op'>&gt;</span> {
<span class='comment'>//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~</span>
<span class='comment'>//                        |            |</span>
<span class='comment'>//         This says `foo` can         |</span>
<span class='comment'>//           only be used with         |</span>
<span class='comment'>//              some type that         |</span>
<span class='comment'>//         implements `Trait`.         |</span>
<span class='comment'>//                                     |</span>
<span class='comment'>//                             This says not only must</span>
<span class='comment'>//                             `T` be an impl of `Trait`</span>
<span class='comment'>//                             but also that the impl</span>
<span class='comment'>//                             must assign the type `u32`</span>
<span class='comment'>//                             to the associated type.</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;in foo&quot;</span>);
}

<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>i8</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span>; }
<span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span>   <span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span>
<span class='comment'>//      |                             |</span>
<span class='comment'>// `i8` does have                     |</span>
<span class='comment'>// implementation                     |</span>
<span class='comment'>// of `Trait`...                      |</span>
<span class='comment'>//                     ... but it is an implementation</span>
<span class='comment'>//                     that assigns `&amp;&#39;static str` to</span>
<span class='comment'>//                     the associated type.</span>

<span class='ident'>foo</span>(<span class='number'>3_i8</span>);
<span class='comment'>// Here, we invoke `foo` with an `i8`, which does not satisfy</span>
<span class='comment'>// the constraint `&lt;i8 as Trait&gt;::AssociatedType=u32`, and</span>
<span class='comment'>// therefore the type-checker complains with this error code.</span>
</pre>

<p>Here is a more subtle instance of the same problem, that can
arise with for-loops in Rust:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>vs</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>for</span> <span class='ident'>v</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>vs</span> {
    <span class='kw'>match</span> <span class='ident'>v</span> {
        <span class='number'>1</span> <span class='op'>=&gt;</span> {}
        _ <span class='op'>=&gt;</span> {}
    }
}
</pre>

<p>The above fails because of an analogous type mismatch,
though may be harder to see. Again, here are some
explanatory comments for the same example:</p>
<pre class='rust rust-example-rendered'>
{
    <span class='kw'>let</span> <span class='ident'>vs</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];

    <span class='comment'>// `for`-loops use a protocol based on the `Iterator`</span>
    <span class='comment'>// trait. Each item yielded in a `for` loop has the</span>
    <span class='comment'>// type `Iterator::Item` -- that is,I `Item` is the</span>
    <span class='comment'>// associated type of the concrete iterator impl.</span>
    <span class='kw'>for</span> <span class='ident'>v</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>vs</span> {
<span class='comment'>//      ~    ~~~</span>
<span class='comment'>//      |     |</span>
<span class='comment'>//      |    We borrow `vs`, iterating over a sequence of</span>
<span class='comment'>//      |    *references* of type `&amp;Elem` (where `Elem` is</span>
<span class='comment'>//      |    vector&#39;s element type). Thus, the associated</span>
<span class='comment'>//      |    type `Item` must be a reference `&amp;`-type ...</span>
<span class='comment'>//      |</span>
<span class='comment'>//  ... and `v` has the type `Iterator::Item`, as dictated by</span>
<span class='comment'>//  the `for`-loop protocol ...</span>

        <span class='kw'>match</span> <span class='ident'>v</span> {
            <span class='number'>1</span> <span class='op'>=&gt;</span> {}
<span class='comment'>//          ~</span>
<span class='comment'>//          |</span>
<span class='comment'>// ... but *here*, `v` is forced to have some integral type;</span>
<span class='comment'>// only types like `u8`,`i8`,`u16`,`i16`, et cetera can</span>
<span class='comment'>// match the pattern `1` ...</span>

            _ <span class='op'>=&gt;</span> {}
        }

<span class='comment'>// ... therefore, the compiler complains, because it sees</span>
<span class='comment'>// an attempt to solve the equations</span>
<span class='comment'>// `some integral-type` = type-of-`v`</span>
<span class='comment'>//                      = `Iterator::Item`</span>
<span class='comment'>//                      = `&amp;Elem` (i.e. `some reference type`)</span>
<span class='comment'>//</span>
<span class='comment'>// which cannot possibly all be true.</span>

    }
}
</pre>

<p>To avoid those issues, you have to make the types match correctly.
So we can fix the previous examples like this:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Basic Example:</span>
<span class='kw'>trait</span> <span class='ident'>Trait</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span>; }
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>t</span>: <span class='ident'>T</span>) <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Trait</span><span class='op'>&lt;</span><span class='ident'>AssociatedType</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;in foo&quot;</span>);
}
<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>i8</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span>; }
<span class='ident'>foo</span>(<span class='number'>3_i8</span>);

<span class='comment'>// For-Loop Example:</span>
<span class='kw'>let</span> <span class='ident'>vs</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>for</span> <span class='ident'>v</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>vs</span> {
    <span class='kw'>match</span> <span class='ident'>v</span> {
        <span class='kw-2'>&amp;</span><span class='number'>1</span> <span class='op'>=&gt;</span> {}
        _ <span class='op'>=&gt;</span> {}
    }
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0272" class="section-header"><a href="#E0272">E0272</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0273" class="section-header"><a href="#E0273">E0273</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0274" class="section-header"><a href="#E0274">E0274</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0275" class="section-header"><a href="#E0275">E0275</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0276" class="section-header"><a href="#E0276">E0276</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0277" class="section-header"><a href="#E0277">E0277</a></h2>
<p>You tried to use a type which doesn&#39;t implement some trait in a place which
expected that trait. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// here we declare the Foo trait with a bar method</span>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}

<span class='comment'>// we now declare a function which takes an object with Foo trait implemented</span>
<span class='comment'>// as parameter</span>
<span class='kw'>fn</span> <span class='ident'>some_func</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span>(<span class='ident'>foo</span>: <span class='ident'>T</span>) {
    <span class='ident'>foo</span>.<span class='ident'>bar</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// we now call the method with the i32 type, which doesn&#39;t implement</span>
    <span class='comment'>// the Foo trait</span>
    <span class='ident'>some_func</span>(<span class='number'>5i32</span>); <span class='comment'>// error: the trait `Foo` is not implemented for the</span>
                     <span class='comment'>//     type `i32`</span>
}
</pre>

<p>In order to fix this error, verify that the type you&#39;re using does implement
the trait. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}

<span class='kw'>fn</span> <span class='ident'>some_func</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span>(<span class='ident'>foo</span>: <span class='ident'>T</span>) {
    <span class='ident'>foo</span>.<span class='ident'>bar</span>(); <span class='comment'>// we can now use this method since i32 implements the</span>
               <span class='comment'>// Foo trait</span>
}

<span class='comment'>// we implement the trait on the i32 type</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>i32</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {}
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>some_func</span>(<span class='number'>5i32</span>); <span class='comment'>// ok!</span>
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0278" class="section-header"><a href="#E0278">E0278</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0279" class="section-header"><a href="#E0279">E0279</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0280" class="section-header"><a href="#E0280">E0280</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0281" class="section-header"><a href="#E0281">E0281</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0282" class="section-header"><a href="#E0282">E0282</a></h2>
<p>This error indicates that type inference did not result in one unique possible
type, and extra information is required. In most cases this can be provided
by adding a type annotation. Sometimes you need to specify a generic type
parameter manually.</p>

<p>A common example is the <code>collect</code> method on <code>Iterator</code>. It has a generic type
parameter with a <code>FromIterator</code> bound, which for a <code>char</code> iterator is
implemented by <code>Vec</code> and <code>String</code> among others. Consider the following snippet
that reverses the characters of a string:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>.<span class='ident'>chars</span>().<span class='ident'>rev</span>().<span class='ident'>collect</span>();
</pre>

<p>In this case, the compiler cannot infer what the type of <code>x</code> should be:
<code>Vec&lt;char&gt;</code> and <code>String</code> are both suitable candidates. To specify which type to
use, you can use a type annotation on <code>x</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>char</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>.<span class='ident'>chars</span>().<span class='ident'>rev</span>().<span class='ident'>collect</span>();
</pre>

<p>It is not necessary to annotate the full type. Once the ambiguity is resolved,
the compiler can infer the rest:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>.<span class='ident'>chars</span>().<span class='ident'>rev</span>().<span class='ident'>collect</span>();
</pre>

<p>Another way to provide the compiler with enough information, is to specify the
generic type parameter:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>.<span class='ident'>chars</span>().<span class='ident'>rev</span>().<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>char</span><span class='op'>&gt;&gt;</span>();
</pre>

<p>Again, you need not specify the full type if the compiler can infer it:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>.<span class='ident'>chars</span>().<span class='ident'>rev</span>().<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>();
</pre>

<p>Apart from a method or function with a generic type parameter, this error can
occur when a type parameter of a struct or trait cannot be inferred. In that
case it is not always possible to use a type annotation, because all candidates
have the same return type. For instance:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='comment'>// Some fields omitted.</span>
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
        <span class='number'>0</span>
    }

    <span class='kw'>fn</span> <span class='ident'>baz</span>() {
        <span class='kw'>let</span> <span class='ident'>number</span> <span class='op'>=</span> <span class='ident'>Foo</span>::<span class='ident'>bar</span>();
    }
}
</pre>

<p>This will fail because the compiler does not know which instance of <code>Foo</code> to
call <code>bar</code> on. Change <code>Foo::bar()</code> to <code>Foo::&lt;T&gt;::bar()</code> to resolve the error.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0283" class="section-header"><a href="#E0283">E0283</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0284" class="section-header"><a href="#E0284">E0284</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0285" class="section-header"><a href="#E0285">E0285</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0296" class="section-header"><a href="#E0296">E0296</a></h2>
<p>This error indicates that the given recursion limit could not be parsed. Ensure
that the value provided is a positive integer between quotes, like so:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>recursion_limit</span><span class='op'>=</span><span class='string'>&quot;1000&quot;</span>]</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0297" class="section-header"><a href="#E0297">E0297</a></h2>
<p>Patterns used to bind names must be irrefutable. That is, they must guarantee
that a name will be extracted in all cases. Instead of pattern matching the
loop variable, consider using a <code>match</code> or <code>if let</code> inside the loop body. For
instance:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// This fails because `None` is not covered.</span>
<span class='kw'>for</span> <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='kw'>in</span> <span class='ident'>xs</span> {
    ...
}

<span class='comment'>// Match inside the loop instead:</span>
<span class='kw'>for</span> <span class='ident'>item</span> <span class='kw'>in</span> <span class='ident'>xs</span> {
    <span class='kw'>match</span> <span class='ident'>item</span> {
        <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> ...
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> ...
    }
}

<span class='comment'>// Or use `if let`:</span>
<span class='kw'>for</span> <span class='ident'>item</span> <span class='kw'>in</span> <span class='ident'>xs</span> {
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='op'>=</span> <span class='ident'>item</span> {
        ...
    }
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0298" class="section-header"><a href="#E0298">E0298</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0299" class="section-header"><a href="#E0299">E0299</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0300" class="section-header"><a href="#E0300">E0300</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0301" class="section-header"><a href="#E0301">E0301</a></h2>
<p>Mutable borrows are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if mutable
borrows were allowed:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(()) {
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> { },
    <span class='ident'>option</span> <span class='kw'>if</span> <span class='ident'>option</span>.<span class='ident'>take</span>().<span class='ident'>is_none</span>() <span class='op'>=&gt;</span> { <span class='comment'>/* impossible, option is `Some` */</span> },
    <span class='prelude-val'>Some</span>(_) <span class='op'>=&gt;</span> { } <span class='comment'>// When the previous match failed, the option became `None`.</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0302" class="section-header"><a href="#E0302">E0302</a></h2>
<p>Assignments are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if assignments
were allowed:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(()) {
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> { },
    <span class='ident'>option</span> <span class='kw'>if</span> { <span class='ident'>option</span> <span class='op'>=</span> <span class='prelude-val'>None</span>; <span class='boolval'>false</span> } { },
    <span class='prelude-val'>Some</span>(_) <span class='op'>=&gt;</span> { } <span class='comment'>// When the previous match failed, the option became `None`.</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0303" class="section-header"><a href="#E0303">E0303</a></h2>
<p>In certain cases it is possible for sub-bindings to violate memory safety.
Updates to the borrow checker in a future version of Rust may remove this
restriction, but for now patterns must be rewritten without sub-bindings.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Code like this...</span>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(<span class='number'>5</span>) {
    <span class='kw-2'>ref</span> <span class='ident'>op_num</span> <span class='kw-2'>@</span> <span class='prelude-val'>Some</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> ...
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> ...
}

<span class='comment'>// After.</span>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(<span class='string'>&quot;hi&quot;</span>.<span class='ident'>to_string</span>()) {
    <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>s</span>) <span class='op'>=&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>op_string_ref</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='ident'>s</span>);
        ...
    }
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> ...
}
</pre>

<p>The <code>op_string_ref</code> binding has type <code>&amp;Option&lt;&amp;String&gt;</code> in both cases.</p>

<p>See also <a href="https://github.com/rust-lang/rust/issues/14587">https://github.com/rust-lang/rust/issues/14587</a></p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0304" class="section-header"><a href="#E0304">E0304</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0305" class="section-header"><a href="#E0305">E0305</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0306" class="section-header"><a href="#E0306">E0306</a></h2>
<p>In an array literal <code>[x; N]</code>, <code>N</code> is the number of elements in the array. This
number cannot be negative.</p>
</div>
<div class="error-described error-used"><h2 id="E0307" class="section-header"><a href="#E0307">E0307</a></h2>
<p>The length of an array is part of its type. For this reason, this length must be
a compile-time constant.</p>
</div>
<div class="error-described error-used"><h2 id="E0308" class="section-header"><a href="#E0308">E0308</a></h2>
<p>This error occurs when the compiler was unable to infer the concrete type of a
variable. This error can occur for several cases, the most common of which is a
mismatch in the expected type that the compiler inferred for a variable&#39;s
initializing expression, and the actual type explicitly assigned to the
variable.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='string'>&quot;I am not a number!&quot;</span>;
<span class='comment'>//     ~~~   ~~~~~~~~~~~~~~~~~~~~</span>
<span class='comment'>//      |             |</span>
<span class='comment'>//      |    initializing expression;</span>
<span class='comment'>//      |    compiler infers type `&amp;str`</span>
<span class='comment'>//      |</span>
<span class='comment'>//    type `i32` assigned to variable `x`</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0309" class="section-header"><a href="#E0309">E0309</a></h2>
<p>Types in type definitions have lifetimes associated with them that represent
how long the data stored within them is guaranteed to be live. This lifetime
must be as long as the data needs to be alive, and missing the constraint that
denotes this will cause this error.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// This won&#39;t compile because T is not constrained, meaning the data</span>
<span class='comment'>// stored in it is not guaranteed to last as long as the reference</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>foo</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>T</span>
}

<span class='comment'>// This will compile, because it has the constraint on the type parameter</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>foo</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>T</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0310" class="section-header"><a href="#E0310">E0310</a></h2>
<p>Types in type definitions have lifetimes associated with them that represent
how long the data stored within them is guaranteed to be live. This lifetime
must be as long as the data needs to be alive, and missing the constraint that
denotes this will cause this error.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// This won&#39;t compile because T is not constrained to the static lifetime</span>
<span class='comment'>// the reference needs</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>foo</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>T</span>
}

<span class='comment'>// This will compile, because it has the constraint on the type parameter</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='lifetime'>&#39;static</span><span class='op'>&gt;</span> {
    <span class='ident'>foo</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>T</span>
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0311" class="section-header"><a href="#E0311">E0311</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0312" class="section-header"><a href="#E0312">E0312</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0313" class="section-header"><a href="#E0313">E0313</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0314" class="section-header"><a href="#E0314">E0314</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0315" class="section-header"><a href="#E0315">E0315</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0316" class="section-header"><a href="#E0316">E0316</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0317" class="section-header"><a href="#E0317">E0317</a></h2>
<p>User-defined types or type parameters cannot shadow the primitive types.
This error indicates you tried to define a type, struct or enum with the same
name as an existing primitive type.</p>

<p>See the Types section of the reference for more information about the primitive
types:</p>

<p><a href="http://doc.rust-lang.org/reference.html#types">http://doc.rust-lang.org/reference.html#types</a></p>
</div>
<div class="error-described error-used"><h2 id="E0318" class="section-header"><a href="#E0318">E0318</a></h2>
<p>Default impls for a trait must be located in the same crate where the trait was
defined. For more information see the <a href="https://github%0A.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md">opt-in builtin traits RFC</a>.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0319" class="section-header"><a href="#E0319">E0319</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0320" class="section-header"><a href="#E0320">E0320</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0321" class="section-header"><a href="#E0321">E0321</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0322" class="section-header"><a href="#E0322">E0322</a></h2>
<p>The <code>Sized</code> trait is a special trait built-in to the compiler for types with a
constant size known at compile-time. This trait is automatically implemented
for types as needed by the compiler, and it is currently disallowed to
explicitly implement it for a type.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0323" class="section-header"><a href="#E0323">E0323</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0324" class="section-header"><a href="#E0324">E0324</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0325" class="section-header"><a href="#E0325">E0325</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0326" class="section-header"><a href="#E0326">E0326</a></h2>
<p>The types of any associated constants in a trait implementation must match the
types in the trait definition. This error indicates that there was a mismatch.</p>

<p>Here&#39;s an example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>const</span> <span class='ident'>BAR</span>: <span class='ident'>bool</span>;
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>const</span> <span class='ident'>BAR</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// error, expected bool, found u32</span>
}
</pre>
</div>
<div class="error-described error-used"><h2 id="E0327" class="section-header"><a href="#E0327">E0327</a></h2>
<p>You cannot use associated items other than constant items as patterns. This
includes method items. Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>B</span> {}

<span class='kw'>impl</span> <span class='ident'>B</span> {
    <span class='kw'>fn</span> <span class='ident'>bb</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>0</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='number'>0</span> {
        <span class='ident'>B</span>::<span class='ident'>bb</span> <span class='op'>=&gt;</span> {} <span class='comment'>// error: associated items in match patterns must</span>
                    <span class='comment'>// be constants</span>
    }
}
</pre>

<p>Please check that you&#39;re not using a method as a pattern. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>B</span> {
    <span class='ident'>ba</span>,
    <span class='ident'>bb</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>B</span>::<span class='ident'>ba</span> {
        <span class='ident'>B</span>::<span class='ident'>bb</span> <span class='op'>=&gt;</span> {} <span class='comment'>// ok!</span>
        _ <span class='op'>=&gt;</span> {}
    }
}
</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0328" class="section-header"><a href="#E0328">E0328</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0329" class="section-header"><a href="#E0329">E0329</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0364" class="section-header"><a href="#E0364">E0364</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0365" class="section-header"><a href="#E0365">E0365</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0366" class="section-header"><a href="#E0366">E0366</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0367" class="section-header"><a href="#E0367">E0367</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0368" class="section-header"><a href="#E0368">E0368</a></h2>
<p>This error indicates that a binary assignment operator like <code>+=</code> or <code>^=</code> was
applied to the wrong types. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span>: <span class='ident'>u16</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='ident'>x</span> <span class='op'>^=</span> <span class='boolval'>true</span>; <span class='comment'>// error, `^=` cannot be applied to types `u16` and `bool`</span>
<span class='ident'>x</span> <span class='op'>+=</span> ();   <span class='comment'>// error, `+=` cannot be applied to types `u16` and `()`</span>
</pre>

<p>Another problem you might be facing is this: suppose you&#39;ve overloaded the <code>+</code>
operator for some type <code>Foo</code> by implementing the <code>std::ops::Add</code> trait for
<code>Foo</code>, but you find that using <code>+=</code> does not work, as in this example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Add</span>;

<span class='kw'>struct</span> <span class='ident'>Foo</span>(<span class='ident'>u32</span>);

<span class='kw'>impl</span> <span class='ident'>Add</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>Foo</span>;

    <span class='kw'>fn</span> <span class='ident'>add</span>(<span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='ident'>Foo</span>) <span class='op'>-&gt;</span> <span class='ident'>Foo</span> {
        <span class='ident'>Foo</span>(<span class='self'>self</span>.<span class='number'>0</span> <span class='op'>+</span> <span class='ident'>rhs</span>.<span class='number'>0</span>)
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span>: <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Foo</span>(<span class='number'>5</span>);
    <span class='ident'>x</span> <span class='op'>+=</span> <span class='ident'>Foo</span>(<span class='number'>7</span>); <span class='comment'>// error, `+= cannot be applied to types `Foo` and `Foo`</span>
}
</pre>

<p>This is because the binary assignment operators currently do not work off of
traits, so it is not possible to overload them. See <a href="https://github.com/rust-lang/rfcs/pull/953">RFC 953</a> for a proposal
to change this.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0369" class="section-header"><a href="#E0369">E0369</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0370" class="section-header"><a href="#E0370">E0370</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0371" class="section-header"><a href="#E0371">E0371</a></h2>
<p>When <code>Trait2</code> is a subtrait of <code>Trait1</code> (for example, when <code>Trait2</code> has a
definition like <code>trait Trait2: Trait1 { ... }</code>), it is not allowed to implement
<code>Trait1</code> for <code>Trait2</code>. This is because <code>Trait2</code> already implements <code>Trait1</code> by
definition, so it is not useful to do this.</p>

<p>Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { } }
<span class='kw'>trait</span> <span class='ident'>Bar</span>: <span class='ident'>Foo</span> { }
<span class='kw'>trait</span> <span class='ident'>Baz</span>: <span class='ident'>Bar</span> { }

<span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>Baz</span> { } <span class='comment'>// error, `Baz` implements `Bar` by definition</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Baz</span> { } <span class='comment'>// error, `Baz` implements `Bar` which implements `Foo`</span>
<span class='kw'>impl</span> <span class='ident'>Baz</span> <span class='kw'>for</span> <span class='ident'>Baz</span> { } <span class='comment'>// error, `Baz` (trivially) implements `Baz`</span>
<span class='kw'>impl</span> <span class='ident'>Baz</span> <span class='kw'>for</span> <span class='ident'>Bar</span> { } <span class='comment'>// Note: This is OK</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0372" class="section-header"><a href="#E0372">E0372</a></h2>
<p>Trying to implement a trait for a trait object (as in <code>impl Trait1 for Trait2 { ... }</code>) does not work if the trait is not object-safe. Please see the
<a href="https://github.com/rust-lang/rfcs/pull/255">RFC 255</a> for more details on object safety rules.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0373" class="section-header"><a href="#E0373">E0373</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0374" class="section-header"><a href="#E0374">E0374</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0375" class="section-header"><a href="#E0375">E0375</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0376" class="section-header"><a href="#E0376">E0376</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0377" class="section-header"><a href="#E0377">E0377</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0378" class="section-header"><a href="#E0378">E0378</a></h2>
<p>Method calls that aren&#39;t calls to inherent <code>const</code> methods are disallowed
in statics, constants, and constant functions.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>BAZ</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>Foo</span>(<span class='number'>25</span>).<span class='ident'>bar</span>(); <span class='comment'>// error, `bar` isn&#39;t `const`</span>

<span class='kw'>struct</span> <span class='ident'>Foo</span>(<span class='ident'>i32</span>);

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>const</span> <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
        <span class='self'>self</span>.<span class='ident'>bar</span>() <span class='comment'>// error, `bar` isn&#39;t `const`</span>
    }

    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='self'>self</span>.<span class='number'>0</span> }
}
</pre>

<p>For more information about <code>const fn</code>&#39;s, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md">RFC 911</a>.</p>
</div>
<div class="error-described error-used"><h2 id="E0379" class="section-header"><a href="#E0379">E0379</a></h2>
<p>Trait methods cannot be declared <code>const</code> by design. For more information, see
<a href="https://github.com/rust-lang/rfcs/pull/911">RFC 911</a>.</p>
</div>
<div class="error-described error-used"><h2 id="E0380" class="section-header"><a href="#E0380">E0380</a></h2>
<p>Default impls are only allowed for traits with no methods or associated items.
For more information see the <a href="https://github.com/rust%0A-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md">opt-in builtin traits RFC</a>.</p>
</div>
<div class="error-described error-used"><h2 id="E0381" class="section-header"><a href="#E0381">E0381</a></h2>
<p>It is not allowed to use or capture an uninitialized variable. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>; <span class='comment'>// error, use of possibly uninitialized variable</span>
</pre>

<p>To fix this, ensure that any declared variables are initialized before being
used.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0382" class="section-header"><a href="#E0382">E0382</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0383" class="section-header"><a href="#E0383">E0383</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0384" class="section-header"><a href="#E0384">E0384</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0385" class="section-header"><a href="#E0385">E0385</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0386" class="section-header"><a href="#E0386">E0386</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0387" class="section-header"><a href="#E0387">E0387</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0388" class="section-header"><a href="#E0388">E0388</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0389" class="section-header"><a href="#E0389">E0389</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0390" class="section-header"><a href="#E0390">E0390</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0391" class="section-header"><a href="#E0391">E0391</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0392" class="section-header"><a href="#E0392">E0392</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0393" class="section-header"><a href="#E0393">E0393</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0394" class="section-header"><a href="#E0394">E0394</a></h2>
<p>From <a href="https://github.com/rust-lang/rfcs/pull/246">RFC 246</a>:</p>

<blockquote>
<p>It is illegal for a static to reference another static by value. It is
required that all references be borrowed.</p>
</blockquote>
</div>
<div class="error-described error-used"><h2 id="E0395" class="section-header"><a href="#E0395">E0395</a></h2>
<p>The value assigned to a constant expression must be known at compile time,
which is not the case when comparing raw pointers. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>static</span> <span class='ident'>foo</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>static</span> <span class='ident'>bar</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>43</span>;

<span class='kw'>static</span> <span class='ident'>baz</span>: <span class='ident'>bool</span> <span class='op'>=</span> { (<span class='kw-2'>&amp;</span><span class='ident'>foo</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>) <span class='op'>==</span> (<span class='kw-2'>&amp;</span><span class='ident'>bar</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>) };
<span class='comment'>// error: raw pointers cannot be compared in statics!</span>
</pre>

<p>Please check that the result of the comparison can be determined at compile time
or isn&#39;t assigned to a constant expression. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>static</span> <span class='ident'>foo</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>static</span> <span class='ident'>bar</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>43</span>;

<span class='kw'>let</span> <span class='ident'>baz</span>: <span class='ident'>bool</span> <span class='op'>=</span> { (<span class='kw-2'>&amp;</span><span class='ident'>foo</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>) <span class='op'>==</span> (<span class='kw-2'>&amp;</span><span class='ident'>bar</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>) };
<span class='comment'>// baz isn&#39;t a constant expression so it&#39;s ok</span>
</pre>
</div>
<div class="error-described error-used"><h2 id="E0396" class="section-header"><a href="#E0396">E0396</a></h2>
<p>The value assigned to a constant expression must be known at compile time,
which is not the case when dereferencing raw pointers. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>foo</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>const</span> <span class='ident'>baz</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span> <span class='op'>=</span> (<span class='kw-2'>&amp;</span><span class='ident'>foo</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>);

<span class='kw'>const</span> <span class='ident'>deref</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>baz</span>;
<span class='comment'>// error: raw pointers cannot be dereferenced in constants</span>
</pre>

<p>To fix this error, please do not assign this value to a constant expression.
Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>foo</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>const</span> <span class='ident'>baz</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span> <span class='op'>=</span> (<span class='kw-2'>&amp;</span><span class='ident'>foo</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>);

<span class='kw'>unsafe</span> { <span class='kw'>let</span> <span class='ident'>deref</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>baz</span>; }
<span class='comment'>// baz isn&#39;t a constant expression so it&#39;s ok</span>
</pre>

<p>You&#39;ll also note that this assignment must be done in an unsafe block!</p>
</div>
<div class="error-described error-used"><h2 id="E0397" class="section-header"><a href="#E0397">E0397</a></h2>
<p>It is not allowed for a mutable static to allocate or have destructors. For
example:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error: mutable statics are not allowed to have boxes</span>
<span class='kw'>static</span> <span class='kw-2'>mut</span> <span class='ident'>FOO</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;&gt;</span> <span class='op'>=</span> <span class='prelude-val'>None</span>;

<span class='comment'>// error: mutable statics are not allowed to have destructors</span>
<span class='kw'>static</span> <span class='kw-2'>mut</span> <span class='ident'>BAR</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;&gt;</span> <span class='op'>=</span> <span class='prelude-val'>None</span>;
</pre>
</div>
<div class="error-described error-used"><h2 id="E0398" class="section-header"><a href="#E0398">E0398</a></h2>
<p>In Rust 1.3, the default object lifetime bounds are expected to
change, as described in RFC #1156 <a href="https://github.com/rust-lang/rfcs/pull/1156">1</a>. You are getting a warning
because the compiler thinks it is possible that this change will cause
a compilation error in your code. It is possible, though unlikely,
that this is a false alarm.</p>

<p>The heart of the change is that where <code>&amp;&#39;a Box&lt;SomeTrait&gt;</code> used to
default to <code>&amp;&#39;a Box&lt;SomeTrait+&#39;a&gt;</code>, it now defaults to <code>&amp;&#39;a Box&lt;SomeTrait+&#39;static&gt;</code> (here, <code>SomeTrait</code> is the name of some trait
type). Note that the only types which are affected are references to
boxes, like <code>&amp;Box&lt;SomeTrait&gt;</code> or <code>&amp;[Box&lt;SomeTrait&gt;]</code>.  More common
types like <code>&amp;SomeTrait</code> or <code>Box&lt;SomeTrait&gt;</code> are unaffected.</p>

<p>To silence this warning, edit your code to use an explicit bound.
Most of the time, this means that you will want to change the
signature of a function that you are calling. For example, if
the error is reported on a call like <code>foo(x)</code>, and <code>foo</code> is
defined as follows:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>arg</span>: <span class='kw-2'>&amp;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>SomeTrait</span><span class='op'>&gt;</span>) { ... }
</pre>

<p>you might change it to:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>arg</span>: <span class='kw-2'>&amp;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>SomeTrait</span><span class='op'>+</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>) { ... }
</pre>

<p>This explicitly states that you expect the trait object <code>SomeTrait</code> to
contain references (with a maximum lifetime of <code>&#39;a</code>).</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0399" class="section-header"><a href="#E0399">E0399</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0400" class="section-header"><a href="#E0400">E0400</a></h2>
<p>No description.</p>
</div>
</body>
</html>