<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="Source to the Rust file `src/librustc_typeck/check/mod.rs`.">
    <meta name="keywords" content="rust, rustlang, rust-lang">

    <title>mod.rs.html -- source</title>

    <link rel="stylesheet" type="text/css" href="../../../normalize.css">
    <link rel="stylesheet" type="text/css" href="../../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../../main.css">
    

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc source">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../../../rustc_typeck/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='logo' width='100'></a>
        
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content"><pre class="line-numbers"><span id="1">   1</span>
<span id="2">   2</span>
<span id="3">   3</span>
<span id="4">   4</span>
<span id="5">   5</span>
<span id="6">   6</span>
<span id="7">   7</span>
<span id="8">   8</span>
<span id="9">   9</span>
<span id="10">  10</span>
<span id="11">  11</span>
<span id="12">  12</span>
<span id="13">  13</span>
<span id="14">  14</span>
<span id="15">  15</span>
<span id="16">  16</span>
<span id="17">  17</span>
<span id="18">  18</span>
<span id="19">  19</span>
<span id="20">  20</span>
<span id="21">  21</span>
<span id="22">  22</span>
<span id="23">  23</span>
<span id="24">  24</span>
<span id="25">  25</span>
<span id="26">  26</span>
<span id="27">  27</span>
<span id="28">  28</span>
<span id="29">  29</span>
<span id="30">  30</span>
<span id="31">  31</span>
<span id="32">  32</span>
<span id="33">  33</span>
<span id="34">  34</span>
<span id="35">  35</span>
<span id="36">  36</span>
<span id="37">  37</span>
<span id="38">  38</span>
<span id="39">  39</span>
<span id="40">  40</span>
<span id="41">  41</span>
<span id="42">  42</span>
<span id="43">  43</span>
<span id="44">  44</span>
<span id="45">  45</span>
<span id="46">  46</span>
<span id="47">  47</span>
<span id="48">  48</span>
<span id="49">  49</span>
<span id="50">  50</span>
<span id="51">  51</span>
<span id="52">  52</span>
<span id="53">  53</span>
<span id="54">  54</span>
<span id="55">  55</span>
<span id="56">  56</span>
<span id="57">  57</span>
<span id="58">  58</span>
<span id="59">  59</span>
<span id="60">  60</span>
<span id="61">  61</span>
<span id="62">  62</span>
<span id="63">  63</span>
<span id="64">  64</span>
<span id="65">  65</span>
<span id="66">  66</span>
<span id="67">  67</span>
<span id="68">  68</span>
<span id="69">  69</span>
<span id="70">  70</span>
<span id="71">  71</span>
<span id="72">  72</span>
<span id="73">  73</span>
<span id="74">  74</span>
<span id="75">  75</span>
<span id="76">  76</span>
<span id="77">  77</span>
<span id="78">  78</span>
<span id="79">  79</span>
<span id="80">  80</span>
<span id="81">  81</span>
<span id="82">  82</span>
<span id="83">  83</span>
<span id="84">  84</span>
<span id="85">  85</span>
<span id="86">  86</span>
<span id="87">  87</span>
<span id="88">  88</span>
<span id="89">  89</span>
<span id="90">  90</span>
<span id="91">  91</span>
<span id="92">  92</span>
<span id="93">  93</span>
<span id="94">  94</span>
<span id="95">  95</span>
<span id="96">  96</span>
<span id="97">  97</span>
<span id="98">  98</span>
<span id="99">  99</span>
<span id="100"> 100</span>
<span id="101"> 101</span>
<span id="102"> 102</span>
<span id="103"> 103</span>
<span id="104"> 104</span>
<span id="105"> 105</span>
<span id="106"> 106</span>
<span id="107"> 107</span>
<span id="108"> 108</span>
<span id="109"> 109</span>
<span id="110"> 110</span>
<span id="111"> 111</span>
<span id="112"> 112</span>
<span id="113"> 113</span>
<span id="114"> 114</span>
<span id="115"> 115</span>
<span id="116"> 116</span>
<span id="117"> 117</span>
<span id="118"> 118</span>
<span id="119"> 119</span>
<span id="120"> 120</span>
<span id="121"> 121</span>
<span id="122"> 122</span>
<span id="123"> 123</span>
<span id="124"> 124</span>
<span id="125"> 125</span>
<span id="126"> 126</span>
<span id="127"> 127</span>
<span id="128"> 128</span>
<span id="129"> 129</span>
<span id="130"> 130</span>
<span id="131"> 131</span>
<span id="132"> 132</span>
<span id="133"> 133</span>
<span id="134"> 134</span>
<span id="135"> 135</span>
<span id="136"> 136</span>
<span id="137"> 137</span>
<span id="138"> 138</span>
<span id="139"> 139</span>
<span id="140"> 140</span>
<span id="141"> 141</span>
<span id="142"> 142</span>
<span id="143"> 143</span>
<span id="144"> 144</span>
<span id="145"> 145</span>
<span id="146"> 146</span>
<span id="147"> 147</span>
<span id="148"> 148</span>
<span id="149"> 149</span>
<span id="150"> 150</span>
<span id="151"> 151</span>
<span id="152"> 152</span>
<span id="153"> 153</span>
<span id="154"> 154</span>
<span id="155"> 155</span>
<span id="156"> 156</span>
<span id="157"> 157</span>
<span id="158"> 158</span>
<span id="159"> 159</span>
<span id="160"> 160</span>
<span id="161"> 161</span>
<span id="162"> 162</span>
<span id="163"> 163</span>
<span id="164"> 164</span>
<span id="165"> 165</span>
<span id="166"> 166</span>
<span id="167"> 167</span>
<span id="168"> 168</span>
<span id="169"> 169</span>
<span id="170"> 170</span>
<span id="171"> 171</span>
<span id="172"> 172</span>
<span id="173"> 173</span>
<span id="174"> 174</span>
<span id="175"> 175</span>
<span id="176"> 176</span>
<span id="177"> 177</span>
<span id="178"> 178</span>
<span id="179"> 179</span>
<span id="180"> 180</span>
<span id="181"> 181</span>
<span id="182"> 182</span>
<span id="183"> 183</span>
<span id="184"> 184</span>
<span id="185"> 185</span>
<span id="186"> 186</span>
<span id="187"> 187</span>
<span id="188"> 188</span>
<span id="189"> 189</span>
<span id="190"> 190</span>
<span id="191"> 191</span>
<span id="192"> 192</span>
<span id="193"> 193</span>
<span id="194"> 194</span>
<span id="195"> 195</span>
<span id="196"> 196</span>
<span id="197"> 197</span>
<span id="198"> 198</span>
<span id="199"> 199</span>
<span id="200"> 200</span>
<span id="201"> 201</span>
<span id="202"> 202</span>
<span id="203"> 203</span>
<span id="204"> 204</span>
<span id="205"> 205</span>
<span id="206"> 206</span>
<span id="207"> 207</span>
<span id="208"> 208</span>
<span id="209"> 209</span>
<span id="210"> 210</span>
<span id="211"> 211</span>
<span id="212"> 212</span>
<span id="213"> 213</span>
<span id="214"> 214</span>
<span id="215"> 215</span>
<span id="216"> 216</span>
<span id="217"> 217</span>
<span id="218"> 218</span>
<span id="219"> 219</span>
<span id="220"> 220</span>
<span id="221"> 221</span>
<span id="222"> 222</span>
<span id="223"> 223</span>
<span id="224"> 224</span>
<span id="225"> 225</span>
<span id="226"> 226</span>
<span id="227"> 227</span>
<span id="228"> 228</span>
<span id="229"> 229</span>
<span id="230"> 230</span>
<span id="231"> 231</span>
<span id="232"> 232</span>
<span id="233"> 233</span>
<span id="234"> 234</span>
<span id="235"> 235</span>
<span id="236"> 236</span>
<span id="237"> 237</span>
<span id="238"> 238</span>
<span id="239"> 239</span>
<span id="240"> 240</span>
<span id="241"> 241</span>
<span id="242"> 242</span>
<span id="243"> 243</span>
<span id="244"> 244</span>
<span id="245"> 245</span>
<span id="246"> 246</span>
<span id="247"> 247</span>
<span id="248"> 248</span>
<span id="249"> 249</span>
<span id="250"> 250</span>
<span id="251"> 251</span>
<span id="252"> 252</span>
<span id="253"> 253</span>
<span id="254"> 254</span>
<span id="255"> 255</span>
<span id="256"> 256</span>
<span id="257"> 257</span>
<span id="258"> 258</span>
<span id="259"> 259</span>
<span id="260"> 260</span>
<span id="261"> 261</span>
<span id="262"> 262</span>
<span id="263"> 263</span>
<span id="264"> 264</span>
<span id="265"> 265</span>
<span id="266"> 266</span>
<span id="267"> 267</span>
<span id="268"> 268</span>
<span id="269"> 269</span>
<span id="270"> 270</span>
<span id="271"> 271</span>
<span id="272"> 272</span>
<span id="273"> 273</span>
<span id="274"> 274</span>
<span id="275"> 275</span>
<span id="276"> 276</span>
<span id="277"> 277</span>
<span id="278"> 278</span>
<span id="279"> 279</span>
<span id="280"> 280</span>
<span id="281"> 281</span>
<span id="282"> 282</span>
<span id="283"> 283</span>
<span id="284"> 284</span>
<span id="285"> 285</span>
<span id="286"> 286</span>
<span id="287"> 287</span>
<span id="288"> 288</span>
<span id="289"> 289</span>
<span id="290"> 290</span>
<span id="291"> 291</span>
<span id="292"> 292</span>
<span id="293"> 293</span>
<span id="294"> 294</span>
<span id="295"> 295</span>
<span id="296"> 296</span>
<span id="297"> 297</span>
<span id="298"> 298</span>
<span id="299"> 299</span>
<span id="300"> 300</span>
<span id="301"> 301</span>
<span id="302"> 302</span>
<span id="303"> 303</span>
<span id="304"> 304</span>
<span id="305"> 305</span>
<span id="306"> 306</span>
<span id="307"> 307</span>
<span id="308"> 308</span>
<span id="309"> 309</span>
<span id="310"> 310</span>
<span id="311"> 311</span>
<span id="312"> 312</span>
<span id="313"> 313</span>
<span id="314"> 314</span>
<span id="315"> 315</span>
<span id="316"> 316</span>
<span id="317"> 317</span>
<span id="318"> 318</span>
<span id="319"> 319</span>
<span id="320"> 320</span>
<span id="321"> 321</span>
<span id="322"> 322</span>
<span id="323"> 323</span>
<span id="324"> 324</span>
<span id="325"> 325</span>
<span id="326"> 326</span>
<span id="327"> 327</span>
<span id="328"> 328</span>
<span id="329"> 329</span>
<span id="330"> 330</span>
<span id="331"> 331</span>
<span id="332"> 332</span>
<span id="333"> 333</span>
<span id="334"> 334</span>
<span id="335"> 335</span>
<span id="336"> 336</span>
<span id="337"> 337</span>
<span id="338"> 338</span>
<span id="339"> 339</span>
<span id="340"> 340</span>
<span id="341"> 341</span>
<span id="342"> 342</span>
<span id="343"> 343</span>
<span id="344"> 344</span>
<span id="345"> 345</span>
<span id="346"> 346</span>
<span id="347"> 347</span>
<span id="348"> 348</span>
<span id="349"> 349</span>
<span id="350"> 350</span>
<span id="351"> 351</span>
<span id="352"> 352</span>
<span id="353"> 353</span>
<span id="354"> 354</span>
<span id="355"> 355</span>
<span id="356"> 356</span>
<span id="357"> 357</span>
<span id="358"> 358</span>
<span id="359"> 359</span>
<span id="360"> 360</span>
<span id="361"> 361</span>
<span id="362"> 362</span>
<span id="363"> 363</span>
<span id="364"> 364</span>
<span id="365"> 365</span>
<span id="366"> 366</span>
<span id="367"> 367</span>
<span id="368"> 368</span>
<span id="369"> 369</span>
<span id="370"> 370</span>
<span id="371"> 371</span>
<span id="372"> 372</span>
<span id="373"> 373</span>
<span id="374"> 374</span>
<span id="375"> 375</span>
<span id="376"> 376</span>
<span id="377"> 377</span>
<span id="378"> 378</span>
<span id="379"> 379</span>
<span id="380"> 380</span>
<span id="381"> 381</span>
<span id="382"> 382</span>
<span id="383"> 383</span>
<span id="384"> 384</span>
<span id="385"> 385</span>
<span id="386"> 386</span>
<span id="387"> 387</span>
<span id="388"> 388</span>
<span id="389"> 389</span>
<span id="390"> 390</span>
<span id="391"> 391</span>
<span id="392"> 392</span>
<span id="393"> 393</span>
<span id="394"> 394</span>
<span id="395"> 395</span>
<span id="396"> 396</span>
<span id="397"> 397</span>
<span id="398"> 398</span>
<span id="399"> 399</span>
<span id="400"> 400</span>
<span id="401"> 401</span>
<span id="402"> 402</span>
<span id="403"> 403</span>
<span id="404"> 404</span>
<span id="405"> 405</span>
<span id="406"> 406</span>
<span id="407"> 407</span>
<span id="408"> 408</span>
<span id="409"> 409</span>
<span id="410"> 410</span>
<span id="411"> 411</span>
<span id="412"> 412</span>
<span id="413"> 413</span>
<span id="414"> 414</span>
<span id="415"> 415</span>
<span id="416"> 416</span>
<span id="417"> 417</span>
<span id="418"> 418</span>
<span id="419"> 419</span>
<span id="420"> 420</span>
<span id="421"> 421</span>
<span id="422"> 422</span>
<span id="423"> 423</span>
<span id="424"> 424</span>
<span id="425"> 425</span>
<span id="426"> 426</span>
<span id="427"> 427</span>
<span id="428"> 428</span>
<span id="429"> 429</span>
<span id="430"> 430</span>
<span id="431"> 431</span>
<span id="432"> 432</span>
<span id="433"> 433</span>
<span id="434"> 434</span>
<span id="435"> 435</span>
<span id="436"> 436</span>
<span id="437"> 437</span>
<span id="438"> 438</span>
<span id="439"> 439</span>
<span id="440"> 440</span>
<span id="441"> 441</span>
<span id="442"> 442</span>
<span id="443"> 443</span>
<span id="444"> 444</span>
<span id="445"> 445</span>
<span id="446"> 446</span>
<span id="447"> 447</span>
<span id="448"> 448</span>
<span id="449"> 449</span>
<span id="450"> 450</span>
<span id="451"> 451</span>
<span id="452"> 452</span>
<span id="453"> 453</span>
<span id="454"> 454</span>
<span id="455"> 455</span>
<span id="456"> 456</span>
<span id="457"> 457</span>
<span id="458"> 458</span>
<span id="459"> 459</span>
<span id="460"> 460</span>
<span id="461"> 461</span>
<span id="462"> 462</span>
<span id="463"> 463</span>
<span id="464"> 464</span>
<span id="465"> 465</span>
<span id="466"> 466</span>
<span id="467"> 467</span>
<span id="468"> 468</span>
<span id="469"> 469</span>
<span id="470"> 470</span>
<span id="471"> 471</span>
<span id="472"> 472</span>
<span id="473"> 473</span>
<span id="474"> 474</span>
<span id="475"> 475</span>
<span id="476"> 476</span>
<span id="477"> 477</span>
<span id="478"> 478</span>
<span id="479"> 479</span>
<span id="480"> 480</span>
<span id="481"> 481</span>
<span id="482"> 482</span>
<span id="483"> 483</span>
<span id="484"> 484</span>
<span id="485"> 485</span>
<span id="486"> 486</span>
<span id="487"> 487</span>
<span id="488"> 488</span>
<span id="489"> 489</span>
<span id="490"> 490</span>
<span id="491"> 491</span>
<span id="492"> 492</span>
<span id="493"> 493</span>
<span id="494"> 494</span>
<span id="495"> 495</span>
<span id="496"> 496</span>
<span id="497"> 497</span>
<span id="498"> 498</span>
<span id="499"> 499</span>
<span id="500"> 500</span>
<span id="501"> 501</span>
<span id="502"> 502</span>
<span id="503"> 503</span>
<span id="504"> 504</span>
<span id="505"> 505</span>
<span id="506"> 506</span>
<span id="507"> 507</span>
<span id="508"> 508</span>
<span id="509"> 509</span>
<span id="510"> 510</span>
<span id="511"> 511</span>
<span id="512"> 512</span>
<span id="513"> 513</span>
<span id="514"> 514</span>
<span id="515"> 515</span>
<span id="516"> 516</span>
<span id="517"> 517</span>
<span id="518"> 518</span>
<span id="519"> 519</span>
<span id="520"> 520</span>
<span id="521"> 521</span>
<span id="522"> 522</span>
<span id="523"> 523</span>
<span id="524"> 524</span>
<span id="525"> 525</span>
<span id="526"> 526</span>
<span id="527"> 527</span>
<span id="528"> 528</span>
<span id="529"> 529</span>
<span id="530"> 530</span>
<span id="531"> 531</span>
<span id="532"> 532</span>
<span id="533"> 533</span>
<span id="534"> 534</span>
<span id="535"> 535</span>
<span id="536"> 536</span>
<span id="537"> 537</span>
<span id="538"> 538</span>
<span id="539"> 539</span>
<span id="540"> 540</span>
<span id="541"> 541</span>
<span id="542"> 542</span>
<span id="543"> 543</span>
<span id="544"> 544</span>
<span id="545"> 545</span>
<span id="546"> 546</span>
<span id="547"> 547</span>
<span id="548"> 548</span>
<span id="549"> 549</span>
<span id="550"> 550</span>
<span id="551"> 551</span>
<span id="552"> 552</span>
<span id="553"> 553</span>
<span id="554"> 554</span>
<span id="555"> 555</span>
<span id="556"> 556</span>
<span id="557"> 557</span>
<span id="558"> 558</span>
<span id="559"> 559</span>
<span id="560"> 560</span>
<span id="561"> 561</span>
<span id="562"> 562</span>
<span id="563"> 563</span>
<span id="564"> 564</span>
<span id="565"> 565</span>
<span id="566"> 566</span>
<span id="567"> 567</span>
<span id="568"> 568</span>
<span id="569"> 569</span>
<span id="570"> 570</span>
<span id="571"> 571</span>
<span id="572"> 572</span>
<span id="573"> 573</span>
<span id="574"> 574</span>
<span id="575"> 575</span>
<span id="576"> 576</span>
<span id="577"> 577</span>
<span id="578"> 578</span>
<span id="579"> 579</span>
<span id="580"> 580</span>
<span id="581"> 581</span>
<span id="582"> 582</span>
<span id="583"> 583</span>
<span id="584"> 584</span>
<span id="585"> 585</span>
<span id="586"> 586</span>
<span id="587"> 587</span>
<span id="588"> 588</span>
<span id="589"> 589</span>
<span id="590"> 590</span>
<span id="591"> 591</span>
<span id="592"> 592</span>
<span id="593"> 593</span>
<span id="594"> 594</span>
<span id="595"> 595</span>
<span id="596"> 596</span>
<span id="597"> 597</span>
<span id="598"> 598</span>
<span id="599"> 599</span>
<span id="600"> 600</span>
<span id="601"> 601</span>
<span id="602"> 602</span>
<span id="603"> 603</span>
<span id="604"> 604</span>
<span id="605"> 605</span>
<span id="606"> 606</span>
<span id="607"> 607</span>
<span id="608"> 608</span>
<span id="609"> 609</span>
<span id="610"> 610</span>
<span id="611"> 611</span>
<span id="612"> 612</span>
<span id="613"> 613</span>
<span id="614"> 614</span>
<span id="615"> 615</span>
<span id="616"> 616</span>
<span id="617"> 617</span>
<span id="618"> 618</span>
<span id="619"> 619</span>
<span id="620"> 620</span>
<span id="621"> 621</span>
<span id="622"> 622</span>
<span id="623"> 623</span>
<span id="624"> 624</span>
<span id="625"> 625</span>
<span id="626"> 626</span>
<span id="627"> 627</span>
<span id="628"> 628</span>
<span id="629"> 629</span>
<span id="630"> 630</span>
<span id="631"> 631</span>
<span id="632"> 632</span>
<span id="633"> 633</span>
<span id="634"> 634</span>
<span id="635"> 635</span>
<span id="636"> 636</span>
<span id="637"> 637</span>
<span id="638"> 638</span>
<span id="639"> 639</span>
<span id="640"> 640</span>
<span id="641"> 641</span>
<span id="642"> 642</span>
<span id="643"> 643</span>
<span id="644"> 644</span>
<span id="645"> 645</span>
<span id="646"> 646</span>
<span id="647"> 647</span>
<span id="648"> 648</span>
<span id="649"> 649</span>
<span id="650"> 650</span>
<span id="651"> 651</span>
<span id="652"> 652</span>
<span id="653"> 653</span>
<span id="654"> 654</span>
<span id="655"> 655</span>
<span id="656"> 656</span>
<span id="657"> 657</span>
<span id="658"> 658</span>
<span id="659"> 659</span>
<span id="660"> 660</span>
<span id="661"> 661</span>
<span id="662"> 662</span>
<span id="663"> 663</span>
<span id="664"> 664</span>
<span id="665"> 665</span>
<span id="666"> 666</span>
<span id="667"> 667</span>
<span id="668"> 668</span>
<span id="669"> 669</span>
<span id="670"> 670</span>
<span id="671"> 671</span>
<span id="672"> 672</span>
<span id="673"> 673</span>
<span id="674"> 674</span>
<span id="675"> 675</span>
<span id="676"> 676</span>
<span id="677"> 677</span>
<span id="678"> 678</span>
<span id="679"> 679</span>
<span id="680"> 680</span>
<span id="681"> 681</span>
<span id="682"> 682</span>
<span id="683"> 683</span>
<span id="684"> 684</span>
<span id="685"> 685</span>
<span id="686"> 686</span>
<span id="687"> 687</span>
<span id="688"> 688</span>
<span id="689"> 689</span>
<span id="690"> 690</span>
<span id="691"> 691</span>
<span id="692"> 692</span>
<span id="693"> 693</span>
<span id="694"> 694</span>
<span id="695"> 695</span>
<span id="696"> 696</span>
<span id="697"> 697</span>
<span id="698"> 698</span>
<span id="699"> 699</span>
<span id="700"> 700</span>
<span id="701"> 701</span>
<span id="702"> 702</span>
<span id="703"> 703</span>
<span id="704"> 704</span>
<span id="705"> 705</span>
<span id="706"> 706</span>
<span id="707"> 707</span>
<span id="708"> 708</span>
<span id="709"> 709</span>
<span id="710"> 710</span>
<span id="711"> 711</span>
<span id="712"> 712</span>
<span id="713"> 713</span>
<span id="714"> 714</span>
<span id="715"> 715</span>
<span id="716"> 716</span>
<span id="717"> 717</span>
<span id="718"> 718</span>
<span id="719"> 719</span>
<span id="720"> 720</span>
<span id="721"> 721</span>
<span id="722"> 722</span>
<span id="723"> 723</span>
<span id="724"> 724</span>
<span id="725"> 725</span>
<span id="726"> 726</span>
<span id="727"> 727</span>
<span id="728"> 728</span>
<span id="729"> 729</span>
<span id="730"> 730</span>
<span id="731"> 731</span>
<span id="732"> 732</span>
<span id="733"> 733</span>
<span id="734"> 734</span>
<span id="735"> 735</span>
<span id="736"> 736</span>
<span id="737"> 737</span>
<span id="738"> 738</span>
<span id="739"> 739</span>
<span id="740"> 740</span>
<span id="741"> 741</span>
<span id="742"> 742</span>
<span id="743"> 743</span>
<span id="744"> 744</span>
<span id="745"> 745</span>
<span id="746"> 746</span>
<span id="747"> 747</span>
<span id="748"> 748</span>
<span id="749"> 749</span>
<span id="750"> 750</span>
<span id="751"> 751</span>
<span id="752"> 752</span>
<span id="753"> 753</span>
<span id="754"> 754</span>
<span id="755"> 755</span>
<span id="756"> 756</span>
<span id="757"> 757</span>
<span id="758"> 758</span>
<span id="759"> 759</span>
<span id="760"> 760</span>
<span id="761"> 761</span>
<span id="762"> 762</span>
<span id="763"> 763</span>
<span id="764"> 764</span>
<span id="765"> 765</span>
<span id="766"> 766</span>
<span id="767"> 767</span>
<span id="768"> 768</span>
<span id="769"> 769</span>
<span id="770"> 770</span>
<span id="771"> 771</span>
<span id="772"> 772</span>
<span id="773"> 773</span>
<span id="774"> 774</span>
<span id="775"> 775</span>
<span id="776"> 776</span>
<span id="777"> 777</span>
<span id="778"> 778</span>
<span id="779"> 779</span>
<span id="780"> 780</span>
<span id="781"> 781</span>
<span id="782"> 782</span>
<span id="783"> 783</span>
<span id="784"> 784</span>
<span id="785"> 785</span>
<span id="786"> 786</span>
<span id="787"> 787</span>
<span id="788"> 788</span>
<span id="789"> 789</span>
<span id="790"> 790</span>
<span id="791"> 791</span>
<span id="792"> 792</span>
<span id="793"> 793</span>
<span id="794"> 794</span>
<span id="795"> 795</span>
<span id="796"> 796</span>
<span id="797"> 797</span>
<span id="798"> 798</span>
<span id="799"> 799</span>
<span id="800"> 800</span>
<span id="801"> 801</span>
<span id="802"> 802</span>
<span id="803"> 803</span>
<span id="804"> 804</span>
<span id="805"> 805</span>
<span id="806"> 806</span>
<span id="807"> 807</span>
<span id="808"> 808</span>
<span id="809"> 809</span>
<span id="810"> 810</span>
<span id="811"> 811</span>
<span id="812"> 812</span>
<span id="813"> 813</span>
<span id="814"> 814</span>
<span id="815"> 815</span>
<span id="816"> 816</span>
<span id="817"> 817</span>
<span id="818"> 818</span>
<span id="819"> 819</span>
<span id="820"> 820</span>
<span id="821"> 821</span>
<span id="822"> 822</span>
<span id="823"> 823</span>
<span id="824"> 824</span>
<span id="825"> 825</span>
<span id="826"> 826</span>
<span id="827"> 827</span>
<span id="828"> 828</span>
<span id="829"> 829</span>
<span id="830"> 830</span>
<span id="831"> 831</span>
<span id="832"> 832</span>
<span id="833"> 833</span>
<span id="834"> 834</span>
<span id="835"> 835</span>
<span id="836"> 836</span>
<span id="837"> 837</span>
<span id="838"> 838</span>
<span id="839"> 839</span>
<span id="840"> 840</span>
<span id="841"> 841</span>
<span id="842"> 842</span>
<span id="843"> 843</span>
<span id="844"> 844</span>
<span id="845"> 845</span>
<span id="846"> 846</span>
<span id="847"> 847</span>
<span id="848"> 848</span>
<span id="849"> 849</span>
<span id="850"> 850</span>
<span id="851"> 851</span>
<span id="852"> 852</span>
<span id="853"> 853</span>
<span id="854"> 854</span>
<span id="855"> 855</span>
<span id="856"> 856</span>
<span id="857"> 857</span>
<span id="858"> 858</span>
<span id="859"> 859</span>
<span id="860"> 860</span>
<span id="861"> 861</span>
<span id="862"> 862</span>
<span id="863"> 863</span>
<span id="864"> 864</span>
<span id="865"> 865</span>
<span id="866"> 866</span>
<span id="867"> 867</span>
<span id="868"> 868</span>
<span id="869"> 869</span>
<span id="870"> 870</span>
<span id="871"> 871</span>
<span id="872"> 872</span>
<span id="873"> 873</span>
<span id="874"> 874</span>
<span id="875"> 875</span>
<span id="876"> 876</span>
<span id="877"> 877</span>
<span id="878"> 878</span>
<span id="879"> 879</span>
<span id="880"> 880</span>
<span id="881"> 881</span>
<span id="882"> 882</span>
<span id="883"> 883</span>
<span id="884"> 884</span>
<span id="885"> 885</span>
<span id="886"> 886</span>
<span id="887"> 887</span>
<span id="888"> 888</span>
<span id="889"> 889</span>
<span id="890"> 890</span>
<span id="891"> 891</span>
<span id="892"> 892</span>
<span id="893"> 893</span>
<span id="894"> 894</span>
<span id="895"> 895</span>
<span id="896"> 896</span>
<span id="897"> 897</span>
<span id="898"> 898</span>
<span id="899"> 899</span>
<span id="900"> 900</span>
<span id="901"> 901</span>
<span id="902"> 902</span>
<span id="903"> 903</span>
<span id="904"> 904</span>
<span id="905"> 905</span>
<span id="906"> 906</span>
<span id="907"> 907</span>
<span id="908"> 908</span>
<span id="909"> 909</span>
<span id="910"> 910</span>
<span id="911"> 911</span>
<span id="912"> 912</span>
<span id="913"> 913</span>
<span id="914"> 914</span>
<span id="915"> 915</span>
<span id="916"> 916</span>
<span id="917"> 917</span>
<span id="918"> 918</span>
<span id="919"> 919</span>
<span id="920"> 920</span>
<span id="921"> 921</span>
<span id="922"> 922</span>
<span id="923"> 923</span>
<span id="924"> 924</span>
<span id="925"> 925</span>
<span id="926"> 926</span>
<span id="927"> 927</span>
<span id="928"> 928</span>
<span id="929"> 929</span>
<span id="930"> 930</span>
<span id="931"> 931</span>
<span id="932"> 932</span>
<span id="933"> 933</span>
<span id="934"> 934</span>
<span id="935"> 935</span>
<span id="936"> 936</span>
<span id="937"> 937</span>
<span id="938"> 938</span>
<span id="939"> 939</span>
<span id="940"> 940</span>
<span id="941"> 941</span>
<span id="942"> 942</span>
<span id="943"> 943</span>
<span id="944"> 944</span>
<span id="945"> 945</span>
<span id="946"> 946</span>
<span id="947"> 947</span>
<span id="948"> 948</span>
<span id="949"> 949</span>
<span id="950"> 950</span>
<span id="951"> 951</span>
<span id="952"> 952</span>
<span id="953"> 953</span>
<span id="954"> 954</span>
<span id="955"> 955</span>
<span id="956"> 956</span>
<span id="957"> 957</span>
<span id="958"> 958</span>
<span id="959"> 959</span>
<span id="960"> 960</span>
<span id="961"> 961</span>
<span id="962"> 962</span>
<span id="963"> 963</span>
<span id="964"> 964</span>
<span id="965"> 965</span>
<span id="966"> 966</span>
<span id="967"> 967</span>
<span id="968"> 968</span>
<span id="969"> 969</span>
<span id="970"> 970</span>
<span id="971"> 971</span>
<span id="972"> 972</span>
<span id="973"> 973</span>
<span id="974"> 974</span>
<span id="975"> 975</span>
<span id="976"> 976</span>
<span id="977"> 977</span>
<span id="978"> 978</span>
<span id="979"> 979</span>
<span id="980"> 980</span>
<span id="981"> 981</span>
<span id="982"> 982</span>
<span id="983"> 983</span>
<span id="984"> 984</span>
<span id="985"> 985</span>
<span id="986"> 986</span>
<span id="987"> 987</span>
<span id="988"> 988</span>
<span id="989"> 989</span>
<span id="990"> 990</span>
<span id="991"> 991</span>
<span id="992"> 992</span>
<span id="993"> 993</span>
<span id="994"> 994</span>
<span id="995"> 995</span>
<span id="996"> 996</span>
<span id="997"> 997</span>
<span id="998"> 998</span>
<span id="999"> 999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
<span id="1111">1111</span>
<span id="1112">1112</span>
<span id="1113">1113</span>
<span id="1114">1114</span>
<span id="1115">1115</span>
<span id="1116">1116</span>
<span id="1117">1117</span>
<span id="1118">1118</span>
<span id="1119">1119</span>
<span id="1120">1120</span>
<span id="1121">1121</span>
<span id="1122">1122</span>
<span id="1123">1123</span>
<span id="1124">1124</span>
<span id="1125">1125</span>
<span id="1126">1126</span>
<span id="1127">1127</span>
<span id="1128">1128</span>
<span id="1129">1129</span>
<span id="1130">1130</span>
<span id="1131">1131</span>
<span id="1132">1132</span>
<span id="1133">1133</span>
<span id="1134">1134</span>
<span id="1135">1135</span>
<span id="1136">1136</span>
<span id="1137">1137</span>
<span id="1138">1138</span>
<span id="1139">1139</span>
<span id="1140">1140</span>
<span id="1141">1141</span>
<span id="1142">1142</span>
<span id="1143">1143</span>
<span id="1144">1144</span>
<span id="1145">1145</span>
<span id="1146">1146</span>
<span id="1147">1147</span>
<span id="1148">1148</span>
<span id="1149">1149</span>
<span id="1150">1150</span>
<span id="1151">1151</span>
<span id="1152">1152</span>
<span id="1153">1153</span>
<span id="1154">1154</span>
<span id="1155">1155</span>
<span id="1156">1156</span>
<span id="1157">1157</span>
<span id="1158">1158</span>
<span id="1159">1159</span>
<span id="1160">1160</span>
<span id="1161">1161</span>
<span id="1162">1162</span>
<span id="1163">1163</span>
<span id="1164">1164</span>
<span id="1165">1165</span>
<span id="1166">1166</span>
<span id="1167">1167</span>
<span id="1168">1168</span>
<span id="1169">1169</span>
<span id="1170">1170</span>
<span id="1171">1171</span>
<span id="1172">1172</span>
<span id="1173">1173</span>
<span id="1174">1174</span>
<span id="1175">1175</span>
<span id="1176">1176</span>
<span id="1177">1177</span>
<span id="1178">1178</span>
<span id="1179">1179</span>
<span id="1180">1180</span>
<span id="1181">1181</span>
<span id="1182">1182</span>
<span id="1183">1183</span>
<span id="1184">1184</span>
<span id="1185">1185</span>
<span id="1186">1186</span>
<span id="1187">1187</span>
<span id="1188">1188</span>
<span id="1189">1189</span>
<span id="1190">1190</span>
<span id="1191">1191</span>
<span id="1192">1192</span>
<span id="1193">1193</span>
<span id="1194">1194</span>
<span id="1195">1195</span>
<span id="1196">1196</span>
<span id="1197">1197</span>
<span id="1198">1198</span>
<span id="1199">1199</span>
<span id="1200">1200</span>
<span id="1201">1201</span>
<span id="1202">1202</span>
<span id="1203">1203</span>
<span id="1204">1204</span>
<span id="1205">1205</span>
<span id="1206">1206</span>
<span id="1207">1207</span>
<span id="1208">1208</span>
<span id="1209">1209</span>
<span id="1210">1210</span>
<span id="1211">1211</span>
<span id="1212">1212</span>
<span id="1213">1213</span>
<span id="1214">1214</span>
<span id="1215">1215</span>
<span id="1216">1216</span>
<span id="1217">1217</span>
<span id="1218">1218</span>
<span id="1219">1219</span>
<span id="1220">1220</span>
<span id="1221">1221</span>
<span id="1222">1222</span>
<span id="1223">1223</span>
<span id="1224">1224</span>
<span id="1225">1225</span>
<span id="1226">1226</span>
<span id="1227">1227</span>
<span id="1228">1228</span>
<span id="1229">1229</span>
<span id="1230">1230</span>
<span id="1231">1231</span>
<span id="1232">1232</span>
<span id="1233">1233</span>
<span id="1234">1234</span>
<span id="1235">1235</span>
<span id="1236">1236</span>
<span id="1237">1237</span>
<span id="1238">1238</span>
<span id="1239">1239</span>
<span id="1240">1240</span>
<span id="1241">1241</span>
<span id="1242">1242</span>
<span id="1243">1243</span>
<span id="1244">1244</span>
<span id="1245">1245</span>
<span id="1246">1246</span>
<span id="1247">1247</span>
<span id="1248">1248</span>
<span id="1249">1249</span>
<span id="1250">1250</span>
<span id="1251">1251</span>
<span id="1252">1252</span>
<span id="1253">1253</span>
<span id="1254">1254</span>
<span id="1255">1255</span>
<span id="1256">1256</span>
<span id="1257">1257</span>
<span id="1258">1258</span>
<span id="1259">1259</span>
<span id="1260">1260</span>
<span id="1261">1261</span>
<span id="1262">1262</span>
<span id="1263">1263</span>
<span id="1264">1264</span>
<span id="1265">1265</span>
<span id="1266">1266</span>
<span id="1267">1267</span>
<span id="1268">1268</span>
<span id="1269">1269</span>
<span id="1270">1270</span>
<span id="1271">1271</span>
<span id="1272">1272</span>
<span id="1273">1273</span>
<span id="1274">1274</span>
<span id="1275">1275</span>
<span id="1276">1276</span>
<span id="1277">1277</span>
<span id="1278">1278</span>
<span id="1279">1279</span>
<span id="1280">1280</span>
<span id="1281">1281</span>
<span id="1282">1282</span>
<span id="1283">1283</span>
<span id="1284">1284</span>
<span id="1285">1285</span>
<span id="1286">1286</span>
<span id="1287">1287</span>
<span id="1288">1288</span>
<span id="1289">1289</span>
<span id="1290">1290</span>
<span id="1291">1291</span>
<span id="1292">1292</span>
<span id="1293">1293</span>
<span id="1294">1294</span>
<span id="1295">1295</span>
<span id="1296">1296</span>
<span id="1297">1297</span>
<span id="1298">1298</span>
<span id="1299">1299</span>
<span id="1300">1300</span>
<span id="1301">1301</span>
<span id="1302">1302</span>
<span id="1303">1303</span>
<span id="1304">1304</span>
<span id="1305">1305</span>
<span id="1306">1306</span>
<span id="1307">1307</span>
<span id="1308">1308</span>
<span id="1309">1309</span>
<span id="1310">1310</span>
<span id="1311">1311</span>
<span id="1312">1312</span>
<span id="1313">1313</span>
<span id="1314">1314</span>
<span id="1315">1315</span>
<span id="1316">1316</span>
<span id="1317">1317</span>
<span id="1318">1318</span>
<span id="1319">1319</span>
<span id="1320">1320</span>
<span id="1321">1321</span>
<span id="1322">1322</span>
<span id="1323">1323</span>
<span id="1324">1324</span>
<span id="1325">1325</span>
<span id="1326">1326</span>
<span id="1327">1327</span>
<span id="1328">1328</span>
<span id="1329">1329</span>
<span id="1330">1330</span>
<span id="1331">1331</span>
<span id="1332">1332</span>
<span id="1333">1333</span>
<span id="1334">1334</span>
<span id="1335">1335</span>
<span id="1336">1336</span>
<span id="1337">1337</span>
<span id="1338">1338</span>
<span id="1339">1339</span>
<span id="1340">1340</span>
<span id="1341">1341</span>
<span id="1342">1342</span>
<span id="1343">1343</span>
<span id="1344">1344</span>
<span id="1345">1345</span>
<span id="1346">1346</span>
<span id="1347">1347</span>
<span id="1348">1348</span>
<span id="1349">1349</span>
<span id="1350">1350</span>
<span id="1351">1351</span>
<span id="1352">1352</span>
<span id="1353">1353</span>
<span id="1354">1354</span>
<span id="1355">1355</span>
<span id="1356">1356</span>
<span id="1357">1357</span>
<span id="1358">1358</span>
<span id="1359">1359</span>
<span id="1360">1360</span>
<span id="1361">1361</span>
<span id="1362">1362</span>
<span id="1363">1363</span>
<span id="1364">1364</span>
<span id="1365">1365</span>
<span id="1366">1366</span>
<span id="1367">1367</span>
<span id="1368">1368</span>
<span id="1369">1369</span>
<span id="1370">1370</span>
<span id="1371">1371</span>
<span id="1372">1372</span>
<span id="1373">1373</span>
<span id="1374">1374</span>
<span id="1375">1375</span>
<span id="1376">1376</span>
<span id="1377">1377</span>
<span id="1378">1378</span>
<span id="1379">1379</span>
<span id="1380">1380</span>
<span id="1381">1381</span>
<span id="1382">1382</span>
<span id="1383">1383</span>
<span id="1384">1384</span>
<span id="1385">1385</span>
<span id="1386">1386</span>
<span id="1387">1387</span>
<span id="1388">1388</span>
<span id="1389">1389</span>
<span id="1390">1390</span>
<span id="1391">1391</span>
<span id="1392">1392</span>
<span id="1393">1393</span>
<span id="1394">1394</span>
<span id="1395">1395</span>
<span id="1396">1396</span>
<span id="1397">1397</span>
<span id="1398">1398</span>
<span id="1399">1399</span>
<span id="1400">1400</span>
<span id="1401">1401</span>
<span id="1402">1402</span>
<span id="1403">1403</span>
<span id="1404">1404</span>
<span id="1405">1405</span>
<span id="1406">1406</span>
<span id="1407">1407</span>
<span id="1408">1408</span>
<span id="1409">1409</span>
<span id="1410">1410</span>
<span id="1411">1411</span>
<span id="1412">1412</span>
<span id="1413">1413</span>
<span id="1414">1414</span>
<span id="1415">1415</span>
<span id="1416">1416</span>
<span id="1417">1417</span>
<span id="1418">1418</span>
<span id="1419">1419</span>
<span id="1420">1420</span>
<span id="1421">1421</span>
<span id="1422">1422</span>
<span id="1423">1423</span>
<span id="1424">1424</span>
<span id="1425">1425</span>
<span id="1426">1426</span>
<span id="1427">1427</span>
<span id="1428">1428</span>
<span id="1429">1429</span>
<span id="1430">1430</span>
<span id="1431">1431</span>
<span id="1432">1432</span>
<span id="1433">1433</span>
<span id="1434">1434</span>
<span id="1435">1435</span>
<span id="1436">1436</span>
<span id="1437">1437</span>
<span id="1438">1438</span>
<span id="1439">1439</span>
<span id="1440">1440</span>
<span id="1441">1441</span>
<span id="1442">1442</span>
<span id="1443">1443</span>
<span id="1444">1444</span>
<span id="1445">1445</span>
<span id="1446">1446</span>
<span id="1447">1447</span>
<span id="1448">1448</span>
<span id="1449">1449</span>
<span id="1450">1450</span>
<span id="1451">1451</span>
<span id="1452">1452</span>
<span id="1453">1453</span>
<span id="1454">1454</span>
<span id="1455">1455</span>
<span id="1456">1456</span>
<span id="1457">1457</span>
<span id="1458">1458</span>
<span id="1459">1459</span>
<span id="1460">1460</span>
<span id="1461">1461</span>
<span id="1462">1462</span>
<span id="1463">1463</span>
<span id="1464">1464</span>
<span id="1465">1465</span>
<span id="1466">1466</span>
<span id="1467">1467</span>
<span id="1468">1468</span>
<span id="1469">1469</span>
<span id="1470">1470</span>
<span id="1471">1471</span>
<span id="1472">1472</span>
<span id="1473">1473</span>
<span id="1474">1474</span>
<span id="1475">1475</span>
<span id="1476">1476</span>
<span id="1477">1477</span>
<span id="1478">1478</span>
<span id="1479">1479</span>
<span id="1480">1480</span>
<span id="1481">1481</span>
<span id="1482">1482</span>
<span id="1483">1483</span>
<span id="1484">1484</span>
<span id="1485">1485</span>
<span id="1486">1486</span>
<span id="1487">1487</span>
<span id="1488">1488</span>
<span id="1489">1489</span>
<span id="1490">1490</span>
<span id="1491">1491</span>
<span id="1492">1492</span>
<span id="1493">1493</span>
<span id="1494">1494</span>
<span id="1495">1495</span>
<span id="1496">1496</span>
<span id="1497">1497</span>
<span id="1498">1498</span>
<span id="1499">1499</span>
<span id="1500">1500</span>
<span id="1501">1501</span>
<span id="1502">1502</span>
<span id="1503">1503</span>
<span id="1504">1504</span>
<span id="1505">1505</span>
<span id="1506">1506</span>
<span id="1507">1507</span>
<span id="1508">1508</span>
<span id="1509">1509</span>
<span id="1510">1510</span>
<span id="1511">1511</span>
<span id="1512">1512</span>
<span id="1513">1513</span>
<span id="1514">1514</span>
<span id="1515">1515</span>
<span id="1516">1516</span>
<span id="1517">1517</span>
<span id="1518">1518</span>
<span id="1519">1519</span>
<span id="1520">1520</span>
<span id="1521">1521</span>
<span id="1522">1522</span>
<span id="1523">1523</span>
<span id="1524">1524</span>
<span id="1525">1525</span>
<span id="1526">1526</span>
<span id="1527">1527</span>
<span id="1528">1528</span>
<span id="1529">1529</span>
<span id="1530">1530</span>
<span id="1531">1531</span>
<span id="1532">1532</span>
<span id="1533">1533</span>
<span id="1534">1534</span>
<span id="1535">1535</span>
<span id="1536">1536</span>
<span id="1537">1537</span>
<span id="1538">1538</span>
<span id="1539">1539</span>
<span id="1540">1540</span>
<span id="1541">1541</span>
<span id="1542">1542</span>
<span id="1543">1543</span>
<span id="1544">1544</span>
<span id="1545">1545</span>
<span id="1546">1546</span>
<span id="1547">1547</span>
<span id="1548">1548</span>
<span id="1549">1549</span>
<span id="1550">1550</span>
<span id="1551">1551</span>
<span id="1552">1552</span>
<span id="1553">1553</span>
<span id="1554">1554</span>
<span id="1555">1555</span>
<span id="1556">1556</span>
<span id="1557">1557</span>
<span id="1558">1558</span>
<span id="1559">1559</span>
<span id="1560">1560</span>
<span id="1561">1561</span>
<span id="1562">1562</span>
<span id="1563">1563</span>
<span id="1564">1564</span>
<span id="1565">1565</span>
<span id="1566">1566</span>
<span id="1567">1567</span>
<span id="1568">1568</span>
<span id="1569">1569</span>
<span id="1570">1570</span>
<span id="1571">1571</span>
<span id="1572">1572</span>
<span id="1573">1573</span>
<span id="1574">1574</span>
<span id="1575">1575</span>
<span id="1576">1576</span>
<span id="1577">1577</span>
<span id="1578">1578</span>
<span id="1579">1579</span>
<span id="1580">1580</span>
<span id="1581">1581</span>
<span id="1582">1582</span>
<span id="1583">1583</span>
<span id="1584">1584</span>
<span id="1585">1585</span>
<span id="1586">1586</span>
<span id="1587">1587</span>
<span id="1588">1588</span>
<span id="1589">1589</span>
<span id="1590">1590</span>
<span id="1591">1591</span>
<span id="1592">1592</span>
<span id="1593">1593</span>
<span id="1594">1594</span>
<span id="1595">1595</span>
<span id="1596">1596</span>
<span id="1597">1597</span>
<span id="1598">1598</span>
<span id="1599">1599</span>
<span id="1600">1600</span>
<span id="1601">1601</span>
<span id="1602">1602</span>
<span id="1603">1603</span>
<span id="1604">1604</span>
<span id="1605">1605</span>
<span id="1606">1606</span>
<span id="1607">1607</span>
<span id="1608">1608</span>
<span id="1609">1609</span>
<span id="1610">1610</span>
<span id="1611">1611</span>
<span id="1612">1612</span>
<span id="1613">1613</span>
<span id="1614">1614</span>
<span id="1615">1615</span>
<span id="1616">1616</span>
<span id="1617">1617</span>
<span id="1618">1618</span>
<span id="1619">1619</span>
<span id="1620">1620</span>
<span id="1621">1621</span>
<span id="1622">1622</span>
<span id="1623">1623</span>
<span id="1624">1624</span>
<span id="1625">1625</span>
<span id="1626">1626</span>
<span id="1627">1627</span>
<span id="1628">1628</span>
<span id="1629">1629</span>
<span id="1630">1630</span>
<span id="1631">1631</span>
<span id="1632">1632</span>
<span id="1633">1633</span>
<span id="1634">1634</span>
<span id="1635">1635</span>
<span id="1636">1636</span>
<span id="1637">1637</span>
<span id="1638">1638</span>
<span id="1639">1639</span>
<span id="1640">1640</span>
<span id="1641">1641</span>
<span id="1642">1642</span>
<span id="1643">1643</span>
<span id="1644">1644</span>
<span id="1645">1645</span>
<span id="1646">1646</span>
<span id="1647">1647</span>
<span id="1648">1648</span>
<span id="1649">1649</span>
<span id="1650">1650</span>
<span id="1651">1651</span>
<span id="1652">1652</span>
<span id="1653">1653</span>
<span id="1654">1654</span>
<span id="1655">1655</span>
<span id="1656">1656</span>
<span id="1657">1657</span>
<span id="1658">1658</span>
<span id="1659">1659</span>
<span id="1660">1660</span>
<span id="1661">1661</span>
<span id="1662">1662</span>
<span id="1663">1663</span>
<span id="1664">1664</span>
<span id="1665">1665</span>
<span id="1666">1666</span>
<span id="1667">1667</span>
<span id="1668">1668</span>
<span id="1669">1669</span>
<span id="1670">1670</span>
<span id="1671">1671</span>
<span id="1672">1672</span>
<span id="1673">1673</span>
<span id="1674">1674</span>
<span id="1675">1675</span>
<span id="1676">1676</span>
<span id="1677">1677</span>
<span id="1678">1678</span>
<span id="1679">1679</span>
<span id="1680">1680</span>
<span id="1681">1681</span>
<span id="1682">1682</span>
<span id="1683">1683</span>
<span id="1684">1684</span>
<span id="1685">1685</span>
<span id="1686">1686</span>
<span id="1687">1687</span>
<span id="1688">1688</span>
<span id="1689">1689</span>
<span id="1690">1690</span>
<span id="1691">1691</span>
<span id="1692">1692</span>
<span id="1693">1693</span>
<span id="1694">1694</span>
<span id="1695">1695</span>
<span id="1696">1696</span>
<span id="1697">1697</span>
<span id="1698">1698</span>
<span id="1699">1699</span>
<span id="1700">1700</span>
<span id="1701">1701</span>
<span id="1702">1702</span>
<span id="1703">1703</span>
<span id="1704">1704</span>
<span id="1705">1705</span>
<span id="1706">1706</span>
<span id="1707">1707</span>
<span id="1708">1708</span>
<span id="1709">1709</span>
<span id="1710">1710</span>
<span id="1711">1711</span>
<span id="1712">1712</span>
<span id="1713">1713</span>
<span id="1714">1714</span>
<span id="1715">1715</span>
<span id="1716">1716</span>
<span id="1717">1717</span>
<span id="1718">1718</span>
<span id="1719">1719</span>
<span id="1720">1720</span>
<span id="1721">1721</span>
<span id="1722">1722</span>
<span id="1723">1723</span>
<span id="1724">1724</span>
<span id="1725">1725</span>
<span id="1726">1726</span>
<span id="1727">1727</span>
<span id="1728">1728</span>
<span id="1729">1729</span>
<span id="1730">1730</span>
<span id="1731">1731</span>
<span id="1732">1732</span>
<span id="1733">1733</span>
<span id="1734">1734</span>
<span id="1735">1735</span>
<span id="1736">1736</span>
<span id="1737">1737</span>
<span id="1738">1738</span>
<span id="1739">1739</span>
<span id="1740">1740</span>
<span id="1741">1741</span>
<span id="1742">1742</span>
<span id="1743">1743</span>
<span id="1744">1744</span>
<span id="1745">1745</span>
<span id="1746">1746</span>
<span id="1747">1747</span>
<span id="1748">1748</span>
<span id="1749">1749</span>
<span id="1750">1750</span>
<span id="1751">1751</span>
<span id="1752">1752</span>
<span id="1753">1753</span>
<span id="1754">1754</span>
<span id="1755">1755</span>
<span id="1756">1756</span>
<span id="1757">1757</span>
<span id="1758">1758</span>
<span id="1759">1759</span>
<span id="1760">1760</span>
<span id="1761">1761</span>
<span id="1762">1762</span>
<span id="1763">1763</span>
<span id="1764">1764</span>
<span id="1765">1765</span>
<span id="1766">1766</span>
<span id="1767">1767</span>
<span id="1768">1768</span>
<span id="1769">1769</span>
<span id="1770">1770</span>
<span id="1771">1771</span>
<span id="1772">1772</span>
<span id="1773">1773</span>
<span id="1774">1774</span>
<span id="1775">1775</span>
<span id="1776">1776</span>
<span id="1777">1777</span>
<span id="1778">1778</span>
<span id="1779">1779</span>
<span id="1780">1780</span>
<span id="1781">1781</span>
<span id="1782">1782</span>
<span id="1783">1783</span>
<span id="1784">1784</span>
<span id="1785">1785</span>
<span id="1786">1786</span>
<span id="1787">1787</span>
<span id="1788">1788</span>
<span id="1789">1789</span>
<span id="1790">1790</span>
<span id="1791">1791</span>
<span id="1792">1792</span>
<span id="1793">1793</span>
<span id="1794">1794</span>
<span id="1795">1795</span>
<span id="1796">1796</span>
<span id="1797">1797</span>
<span id="1798">1798</span>
<span id="1799">1799</span>
<span id="1800">1800</span>
<span id="1801">1801</span>
<span id="1802">1802</span>
<span id="1803">1803</span>
<span id="1804">1804</span>
<span id="1805">1805</span>
<span id="1806">1806</span>
<span id="1807">1807</span>
<span id="1808">1808</span>
<span id="1809">1809</span>
<span id="1810">1810</span>
<span id="1811">1811</span>
<span id="1812">1812</span>
<span id="1813">1813</span>
<span id="1814">1814</span>
<span id="1815">1815</span>
<span id="1816">1816</span>
<span id="1817">1817</span>
<span id="1818">1818</span>
<span id="1819">1819</span>
<span id="1820">1820</span>
<span id="1821">1821</span>
<span id="1822">1822</span>
<span id="1823">1823</span>
<span id="1824">1824</span>
<span id="1825">1825</span>
<span id="1826">1826</span>
<span id="1827">1827</span>
<span id="1828">1828</span>
<span id="1829">1829</span>
<span id="1830">1830</span>
<span id="1831">1831</span>
<span id="1832">1832</span>
<span id="1833">1833</span>
<span id="1834">1834</span>
<span id="1835">1835</span>
<span id="1836">1836</span>
<span id="1837">1837</span>
<span id="1838">1838</span>
<span id="1839">1839</span>
<span id="1840">1840</span>
<span id="1841">1841</span>
<span id="1842">1842</span>
<span id="1843">1843</span>
<span id="1844">1844</span>
<span id="1845">1845</span>
<span id="1846">1846</span>
<span id="1847">1847</span>
<span id="1848">1848</span>
<span id="1849">1849</span>
<span id="1850">1850</span>
<span id="1851">1851</span>
<span id="1852">1852</span>
<span id="1853">1853</span>
<span id="1854">1854</span>
<span id="1855">1855</span>
<span id="1856">1856</span>
<span id="1857">1857</span>
<span id="1858">1858</span>
<span id="1859">1859</span>
<span id="1860">1860</span>
<span id="1861">1861</span>
<span id="1862">1862</span>
<span id="1863">1863</span>
<span id="1864">1864</span>
<span id="1865">1865</span>
<span id="1866">1866</span>
<span id="1867">1867</span>
<span id="1868">1868</span>
<span id="1869">1869</span>
<span id="1870">1870</span>
<span id="1871">1871</span>
<span id="1872">1872</span>
<span id="1873">1873</span>
<span id="1874">1874</span>
<span id="1875">1875</span>
<span id="1876">1876</span>
<span id="1877">1877</span>
<span id="1878">1878</span>
<span id="1879">1879</span>
<span id="1880">1880</span>
<span id="1881">1881</span>
<span id="1882">1882</span>
<span id="1883">1883</span>
<span id="1884">1884</span>
<span id="1885">1885</span>
<span id="1886">1886</span>
<span id="1887">1887</span>
<span id="1888">1888</span>
<span id="1889">1889</span>
<span id="1890">1890</span>
<span id="1891">1891</span>
<span id="1892">1892</span>
<span id="1893">1893</span>
<span id="1894">1894</span>
<span id="1895">1895</span>
<span id="1896">1896</span>
<span id="1897">1897</span>
<span id="1898">1898</span>
<span id="1899">1899</span>
<span id="1900">1900</span>
<span id="1901">1901</span>
<span id="1902">1902</span>
<span id="1903">1903</span>
<span id="1904">1904</span>
<span id="1905">1905</span>
<span id="1906">1906</span>
<span id="1907">1907</span>
<span id="1908">1908</span>
<span id="1909">1909</span>
<span id="1910">1910</span>
<span id="1911">1911</span>
<span id="1912">1912</span>
<span id="1913">1913</span>
<span id="1914">1914</span>
<span id="1915">1915</span>
<span id="1916">1916</span>
<span id="1917">1917</span>
<span id="1918">1918</span>
<span id="1919">1919</span>
<span id="1920">1920</span>
<span id="1921">1921</span>
<span id="1922">1922</span>
<span id="1923">1923</span>
<span id="1924">1924</span>
<span id="1925">1925</span>
<span id="1926">1926</span>
<span id="1927">1927</span>
<span id="1928">1928</span>
<span id="1929">1929</span>
<span id="1930">1930</span>
<span id="1931">1931</span>
<span id="1932">1932</span>
<span id="1933">1933</span>
<span id="1934">1934</span>
<span id="1935">1935</span>
<span id="1936">1936</span>
<span id="1937">1937</span>
<span id="1938">1938</span>
<span id="1939">1939</span>
<span id="1940">1940</span>
<span id="1941">1941</span>
<span id="1942">1942</span>
<span id="1943">1943</span>
<span id="1944">1944</span>
<span id="1945">1945</span>
<span id="1946">1946</span>
<span id="1947">1947</span>
<span id="1948">1948</span>
<span id="1949">1949</span>
<span id="1950">1950</span>
<span id="1951">1951</span>
<span id="1952">1952</span>
<span id="1953">1953</span>
<span id="1954">1954</span>
<span id="1955">1955</span>
<span id="1956">1956</span>
<span id="1957">1957</span>
<span id="1958">1958</span>
<span id="1959">1959</span>
<span id="1960">1960</span>
<span id="1961">1961</span>
<span id="1962">1962</span>
<span id="1963">1963</span>
<span id="1964">1964</span>
<span id="1965">1965</span>
<span id="1966">1966</span>
<span id="1967">1967</span>
<span id="1968">1968</span>
<span id="1969">1969</span>
<span id="1970">1970</span>
<span id="1971">1971</span>
<span id="1972">1972</span>
<span id="1973">1973</span>
<span id="1974">1974</span>
<span id="1975">1975</span>
<span id="1976">1976</span>
<span id="1977">1977</span>
<span id="1978">1978</span>
<span id="1979">1979</span>
<span id="1980">1980</span>
<span id="1981">1981</span>
<span id="1982">1982</span>
<span id="1983">1983</span>
<span id="1984">1984</span>
<span id="1985">1985</span>
<span id="1986">1986</span>
<span id="1987">1987</span>
<span id="1988">1988</span>
<span id="1989">1989</span>
<span id="1990">1990</span>
<span id="1991">1991</span>
<span id="1992">1992</span>
<span id="1993">1993</span>
<span id="1994">1994</span>
<span id="1995">1995</span>
<span id="1996">1996</span>
<span id="1997">1997</span>
<span id="1998">1998</span>
<span id="1999">1999</span>
<span id="2000">2000</span>
<span id="2001">2001</span>
<span id="2002">2002</span>
<span id="2003">2003</span>
<span id="2004">2004</span>
<span id="2005">2005</span>
<span id="2006">2006</span>
<span id="2007">2007</span>
<span id="2008">2008</span>
<span id="2009">2009</span>
<span id="2010">2010</span>
<span id="2011">2011</span>
<span id="2012">2012</span>
<span id="2013">2013</span>
<span id="2014">2014</span>
<span id="2015">2015</span>
<span id="2016">2016</span>
<span id="2017">2017</span>
<span id="2018">2018</span>
<span id="2019">2019</span>
<span id="2020">2020</span>
<span id="2021">2021</span>
<span id="2022">2022</span>
<span id="2023">2023</span>
<span id="2024">2024</span>
<span id="2025">2025</span>
<span id="2026">2026</span>
<span id="2027">2027</span>
<span id="2028">2028</span>
<span id="2029">2029</span>
<span id="2030">2030</span>
<span id="2031">2031</span>
<span id="2032">2032</span>
<span id="2033">2033</span>
<span id="2034">2034</span>
<span id="2035">2035</span>
<span id="2036">2036</span>
<span id="2037">2037</span>
<span id="2038">2038</span>
<span id="2039">2039</span>
<span id="2040">2040</span>
<span id="2041">2041</span>
<span id="2042">2042</span>
<span id="2043">2043</span>
<span id="2044">2044</span>
<span id="2045">2045</span>
<span id="2046">2046</span>
<span id="2047">2047</span>
<span id="2048">2048</span>
<span id="2049">2049</span>
<span id="2050">2050</span>
<span id="2051">2051</span>
<span id="2052">2052</span>
<span id="2053">2053</span>
<span id="2054">2054</span>
<span id="2055">2055</span>
<span id="2056">2056</span>
<span id="2057">2057</span>
<span id="2058">2058</span>
<span id="2059">2059</span>
<span id="2060">2060</span>
<span id="2061">2061</span>
<span id="2062">2062</span>
<span id="2063">2063</span>
<span id="2064">2064</span>
<span id="2065">2065</span>
<span id="2066">2066</span>
<span id="2067">2067</span>
<span id="2068">2068</span>
<span id="2069">2069</span>
<span id="2070">2070</span>
<span id="2071">2071</span>
<span id="2072">2072</span>
<span id="2073">2073</span>
<span id="2074">2074</span>
<span id="2075">2075</span>
<span id="2076">2076</span>
<span id="2077">2077</span>
<span id="2078">2078</span>
<span id="2079">2079</span>
<span id="2080">2080</span>
<span id="2081">2081</span>
<span id="2082">2082</span>
<span id="2083">2083</span>
<span id="2084">2084</span>
<span id="2085">2085</span>
<span id="2086">2086</span>
<span id="2087">2087</span>
<span id="2088">2088</span>
<span id="2089">2089</span>
<span id="2090">2090</span>
<span id="2091">2091</span>
<span id="2092">2092</span>
<span id="2093">2093</span>
<span id="2094">2094</span>
<span id="2095">2095</span>
<span id="2096">2096</span>
<span id="2097">2097</span>
<span id="2098">2098</span>
<span id="2099">2099</span>
<span id="2100">2100</span>
<span id="2101">2101</span>
<span id="2102">2102</span>
<span id="2103">2103</span>
<span id="2104">2104</span>
<span id="2105">2105</span>
<span id="2106">2106</span>
<span id="2107">2107</span>
<span id="2108">2108</span>
<span id="2109">2109</span>
<span id="2110">2110</span>
<span id="2111">2111</span>
<span id="2112">2112</span>
<span id="2113">2113</span>
<span id="2114">2114</span>
<span id="2115">2115</span>
<span id="2116">2116</span>
<span id="2117">2117</span>
<span id="2118">2118</span>
<span id="2119">2119</span>
<span id="2120">2120</span>
<span id="2121">2121</span>
<span id="2122">2122</span>
<span id="2123">2123</span>
<span id="2124">2124</span>
<span id="2125">2125</span>
<span id="2126">2126</span>
<span id="2127">2127</span>
<span id="2128">2128</span>
<span id="2129">2129</span>
<span id="2130">2130</span>
<span id="2131">2131</span>
<span id="2132">2132</span>
<span id="2133">2133</span>
<span id="2134">2134</span>
<span id="2135">2135</span>
<span id="2136">2136</span>
<span id="2137">2137</span>
<span id="2138">2138</span>
<span id="2139">2139</span>
<span id="2140">2140</span>
<span id="2141">2141</span>
<span id="2142">2142</span>
<span id="2143">2143</span>
<span id="2144">2144</span>
<span id="2145">2145</span>
<span id="2146">2146</span>
<span id="2147">2147</span>
<span id="2148">2148</span>
<span id="2149">2149</span>
<span id="2150">2150</span>
<span id="2151">2151</span>
<span id="2152">2152</span>
<span id="2153">2153</span>
<span id="2154">2154</span>
<span id="2155">2155</span>
<span id="2156">2156</span>
<span id="2157">2157</span>
<span id="2158">2158</span>
<span id="2159">2159</span>
<span id="2160">2160</span>
<span id="2161">2161</span>
<span id="2162">2162</span>
<span id="2163">2163</span>
<span id="2164">2164</span>
<span id="2165">2165</span>
<span id="2166">2166</span>
<span id="2167">2167</span>
<span id="2168">2168</span>
<span id="2169">2169</span>
<span id="2170">2170</span>
<span id="2171">2171</span>
<span id="2172">2172</span>
<span id="2173">2173</span>
<span id="2174">2174</span>
<span id="2175">2175</span>
<span id="2176">2176</span>
<span id="2177">2177</span>
<span id="2178">2178</span>
<span id="2179">2179</span>
<span id="2180">2180</span>
<span id="2181">2181</span>
<span id="2182">2182</span>
<span id="2183">2183</span>
<span id="2184">2184</span>
<span id="2185">2185</span>
<span id="2186">2186</span>
<span id="2187">2187</span>
<span id="2188">2188</span>
<span id="2189">2189</span>
<span id="2190">2190</span>
<span id="2191">2191</span>
<span id="2192">2192</span>
<span id="2193">2193</span>
<span id="2194">2194</span>
<span id="2195">2195</span>
<span id="2196">2196</span>
<span id="2197">2197</span>
<span id="2198">2198</span>
<span id="2199">2199</span>
<span id="2200">2200</span>
<span id="2201">2201</span>
<span id="2202">2202</span>
<span id="2203">2203</span>
<span id="2204">2204</span>
<span id="2205">2205</span>
<span id="2206">2206</span>
<span id="2207">2207</span>
<span id="2208">2208</span>
<span id="2209">2209</span>
<span id="2210">2210</span>
<span id="2211">2211</span>
<span id="2212">2212</span>
<span id="2213">2213</span>
<span id="2214">2214</span>
<span id="2215">2215</span>
<span id="2216">2216</span>
<span id="2217">2217</span>
<span id="2218">2218</span>
<span id="2219">2219</span>
<span id="2220">2220</span>
<span id="2221">2221</span>
<span id="2222">2222</span>
<span id="2223">2223</span>
<span id="2224">2224</span>
<span id="2225">2225</span>
<span id="2226">2226</span>
<span id="2227">2227</span>
<span id="2228">2228</span>
<span id="2229">2229</span>
<span id="2230">2230</span>
<span id="2231">2231</span>
<span id="2232">2232</span>
<span id="2233">2233</span>
<span id="2234">2234</span>
<span id="2235">2235</span>
<span id="2236">2236</span>
<span id="2237">2237</span>
<span id="2238">2238</span>
<span id="2239">2239</span>
<span id="2240">2240</span>
<span id="2241">2241</span>
<span id="2242">2242</span>
<span id="2243">2243</span>
<span id="2244">2244</span>
<span id="2245">2245</span>
<span id="2246">2246</span>
<span id="2247">2247</span>
<span id="2248">2248</span>
<span id="2249">2249</span>
<span id="2250">2250</span>
<span id="2251">2251</span>
<span id="2252">2252</span>
<span id="2253">2253</span>
<span id="2254">2254</span>
<span id="2255">2255</span>
<span id="2256">2256</span>
<span id="2257">2257</span>
<span id="2258">2258</span>
<span id="2259">2259</span>
<span id="2260">2260</span>
<span id="2261">2261</span>
<span id="2262">2262</span>
<span id="2263">2263</span>
<span id="2264">2264</span>
<span id="2265">2265</span>
<span id="2266">2266</span>
<span id="2267">2267</span>
<span id="2268">2268</span>
<span id="2269">2269</span>
<span id="2270">2270</span>
<span id="2271">2271</span>
<span id="2272">2272</span>
<span id="2273">2273</span>
<span id="2274">2274</span>
<span id="2275">2275</span>
<span id="2276">2276</span>
<span id="2277">2277</span>
<span id="2278">2278</span>
<span id="2279">2279</span>
<span id="2280">2280</span>
<span id="2281">2281</span>
<span id="2282">2282</span>
<span id="2283">2283</span>
<span id="2284">2284</span>
<span id="2285">2285</span>
<span id="2286">2286</span>
<span id="2287">2287</span>
<span id="2288">2288</span>
<span id="2289">2289</span>
<span id="2290">2290</span>
<span id="2291">2291</span>
<span id="2292">2292</span>
<span id="2293">2293</span>
<span id="2294">2294</span>
<span id="2295">2295</span>
<span id="2296">2296</span>
<span id="2297">2297</span>
<span id="2298">2298</span>
<span id="2299">2299</span>
<span id="2300">2300</span>
<span id="2301">2301</span>
<span id="2302">2302</span>
<span id="2303">2303</span>
<span id="2304">2304</span>
<span id="2305">2305</span>
<span id="2306">2306</span>
<span id="2307">2307</span>
<span id="2308">2308</span>
<span id="2309">2309</span>
<span id="2310">2310</span>
<span id="2311">2311</span>
<span id="2312">2312</span>
<span id="2313">2313</span>
<span id="2314">2314</span>
<span id="2315">2315</span>
<span id="2316">2316</span>
<span id="2317">2317</span>
<span id="2318">2318</span>
<span id="2319">2319</span>
<span id="2320">2320</span>
<span id="2321">2321</span>
<span id="2322">2322</span>
<span id="2323">2323</span>
<span id="2324">2324</span>
<span id="2325">2325</span>
<span id="2326">2326</span>
<span id="2327">2327</span>
<span id="2328">2328</span>
<span id="2329">2329</span>
<span id="2330">2330</span>
<span id="2331">2331</span>
<span id="2332">2332</span>
<span id="2333">2333</span>
<span id="2334">2334</span>
<span id="2335">2335</span>
<span id="2336">2336</span>
<span id="2337">2337</span>
<span id="2338">2338</span>
<span id="2339">2339</span>
<span id="2340">2340</span>
<span id="2341">2341</span>
<span id="2342">2342</span>
<span id="2343">2343</span>
<span id="2344">2344</span>
<span id="2345">2345</span>
<span id="2346">2346</span>
<span id="2347">2347</span>
<span id="2348">2348</span>
<span id="2349">2349</span>
<span id="2350">2350</span>
<span id="2351">2351</span>
<span id="2352">2352</span>
<span id="2353">2353</span>
<span id="2354">2354</span>
<span id="2355">2355</span>
<span id="2356">2356</span>
<span id="2357">2357</span>
<span id="2358">2358</span>
<span id="2359">2359</span>
<span id="2360">2360</span>
<span id="2361">2361</span>
<span id="2362">2362</span>
<span id="2363">2363</span>
<span id="2364">2364</span>
<span id="2365">2365</span>
<span id="2366">2366</span>
<span id="2367">2367</span>
<span id="2368">2368</span>
<span id="2369">2369</span>
<span id="2370">2370</span>
<span id="2371">2371</span>
<span id="2372">2372</span>
<span id="2373">2373</span>
<span id="2374">2374</span>
<span id="2375">2375</span>
<span id="2376">2376</span>
<span id="2377">2377</span>
<span id="2378">2378</span>
<span id="2379">2379</span>
<span id="2380">2380</span>
<span id="2381">2381</span>
<span id="2382">2382</span>
<span id="2383">2383</span>
<span id="2384">2384</span>
<span id="2385">2385</span>
<span id="2386">2386</span>
<span id="2387">2387</span>
<span id="2388">2388</span>
<span id="2389">2389</span>
<span id="2390">2390</span>
<span id="2391">2391</span>
<span id="2392">2392</span>
<span id="2393">2393</span>
<span id="2394">2394</span>
<span id="2395">2395</span>
<span id="2396">2396</span>
<span id="2397">2397</span>
<span id="2398">2398</span>
<span id="2399">2399</span>
<span id="2400">2400</span>
<span id="2401">2401</span>
<span id="2402">2402</span>
<span id="2403">2403</span>
<span id="2404">2404</span>
<span id="2405">2405</span>
<span id="2406">2406</span>
<span id="2407">2407</span>
<span id="2408">2408</span>
<span id="2409">2409</span>
<span id="2410">2410</span>
<span id="2411">2411</span>
<span id="2412">2412</span>
<span id="2413">2413</span>
<span id="2414">2414</span>
<span id="2415">2415</span>
<span id="2416">2416</span>
<span id="2417">2417</span>
<span id="2418">2418</span>
<span id="2419">2419</span>
<span id="2420">2420</span>
<span id="2421">2421</span>
<span id="2422">2422</span>
<span id="2423">2423</span>
<span id="2424">2424</span>
<span id="2425">2425</span>
<span id="2426">2426</span>
<span id="2427">2427</span>
<span id="2428">2428</span>
<span id="2429">2429</span>
<span id="2430">2430</span>
<span id="2431">2431</span>
<span id="2432">2432</span>
<span id="2433">2433</span>
<span id="2434">2434</span>
<span id="2435">2435</span>
<span id="2436">2436</span>
<span id="2437">2437</span>
<span id="2438">2438</span>
<span id="2439">2439</span>
<span id="2440">2440</span>
<span id="2441">2441</span>
<span id="2442">2442</span>
<span id="2443">2443</span>
<span id="2444">2444</span>
<span id="2445">2445</span>
<span id="2446">2446</span>
<span id="2447">2447</span>
<span id="2448">2448</span>
<span id="2449">2449</span>
<span id="2450">2450</span>
<span id="2451">2451</span>
<span id="2452">2452</span>
<span id="2453">2453</span>
<span id="2454">2454</span>
<span id="2455">2455</span>
<span id="2456">2456</span>
<span id="2457">2457</span>
<span id="2458">2458</span>
<span id="2459">2459</span>
<span id="2460">2460</span>
<span id="2461">2461</span>
<span id="2462">2462</span>
<span id="2463">2463</span>
<span id="2464">2464</span>
<span id="2465">2465</span>
<span id="2466">2466</span>
<span id="2467">2467</span>
<span id="2468">2468</span>
<span id="2469">2469</span>
<span id="2470">2470</span>
<span id="2471">2471</span>
<span id="2472">2472</span>
<span id="2473">2473</span>
<span id="2474">2474</span>
<span id="2475">2475</span>
<span id="2476">2476</span>
<span id="2477">2477</span>
<span id="2478">2478</span>
<span id="2479">2479</span>
<span id="2480">2480</span>
<span id="2481">2481</span>
<span id="2482">2482</span>
<span id="2483">2483</span>
<span id="2484">2484</span>
<span id="2485">2485</span>
<span id="2486">2486</span>
<span id="2487">2487</span>
<span id="2488">2488</span>
<span id="2489">2489</span>
<span id="2490">2490</span>
<span id="2491">2491</span>
<span id="2492">2492</span>
<span id="2493">2493</span>
<span id="2494">2494</span>
<span id="2495">2495</span>
<span id="2496">2496</span>
<span id="2497">2497</span>
<span id="2498">2498</span>
<span id="2499">2499</span>
<span id="2500">2500</span>
<span id="2501">2501</span>
<span id="2502">2502</span>
<span id="2503">2503</span>
<span id="2504">2504</span>
<span id="2505">2505</span>
<span id="2506">2506</span>
<span id="2507">2507</span>
<span id="2508">2508</span>
<span id="2509">2509</span>
<span id="2510">2510</span>
<span id="2511">2511</span>
<span id="2512">2512</span>
<span id="2513">2513</span>
<span id="2514">2514</span>
<span id="2515">2515</span>
<span id="2516">2516</span>
<span id="2517">2517</span>
<span id="2518">2518</span>
<span id="2519">2519</span>
<span id="2520">2520</span>
<span id="2521">2521</span>
<span id="2522">2522</span>
<span id="2523">2523</span>
<span id="2524">2524</span>
<span id="2525">2525</span>
<span id="2526">2526</span>
<span id="2527">2527</span>
<span id="2528">2528</span>
<span id="2529">2529</span>
<span id="2530">2530</span>
<span id="2531">2531</span>
<span id="2532">2532</span>
<span id="2533">2533</span>
<span id="2534">2534</span>
<span id="2535">2535</span>
<span id="2536">2536</span>
<span id="2537">2537</span>
<span id="2538">2538</span>
<span id="2539">2539</span>
<span id="2540">2540</span>
<span id="2541">2541</span>
<span id="2542">2542</span>
<span id="2543">2543</span>
<span id="2544">2544</span>
<span id="2545">2545</span>
<span id="2546">2546</span>
<span id="2547">2547</span>
<span id="2548">2548</span>
<span id="2549">2549</span>
<span id="2550">2550</span>
<span id="2551">2551</span>
<span id="2552">2552</span>
<span id="2553">2553</span>
<span id="2554">2554</span>
<span id="2555">2555</span>
<span id="2556">2556</span>
<span id="2557">2557</span>
<span id="2558">2558</span>
<span id="2559">2559</span>
<span id="2560">2560</span>
<span id="2561">2561</span>
<span id="2562">2562</span>
<span id="2563">2563</span>
<span id="2564">2564</span>
<span id="2565">2565</span>
<span id="2566">2566</span>
<span id="2567">2567</span>
<span id="2568">2568</span>
<span id="2569">2569</span>
<span id="2570">2570</span>
<span id="2571">2571</span>
<span id="2572">2572</span>
<span id="2573">2573</span>
<span id="2574">2574</span>
<span id="2575">2575</span>
<span id="2576">2576</span>
<span id="2577">2577</span>
<span id="2578">2578</span>
<span id="2579">2579</span>
<span id="2580">2580</span>
<span id="2581">2581</span>
<span id="2582">2582</span>
<span id="2583">2583</span>
<span id="2584">2584</span>
<span id="2585">2585</span>
<span id="2586">2586</span>
<span id="2587">2587</span>
<span id="2588">2588</span>
<span id="2589">2589</span>
<span id="2590">2590</span>
<span id="2591">2591</span>
<span id="2592">2592</span>
<span id="2593">2593</span>
<span id="2594">2594</span>
<span id="2595">2595</span>
<span id="2596">2596</span>
<span id="2597">2597</span>
<span id="2598">2598</span>
<span id="2599">2599</span>
<span id="2600">2600</span>
<span id="2601">2601</span>
<span id="2602">2602</span>
<span id="2603">2603</span>
<span id="2604">2604</span>
<span id="2605">2605</span>
<span id="2606">2606</span>
<span id="2607">2607</span>
<span id="2608">2608</span>
<span id="2609">2609</span>
<span id="2610">2610</span>
<span id="2611">2611</span>
<span id="2612">2612</span>
<span id="2613">2613</span>
<span id="2614">2614</span>
<span id="2615">2615</span>
<span id="2616">2616</span>
<span id="2617">2617</span>
<span id="2618">2618</span>
<span id="2619">2619</span>
<span id="2620">2620</span>
<span id="2621">2621</span>
<span id="2622">2622</span>
<span id="2623">2623</span>
<span id="2624">2624</span>
<span id="2625">2625</span>
<span id="2626">2626</span>
<span id="2627">2627</span>
<span id="2628">2628</span>
<span id="2629">2629</span>
<span id="2630">2630</span>
<span id="2631">2631</span>
<span id="2632">2632</span>
<span id="2633">2633</span>
<span id="2634">2634</span>
<span id="2635">2635</span>
<span id="2636">2636</span>
<span id="2637">2637</span>
<span id="2638">2638</span>
<span id="2639">2639</span>
<span id="2640">2640</span>
<span id="2641">2641</span>
<span id="2642">2642</span>
<span id="2643">2643</span>
<span id="2644">2644</span>
<span id="2645">2645</span>
<span id="2646">2646</span>
<span id="2647">2647</span>
<span id="2648">2648</span>
<span id="2649">2649</span>
<span id="2650">2650</span>
<span id="2651">2651</span>
<span id="2652">2652</span>
<span id="2653">2653</span>
<span id="2654">2654</span>
<span id="2655">2655</span>
<span id="2656">2656</span>
<span id="2657">2657</span>
<span id="2658">2658</span>
<span id="2659">2659</span>
<span id="2660">2660</span>
<span id="2661">2661</span>
<span id="2662">2662</span>
<span id="2663">2663</span>
<span id="2664">2664</span>
<span id="2665">2665</span>
<span id="2666">2666</span>
<span id="2667">2667</span>
<span id="2668">2668</span>
<span id="2669">2669</span>
<span id="2670">2670</span>
<span id="2671">2671</span>
<span id="2672">2672</span>
<span id="2673">2673</span>
<span id="2674">2674</span>
<span id="2675">2675</span>
<span id="2676">2676</span>
<span id="2677">2677</span>
<span id="2678">2678</span>
<span id="2679">2679</span>
<span id="2680">2680</span>
<span id="2681">2681</span>
<span id="2682">2682</span>
<span id="2683">2683</span>
<span id="2684">2684</span>
<span id="2685">2685</span>
<span id="2686">2686</span>
<span id="2687">2687</span>
<span id="2688">2688</span>
<span id="2689">2689</span>
<span id="2690">2690</span>
<span id="2691">2691</span>
<span id="2692">2692</span>
<span id="2693">2693</span>
<span id="2694">2694</span>
<span id="2695">2695</span>
<span id="2696">2696</span>
<span id="2697">2697</span>
<span id="2698">2698</span>
<span id="2699">2699</span>
<span id="2700">2700</span>
<span id="2701">2701</span>
<span id="2702">2702</span>
<span id="2703">2703</span>
<span id="2704">2704</span>
<span id="2705">2705</span>
<span id="2706">2706</span>
<span id="2707">2707</span>
<span id="2708">2708</span>
<span id="2709">2709</span>
<span id="2710">2710</span>
<span id="2711">2711</span>
<span id="2712">2712</span>
<span id="2713">2713</span>
<span id="2714">2714</span>
<span id="2715">2715</span>
<span id="2716">2716</span>
<span id="2717">2717</span>
<span id="2718">2718</span>
<span id="2719">2719</span>
<span id="2720">2720</span>
<span id="2721">2721</span>
<span id="2722">2722</span>
<span id="2723">2723</span>
<span id="2724">2724</span>
<span id="2725">2725</span>
<span id="2726">2726</span>
<span id="2727">2727</span>
<span id="2728">2728</span>
<span id="2729">2729</span>
<span id="2730">2730</span>
<span id="2731">2731</span>
<span id="2732">2732</span>
<span id="2733">2733</span>
<span id="2734">2734</span>
<span id="2735">2735</span>
<span id="2736">2736</span>
<span id="2737">2737</span>
<span id="2738">2738</span>
<span id="2739">2739</span>
<span id="2740">2740</span>
<span id="2741">2741</span>
<span id="2742">2742</span>
<span id="2743">2743</span>
<span id="2744">2744</span>
<span id="2745">2745</span>
<span id="2746">2746</span>
<span id="2747">2747</span>
<span id="2748">2748</span>
<span id="2749">2749</span>
<span id="2750">2750</span>
<span id="2751">2751</span>
<span id="2752">2752</span>
<span id="2753">2753</span>
<span id="2754">2754</span>
<span id="2755">2755</span>
<span id="2756">2756</span>
<span id="2757">2757</span>
<span id="2758">2758</span>
<span id="2759">2759</span>
<span id="2760">2760</span>
<span id="2761">2761</span>
<span id="2762">2762</span>
<span id="2763">2763</span>
<span id="2764">2764</span>
<span id="2765">2765</span>
<span id="2766">2766</span>
<span id="2767">2767</span>
<span id="2768">2768</span>
<span id="2769">2769</span>
<span id="2770">2770</span>
<span id="2771">2771</span>
<span id="2772">2772</span>
<span id="2773">2773</span>
<span id="2774">2774</span>
<span id="2775">2775</span>
<span id="2776">2776</span>
<span id="2777">2777</span>
<span id="2778">2778</span>
<span id="2779">2779</span>
<span id="2780">2780</span>
<span id="2781">2781</span>
<span id="2782">2782</span>
<span id="2783">2783</span>
<span id="2784">2784</span>
<span id="2785">2785</span>
<span id="2786">2786</span>
<span id="2787">2787</span>
<span id="2788">2788</span>
<span id="2789">2789</span>
<span id="2790">2790</span>
<span id="2791">2791</span>
<span id="2792">2792</span>
<span id="2793">2793</span>
<span id="2794">2794</span>
<span id="2795">2795</span>
<span id="2796">2796</span>
<span id="2797">2797</span>
<span id="2798">2798</span>
<span id="2799">2799</span>
<span id="2800">2800</span>
<span id="2801">2801</span>
<span id="2802">2802</span>
<span id="2803">2803</span>
<span id="2804">2804</span>
<span id="2805">2805</span>
<span id="2806">2806</span>
<span id="2807">2807</span>
<span id="2808">2808</span>
<span id="2809">2809</span>
<span id="2810">2810</span>
<span id="2811">2811</span>
<span id="2812">2812</span>
<span id="2813">2813</span>
<span id="2814">2814</span>
<span id="2815">2815</span>
<span id="2816">2816</span>
<span id="2817">2817</span>
<span id="2818">2818</span>
<span id="2819">2819</span>
<span id="2820">2820</span>
<span id="2821">2821</span>
<span id="2822">2822</span>
<span id="2823">2823</span>
<span id="2824">2824</span>
<span id="2825">2825</span>
<span id="2826">2826</span>
<span id="2827">2827</span>
<span id="2828">2828</span>
<span id="2829">2829</span>
<span id="2830">2830</span>
<span id="2831">2831</span>
<span id="2832">2832</span>
<span id="2833">2833</span>
<span id="2834">2834</span>
<span id="2835">2835</span>
<span id="2836">2836</span>
<span id="2837">2837</span>
<span id="2838">2838</span>
<span id="2839">2839</span>
<span id="2840">2840</span>
<span id="2841">2841</span>
<span id="2842">2842</span>
<span id="2843">2843</span>
<span id="2844">2844</span>
<span id="2845">2845</span>
<span id="2846">2846</span>
<span id="2847">2847</span>
<span id="2848">2848</span>
<span id="2849">2849</span>
<span id="2850">2850</span>
<span id="2851">2851</span>
<span id="2852">2852</span>
<span id="2853">2853</span>
<span id="2854">2854</span>
<span id="2855">2855</span>
<span id="2856">2856</span>
<span id="2857">2857</span>
<span id="2858">2858</span>
<span id="2859">2859</span>
<span id="2860">2860</span>
<span id="2861">2861</span>
<span id="2862">2862</span>
<span id="2863">2863</span>
<span id="2864">2864</span>
<span id="2865">2865</span>
<span id="2866">2866</span>
<span id="2867">2867</span>
<span id="2868">2868</span>
<span id="2869">2869</span>
<span id="2870">2870</span>
<span id="2871">2871</span>
<span id="2872">2872</span>
<span id="2873">2873</span>
<span id="2874">2874</span>
<span id="2875">2875</span>
<span id="2876">2876</span>
<span id="2877">2877</span>
<span id="2878">2878</span>
<span id="2879">2879</span>
<span id="2880">2880</span>
<span id="2881">2881</span>
<span id="2882">2882</span>
<span id="2883">2883</span>
<span id="2884">2884</span>
<span id="2885">2885</span>
<span id="2886">2886</span>
<span id="2887">2887</span>
<span id="2888">2888</span>
<span id="2889">2889</span>
<span id="2890">2890</span>
<span id="2891">2891</span>
<span id="2892">2892</span>
<span id="2893">2893</span>
<span id="2894">2894</span>
<span id="2895">2895</span>
<span id="2896">2896</span>
<span id="2897">2897</span>
<span id="2898">2898</span>
<span id="2899">2899</span>
<span id="2900">2900</span>
<span id="2901">2901</span>
<span id="2902">2902</span>
<span id="2903">2903</span>
<span id="2904">2904</span>
<span id="2905">2905</span>
<span id="2906">2906</span>
<span id="2907">2907</span>
<span id="2908">2908</span>
<span id="2909">2909</span>
<span id="2910">2910</span>
<span id="2911">2911</span>
<span id="2912">2912</span>
<span id="2913">2913</span>
<span id="2914">2914</span>
<span id="2915">2915</span>
<span id="2916">2916</span>
<span id="2917">2917</span>
<span id="2918">2918</span>
<span id="2919">2919</span>
<span id="2920">2920</span>
<span id="2921">2921</span>
<span id="2922">2922</span>
<span id="2923">2923</span>
<span id="2924">2924</span>
<span id="2925">2925</span>
<span id="2926">2926</span>
<span id="2927">2927</span>
<span id="2928">2928</span>
<span id="2929">2929</span>
<span id="2930">2930</span>
<span id="2931">2931</span>
<span id="2932">2932</span>
<span id="2933">2933</span>
<span id="2934">2934</span>
<span id="2935">2935</span>
<span id="2936">2936</span>
<span id="2937">2937</span>
<span id="2938">2938</span>
<span id="2939">2939</span>
<span id="2940">2940</span>
<span id="2941">2941</span>
<span id="2942">2942</span>
<span id="2943">2943</span>
<span id="2944">2944</span>
<span id="2945">2945</span>
<span id="2946">2946</span>
<span id="2947">2947</span>
<span id="2948">2948</span>
<span id="2949">2949</span>
<span id="2950">2950</span>
<span id="2951">2951</span>
<span id="2952">2952</span>
<span id="2953">2953</span>
<span id="2954">2954</span>
<span id="2955">2955</span>
<span id="2956">2956</span>
<span id="2957">2957</span>
<span id="2958">2958</span>
<span id="2959">2959</span>
<span id="2960">2960</span>
<span id="2961">2961</span>
<span id="2962">2962</span>
<span id="2963">2963</span>
<span id="2964">2964</span>
<span id="2965">2965</span>
<span id="2966">2966</span>
<span id="2967">2967</span>
<span id="2968">2968</span>
<span id="2969">2969</span>
<span id="2970">2970</span>
<span id="2971">2971</span>
<span id="2972">2972</span>
<span id="2973">2973</span>
<span id="2974">2974</span>
<span id="2975">2975</span>
<span id="2976">2976</span>
<span id="2977">2977</span>
<span id="2978">2978</span>
<span id="2979">2979</span>
<span id="2980">2980</span>
<span id="2981">2981</span>
<span id="2982">2982</span>
<span id="2983">2983</span>
<span id="2984">2984</span>
<span id="2985">2985</span>
<span id="2986">2986</span>
<span id="2987">2987</span>
<span id="2988">2988</span>
<span id="2989">2989</span>
<span id="2990">2990</span>
<span id="2991">2991</span>
<span id="2992">2992</span>
<span id="2993">2993</span>
<span id="2994">2994</span>
<span id="2995">2995</span>
<span id="2996">2996</span>
<span id="2997">2997</span>
<span id="2998">2998</span>
<span id="2999">2999</span>
<span id="3000">3000</span>
<span id="3001">3001</span>
<span id="3002">3002</span>
<span id="3003">3003</span>
<span id="3004">3004</span>
<span id="3005">3005</span>
<span id="3006">3006</span>
<span id="3007">3007</span>
<span id="3008">3008</span>
<span id="3009">3009</span>
<span id="3010">3010</span>
<span id="3011">3011</span>
<span id="3012">3012</span>
<span id="3013">3013</span>
<span id="3014">3014</span>
<span id="3015">3015</span>
<span id="3016">3016</span>
<span id="3017">3017</span>
<span id="3018">3018</span>
<span id="3019">3019</span>
<span id="3020">3020</span>
<span id="3021">3021</span>
<span id="3022">3022</span>
<span id="3023">3023</span>
<span id="3024">3024</span>
<span id="3025">3025</span>
<span id="3026">3026</span>
<span id="3027">3027</span>
<span id="3028">3028</span>
<span id="3029">3029</span>
<span id="3030">3030</span>
<span id="3031">3031</span>
<span id="3032">3032</span>
<span id="3033">3033</span>
<span id="3034">3034</span>
<span id="3035">3035</span>
<span id="3036">3036</span>
<span id="3037">3037</span>
<span id="3038">3038</span>
<span id="3039">3039</span>
<span id="3040">3040</span>
<span id="3041">3041</span>
<span id="3042">3042</span>
<span id="3043">3043</span>
<span id="3044">3044</span>
<span id="3045">3045</span>
<span id="3046">3046</span>
<span id="3047">3047</span>
<span id="3048">3048</span>
<span id="3049">3049</span>
<span id="3050">3050</span>
<span id="3051">3051</span>
<span id="3052">3052</span>
<span id="3053">3053</span>
<span id="3054">3054</span>
<span id="3055">3055</span>
<span id="3056">3056</span>
<span id="3057">3057</span>
<span id="3058">3058</span>
<span id="3059">3059</span>
<span id="3060">3060</span>
<span id="3061">3061</span>
<span id="3062">3062</span>
<span id="3063">3063</span>
<span id="3064">3064</span>
<span id="3065">3065</span>
<span id="3066">3066</span>
<span id="3067">3067</span>
<span id="3068">3068</span>
<span id="3069">3069</span>
<span id="3070">3070</span>
<span id="3071">3071</span>
<span id="3072">3072</span>
<span id="3073">3073</span>
<span id="3074">3074</span>
<span id="3075">3075</span>
<span id="3076">3076</span>
<span id="3077">3077</span>
<span id="3078">3078</span>
<span id="3079">3079</span>
<span id="3080">3080</span>
<span id="3081">3081</span>
<span id="3082">3082</span>
<span id="3083">3083</span>
<span id="3084">3084</span>
<span id="3085">3085</span>
<span id="3086">3086</span>
<span id="3087">3087</span>
<span id="3088">3088</span>
<span id="3089">3089</span>
<span id="3090">3090</span>
<span id="3091">3091</span>
<span id="3092">3092</span>
<span id="3093">3093</span>
<span id="3094">3094</span>
<span id="3095">3095</span>
<span id="3096">3096</span>
<span id="3097">3097</span>
<span id="3098">3098</span>
<span id="3099">3099</span>
<span id="3100">3100</span>
<span id="3101">3101</span>
<span id="3102">3102</span>
<span id="3103">3103</span>
<span id="3104">3104</span>
<span id="3105">3105</span>
<span id="3106">3106</span>
<span id="3107">3107</span>
<span id="3108">3108</span>
<span id="3109">3109</span>
<span id="3110">3110</span>
<span id="3111">3111</span>
<span id="3112">3112</span>
<span id="3113">3113</span>
<span id="3114">3114</span>
<span id="3115">3115</span>
<span id="3116">3116</span>
<span id="3117">3117</span>
<span id="3118">3118</span>
<span id="3119">3119</span>
<span id="3120">3120</span>
<span id="3121">3121</span>
<span id="3122">3122</span>
<span id="3123">3123</span>
<span id="3124">3124</span>
<span id="3125">3125</span>
<span id="3126">3126</span>
<span id="3127">3127</span>
<span id="3128">3128</span>
<span id="3129">3129</span>
<span id="3130">3130</span>
<span id="3131">3131</span>
<span id="3132">3132</span>
<span id="3133">3133</span>
<span id="3134">3134</span>
<span id="3135">3135</span>
<span id="3136">3136</span>
<span id="3137">3137</span>
<span id="3138">3138</span>
<span id="3139">3139</span>
<span id="3140">3140</span>
<span id="3141">3141</span>
<span id="3142">3142</span>
<span id="3143">3143</span>
<span id="3144">3144</span>
<span id="3145">3145</span>
<span id="3146">3146</span>
<span id="3147">3147</span>
<span id="3148">3148</span>
<span id="3149">3149</span>
<span id="3150">3150</span>
<span id="3151">3151</span>
<span id="3152">3152</span>
<span id="3153">3153</span>
<span id="3154">3154</span>
<span id="3155">3155</span>
<span id="3156">3156</span>
<span id="3157">3157</span>
<span id="3158">3158</span>
<span id="3159">3159</span>
<span id="3160">3160</span>
<span id="3161">3161</span>
<span id="3162">3162</span>
<span id="3163">3163</span>
<span id="3164">3164</span>
<span id="3165">3165</span>
<span id="3166">3166</span>
<span id="3167">3167</span>
<span id="3168">3168</span>
<span id="3169">3169</span>
<span id="3170">3170</span>
<span id="3171">3171</span>
<span id="3172">3172</span>
<span id="3173">3173</span>
<span id="3174">3174</span>
<span id="3175">3175</span>
<span id="3176">3176</span>
<span id="3177">3177</span>
<span id="3178">3178</span>
<span id="3179">3179</span>
<span id="3180">3180</span>
<span id="3181">3181</span>
<span id="3182">3182</span>
<span id="3183">3183</span>
<span id="3184">3184</span>
<span id="3185">3185</span>
<span id="3186">3186</span>
<span id="3187">3187</span>
<span id="3188">3188</span>
<span id="3189">3189</span>
<span id="3190">3190</span>
<span id="3191">3191</span>
<span id="3192">3192</span>
<span id="3193">3193</span>
<span id="3194">3194</span>
<span id="3195">3195</span>
<span id="3196">3196</span>
<span id="3197">3197</span>
<span id="3198">3198</span>
<span id="3199">3199</span>
<span id="3200">3200</span>
<span id="3201">3201</span>
<span id="3202">3202</span>
<span id="3203">3203</span>
<span id="3204">3204</span>
<span id="3205">3205</span>
<span id="3206">3206</span>
<span id="3207">3207</span>
<span id="3208">3208</span>
<span id="3209">3209</span>
<span id="3210">3210</span>
<span id="3211">3211</span>
<span id="3212">3212</span>
<span id="3213">3213</span>
<span id="3214">3214</span>
<span id="3215">3215</span>
<span id="3216">3216</span>
<span id="3217">3217</span>
<span id="3218">3218</span>
<span id="3219">3219</span>
<span id="3220">3220</span>
<span id="3221">3221</span>
<span id="3222">3222</span>
<span id="3223">3223</span>
<span id="3224">3224</span>
<span id="3225">3225</span>
<span id="3226">3226</span>
<span id="3227">3227</span>
<span id="3228">3228</span>
<span id="3229">3229</span>
<span id="3230">3230</span>
<span id="3231">3231</span>
<span id="3232">3232</span>
<span id="3233">3233</span>
<span id="3234">3234</span>
<span id="3235">3235</span>
<span id="3236">3236</span>
<span id="3237">3237</span>
<span id="3238">3238</span>
<span id="3239">3239</span>
<span id="3240">3240</span>
<span id="3241">3241</span>
<span id="3242">3242</span>
<span id="3243">3243</span>
<span id="3244">3244</span>
<span id="3245">3245</span>
<span id="3246">3246</span>
<span id="3247">3247</span>
<span id="3248">3248</span>
<span id="3249">3249</span>
<span id="3250">3250</span>
<span id="3251">3251</span>
<span id="3252">3252</span>
<span id="3253">3253</span>
<span id="3254">3254</span>
<span id="3255">3255</span>
<span id="3256">3256</span>
<span id="3257">3257</span>
<span id="3258">3258</span>
<span id="3259">3259</span>
<span id="3260">3260</span>
<span id="3261">3261</span>
<span id="3262">3262</span>
<span id="3263">3263</span>
<span id="3264">3264</span>
<span id="3265">3265</span>
<span id="3266">3266</span>
<span id="3267">3267</span>
<span id="3268">3268</span>
<span id="3269">3269</span>
<span id="3270">3270</span>
<span id="3271">3271</span>
<span id="3272">3272</span>
<span id="3273">3273</span>
<span id="3274">3274</span>
<span id="3275">3275</span>
<span id="3276">3276</span>
<span id="3277">3277</span>
<span id="3278">3278</span>
<span id="3279">3279</span>
<span id="3280">3280</span>
<span id="3281">3281</span>
<span id="3282">3282</span>
<span id="3283">3283</span>
<span id="3284">3284</span>
<span id="3285">3285</span>
<span id="3286">3286</span>
<span id="3287">3287</span>
<span id="3288">3288</span>
<span id="3289">3289</span>
<span id="3290">3290</span>
<span id="3291">3291</span>
<span id="3292">3292</span>
<span id="3293">3293</span>
<span id="3294">3294</span>
<span id="3295">3295</span>
<span id="3296">3296</span>
<span id="3297">3297</span>
<span id="3298">3298</span>
<span id="3299">3299</span>
<span id="3300">3300</span>
<span id="3301">3301</span>
<span id="3302">3302</span>
<span id="3303">3303</span>
<span id="3304">3304</span>
<span id="3305">3305</span>
<span id="3306">3306</span>
<span id="3307">3307</span>
<span id="3308">3308</span>
<span id="3309">3309</span>
<span id="3310">3310</span>
<span id="3311">3311</span>
<span id="3312">3312</span>
<span id="3313">3313</span>
<span id="3314">3314</span>
<span id="3315">3315</span>
<span id="3316">3316</span>
<span id="3317">3317</span>
<span id="3318">3318</span>
<span id="3319">3319</span>
<span id="3320">3320</span>
<span id="3321">3321</span>
<span id="3322">3322</span>
<span id="3323">3323</span>
<span id="3324">3324</span>
<span id="3325">3325</span>
<span id="3326">3326</span>
<span id="3327">3327</span>
<span id="3328">3328</span>
<span id="3329">3329</span>
<span id="3330">3330</span>
<span id="3331">3331</span>
<span id="3332">3332</span>
<span id="3333">3333</span>
<span id="3334">3334</span>
<span id="3335">3335</span>
<span id="3336">3336</span>
<span id="3337">3337</span>
<span id="3338">3338</span>
<span id="3339">3339</span>
<span id="3340">3340</span>
<span id="3341">3341</span>
<span id="3342">3342</span>
<span id="3343">3343</span>
<span id="3344">3344</span>
<span id="3345">3345</span>
<span id="3346">3346</span>
<span id="3347">3347</span>
<span id="3348">3348</span>
<span id="3349">3349</span>
<span id="3350">3350</span>
<span id="3351">3351</span>
<span id="3352">3352</span>
<span id="3353">3353</span>
<span id="3354">3354</span>
<span id="3355">3355</span>
<span id="3356">3356</span>
<span id="3357">3357</span>
<span id="3358">3358</span>
<span id="3359">3359</span>
<span id="3360">3360</span>
<span id="3361">3361</span>
<span id="3362">3362</span>
<span id="3363">3363</span>
<span id="3364">3364</span>
<span id="3365">3365</span>
<span id="3366">3366</span>
<span id="3367">3367</span>
<span id="3368">3368</span>
<span id="3369">3369</span>
<span id="3370">3370</span>
<span id="3371">3371</span>
<span id="3372">3372</span>
<span id="3373">3373</span>
<span id="3374">3374</span>
<span id="3375">3375</span>
<span id="3376">3376</span>
<span id="3377">3377</span>
<span id="3378">3378</span>
<span id="3379">3379</span>
<span id="3380">3380</span>
<span id="3381">3381</span>
<span id="3382">3382</span>
<span id="3383">3383</span>
<span id="3384">3384</span>
<span id="3385">3385</span>
<span id="3386">3386</span>
<span id="3387">3387</span>
<span id="3388">3388</span>
<span id="3389">3389</span>
<span id="3390">3390</span>
<span id="3391">3391</span>
<span id="3392">3392</span>
<span id="3393">3393</span>
<span id="3394">3394</span>
<span id="3395">3395</span>
<span id="3396">3396</span>
<span id="3397">3397</span>
<span id="3398">3398</span>
<span id="3399">3399</span>
<span id="3400">3400</span>
<span id="3401">3401</span>
<span id="3402">3402</span>
<span id="3403">3403</span>
<span id="3404">3404</span>
<span id="3405">3405</span>
<span id="3406">3406</span>
<span id="3407">3407</span>
<span id="3408">3408</span>
<span id="3409">3409</span>
<span id="3410">3410</span>
<span id="3411">3411</span>
<span id="3412">3412</span>
<span id="3413">3413</span>
<span id="3414">3414</span>
<span id="3415">3415</span>
<span id="3416">3416</span>
<span id="3417">3417</span>
<span id="3418">3418</span>
<span id="3419">3419</span>
<span id="3420">3420</span>
<span id="3421">3421</span>
<span id="3422">3422</span>
<span id="3423">3423</span>
<span id="3424">3424</span>
<span id="3425">3425</span>
<span id="3426">3426</span>
<span id="3427">3427</span>
<span id="3428">3428</span>
<span id="3429">3429</span>
<span id="3430">3430</span>
<span id="3431">3431</span>
<span id="3432">3432</span>
<span id="3433">3433</span>
<span id="3434">3434</span>
<span id="3435">3435</span>
<span id="3436">3436</span>
<span id="3437">3437</span>
<span id="3438">3438</span>
<span id="3439">3439</span>
<span id="3440">3440</span>
<span id="3441">3441</span>
<span id="3442">3442</span>
<span id="3443">3443</span>
<span id="3444">3444</span>
<span id="3445">3445</span>
<span id="3446">3446</span>
<span id="3447">3447</span>
<span id="3448">3448</span>
<span id="3449">3449</span>
<span id="3450">3450</span>
<span id="3451">3451</span>
<span id="3452">3452</span>
<span id="3453">3453</span>
<span id="3454">3454</span>
<span id="3455">3455</span>
<span id="3456">3456</span>
<span id="3457">3457</span>
<span id="3458">3458</span>
<span id="3459">3459</span>
<span id="3460">3460</span>
<span id="3461">3461</span>
<span id="3462">3462</span>
<span id="3463">3463</span>
<span id="3464">3464</span>
<span id="3465">3465</span>
<span id="3466">3466</span>
<span id="3467">3467</span>
<span id="3468">3468</span>
<span id="3469">3469</span>
<span id="3470">3470</span>
<span id="3471">3471</span>
<span id="3472">3472</span>
<span id="3473">3473</span>
<span id="3474">3474</span>
<span id="3475">3475</span>
<span id="3476">3476</span>
<span id="3477">3477</span>
<span id="3478">3478</span>
<span id="3479">3479</span>
<span id="3480">3480</span>
<span id="3481">3481</span>
<span id="3482">3482</span>
<span id="3483">3483</span>
<span id="3484">3484</span>
<span id="3485">3485</span>
<span id="3486">3486</span>
<span id="3487">3487</span>
<span id="3488">3488</span>
<span id="3489">3489</span>
<span id="3490">3490</span>
<span id="3491">3491</span>
<span id="3492">3492</span>
<span id="3493">3493</span>
<span id="3494">3494</span>
<span id="3495">3495</span>
<span id="3496">3496</span>
<span id="3497">3497</span>
<span id="3498">3498</span>
<span id="3499">3499</span>
<span id="3500">3500</span>
<span id="3501">3501</span>
<span id="3502">3502</span>
<span id="3503">3503</span>
<span id="3504">3504</span>
<span id="3505">3505</span>
<span id="3506">3506</span>
<span id="3507">3507</span>
<span id="3508">3508</span>
<span id="3509">3509</span>
<span id="3510">3510</span>
<span id="3511">3511</span>
<span id="3512">3512</span>
<span id="3513">3513</span>
<span id="3514">3514</span>
<span id="3515">3515</span>
<span id="3516">3516</span>
<span id="3517">3517</span>
<span id="3518">3518</span>
<span id="3519">3519</span>
<span id="3520">3520</span>
<span id="3521">3521</span>
<span id="3522">3522</span>
<span id="3523">3523</span>
<span id="3524">3524</span>
<span id="3525">3525</span>
<span id="3526">3526</span>
<span id="3527">3527</span>
<span id="3528">3528</span>
<span id="3529">3529</span>
<span id="3530">3530</span>
<span id="3531">3531</span>
<span id="3532">3532</span>
<span id="3533">3533</span>
<span id="3534">3534</span>
<span id="3535">3535</span>
<span id="3536">3536</span>
<span id="3537">3537</span>
<span id="3538">3538</span>
<span id="3539">3539</span>
<span id="3540">3540</span>
<span id="3541">3541</span>
<span id="3542">3542</span>
<span id="3543">3543</span>
<span id="3544">3544</span>
<span id="3545">3545</span>
<span id="3546">3546</span>
<span id="3547">3547</span>
<span id="3548">3548</span>
<span id="3549">3549</span>
<span id="3550">3550</span>
<span id="3551">3551</span>
<span id="3552">3552</span>
<span id="3553">3553</span>
<span id="3554">3554</span>
<span id="3555">3555</span>
<span id="3556">3556</span>
<span id="3557">3557</span>
<span id="3558">3558</span>
<span id="3559">3559</span>
<span id="3560">3560</span>
<span id="3561">3561</span>
<span id="3562">3562</span>
<span id="3563">3563</span>
<span id="3564">3564</span>
<span id="3565">3565</span>
<span id="3566">3566</span>
<span id="3567">3567</span>
<span id="3568">3568</span>
<span id="3569">3569</span>
<span id="3570">3570</span>
<span id="3571">3571</span>
<span id="3572">3572</span>
<span id="3573">3573</span>
<span id="3574">3574</span>
<span id="3575">3575</span>
<span id="3576">3576</span>
<span id="3577">3577</span>
<span id="3578">3578</span>
<span id="3579">3579</span>
<span id="3580">3580</span>
<span id="3581">3581</span>
<span id="3582">3582</span>
<span id="3583">3583</span>
<span id="3584">3584</span>
<span id="3585">3585</span>
<span id="3586">3586</span>
<span id="3587">3587</span>
<span id="3588">3588</span>
<span id="3589">3589</span>
<span id="3590">3590</span>
<span id="3591">3591</span>
<span id="3592">3592</span>
<span id="3593">3593</span>
<span id="3594">3594</span>
<span id="3595">3595</span>
<span id="3596">3596</span>
<span id="3597">3597</span>
<span id="3598">3598</span>
<span id="3599">3599</span>
<span id="3600">3600</span>
<span id="3601">3601</span>
<span id="3602">3602</span>
<span id="3603">3603</span>
<span id="3604">3604</span>
<span id="3605">3605</span>
<span id="3606">3606</span>
<span id="3607">3607</span>
<span id="3608">3608</span>
<span id="3609">3609</span>
<span id="3610">3610</span>
<span id="3611">3611</span>
<span id="3612">3612</span>
<span id="3613">3613</span>
<span id="3614">3614</span>
<span id="3615">3615</span>
<span id="3616">3616</span>
<span id="3617">3617</span>
<span id="3618">3618</span>
<span id="3619">3619</span>
<span id="3620">3620</span>
<span id="3621">3621</span>
<span id="3622">3622</span>
<span id="3623">3623</span>
<span id="3624">3624</span>
<span id="3625">3625</span>
<span id="3626">3626</span>
<span id="3627">3627</span>
<span id="3628">3628</span>
<span id="3629">3629</span>
<span id="3630">3630</span>
<span id="3631">3631</span>
<span id="3632">3632</span>
<span id="3633">3633</span>
<span id="3634">3634</span>
<span id="3635">3635</span>
<span id="3636">3636</span>
<span id="3637">3637</span>
<span id="3638">3638</span>
<span id="3639">3639</span>
<span id="3640">3640</span>
<span id="3641">3641</span>
<span id="3642">3642</span>
<span id="3643">3643</span>
<span id="3644">3644</span>
<span id="3645">3645</span>
<span id="3646">3646</span>
<span id="3647">3647</span>
<span id="3648">3648</span>
<span id="3649">3649</span>
<span id="3650">3650</span>
<span id="3651">3651</span>
<span id="3652">3652</span>
<span id="3653">3653</span>
<span id="3654">3654</span>
<span id="3655">3655</span>
<span id="3656">3656</span>
<span id="3657">3657</span>
<span id="3658">3658</span>
<span id="3659">3659</span>
<span id="3660">3660</span>
<span id="3661">3661</span>
<span id="3662">3662</span>
<span id="3663">3663</span>
<span id="3664">3664</span>
<span id="3665">3665</span>
<span id="3666">3666</span>
<span id="3667">3667</span>
<span id="3668">3668</span>
<span id="3669">3669</span>
<span id="3670">3670</span>
<span id="3671">3671</span>
<span id="3672">3672</span>
<span id="3673">3673</span>
<span id="3674">3674</span>
<span id="3675">3675</span>
<span id="3676">3676</span>
<span id="3677">3677</span>
<span id="3678">3678</span>
<span id="3679">3679</span>
<span id="3680">3680</span>
<span id="3681">3681</span>
<span id="3682">3682</span>
<span id="3683">3683</span>
<span id="3684">3684</span>
<span id="3685">3685</span>
<span id="3686">3686</span>
<span id="3687">3687</span>
<span id="3688">3688</span>
<span id="3689">3689</span>
<span id="3690">3690</span>
<span id="3691">3691</span>
<span id="3692">3692</span>
<span id="3693">3693</span>
<span id="3694">3694</span>
<span id="3695">3695</span>
<span id="3696">3696</span>
<span id="3697">3697</span>
<span id="3698">3698</span>
<span id="3699">3699</span>
<span id="3700">3700</span>
<span id="3701">3701</span>
<span id="3702">3702</span>
<span id="3703">3703</span>
<span id="3704">3704</span>
<span id="3705">3705</span>
<span id="3706">3706</span>
<span id="3707">3707</span>
<span id="3708">3708</span>
<span id="3709">3709</span>
<span id="3710">3710</span>
<span id="3711">3711</span>
<span id="3712">3712</span>
<span id="3713">3713</span>
<span id="3714">3714</span>
<span id="3715">3715</span>
<span id="3716">3716</span>
<span id="3717">3717</span>
<span id="3718">3718</span>
<span id="3719">3719</span>
<span id="3720">3720</span>
<span id="3721">3721</span>
<span id="3722">3722</span>
<span id="3723">3723</span>
<span id="3724">3724</span>
<span id="3725">3725</span>
<span id="3726">3726</span>
<span id="3727">3727</span>
<span id="3728">3728</span>
<span id="3729">3729</span>
<span id="3730">3730</span>
<span id="3731">3731</span>
<span id="3732">3732</span>
<span id="3733">3733</span>
<span id="3734">3734</span>
<span id="3735">3735</span>
<span id="3736">3736</span>
<span id="3737">3737</span>
<span id="3738">3738</span>
<span id="3739">3739</span>
<span id="3740">3740</span>
<span id="3741">3741</span>
<span id="3742">3742</span>
<span id="3743">3743</span>
<span id="3744">3744</span>
<span id="3745">3745</span>
<span id="3746">3746</span>
<span id="3747">3747</span>
<span id="3748">3748</span>
<span id="3749">3749</span>
<span id="3750">3750</span>
<span id="3751">3751</span>
<span id="3752">3752</span>
<span id="3753">3753</span>
<span id="3754">3754</span>
<span id="3755">3755</span>
<span id="3756">3756</span>
<span id="3757">3757</span>
<span id="3758">3758</span>
<span id="3759">3759</span>
<span id="3760">3760</span>
<span id="3761">3761</span>
<span id="3762">3762</span>
<span id="3763">3763</span>
<span id="3764">3764</span>
<span id="3765">3765</span>
<span id="3766">3766</span>
<span id="3767">3767</span>
<span id="3768">3768</span>
<span id="3769">3769</span>
<span id="3770">3770</span>
<span id="3771">3771</span>
<span id="3772">3772</span>
<span id="3773">3773</span>
<span id="3774">3774</span>
<span id="3775">3775</span>
<span id="3776">3776</span>
<span id="3777">3777</span>
<span id="3778">3778</span>
<span id="3779">3779</span>
<span id="3780">3780</span>
<span id="3781">3781</span>
<span id="3782">3782</span>
<span id="3783">3783</span>
<span id="3784">3784</span>
<span id="3785">3785</span>
<span id="3786">3786</span>
<span id="3787">3787</span>
<span id="3788">3788</span>
<span id="3789">3789</span>
<span id="3790">3790</span>
<span id="3791">3791</span>
<span id="3792">3792</span>
<span id="3793">3793</span>
<span id="3794">3794</span>
<span id="3795">3795</span>
<span id="3796">3796</span>
<span id="3797">3797</span>
<span id="3798">3798</span>
<span id="3799">3799</span>
<span id="3800">3800</span>
<span id="3801">3801</span>
<span id="3802">3802</span>
<span id="3803">3803</span>
<span id="3804">3804</span>
<span id="3805">3805</span>
<span id="3806">3806</span>
<span id="3807">3807</span>
<span id="3808">3808</span>
<span id="3809">3809</span>
<span id="3810">3810</span>
<span id="3811">3811</span>
<span id="3812">3812</span>
<span id="3813">3813</span>
<span id="3814">3814</span>
<span id="3815">3815</span>
<span id="3816">3816</span>
<span id="3817">3817</span>
<span id="3818">3818</span>
<span id="3819">3819</span>
<span id="3820">3820</span>
<span id="3821">3821</span>
<span id="3822">3822</span>
<span id="3823">3823</span>
<span id="3824">3824</span>
<span id="3825">3825</span>
<span id="3826">3826</span>
<span id="3827">3827</span>
<span id="3828">3828</span>
<span id="3829">3829</span>
<span id="3830">3830</span>
<span id="3831">3831</span>
<span id="3832">3832</span>
<span id="3833">3833</span>
<span id="3834">3834</span>
<span id="3835">3835</span>
<span id="3836">3836</span>
<span id="3837">3837</span>
<span id="3838">3838</span>
<span id="3839">3839</span>
<span id="3840">3840</span>
<span id="3841">3841</span>
<span id="3842">3842</span>
<span id="3843">3843</span>
<span id="3844">3844</span>
<span id="3845">3845</span>
<span id="3846">3846</span>
<span id="3847">3847</span>
<span id="3848">3848</span>
<span id="3849">3849</span>
<span id="3850">3850</span>
<span id="3851">3851</span>
<span id="3852">3852</span>
<span id="3853">3853</span>
<span id="3854">3854</span>
<span id="3855">3855</span>
<span id="3856">3856</span>
<span id="3857">3857</span>
<span id="3858">3858</span>
<span id="3859">3859</span>
<span id="3860">3860</span>
<span id="3861">3861</span>
<span id="3862">3862</span>
<span id="3863">3863</span>
<span id="3864">3864</span>
<span id="3865">3865</span>
<span id="3866">3866</span>
<span id="3867">3867</span>
<span id="3868">3868</span>
<span id="3869">3869</span>
<span id="3870">3870</span>
<span id="3871">3871</span>
<span id="3872">3872</span>
<span id="3873">3873</span>
<span id="3874">3874</span>
<span id="3875">3875</span>
<span id="3876">3876</span>
<span id="3877">3877</span>
<span id="3878">3878</span>
<span id="3879">3879</span>
<span id="3880">3880</span>
<span id="3881">3881</span>
<span id="3882">3882</span>
<span id="3883">3883</span>
<span id="3884">3884</span>
<span id="3885">3885</span>
<span id="3886">3886</span>
<span id="3887">3887</span>
<span id="3888">3888</span>
<span id="3889">3889</span>
<span id="3890">3890</span>
<span id="3891">3891</span>
<span id="3892">3892</span>
<span id="3893">3893</span>
<span id="3894">3894</span>
<span id="3895">3895</span>
<span id="3896">3896</span>
<span id="3897">3897</span>
<span id="3898">3898</span>
<span id="3899">3899</span>
<span id="3900">3900</span>
<span id="3901">3901</span>
<span id="3902">3902</span>
<span id="3903">3903</span>
<span id="3904">3904</span>
<span id="3905">3905</span>
<span id="3906">3906</span>
<span id="3907">3907</span>
<span id="3908">3908</span>
<span id="3909">3909</span>
<span id="3910">3910</span>
<span id="3911">3911</span>
<span id="3912">3912</span>
<span id="3913">3913</span>
<span id="3914">3914</span>
<span id="3915">3915</span>
<span id="3916">3916</span>
<span id="3917">3917</span>
<span id="3918">3918</span>
<span id="3919">3919</span>
<span id="3920">3920</span>
<span id="3921">3921</span>
<span id="3922">3922</span>
<span id="3923">3923</span>
<span id="3924">3924</span>
<span id="3925">3925</span>
<span id="3926">3926</span>
<span id="3927">3927</span>
<span id="3928">3928</span>
<span id="3929">3929</span>
<span id="3930">3930</span>
<span id="3931">3931</span>
<span id="3932">3932</span>
<span id="3933">3933</span>
<span id="3934">3934</span>
<span id="3935">3935</span>
<span id="3936">3936</span>
<span id="3937">3937</span>
<span id="3938">3938</span>
<span id="3939">3939</span>
<span id="3940">3940</span>
<span id="3941">3941</span>
<span id="3942">3942</span>
<span id="3943">3943</span>
<span id="3944">3944</span>
<span id="3945">3945</span>
<span id="3946">3946</span>
<span id="3947">3947</span>
<span id="3948">3948</span>
<span id="3949">3949</span>
<span id="3950">3950</span>
<span id="3951">3951</span>
<span id="3952">3952</span>
<span id="3953">3953</span>
<span id="3954">3954</span>
<span id="3955">3955</span>
<span id="3956">3956</span>
<span id="3957">3957</span>
<span id="3958">3958</span>
<span id="3959">3959</span>
<span id="3960">3960</span>
<span id="3961">3961</span>
<span id="3962">3962</span>
<span id="3963">3963</span>
<span id="3964">3964</span>
<span id="3965">3965</span>
<span id="3966">3966</span>
<span id="3967">3967</span>
<span id="3968">3968</span>
<span id="3969">3969</span>
<span id="3970">3970</span>
<span id="3971">3971</span>
<span id="3972">3972</span>
<span id="3973">3973</span>
<span id="3974">3974</span>
<span id="3975">3975</span>
<span id="3976">3976</span>
<span id="3977">3977</span>
<span id="3978">3978</span>
<span id="3979">3979</span>
<span id="3980">3980</span>
<span id="3981">3981</span>
<span id="3982">3982</span>
<span id="3983">3983</span>
<span id="3984">3984</span>
<span id="3985">3985</span>
<span id="3986">3986</span>
<span id="3987">3987</span>
<span id="3988">3988</span>
<span id="3989">3989</span>
<span id="3990">3990</span>
<span id="3991">3991</span>
<span id="3992">3992</span>
<span id="3993">3993</span>
<span id="3994">3994</span>
<span id="3995">3995</span>
<span id="3996">3996</span>
<span id="3997">3997</span>
<span id="3998">3998</span>
<span id="3999">3999</span>
<span id="4000">4000</span>
<span id="4001">4001</span>
<span id="4002">4002</span>
<span id="4003">4003</span>
<span id="4004">4004</span>
<span id="4005">4005</span>
<span id="4006">4006</span>
<span id="4007">4007</span>
<span id="4008">4008</span>
<span id="4009">4009</span>
<span id="4010">4010</span>
<span id="4011">4011</span>
<span id="4012">4012</span>
<span id="4013">4013</span>
<span id="4014">4014</span>
<span id="4015">4015</span>
<span id="4016">4016</span>
<span id="4017">4017</span>
<span id="4018">4018</span>
<span id="4019">4019</span>
<span id="4020">4020</span>
<span id="4021">4021</span>
<span id="4022">4022</span>
<span id="4023">4023</span>
<span id="4024">4024</span>
<span id="4025">4025</span>
<span id="4026">4026</span>
<span id="4027">4027</span>
<span id="4028">4028</span>
<span id="4029">4029</span>
<span id="4030">4030</span>
<span id="4031">4031</span>
<span id="4032">4032</span>
<span id="4033">4033</span>
<span id="4034">4034</span>
<span id="4035">4035</span>
<span id="4036">4036</span>
<span id="4037">4037</span>
<span id="4038">4038</span>
<span id="4039">4039</span>
<span id="4040">4040</span>
<span id="4041">4041</span>
<span id="4042">4042</span>
<span id="4043">4043</span>
<span id="4044">4044</span>
<span id="4045">4045</span>
<span id="4046">4046</span>
<span id="4047">4047</span>
<span id="4048">4048</span>
<span id="4049">4049</span>
<span id="4050">4050</span>
<span id="4051">4051</span>
<span id="4052">4052</span>
<span id="4053">4053</span>
<span id="4054">4054</span>
<span id="4055">4055</span>
<span id="4056">4056</span>
<span id="4057">4057</span>
<span id="4058">4058</span>
<span id="4059">4059</span>
<span id="4060">4060</span>
<span id="4061">4061</span>
<span id="4062">4062</span>
<span id="4063">4063</span>
<span id="4064">4064</span>
<span id="4065">4065</span>
<span id="4066">4066</span>
<span id="4067">4067</span>
<span id="4068">4068</span>
<span id="4069">4069</span>
<span id="4070">4070</span>
<span id="4071">4071</span>
<span id="4072">4072</span>
<span id="4073">4073</span>
<span id="4074">4074</span>
<span id="4075">4075</span>
<span id="4076">4076</span>
<span id="4077">4077</span>
<span id="4078">4078</span>
<span id="4079">4079</span>
<span id="4080">4080</span>
<span id="4081">4081</span>
<span id="4082">4082</span>
<span id="4083">4083</span>
<span id="4084">4084</span>
<span id="4085">4085</span>
<span id="4086">4086</span>
<span id="4087">4087</span>
<span id="4088">4088</span>
<span id="4089">4089</span>
<span id="4090">4090</span>
<span id="4091">4091</span>
<span id="4092">4092</span>
<span id="4093">4093</span>
<span id="4094">4094</span>
<span id="4095">4095</span>
<span id="4096">4096</span>
<span id="4097">4097</span>
<span id="4098">4098</span>
<span id="4099">4099</span>
<span id="4100">4100</span>
<span id="4101">4101</span>
<span id="4102">4102</span>
<span id="4103">4103</span>
<span id="4104">4104</span>
<span id="4105">4105</span>
<span id="4106">4106</span>
<span id="4107">4107</span>
<span id="4108">4108</span>
<span id="4109">4109</span>
<span id="4110">4110</span>
<span id="4111">4111</span>
<span id="4112">4112</span>
<span id="4113">4113</span>
<span id="4114">4114</span>
<span id="4115">4115</span>
<span id="4116">4116</span>
<span id="4117">4117</span>
<span id="4118">4118</span>
<span id="4119">4119</span>
<span id="4120">4120</span>
<span id="4121">4121</span>
<span id="4122">4122</span>
<span id="4123">4123</span>
<span id="4124">4124</span>
<span id="4125">4125</span>
<span id="4126">4126</span>
<span id="4127">4127</span>
<span id="4128">4128</span>
<span id="4129">4129</span>
<span id="4130">4130</span>
<span id="4131">4131</span>
<span id="4132">4132</span>
<span id="4133">4133</span>
<span id="4134">4134</span>
<span id="4135">4135</span>
<span id="4136">4136</span>
<span id="4137">4137</span>
<span id="4138">4138</span>
<span id="4139">4139</span>
<span id="4140">4140</span>
<span id="4141">4141</span>
<span id="4142">4142</span>
<span id="4143">4143</span>
<span id="4144">4144</span>
<span id="4145">4145</span>
<span id="4146">4146</span>
<span id="4147">4147</span>
<span id="4148">4148</span>
<span id="4149">4149</span>
<span id="4150">4150</span>
<span id="4151">4151</span>
<span id="4152">4152</span>
<span id="4153">4153</span>
<span id="4154">4154</span>
<span id="4155">4155</span>
<span id="4156">4156</span>
<span id="4157">4157</span>
<span id="4158">4158</span>
<span id="4159">4159</span>
<span id="4160">4160</span>
<span id="4161">4161</span>
<span id="4162">4162</span>
<span id="4163">4163</span>
<span id="4164">4164</span>
<span id="4165">4165</span>
<span id="4166">4166</span>
<span id="4167">4167</span>
<span id="4168">4168</span>
<span id="4169">4169</span>
<span id="4170">4170</span>
<span id="4171">4171</span>
<span id="4172">4172</span>
<span id="4173">4173</span>
<span id="4174">4174</span>
<span id="4175">4175</span>
<span id="4176">4176</span>
<span id="4177">4177</span>
<span id="4178">4178</span>
<span id="4179">4179</span>
<span id="4180">4180</span>
<span id="4181">4181</span>
<span id="4182">4182</span>
<span id="4183">4183</span>
<span id="4184">4184</span>
<span id="4185">4185</span>
<span id="4186">4186</span>
<span id="4187">4187</span>
<span id="4188">4188</span>
<span id="4189">4189</span>
<span id="4190">4190</span>
<span id="4191">4191</span>
<span id="4192">4192</span>
<span id="4193">4193</span>
<span id="4194">4194</span>
<span id="4195">4195</span>
<span id="4196">4196</span>
<span id="4197">4197</span>
<span id="4198">4198</span>
<span id="4199">4199</span>
<span id="4200">4200</span>
<span id="4201">4201</span>
<span id="4202">4202</span>
<span id="4203">4203</span>
<span id="4204">4204</span>
<span id="4205">4205</span>
<span id="4206">4206</span>
<span id="4207">4207</span>
<span id="4208">4208</span>
<span id="4209">4209</span>
<span id="4210">4210</span>
<span id="4211">4211</span>
<span id="4212">4212</span>
<span id="4213">4213</span>
<span id="4214">4214</span>
<span id="4215">4215</span>
<span id="4216">4216</span>
<span id="4217">4217</span>
<span id="4218">4218</span>
<span id="4219">4219</span>
<span id="4220">4220</span>
<span id="4221">4221</span>
<span id="4222">4222</span>
<span id="4223">4223</span>
<span id="4224">4224</span>
<span id="4225">4225</span>
<span id="4226">4226</span>
<span id="4227">4227</span>
<span id="4228">4228</span>
<span id="4229">4229</span>
<span id="4230">4230</span>
<span id="4231">4231</span>
<span id="4232">4232</span>
<span id="4233">4233</span>
<span id="4234">4234</span>
<span id="4235">4235</span>
<span id="4236">4236</span>
<span id="4237">4237</span>
<span id="4238">4238</span>
<span id="4239">4239</span>
<span id="4240">4240</span>
<span id="4241">4241</span>
<span id="4242">4242</span>
<span id="4243">4243</span>
<span id="4244">4244</span>
<span id="4245">4245</span>
<span id="4246">4246</span>
<span id="4247">4247</span>
<span id="4248">4248</span>
<span id="4249">4249</span>
<span id="4250">4250</span>
<span id="4251">4251</span>
<span id="4252">4252</span>
<span id="4253">4253</span>
<span id="4254">4254</span>
<span id="4255">4255</span>
<span id="4256">4256</span>
<span id="4257">4257</span>
<span id="4258">4258</span>
<span id="4259">4259</span>
<span id="4260">4260</span>
<span id="4261">4261</span>
<span id="4262">4262</span>
<span id="4263">4263</span>
<span id="4264">4264</span>
<span id="4265">4265</span>
<span id="4266">4266</span>
<span id="4267">4267</span>
<span id="4268">4268</span>
<span id="4269">4269</span>
<span id="4270">4270</span>
<span id="4271">4271</span>
<span id="4272">4272</span>
<span id="4273">4273</span>
<span id="4274">4274</span>
<span id="4275">4275</span>
<span id="4276">4276</span>
<span id="4277">4277</span>
<span id="4278">4278</span>
<span id="4279">4279</span>
<span id="4280">4280</span>
<span id="4281">4281</span>
<span id="4282">4282</span>
<span id="4283">4283</span>
<span id="4284">4284</span>
<span id="4285">4285</span>
<span id="4286">4286</span>
<span id="4287">4287</span>
<span id="4288">4288</span>
<span id="4289">4289</span>
<span id="4290">4290</span>
<span id="4291">4291</span>
<span id="4292">4292</span>
<span id="4293">4293</span>
<span id="4294">4294</span>
<span id="4295">4295</span>
<span id="4296">4296</span>
<span id="4297">4297</span>
<span id="4298">4298</span>
<span id="4299">4299</span>
<span id="4300">4300</span>
<span id="4301">4301</span>
<span id="4302">4302</span>
<span id="4303">4303</span>
<span id="4304">4304</span>
<span id="4305">4305</span>
<span id="4306">4306</span>
<span id="4307">4307</span>
<span id="4308">4308</span>
<span id="4309">4309</span>
<span id="4310">4310</span>
<span id="4311">4311</span>
<span id="4312">4312</span>
<span id="4313">4313</span>
<span id="4314">4314</span>
<span id="4315">4315</span>
<span id="4316">4316</span>
<span id="4317">4317</span>
<span id="4318">4318</span>
<span id="4319">4319</span>
<span id="4320">4320</span>
<span id="4321">4321</span>
<span id="4322">4322</span>
<span id="4323">4323</span>
<span id="4324">4324</span>
<span id="4325">4325</span>
<span id="4326">4326</span>
<span id="4327">4327</span>
<span id="4328">4328</span>
<span id="4329">4329</span>
<span id="4330">4330</span>
<span id="4331">4331</span>
<span id="4332">4332</span>
<span id="4333">4333</span>
<span id="4334">4334</span>
<span id="4335">4335</span>
<span id="4336">4336</span>
<span id="4337">4337</span>
<span id="4338">4338</span>
<span id="4339">4339</span>
<span id="4340">4340</span>
<span id="4341">4341</span>
<span id="4342">4342</span>
<span id="4343">4343</span>
<span id="4344">4344</span>
<span id="4345">4345</span>
<span id="4346">4346</span>
<span id="4347">4347</span>
<span id="4348">4348</span>
<span id="4349">4349</span>
<span id="4350">4350</span>
<span id="4351">4351</span>
<span id="4352">4352</span>
<span id="4353">4353</span>
<span id="4354">4354</span>
<span id="4355">4355</span>
<span id="4356">4356</span>
<span id="4357">4357</span>
<span id="4358">4358</span>
<span id="4359">4359</span>
<span id="4360">4360</span>
<span id="4361">4361</span>
<span id="4362">4362</span>
<span id="4363">4363</span>
<span id="4364">4364</span>
<span id="4365">4365</span>
<span id="4366">4366</span>
<span id="4367">4367</span>
<span id="4368">4368</span>
<span id="4369">4369</span>
<span id="4370">4370</span>
<span id="4371">4371</span>
<span id="4372">4372</span>
<span id="4373">4373</span>
<span id="4374">4374</span>
<span id="4375">4375</span>
<span id="4376">4376</span>
<span id="4377">4377</span>
<span id="4378">4378</span>
<span id="4379">4379</span>
<span id="4380">4380</span>
<span id="4381">4381</span>
<span id="4382">4382</span>
<span id="4383">4383</span>
<span id="4384">4384</span>
<span id="4385">4385</span>
<span id="4386">4386</span>
<span id="4387">4387</span>
<span id="4388">4388</span>
<span id="4389">4389</span>
<span id="4390">4390</span>
<span id="4391">4391</span>
<span id="4392">4392</span>
<span id="4393">4393</span>
<span id="4394">4394</span>
<span id="4395">4395</span>
<span id="4396">4396</span>
<span id="4397">4397</span>
<span id="4398">4398</span>
<span id="4399">4399</span>
<span id="4400">4400</span>
<span id="4401">4401</span>
<span id="4402">4402</span>
<span id="4403">4403</span>
<span id="4404">4404</span>
<span id="4405">4405</span>
<span id="4406">4406</span>
<span id="4407">4407</span>
<span id="4408">4408</span>
<span id="4409">4409</span>
<span id="4410">4410</span>
<span id="4411">4411</span>
<span id="4412">4412</span>
<span id="4413">4413</span>
<span id="4414">4414</span>
<span id="4415">4415</span>
<span id="4416">4416</span>
<span id="4417">4417</span>
<span id="4418">4418</span>
<span id="4419">4419</span>
<span id="4420">4420</span>
<span id="4421">4421</span>
<span id="4422">4422</span>
<span id="4423">4423</span>
<span id="4424">4424</span>
<span id="4425">4425</span>
<span id="4426">4426</span>
<span id="4427">4427</span>
<span id="4428">4428</span>
<span id="4429">4429</span>
<span id="4430">4430</span>
<span id="4431">4431</span>
<span id="4432">4432</span>
<span id="4433">4433</span>
<span id="4434">4434</span>
<span id="4435">4435</span>
<span id="4436">4436</span>
<span id="4437">4437</span>
<span id="4438">4438</span>
<span id="4439">4439</span>
<span id="4440">4440</span>
<span id="4441">4441</span>
<span id="4442">4442</span>
<span id="4443">4443</span>
<span id="4444">4444</span>
<span id="4445">4445</span>
<span id="4446">4446</span>
<span id="4447">4447</span>
<span id="4448">4448</span>
<span id="4449">4449</span>
<span id="4450">4450</span>
<span id="4451">4451</span>
<span id="4452">4452</span>
<span id="4453">4453</span>
<span id="4454">4454</span>
<span id="4455">4455</span>
<span id="4456">4456</span>
<span id="4457">4457</span>
<span id="4458">4458</span>
<span id="4459">4459</span>
<span id="4460">4460</span>
<span id="4461">4461</span>
<span id="4462">4462</span>
<span id="4463">4463</span>
<span id="4464">4464</span>
<span id="4465">4465</span>
<span id="4466">4466</span>
<span id="4467">4467</span>
<span id="4468">4468</span>
<span id="4469">4469</span>
<span id="4470">4470</span>
<span id="4471">4471</span>
<span id="4472">4472</span>
<span id="4473">4473</span>
<span id="4474">4474</span>
<span id="4475">4475</span>
<span id="4476">4476</span>
<span id="4477">4477</span>
<span id="4478">4478</span>
<span id="4479">4479</span>
<span id="4480">4480</span>
<span id="4481">4481</span>
<span id="4482">4482</span>
<span id="4483">4483</span>
<span id="4484">4484</span>
<span id="4485">4485</span>
<span id="4486">4486</span>
<span id="4487">4487</span>
<span id="4488">4488</span>
<span id="4489">4489</span>
<span id="4490">4490</span>
<span id="4491">4491</span>
<span id="4492">4492</span>
<span id="4493">4493</span>
<span id="4494">4494</span>
<span id="4495">4495</span>
<span id="4496">4496</span>
<span id="4497">4497</span>
<span id="4498">4498</span>
<span id="4499">4499</span>
<span id="4500">4500</span>
<span id="4501">4501</span>
<span id="4502">4502</span>
<span id="4503">4503</span>
<span id="4504">4504</span>
<span id="4505">4505</span>
<span id="4506">4506</span>
<span id="4507">4507</span>
<span id="4508">4508</span>
<span id="4509">4509</span>
<span id="4510">4510</span>
<span id="4511">4511</span>
<span id="4512">4512</span>
<span id="4513">4513</span>
<span id="4514">4514</span>
<span id="4515">4515</span>
<span id="4516">4516</span>
<span id="4517">4517</span>
<span id="4518">4518</span>
<span id="4519">4519</span>
<span id="4520">4520</span>
<span id="4521">4521</span>
<span id="4522">4522</span>
<span id="4523">4523</span>
<span id="4524">4524</span>
<span id="4525">4525</span>
<span id="4526">4526</span>
<span id="4527">4527</span>
<span id="4528">4528</span>
<span id="4529">4529</span>
<span id="4530">4530</span>
<span id="4531">4531</span>
<span id="4532">4532</span>
<span id="4533">4533</span>
<span id="4534">4534</span>
<span id="4535">4535</span>
<span id="4536">4536</span>
<span id="4537">4537</span>
<span id="4538">4538</span>
<span id="4539">4539</span>
<span id="4540">4540</span>
<span id="4541">4541</span>
<span id="4542">4542</span>
<span id="4543">4543</span>
<span id="4544">4544</span>
<span id="4545">4545</span>
<span id="4546">4546</span>
<span id="4547">4547</span>
<span id="4548">4548</span>
<span id="4549">4549</span>
<span id="4550">4550</span>
<span id="4551">4551</span>
<span id="4552">4552</span>
<span id="4553">4553</span>
<span id="4554">4554</span>
<span id="4555">4555</span>
<span id="4556">4556</span>
<span id="4557">4557</span>
<span id="4558">4558</span>
<span id="4559">4559</span>
<span id="4560">4560</span>
<span id="4561">4561</span>
<span id="4562">4562</span>
<span id="4563">4563</span>
<span id="4564">4564</span>
<span id="4565">4565</span>
<span id="4566">4566</span>
<span id="4567">4567</span>
<span id="4568">4568</span>
<span id="4569">4569</span>
<span id="4570">4570</span>
<span id="4571">4571</span>
<span id="4572">4572</span>
<span id="4573">4573</span>
<span id="4574">4574</span>
<span id="4575">4575</span>
<span id="4576">4576</span>
<span id="4577">4577</span>
<span id="4578">4578</span>
<span id="4579">4579</span>
<span id="4580">4580</span>
<span id="4581">4581</span>
<span id="4582">4582</span>
<span id="4583">4583</span>
<span id="4584">4584</span>
<span id="4585">4585</span>
<span id="4586">4586</span>
<span id="4587">4587</span>
<span id="4588">4588</span>
<span id="4589">4589</span>
<span id="4590">4590</span>
<span id="4591">4591</span>
<span id="4592">4592</span>
<span id="4593">4593</span>
<span id="4594">4594</span>
<span id="4595">4595</span>
<span id="4596">4596</span>
<span id="4597">4597</span>
<span id="4598">4598</span>
<span id="4599">4599</span>
<span id="4600">4600</span>
<span id="4601">4601</span>
<span id="4602">4602</span>
<span id="4603">4603</span>
<span id="4604">4604</span>
<span id="4605">4605</span>
<span id="4606">4606</span>
<span id="4607">4607</span>
<span id="4608">4608</span>
<span id="4609">4609</span>
<span id="4610">4610</span>
<span id="4611">4611</span>
<span id="4612">4612</span>
<span id="4613">4613</span>
<span id="4614">4614</span>
<span id="4615">4615</span>
<span id="4616">4616</span>
<span id="4617">4617</span>
<span id="4618">4618</span>
<span id="4619">4619</span>
<span id="4620">4620</span>
<span id="4621">4621</span>
<span id="4622">4622</span>
<span id="4623">4623</span>
<span id="4624">4624</span>
<span id="4625">4625</span>
<span id="4626">4626</span>
<span id="4627">4627</span>
<span id="4628">4628</span>
<span id="4629">4629</span>
<span id="4630">4630</span>
<span id="4631">4631</span>
<span id="4632">4632</span>
<span id="4633">4633</span>
<span id="4634">4634</span>
<span id="4635">4635</span>
<span id="4636">4636</span>
<span id="4637">4637</span>
<span id="4638">4638</span>
<span id="4639">4639</span>
<span id="4640">4640</span>
<span id="4641">4641</span>
<span id="4642">4642</span>
<span id="4643">4643</span>
<span id="4644">4644</span>
<span id="4645">4645</span>
<span id="4646">4646</span>
<span id="4647">4647</span>
<span id="4648">4648</span>
<span id="4649">4649</span>
<span id="4650">4650</span>
<span id="4651">4651</span>
<span id="4652">4652</span>
<span id="4653">4653</span>
<span id="4654">4654</span>
<span id="4655">4655</span>
<span id="4656">4656</span>
<span id="4657">4657</span>
<span id="4658">4658</span>
<span id="4659">4659</span>
<span id="4660">4660</span>
<span id="4661">4661</span>
<span id="4662">4662</span>
<span id="4663">4663</span>
<span id="4664">4664</span>
<span id="4665">4665</span>
<span id="4666">4666</span>
<span id="4667">4667</span>
<span id="4668">4668</span>
<span id="4669">4669</span>
<span id="4670">4670</span>
<span id="4671">4671</span>
<span id="4672">4672</span>
<span id="4673">4673</span>
<span id="4674">4674</span>
<span id="4675">4675</span>
<span id="4676">4676</span>
<span id="4677">4677</span>
<span id="4678">4678</span>
<span id="4679">4679</span>
<span id="4680">4680</span>
<span id="4681">4681</span>
<span id="4682">4682</span>
<span id="4683">4683</span>
<span id="4684">4684</span>
<span id="4685">4685</span>
<span id="4686">4686</span>
<span id="4687">4687</span>
<span id="4688">4688</span>
<span id="4689">4689</span>
<span id="4690">4690</span>
<span id="4691">4691</span>
<span id="4692">4692</span>
<span id="4693">4693</span>
<span id="4694">4694</span>
<span id="4695">4695</span>
<span id="4696">4696</span>
<span id="4697">4697</span>
<span id="4698">4698</span>
<span id="4699">4699</span>
<span id="4700">4700</span>
<span id="4701">4701</span>
<span id="4702">4702</span>
<span id="4703">4703</span>
<span id="4704">4704</span>
<span id="4705">4705</span>
<span id="4706">4706</span>
<span id="4707">4707</span>
<span id="4708">4708</span>
<span id="4709">4709</span>
<span id="4710">4710</span>
<span id="4711">4711</span>
<span id="4712">4712</span>
<span id="4713">4713</span>
<span id="4714">4714</span>
<span id="4715">4715</span>
<span id="4716">4716</span>
<span id="4717">4717</span>
<span id="4718">4718</span>
<span id="4719">4719</span>
<span id="4720">4720</span>
<span id="4721">4721</span>
<span id="4722">4722</span>
<span id="4723">4723</span>
<span id="4724">4724</span>
<span id="4725">4725</span>
<span id="4726">4726</span>
<span id="4727">4727</span>
<span id="4728">4728</span>
<span id="4729">4729</span>
<span id="4730">4730</span>
<span id="4731">4731</span>
<span id="4732">4732</span>
<span id="4733">4733</span>
<span id="4734">4734</span>
<span id="4735">4735</span>
<span id="4736">4736</span>
<span id="4737">4737</span>
<span id="4738">4738</span>
<span id="4739">4739</span>
<span id="4740">4740</span>
<span id="4741">4741</span>
<span id="4742">4742</span>
<span id="4743">4743</span>
<span id="4744">4744</span>
<span id="4745">4745</span>
<span id="4746">4746</span>
<span id="4747">4747</span>
<span id="4748">4748</span>
<span id="4749">4749</span>
<span id="4750">4750</span>
<span id="4751">4751</span>
<span id="4752">4752</span>
<span id="4753">4753</span>
<span id="4754">4754</span>
<span id="4755">4755</span>
<span id="4756">4756</span>
<span id="4757">4757</span>
<span id="4758">4758</span>
<span id="4759">4759</span>
<span id="4760">4760</span>
<span id="4761">4761</span>
<span id="4762">4762</span>
<span id="4763">4763</span>
<span id="4764">4764</span>
<span id="4765">4765</span>
<span id="4766">4766</span>
<span id="4767">4767</span>
<span id="4768">4768</span>
<span id="4769">4769</span>
<span id="4770">4770</span>
<span id="4771">4771</span>
<span id="4772">4772</span>
<span id="4773">4773</span>
<span id="4774">4774</span>
<span id="4775">4775</span>
<span id="4776">4776</span>
<span id="4777">4777</span>
<span id="4778">4778</span>
<span id="4779">4779</span>
<span id="4780">4780</span>
<span id="4781">4781</span>
<span id="4782">4782</span>
<span id="4783">4783</span>
<span id="4784">4784</span>
<span id="4785">4785</span>
<span id="4786">4786</span>
<span id="4787">4787</span>
<span id="4788">4788</span>
<span id="4789">4789</span>
<span id="4790">4790</span>
<span id="4791">4791</span>
<span id="4792">4792</span>
<span id="4793">4793</span>
<span id="4794">4794</span>
<span id="4795">4795</span>
<span id="4796">4796</span>
<span id="4797">4797</span>
<span id="4798">4798</span>
<span id="4799">4799</span>
<span id="4800">4800</span>
<span id="4801">4801</span>
<span id="4802">4802</span>
<span id="4803">4803</span>
<span id="4804">4804</span>
<span id="4805">4805</span>
<span id="4806">4806</span>
<span id="4807">4807</span>
<span id="4808">4808</span>
<span id="4809">4809</span>
<span id="4810">4810</span>
<span id="4811">4811</span>
<span id="4812">4812</span>
<span id="4813">4813</span>
<span id="4814">4814</span>
<span id="4815">4815</span>
<span id="4816">4816</span>
<span id="4817">4817</span>
<span id="4818">4818</span>
<span id="4819">4819</span>
<span id="4820">4820</span>
<span id="4821">4821</span>
<span id="4822">4822</span>
<span id="4823">4823</span>
<span id="4824">4824</span>
<span id="4825">4825</span>
<span id="4826">4826</span>
<span id="4827">4827</span>
<span id="4828">4828</span>
<span id="4829">4829</span>
<span id="4830">4830</span>
<span id="4831">4831</span>
<span id="4832">4832</span>
<span id="4833">4833</span>
<span id="4834">4834</span>
<span id="4835">4835</span>
<span id="4836">4836</span>
<span id="4837">4837</span>
<span id="4838">4838</span>
<span id="4839">4839</span>
<span id="4840">4840</span>
<span id="4841">4841</span>
<span id="4842">4842</span>
<span id="4843">4843</span>
<span id="4844">4844</span>
<span id="4845">4845</span>
<span id="4846">4846</span>
<span id="4847">4847</span>
<span id="4848">4848</span>
<span id="4849">4849</span>
<span id="4850">4850</span>
<span id="4851">4851</span>
<span id="4852">4852</span>
<span id="4853">4853</span>
<span id="4854">4854</span>
<span id="4855">4855</span>
<span id="4856">4856</span>
<span id="4857">4857</span>
<span id="4858">4858</span>
<span id="4859">4859</span>
<span id="4860">4860</span>
<span id="4861">4861</span>
<span id="4862">4862</span>
<span id="4863">4863</span>
<span id="4864">4864</span>
<span id="4865">4865</span>
<span id="4866">4866</span>
<span id="4867">4867</span>
<span id="4868">4868</span>
<span id="4869">4869</span>
<span id="4870">4870</span>
<span id="4871">4871</span>
<span id="4872">4872</span>
<span id="4873">4873</span>
<span id="4874">4874</span>
<span id="4875">4875</span>
<span id="4876">4876</span>
<span id="4877">4877</span>
<span id="4878">4878</span>
<span id="4879">4879</span>
<span id="4880">4880</span>
<span id="4881">4881</span>
<span id="4882">4882</span>
<span id="4883">4883</span>
<span id="4884">4884</span>
<span id="4885">4885</span>
<span id="4886">4886</span>
<span id="4887">4887</span>
<span id="4888">4888</span>
<span id="4889">4889</span>
<span id="4890">4890</span>
<span id="4891">4891</span>
<span id="4892">4892</span>
<span id="4893">4893</span>
<span id="4894">4894</span>
<span id="4895">4895</span>
<span id="4896">4896</span>
<span id="4897">4897</span>
<span id="4898">4898</span>
<span id="4899">4899</span>
<span id="4900">4900</span>
<span id="4901">4901</span>
<span id="4902">4902</span>
<span id="4903">4903</span>
<span id="4904">4904</span>
<span id="4905">4905</span>
<span id="4906">4906</span>
<span id="4907">4907</span>
<span id="4908">4908</span>
<span id="4909">4909</span>
<span id="4910">4910</span>
<span id="4911">4911</span>
<span id="4912">4912</span>
<span id="4913">4913</span>
<span id="4914">4914</span>
<span id="4915">4915</span>
<span id="4916">4916</span>
<span id="4917">4917</span>
<span id="4918">4918</span>
<span id="4919">4919</span>
<span id="4920">4920</span>
<span id="4921">4921</span>
<span id="4922">4922</span>
<span id="4923">4923</span>
<span id="4924">4924</span>
<span id="4925">4925</span>
<span id="4926">4926</span>
<span id="4927">4927</span>
<span id="4928">4928</span>
<span id="4929">4929</span>
<span id="4930">4930</span>
<span id="4931">4931</span>
<span id="4932">4932</span>
<span id="4933">4933</span>
<span id="4934">4934</span>
<span id="4935">4935</span>
<span id="4936">4936</span>
<span id="4937">4937</span>
<span id="4938">4938</span>
<span id="4939">4939</span>
<span id="4940">4940</span>
<span id="4941">4941</span>
<span id="4942">4942</span>
<span id="4943">4943</span>
<span id="4944">4944</span>
<span id="4945">4945</span>
<span id="4946">4946</span>
<span id="4947">4947</span>
<span id="4948">4948</span>
<span id="4949">4949</span>
<span id="4950">4950</span>
<span id="4951">4951</span>
<span id="4952">4952</span>
<span id="4953">4953</span>
<span id="4954">4954</span>
<span id="4955">4955</span>
<span id="4956">4956</span>
<span id="4957">4957</span>
<span id="4958">4958</span>
<span id="4959">4959</span>
<span id="4960">4960</span>
<span id="4961">4961</span>
<span id="4962">4962</span>
<span id="4963">4963</span>
<span id="4964">4964</span>
<span id="4965">4965</span>
<span id="4966">4966</span>
<span id="4967">4967</span>
<span id="4968">4968</span>
<span id="4969">4969</span>
<span id="4970">4970</span>
<span id="4971">4971</span>
<span id="4972">4972</span>
<span id="4973">4973</span>
<span id="4974">4974</span>
<span id="4975">4975</span>
<span id="4976">4976</span>
<span id="4977">4977</span>
<span id="4978">4978</span>
<span id="4979">4979</span>
<span id="4980">4980</span>
<span id="4981">4981</span>
<span id="4982">4982</span>
<span id="4983">4983</span>
<span id="4984">4984</span>
<span id="4985">4985</span>
<span id="4986">4986</span>
<span id="4987">4987</span>
<span id="4988">4988</span>
<span id="4989">4989</span>
<span id="4990">4990</span>
<span id="4991">4991</span>
<span id="4992">4992</span>
<span id="4993">4993</span>
<span id="4994">4994</span>
<span id="4995">4995</span>
<span id="4996">4996</span>
<span id="4997">4997</span>
<span id="4998">4998</span>
<span id="4999">4999</span>
<span id="5000">5000</span>
<span id="5001">5001</span>
<span id="5002">5002</span>
<span id="5003">5003</span>
<span id="5004">5004</span>
<span id="5005">5005</span>
<span id="5006">5006</span>
<span id="5007">5007</span>
<span id="5008">5008</span>
<span id="5009">5009</span>
<span id="5010">5010</span>
<span id="5011">5011</span>
<span id="5012">5012</span>
<span id="5013">5013</span>
<span id="5014">5014</span>
<span id="5015">5015</span>
<span id="5016">5016</span>
<span id="5017">5017</span>
<span id="5018">5018</span>
<span id="5019">5019</span>
<span id="5020">5020</span>
<span id="5021">5021</span>
<span id="5022">5022</span>
<span id="5023">5023</span>
<span id="5024">5024</span>
<span id="5025">5025</span>
<span id="5026">5026</span>
<span id="5027">5027</span>
<span id="5028">5028</span>
<span id="5029">5029</span>
<span id="5030">5030</span>
<span id="5031">5031</span>
<span id="5032">5032</span>
<span id="5033">5033</span>
<span id="5034">5034</span>
<span id="5035">5035</span>
<span id="5036">5036</span>
<span id="5037">5037</span>
<span id="5038">5038</span>
<span id="5039">5039</span>
<span id="5040">5040</span>
<span id="5041">5041</span>
<span id="5042">5042</span>
<span id="5043">5043</span>
<span id="5044">5044</span>
<span id="5045">5045</span>
<span id="5046">5046</span>
<span id="5047">5047</span>
<span id="5048">5048</span>
</pre><pre class="rust ">
<span class="comment">// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT</span>
<span class="comment">// file at the top-level directory of this distribution and at</span>
<span class="comment">// http://rust-lang.org/COPYRIGHT.</span>
<span class="comment">//</span>
<span class="comment">// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or</span>
<span class="comment">// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license</span>
<span class="comment">// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your</span>
<span class="comment">// option. This file may not be copied, modified, or distributed</span>
<span class="comment">// except according to those terms.</span>

<span class="comment">/*

# check.rs

Within the check phase of type check, we check each item one at a time
(bodies of function expressions are checked as part of the containing
function).  Inference is used to supply types wherever they are
unknown.

By far the most complex case is checking the body of a function. This
can be broken down into several distinct phases:

- gather: creates type variables to represent the type of each local
  variable and pattern binding.

- main: the main pass does the lion&#39;s share of the work: it
  determines the types of all expressions, resolves
  methods, checks for most invalid conditions, and so forth.  In
  some cases, where a type is unknown, it may create a type or region
  variable and use that as the type of an expression.

  In the process of checking, various constraints will be placed on
  these type variables through the subtyping relationships requested
  through the `demand` module.  The `infer` module is in charge
  of resolving those constraints.

- regionck: after main is complete, the regionck pass goes over all
  types looking for regions and making sure that they did not escape
  into places they are not in scope.  This may also influence the
  final assignments of the various region variables if there is some
  flexibility.

- vtable: find and records the impls to use for each trait bound that
  appears on a type parameter.

- writeback: writes the final types within a function body, replacing
  type variables with their final inferred types.  These final types
  are written into the `tcx.node_types` table, which should *never* contain
  any reference to a type variable.

## Intermediate types

While type checking a function, the intermediate types for the
expressions, blocks, and so forth contained within the function are
stored in `fcx.node_types` and `fcx.node_substs`.  These types
may contain unresolved type variables.  After type checking is
complete, the functions in the writeback module are used to take the
types from this table, resolve them, and then write them into their
permanent home in the type context `tcx`.

This means that during inferencing you should use `fcx.write_ty()`
and `fcx.expr_ty()` / `fcx.node_ty()` to write/obtain the types of
nodes within the function.

The types of top-level items, which never contain unbound type
variables, are stored directly into the `tcx` tables.

n.b.: A type variable is not the same thing as a type parameter.  A
type variable is rather an &quot;instance&quot; of a type parameter: that is,
given a generic function `fn foo&lt;T&gt;(t: T)`: while checking the
function `foo`, the type `ty_param(0)` refers to the type `T`, which
is treated in abstract.  When `foo()` is called, however, `T` will be
substituted for a fresh type variable `N`.  This variable will
eventually be resolved to some concrete type (which might itself be
type parameter).

*/</span>

<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">Expectation</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="self">self</span>::<span class="ident">autoderef</span>::<span class="ident">Autoderef</span>;
<span class="kw">use</span> <span class="self">self</span>::<span class="ident">callee</span>::<span class="ident">DeferredCallResolution</span>;
<span class="kw">use</span> <span class="self">self</span>::<span class="ident">coercion</span>::{<span class="ident">CoerceMany</span>, <span class="ident">DynamicCoerceMany</span>};
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">compare_method</span>::{<span class="ident">compare_impl_method</span>, <span class="ident">compare_const_impl</span>};
<span class="kw">use</span> <span class="self">self</span>::<span class="ident">method</span>::<span class="ident">MethodCallee</span>;
<span class="kw">use</span> <span class="self">self</span>::<span class="ident">TupleArgumentsFlag</span>::<span class="kw-2">*</span>;

<span class="kw">use</span> <span class="ident">astconv</span>::<span class="ident">AstConv</span>;
<span class="kw">use</span> <span class="ident">hir</span>::<span class="ident">def</span>::{<span class="ident">Def</span>, <span class="ident">CtorKind</span>};
<span class="kw">use</span> <span class="ident">hir</span>::<span class="ident">def_id</span>::{<span class="ident">CrateNum</span>, <span class="ident">DefId</span>, <span class="ident">LOCAL_CRATE</span>};
<span class="kw">use</span> <span class="ident">rustc_back</span>::<span class="ident">slice</span>::<span class="ident">ref_slice</span>;
<span class="kw">use</span> <span class="ident">namespace</span>::<span class="ident">Namespace</span>;
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">infer</span>::{<span class="self">self</span>, <span class="ident">InferCtxt</span>, <span class="ident">InferOk</span>, <span class="ident">RegionVariableOrigin</span>};
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">infer</span>::<span class="ident">type_variable</span>::{<span class="ident">TypeVariableOrigin</span>};
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">middle</span>::<span class="ident">region</span>;
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">ty</span>::<span class="ident">subst</span>::{<span class="ident">Kind</span>, <span class="ident">Subst</span>, <span class="ident">Substs</span>};
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">traits</span>::{<span class="self">self</span>, <span class="ident">FulfillmentContext</span>, <span class="ident">ObligationCause</span>, <span class="ident">ObligationCauseCode</span>};
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">ty</span>::{<span class="ident">ParamTy</span>, <span class="ident">LvaluePreference</span>, <span class="ident">NoPreference</span>, <span class="ident">PreferMutLvalue</span>};
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">ty</span>::{<span class="self">self</span>, <span class="ident">Ty</span>, <span class="ident">TyCtxt</span>, <span class="ident">Visibility</span>};
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">ty</span>::<span class="ident">adjustment</span>::{<span class="ident">Adjust</span>, <span class="ident">Adjustment</span>, <span class="ident">AutoBorrow</span>};
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">ty</span>::<span class="ident">fold</span>::{<span class="ident">BottomUpFolder</span>, <span class="ident">TypeFoldable</span>};
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">ty</span>::<span class="ident">maps</span>::<span class="ident">Providers</span>;
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">ty</span>::<span class="ident">util</span>::{<span class="ident">Representability</span>, <span class="ident">IntTypeExt</span>};
<span class="kw">use</span> <span class="ident">errors</span>::<span class="ident">DiagnosticBuilder</span>;
<span class="kw">use</span> <span class="ident">require_c_abi_if_variadic</span>;
<span class="kw">use</span> <span class="ident">session</span>::{<span class="ident">CompileIncomplete</span>, <span class="ident">Session</span>};
<span class="kw">use</span> <span class="ident">TypeAndSubsts</span>;
<span class="kw">use</span> <span class="ident">lint</span>;
<span class="kw">use</span> <span class="ident">util</span>::<span class="ident">common</span>::{<span class="ident">ErrorReported</span>, <span class="ident">indenter</span>};
<span class="kw">use</span> <span class="ident">util</span>::<span class="ident">nodemap</span>::{<span class="ident">DefIdMap</span>, <span class="ident">DefIdSet</span>, <span class="ident">FxHashMap</span>, <span class="ident">NodeMap</span>};

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cell</span>::{<span class="ident">Cell</span>, <span class="ident">RefCell</span>, <span class="ident">Ref</span>, <span class="ident">RefMut</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">rc</span>::<span class="ident">Rc</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">hash_map</span>::<span class="ident">Entry</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cmp</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fmt</span>::<span class="ident">Display</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">replace</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">ops</span>::{<span class="self">self</span>, <span class="ident">Deref</span>};
<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">abi</span>::<span class="ident">Abi</span>;
<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">ast</span>;
<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">codemap</span>::{<span class="self">self</span>, <span class="ident">original_sp</span>, <span class="ident">Spanned</span>};
<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">feature_gate</span>::{<span class="ident">GateIssue</span>, <span class="ident">emit_feature_err</span>};
<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">ptr</span>::<span class="ident">P</span>;
<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">symbol</span>::{<span class="ident">Symbol</span>, <span class="ident">InternedString</span>, <span class="ident">keywords</span>};
<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">util</span>::<span class="ident">lev_distance</span>::<span class="ident">find_best_match_for_name</span>;
<span class="kw">use</span> <span class="ident">syntax_pos</span>::{<span class="self">self</span>, <span class="ident">BytePos</span>, <span class="ident">Span</span>, <span class="ident">MultiSpan</span>};

<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">hir</span>::<span class="ident">intravisit</span>::{<span class="self">self</span>, <span class="ident">Visitor</span>, <span class="ident">NestedVisitorMap</span>};
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">hir</span>::<span class="ident">itemlikevisit</span>::<span class="ident">ItemLikeVisitor</span>;
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">hir</span>::<span class="ident">map</span>::<span class="ident">Node</span>;
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">hir</span>::{<span class="self">self</span>, <span class="ident">PatKind</span>};
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">middle</span>::<span class="ident">lang_items</span>;
<span class="kw">use</span> <span class="ident">rustc_back</span>::<span class="ident">slice</span>;
<span class="kw">use</span> <span class="ident">rustc_const_math</span>::<span class="ident">ConstInt</span>;

<span class="kw">mod</span> <span class="ident">autoderef</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">dropck</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">_match</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">writeback</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">regionck</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">coercion</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">demand</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">method</span>;
<span class="kw">mod</span> <span class="ident">upvar</span>;
<span class="kw">mod</span> <span class="ident">wfcheck</span>;
<span class="kw">mod</span> <span class="ident">cast</span>;
<span class="kw">mod</span> <span class="ident">closure</span>;
<span class="kw">mod</span> <span class="ident">callee</span>;
<span class="kw">mod</span> <span class="ident">compare_method</span>;
<span class="kw">mod</span> <span class="ident">generator_interior</span>;
<span class="kw">mod</span> <span class="ident">intrinsic</span>;
<span class="kw">mod</span> <span class="ident">op</span>;

<span class="doccomment">/// A wrapper for InferCtxt&#39;s `in_progress_tables` field.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">struct</span> <span class="ident">MaybeInProgressTables</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>: <span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">maybe_tables</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">ty</span>::<span class="ident">TypeckTables</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">MaybeInProgressTables</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">borrow</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Ref</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ty</span>::<span class="ident">TypeckTables</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span> {
        <span class="kw">match</span> <span class="self">self</span>.<span class="ident">maybe_tables</span> {
            <span class="prelude-val">Some</span>(<span class="ident">tables</span>) <span class="op">=&gt;</span> <span class="ident">tables</span>.<span class="ident">borrow</span>(),
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> {
                <span class="macro">bug</span><span class="macro">!</span>(<span class="string">&quot;MaybeInProgressTables: inh/fcx.tables.borrow() with no tables&quot;</span>)
            }
        }
    }

    <span class="kw">fn</span> <span class="ident">borrow_mut</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">RefMut</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ty</span>::<span class="ident">TypeckTables</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span> {
        <span class="kw">match</span> <span class="self">self</span>.<span class="ident">maybe_tables</span> {
            <span class="prelude-val">Some</span>(<span class="ident">tables</span>) <span class="op">=&gt;</span> <span class="ident">tables</span>.<span class="ident">borrow_mut</span>(),
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> {
                <span class="macro">bug</span><span class="macro">!</span>(<span class="string">&quot;MaybeInProgressTables: inh/fcx.tables.borrow_mut() with no tables&quot;</span>)
            }
        }
    }
}


<span class="doccomment">/// closures defined within the function.  For example:</span>
<span class="doccomment">///</span>
<span class="doccomment">///     fn foo() {</span>
<span class="doccomment">///         bar(move|| { ... })</span>
<span class="doccomment">///     }</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Here, the function `foo()` and the closure passed to</span>
<span class="doccomment">/// `bar()` will each have their own `FnCtxt`, but they will</span>
<span class="doccomment">/// share the inherited fields.</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Inherited</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>: <span class="lifetime">&#39;a</span><span class="op">+</span><span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span>: <span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">infcx</span>: <span class="ident">InferCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,

    <span class="ident">tables</span>: <span class="ident">MaybeInProgressTables</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,

    <span class="ident">locals</span>: <span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">NodeMap</span><span class="op">&lt;</span><span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span>,

    <span class="ident">fulfillment_cx</span>: <span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">traits</span>::<span class="ident">FulfillmentContext</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>,

    <span class="comment">// When we process a call like `c()` where `c` is a closure type,</span>
    <span class="comment">// we may not have decided yet whether `c` is a `Fn`, `FnMut`, or</span>
    <span class="comment">// `FnOnce` closure. In that case, we defer full resolution of the</span>
    <span class="comment">// call until upvar inference can kick in and make the</span>
    <span class="comment">// decision. We keep these deferred resolutions grouped by the</span>
    <span class="comment">// def-id of the closure, so that once we decide, we can easily go</span>
    <span class="comment">// back and process them.</span>
    <span class="ident">deferred_call_resolutions</span>: <span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">DefIdMap</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">DeferredCallResolution</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span><span class="op">&gt;&gt;</span>,

    <span class="ident">deferred_cast_checks</span>: <span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">cast</span>::<span class="ident">CastCheck</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span>,

    <span class="ident">deferred_generator_interiors</span>: <span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">hir</span>::<span class="ident">BodyId</span>, <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)<span class="op">&gt;&gt;</span>,

    <span class="comment">// Anonymized types found in explicit return types and their</span>
    <span class="comment">// associated fresh inference variable. Writeback resolves these</span>
    <span class="comment">// variables to get the concrete type, which can be used to</span>
    <span class="comment">// deanonymize TyAnon, after typeck is done with all functions.</span>
    <span class="ident">anon_types</span>: <span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">NodeMap</span><span class="op">&lt;</span><span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span>,

    <span class="doccomment">/// Each type parameter has an implicit region bound that</span>
    <span class="doccomment">/// indicates it must outlive at least the function body (the user</span>
    <span class="doccomment">/// may specify stronger requirements). This field indicates the</span>
    <span class="doccomment">/// region of the callee. If it is `None`, then the parameter</span>
    <span class="doccomment">/// environment is for an item or something where the &quot;callee&quot; is</span>
    <span class="doccomment">/// not clear.</span>
    <span class="ident">implicit_region_bound</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ty</span>::<span class="ident">Region</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>,

    <span class="ident">body_id</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">hir</span>::<span class="ident">BodyId</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">Deref</span> <span class="kw">for</span> <span class="ident">Inherited</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">type</span> <span class="ident">Target</span> <span class="op">=</span> <span class="ident">InferCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>;
    <span class="kw">fn</span> <span class="ident">deref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Target</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">infcx</span>
    }
}

<span class="doccomment">/// When type-checking an expression, we propagate downward</span>
<span class="doccomment">/// whatever type hint we are able in the form of an `Expectation`.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="doccomment">/// We know nothing about what type this expression should have.</span>
    <span class="ident">NoExpectation</span>,

    <span class="doccomment">/// This expression is an `if` condition, it must resolve to `bool`.</span>
    <span class="ident">ExpectIfCondition</span>,

    <span class="doccomment">/// This expression should have the type given (or some subtype)</span>
    <span class="ident">ExpectHasType</span>(<span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>),

    <span class="doccomment">/// This expression will be cast to the `Ty`</span>
    <span class="ident">ExpectCastableToType</span>(<span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>),

    <span class="doccomment">/// This rvalue expression will be wrapped in `&amp;` or `Box` and coerced</span>
    <span class="doccomment">/// to `&amp;Ty` or `Box&lt;Ty&gt;`, respectively. `Ty` is `[A]` or `Trait`.</span>
    <span class="ident">ExpectRvalueLikeUnsized</span>(<span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>),
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="comment">// Disregard &quot;castable to&quot; expectations because they</span>
    <span class="comment">// can lead us astray. Consider for example `if cond</span>
    <span class="comment">// {22} else {c} as u8` -- if we propagate the</span>
    <span class="comment">// &quot;castable to u8&quot; constraint to 22, it will pick the</span>
    <span class="comment">// type 22u8, which is overly constrained (c might not</span>
    <span class="comment">// be a u8). In effect, the problem is that the</span>
    <span class="comment">// &quot;castable to&quot; expectation is not the tightest thing</span>
    <span class="comment">// we can say, so we want to drop it in this case.</span>
    <span class="comment">// The tightest thing we can say is &quot;must unify with</span>
    <span class="comment">// else branch&quot;. Note that in the case of a &quot;has type&quot;</span>
    <span class="comment">// constraint, this limitation does not hold.</span>

    <span class="comment">// If the expected type is just a type variable, then don&#39;t use</span>
    <span class="comment">// an expected type. Otherwise, we might write parts of the type</span>
    <span class="comment">// when checking the &#39;then&#39; block which are incompatible with the</span>
    <span class="comment">// &#39;else&#39; branch.</span>
    <span class="kw">fn</span> <span class="ident">adjust_for_branches</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">fcx</span>: <span class="kw-2">&amp;</span><span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="kw-2">*</span><span class="self">self</span> {
            <span class="ident">ExpectHasType</span>(<span class="ident">ety</span>) <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="ident">ety</span> <span class="op">=</span> <span class="ident">fcx</span>.<span class="ident">shallow_resolve</span>(<span class="ident">ety</span>);
                <span class="kw">if</span> <span class="op">!</span><span class="ident">ety</span>.<span class="ident">is_ty_var</span>() {
                    <span class="ident">ExpectHasType</span>(<span class="ident">ety</span>)
                } <span class="kw">else</span> {
                    <span class="ident">NoExpectation</span>
                }
            }
            <span class="ident">ExpectRvalueLikeUnsized</span>(<span class="ident">ety</span>) <span class="op">=&gt;</span> {
                <span class="ident">ExpectRvalueLikeUnsized</span>(<span class="ident">ety</span>)
            }
            _ <span class="op">=&gt;</span> <span class="ident">NoExpectation</span>
        }
    }

    <span class="doccomment">/// Provide an expectation for an rvalue expression given an *optional*</span>
    <span class="doccomment">/// hint, which is not required for type safety (the resulting type might</span>
    <span class="doccomment">/// be checked higher up, as is the case with `&amp;expr` and `box expr`), but</span>
    <span class="doccomment">/// is useful in determining the concrete type.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The primary use case is where the expected type is a fat pointer,</span>
    <span class="doccomment">/// like `&amp;[isize]`. For example, consider the following statement:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///    let x: &amp;[isize] = &amp;[1, 2, 3];</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// In this case, the expected type for the `&amp;[1, 2, 3]` expression is</span>
    <span class="doccomment">/// `&amp;[isize]`. If however we were to say that `[1, 2, 3]` has the</span>
    <span class="doccomment">/// expectation `ExpectHasType([isize])`, that would be too strong --</span>
    <span class="doccomment">/// `[1, 2, 3]` does not have the type `[isize]` but rather `[isize; 3]`.</span>
    <span class="doccomment">/// It is only the `&amp;[1, 2, 3]` expression as a whole that can be coerced</span>
    <span class="doccomment">/// to the type `&amp;[isize]`. Therefore, we propagate this more limited hint,</span>
    <span class="doccomment">/// which still is useful, because it informs integer literals and the like.</span>
    <span class="doccomment">/// See the test case `test/run-pass/coerce-expect-unsized.rs` and #20169</span>
    <span class="doccomment">/// for examples of where this comes up,.</span>
    <span class="kw">fn</span> <span class="ident">rvalue_hint</span>(<span class="ident">fcx</span>: <span class="kw-2">&amp;</span><span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="ident">fcx</span>.<span class="ident">tcx</span>.<span class="ident">struct_tail</span>(<span class="ident">ty</span>).<span class="ident">sty</span> {
            <span class="ident">ty</span>::<span class="ident">TySlice</span>(_) <span class="op">|</span> <span class="ident">ty</span>::<span class="ident">TyStr</span> <span class="op">|</span> <span class="ident">ty</span>::<span class="ident">TyDynamic</span>(..) <span class="op">=&gt;</span> {
                <span class="ident">ExpectRvalueLikeUnsized</span>(<span class="ident">ty</span>)
            }
            _ <span class="op">=&gt;</span> <span class="ident">ExpectHasType</span>(<span class="ident">ty</span>)
        }
    }

    <span class="comment">// Resolves `expected` by a single level if it is a variable. If</span>
    <span class="comment">// there is no expected type or resolution is not possible (e.g.,</span>
    <span class="comment">// no constraints yet present), just returns `None`.</span>
    <span class="kw">fn</span> <span class="ident">resolve</span>(<span class="self">self</span>, <span class="ident">fcx</span>: <span class="kw-2">&amp;</span><span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">NoExpectation</span> <span class="op">=&gt;</span> <span class="ident">NoExpectation</span>,
            <span class="ident">ExpectIfCondition</span> <span class="op">=&gt;</span> <span class="ident">ExpectIfCondition</span>,
            <span class="ident">ExpectCastableToType</span>(<span class="ident">t</span>) <span class="op">=&gt;</span> {
                <span class="ident">ExpectCastableToType</span>(<span class="ident">fcx</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="kw-2">&amp;</span><span class="ident">t</span>))
            }
            <span class="ident">ExpectHasType</span>(<span class="ident">t</span>) <span class="op">=&gt;</span> {
                <span class="ident">ExpectHasType</span>(<span class="ident">fcx</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="kw-2">&amp;</span><span class="ident">t</span>))
            }
            <span class="ident">ExpectRvalueLikeUnsized</span>(<span class="ident">t</span>) <span class="op">=&gt;</span> {
                <span class="ident">ExpectRvalueLikeUnsized</span>(<span class="ident">fcx</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="kw-2">&amp;</span><span class="ident">t</span>))
            }
        }
    }

    <span class="kw">fn</span> <span class="ident">to_option</span>(<span class="self">self</span>, <span class="ident">fcx</span>: <span class="kw-2">&amp;</span><span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span> {
        <span class="kw">match</span> <span class="self">self</span>.<span class="ident">resolve</span>(<span class="ident">fcx</span>) {
            <span class="ident">NoExpectation</span> <span class="op">=&gt;</span> <span class="prelude-val">None</span>,
            <span class="ident">ExpectIfCondition</span> <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">fcx</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">bool</span>),
            <span class="ident">ExpectCastableToType</span>(<span class="ident">ty</span>) <span class="op">|</span>
            <span class="ident">ExpectHasType</span>(<span class="ident">ty</span>) <span class="op">|</span>
            <span class="ident">ExpectRvalueLikeUnsized</span>(<span class="ident">ty</span>) <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">ty</span>),
        }
    }

    <span class="doccomment">/// It sometimes happens that we want to turn an expectation into</span>
    <span class="doccomment">/// a **hard constraint** (i.e., something that must be satisfied</span>
    <span class="doccomment">/// for the program to type-check). `only_has_type` will return</span>
    <span class="doccomment">/// such a constraint, if it exists.</span>
    <span class="kw">fn</span> <span class="ident">only_has_type</span>(<span class="self">self</span>, <span class="ident">fcx</span>: <span class="kw-2">&amp;</span><span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span> {
        <span class="kw">match</span> <span class="self">self</span>.<span class="ident">resolve</span>(<span class="ident">fcx</span>) {
            <span class="ident">ExpectHasType</span>(<span class="ident">ty</span>) <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">ty</span>),
            <span class="ident">ExpectIfCondition</span> <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">fcx</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">bool</span>),
            <span class="ident">NoExpectation</span> <span class="op">|</span> <span class="ident">ExpectCastableToType</span>(_) <span class="op">|</span> <span class="ident">ExpectRvalueLikeUnsized</span>(_) <span class="op">=&gt;</span> <span class="prelude-val">None</span>,
        }
    }

    <span class="doccomment">/// Like `only_has_type`, but instead of returning `None` if no</span>
    <span class="doccomment">/// hard constraint exists, creates a fresh type variable.</span>
    <span class="kw">fn</span> <span class="ident">coercion_target_type</span>(<span class="self">self</span>, <span class="ident">fcx</span>: <span class="kw-2">&amp;</span><span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">span</span>: <span class="ident">Span</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">only_has_type</span>(<span class="ident">fcx</span>)
            .<span class="ident">unwrap_or_else</span>(<span class="op">||</span> <span class="ident">fcx</span>.<span class="ident">next_ty_var</span>(<span class="ident">TypeVariableOrigin</span>::<span class="ident">MiscVariable</span>(<span class="ident">span</span>)))
    }
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UnsafetyState</span> {
    <span class="kw">pub</span> <span class="ident">def</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>,
    <span class="kw">pub</span> <span class="ident">unsafety</span>: <span class="ident">hir</span>::<span class="ident">Unsafety</span>,
    <span class="kw">pub</span> <span class="ident">unsafe_push_count</span>: <span class="ident">u32</span>,
    <span class="ident">from_fn</span>: <span class="ident">bool</span>
}

<span class="kw">impl</span> <span class="ident">UnsafetyState</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">function</span>(<span class="ident">unsafety</span>: <span class="ident">hir</span>::<span class="ident">Unsafety</span>, <span class="ident">def</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>) <span class="op">-&gt;</span> <span class="ident">UnsafetyState</span> {
        <span class="ident">UnsafetyState</span> { <span class="ident">def</span>: <span class="ident">def</span>, <span class="ident">unsafety</span>: <span class="ident">unsafety</span>, <span class="ident">unsafe_push_count</span>: <span class="number">0</span>, <span class="ident">from_fn</span>: <span class="bool-val">true</span> }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">recurse</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">blk</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Block</span>) <span class="op">-&gt;</span> <span class="ident">UnsafetyState</span> {
        <span class="kw">match</span> <span class="self">self</span>.<span class="ident">unsafety</span> {
            <span class="comment">// If this unsafe, then if the outer function was already marked as</span>
            <span class="comment">// unsafe we shouldn&#39;t attribute the unsafe&#39;ness to the block. This</span>
            <span class="comment">// way the block can be warned about instead of ignoring this</span>
            <span class="comment">// extraneous block (functions are never warned about).</span>
            <span class="ident">hir</span>::<span class="ident">Unsafety</span>::<span class="ident">Unsafe</span> <span class="kw">if</span> <span class="self">self</span>.<span class="ident">from_fn</span> <span class="op">=&gt;</span> <span class="kw-2">*</span><span class="self">self</span>,

            <span class="ident">unsafety</span> <span class="op">=&gt;</span> {
                <span class="kw">let</span> (<span class="ident">unsafety</span>, <span class="ident">def</span>, <span class="ident">count</span>) <span class="op">=</span> <span class="kw">match</span> <span class="ident">blk</span>.<span class="ident">rules</span> {
                    <span class="ident">hir</span>::<span class="ident">PushUnsafeBlock</span>(..) <span class="op">=&gt;</span>
                        (<span class="ident">unsafety</span>, <span class="ident">blk</span>.<span class="ident">id</span>, <span class="self">self</span>.<span class="ident">unsafe_push_count</span>.<span class="ident">checked_add</span>(<span class="number">1</span>).<span class="ident">unwrap</span>()),
                    <span class="ident">hir</span>::<span class="ident">PopUnsafeBlock</span>(..) <span class="op">=&gt;</span>
                        (<span class="ident">unsafety</span>, <span class="ident">blk</span>.<span class="ident">id</span>, <span class="self">self</span>.<span class="ident">unsafe_push_count</span>.<span class="ident">checked_sub</span>(<span class="number">1</span>).<span class="ident">unwrap</span>()),
                    <span class="ident">hir</span>::<span class="ident">UnsafeBlock</span>(..) <span class="op">=&gt;</span>
                        (<span class="ident">hir</span>::<span class="ident">Unsafety</span>::<span class="ident">Unsafe</span>, <span class="ident">blk</span>.<span class="ident">id</span>, <span class="self">self</span>.<span class="ident">unsafe_push_count</span>),
                    <span class="ident">hir</span>::<span class="ident">DefaultBlock</span> <span class="op">=&gt;</span>
                        (<span class="ident">unsafety</span>, <span class="self">self</span>.<span class="ident">def</span>, <span class="self">self</span>.<span class="ident">unsafe_push_count</span>),
                };
                <span class="ident">UnsafetyState</span>{ <span class="ident">def</span>,
                               <span class="ident">unsafety</span>,
                               <span class="ident">unsafe_push_count</span>: <span class="ident">count</span>,
                               <span class="ident">from_fn</span>: <span class="bool-val">false</span> }
            }
        }
    }
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Copy</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">LvalueOp</span> {
    <span class="ident">Deref</span>,
    <span class="ident">Index</span>
}

<span class="doccomment">/// Tracks whether executing a node may exit normally (versus</span>
<span class="doccomment">/// return/break/panic, which &quot;diverge&quot;, leaving dead code in their</span>
<span class="doccomment">/// wake). Tracked semi-automatically (through type variables marked</span>
<span class="doccomment">/// as diverging), with some manual adjustments for control-flow</span>
<span class="doccomment">/// primitives (approximating a CFG).</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">PartialOrd</span>, <span class="ident">Ord</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">Diverges</span> {
    <span class="doccomment">/// Potentially unknown, some cases converge,</span>
    <span class="doccomment">/// others require a CFG to determine them.</span>
    <span class="ident">Maybe</span>,

    <span class="doccomment">/// Definitely known to diverge and therefore</span>
    <span class="doccomment">/// not reach the next sibling or its parent.</span>
    <span class="ident">Always</span>,

    <span class="doccomment">/// Same as `Always` but with a reachability</span>
    <span class="doccomment">/// warning already emitted</span>
    <span class="ident">WarnedAlways</span>
}

<span class="comment">// Convenience impls for combinig `Diverges`.</span>

<span class="kw">impl</span> <span class="ident">ops</span>::<span class="ident">BitAnd</span> <span class="kw">for</span> <span class="ident">Diverges</span> {
    <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="self">Self</span>;
    <span class="kw">fn</span> <span class="ident">bitand</span>(<span class="self">self</span>, <span class="ident">other</span>: <span class="self">Self</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="ident">cmp</span>::<span class="ident">min</span>(<span class="self">self</span>, <span class="ident">other</span>)
    }
}

<span class="kw">impl</span> <span class="ident">ops</span>::<span class="ident">BitOr</span> <span class="kw">for</span> <span class="ident">Diverges</span> {
    <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="self">Self</span>;
    <span class="kw">fn</span> <span class="ident">bitor</span>(<span class="self">self</span>, <span class="ident">other</span>: <span class="self">Self</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="ident">cmp</span>::<span class="ident">max</span>(<span class="self">self</span>, <span class="ident">other</span>)
    }
}

<span class="kw">impl</span> <span class="ident">ops</span>::<span class="ident">BitAndAssign</span> <span class="kw">for</span> <span class="ident">Diverges</span> {
    <span class="kw">fn</span> <span class="ident">bitand_assign</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">other</span>: <span class="self">Self</span>) {
        <span class="kw-2">*</span><span class="self">self</span> <span class="op">=</span> <span class="kw-2">*</span><span class="self">self</span> <span class="op">&amp;</span> <span class="ident">other</span>;
    }
}

<span class="kw">impl</span> <span class="ident">ops</span>::<span class="ident">BitOrAssign</span> <span class="kw">for</span> <span class="ident">Diverges</span> {
    <span class="kw">fn</span> <span class="ident">bitor_assign</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">other</span>: <span class="self">Self</span>) {
        <span class="kw-2">*</span><span class="self">self</span> <span class="op">=</span> <span class="kw-2">*</span><span class="self">self</span> <span class="op">|</span> <span class="ident">other</span>;
    }
}

<span class="kw">impl</span> <span class="ident">Diverges</span> {
    <span class="kw">fn</span> <span class="ident">always</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
        <span class="self">self</span> <span class="op">&gt;=</span> <span class="ident">Diverges</span>::<span class="ident">Always</span>
    }
}

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BreakableCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>: <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="ident">may_break</span>: <span class="ident">bool</span>,

    <span class="comment">// this is `null` for loops where break with a value is illegal,</span>
    <span class="comment">// such as `while`, `for`, and `while let`</span>
    <span class="ident">coerce</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">DynamicCoerceMany</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>,
}

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">EnclosingBreakables</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>: <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="ident">stack</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">BreakableCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>,
    <span class="ident">by_id</span>: <span class="ident">NodeMap</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">EnclosingBreakables</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">find_breakable</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">target_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BreakableCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">ix</span> <span class="op">=</span> <span class="kw-2">*</span><span class="self">self</span>.<span class="ident">by_id</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">target_id</span>).<span class="ident">unwrap_or_else</span>(<span class="op">||</span> {
            <span class="macro">bug</span><span class="macro">!</span>(<span class="string">&quot;could not find enclosing breakable with id {}&quot;</span>, <span class="ident">target_id</span>);
        });
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>.<span class="ident">stack</span>[<span class="ident">ix</span>]
    }
}

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>: <span class="lifetime">&#39;a</span><span class="op">+</span><span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span>: <span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">body_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>,

    <span class="doccomment">/// The parameter environment used for proving trait obligations</span>
    <span class="doccomment">/// in this function. This can change when we descend into</span>
    <span class="doccomment">/// closures (as they bring new things into scope), hence it is</span>
    <span class="doccomment">/// not part of `Inherited` (as of the time of this writing,</span>
    <span class="doccomment">/// closures do not yet change the environment, but they will</span>
    <span class="doccomment">/// eventually).</span>
    <span class="ident">param_env</span>: <span class="ident">ty</span>::<span class="ident">ParamEnv</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,

    <span class="comment">// Number of errors that had been reported when we started</span>
    <span class="comment">// checking this function. On exit, if we find that *more* errors</span>
    <span class="comment">// have been reported, we will skip regionck and other work that</span>
    <span class="comment">// expects the types within the function to be consistent.</span>
    <span class="ident">err_count_on_creation</span>: <span class="ident">usize</span>,

    <span class="ident">ret_coercion</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">DynamicCoerceMany</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span>,

    <span class="ident">yield_ty</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>,

    <span class="ident">ps</span>: <span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">UnsafetyState</span><span class="op">&gt;</span>,

    <span class="doccomment">/// Whether the last checked node generates a divergence (e.g.,</span>
    <span class="doccomment">/// `return` will set this to Always). In general, when entering</span>
    <span class="doccomment">/// an expression or other node in the tree, the initial value</span>
    <span class="doccomment">/// indicates whether prior parts of the containing expression may</span>
    <span class="doccomment">/// have diverged. It is then typically set to `Maybe` (and the</span>
    <span class="doccomment">/// old value remembered) for processing the subparts of the</span>
    <span class="doccomment">/// current expression. As each subpart is processed, they may set</span>
    <span class="doccomment">/// the flag to `Always` etc.  Finally, at the end, we take the</span>
    <span class="doccomment">/// result and &quot;union&quot; it with the original value, so that when we</span>
    <span class="doccomment">/// return the flag indicates if any subpart of the the parent</span>
    <span class="doccomment">/// expression (up to and including this part) has diverged.  So,</span>
    <span class="doccomment">/// if you read it after evaluating a subexpression `X`, the value</span>
    <span class="doccomment">/// you get indicates whether any subexpression that was</span>
    <span class="doccomment">/// evaluating up to and including `X` diverged.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// We use this flag for two purposes:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// - To warn about unreachable code: if, after processing a</span>
    <span class="doccomment">///   sub-expression but before we have applied the effects of the</span>
    <span class="doccomment">///   current node, we see that the flag is set to `Always`, we</span>
    <span class="doccomment">///   can issue a warning. This corresponds to something like</span>
    <span class="doccomment">///   `foo(return)`; we warn on the `foo()` expression. (We then</span>
    <span class="doccomment">///   update the flag to `WarnedAlways` to suppress duplicate</span>
    <span class="doccomment">///   reports.) Similarly, if we traverse to a fresh statement (or</span>
    <span class="doccomment">///   tail expression) from a `Always` setting, we will issue a</span>
    <span class="doccomment">///   warning. This corresponds to something like `{return;</span>
    <span class="doccomment">///   foo();}` or `{return; 22}`, where we would warn on the</span>
    <span class="doccomment">///   `foo()` or `22`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// - To permit assignment into a local variable or other lvalue</span>
    <span class="doccomment">///   (including the &quot;return slot&quot;) of type `!`.  This is allowed</span>
    <span class="doccomment">///   if **either** the type of value being assigned is `!`, which</span>
    <span class="doccomment">///   means the current code is dead, **or** the expression&#39;s</span>
    <span class="doccomment">///   diverging flag is true, which means that a diverging value was</span>
    <span class="doccomment">///   wrapped (e.g., `let x: ! = foo(return)`).</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// To repeat the last point: an expression represents dead-code</span>
    <span class="doccomment">/// if, after checking it, **either** its type is `!` OR the</span>
    <span class="doccomment">/// diverges flag is set to something other than `Maybe`.</span>
    <span class="ident">diverges</span>: <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">Diverges</span><span class="op">&gt;</span>,

    <span class="doccomment">/// Whether any child nodes have any type errors.</span>
    <span class="ident">has_errors</span>: <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>,

    <span class="ident">enclosing_breakables</span>: <span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">EnclosingBreakables</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>,

    <span class="ident">inh</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Inherited</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">Deref</span> <span class="kw">for</span> <span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">type</span> <span class="ident">Target</span> <span class="op">=</span> <span class="ident">Inherited</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>;
    <span class="kw">fn</span> <span class="ident">deref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Target</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">inh</span>
    }
}

<span class="doccomment">/// Helper type of a temporary returned by Inherited::build(...).</span>
<span class="doccomment">/// Necessary because we can&#39;t write the following bound:</span>
<span class="doccomment">/// F: for&lt;&#39;b, &#39;tcx&gt; where &#39;gcx: &#39;tcx FnOnce(Inherited&lt;&#39;b, &#39;gcx, &#39;tcx&gt;).</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">InheritedBuilder</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>: <span class="lifetime">&#39;a</span><span class="op">+</span><span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span>: <span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">infcx</span>: <span class="ident">infer</span>::<span class="ident">InferCtxtBuilder</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
    <span class="ident">def_id</span>: <span class="ident">DefId</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">Inherited</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">build</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;gcx</span><span class="op">&gt;</span>, <span class="ident">def_id</span>: <span class="ident">DefId</span>)
                 <span class="op">-&gt;</span> <span class="ident">InheritedBuilder</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">hir_id_root</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">def_id</span>.<span class="ident">is_local</span>() {
            <span class="kw">let</span> <span class="ident">node_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">as_local_node_id</span>(<span class="ident">def_id</span>).<span class="ident">unwrap</span>();
            <span class="kw">let</span> <span class="ident">hir_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">definitions</span>().<span class="ident">node_to_hir_id</span>(<span class="ident">node_id</span>);
            <span class="ident">DefId</span>::<span class="ident">local</span>(<span class="ident">hir_id</span>.<span class="ident">owner</span>)
        } <span class="kw">else</span> {
            <span class="ident">def_id</span>
        };

        <span class="ident">InheritedBuilder</span> {
            <span class="ident">infcx</span>: <span class="ident">tcx</span>.<span class="ident">infer_ctxt</span>().<span class="ident">with_fresh_in_progress_tables</span>(<span class="ident">hir_id_root</span>),
            <span class="ident">def_id</span>,
        }
    }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">InheritedBuilder</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">enter</span><span class="op">&lt;</span><span class="ident">F</span>, <span class="ident">R</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">f</span>: <span class="ident">F</span>) <span class="op">-&gt;</span> <span class="ident">R</span>
        <span class="kw">where</span> <span class="ident">F</span>: <span class="kw">for</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span> <span class="ident">FnOnce</span>(<span class="ident">Inherited</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">R</span>
    {
        <span class="kw">let</span> <span class="ident">def_id</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">def_id</span>;
        <span class="self">self</span>.<span class="ident">infcx</span>.<span class="ident">enter</span>(<span class="op">|</span><span class="ident">infcx</span><span class="op">|</span> <span class="ident">f</span>(<span class="ident">Inherited</span>::<span class="ident">new</span>(<span class="ident">infcx</span>, <span class="ident">def_id</span>)))
    }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">Inherited</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">infcx</span>: <span class="ident">InferCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">def_id</span>: <span class="ident">DefId</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="kw">let</span> <span class="ident">tcx</span> <span class="op">=</span> <span class="ident">infcx</span>.<span class="ident">tcx</span>;
        <span class="kw">let</span> <span class="ident">item_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">as_local_node_id</span>(<span class="ident">def_id</span>);
        <span class="kw">let</span> <span class="ident">body_id</span> <span class="op">=</span> <span class="ident">item_id</span>.<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">id</span><span class="op">|</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">maybe_body_owned_by</span>(<span class="ident">id</span>));
        <span class="kw">let</span> <span class="ident">implicit_region_bound</span> <span class="op">=</span> <span class="ident">body_id</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">body_id</span><span class="op">|</span> {
            <span class="kw">let</span> <span class="ident">body</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">body</span>(<span class="ident">body_id</span>);
            <span class="ident">tcx</span>.<span class="ident">mk_region</span>(<span class="ident">ty</span>::<span class="ident">ReScope</span>(<span class="ident">region</span>::<span class="ident">Scope</span>::<span class="ident">CallSite</span>(<span class="ident">body</span>.<span class="ident">value</span>.<span class="ident">hir_id</span>.<span class="ident">local_id</span>)))
        });

        <span class="ident">Inherited</span> {
            <span class="ident">tables</span>: <span class="ident">MaybeInProgressTables</span> {
                <span class="ident">maybe_tables</span>: <span class="ident">infcx</span>.<span class="ident">in_progress_tables</span>,
            },
            <span class="ident">infcx</span>,
            <span class="ident">fulfillment_cx</span>: <span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="ident">traits</span>::<span class="ident">FulfillmentContext</span>::<span class="ident">new</span>()),
            <span class="ident">locals</span>: <span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="ident">NodeMap</span>()),
            <span class="ident">deferred_call_resolutions</span>: <span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="ident">DefIdMap</span>()),
            <span class="ident">deferred_cast_checks</span>: <span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="ident">Vec</span>::<span class="ident">new</span>()),
            <span class="ident">deferred_generator_interiors</span>: <span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="ident">Vec</span>::<span class="ident">new</span>()),
            <span class="ident">anon_types</span>: <span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="ident">NodeMap</span>()),
            <span class="ident">implicit_region_bound</span>,
            <span class="ident">body_id</span>,
        }
    }

    <span class="kw">fn</span> <span class="ident">register_predicate</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">obligation</span>: <span class="ident">traits</span>::<span class="ident">PredicateObligation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) {
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;register_predicate({:?})&quot;</span>, <span class="ident">obligation</span>);
        <span class="kw">if</span> <span class="ident">obligation</span>.<span class="ident">has_escaping_regions</span>() {
            <span class="macro">span_bug</span><span class="macro">!</span>(<span class="ident">obligation</span>.<span class="ident">cause</span>.<span class="ident">span</span>, <span class="string">&quot;escaping regions in predicate {:?}&quot;</span>,
                      <span class="ident">obligation</span>);
        }
        <span class="self">self</span>.<span class="ident">fulfillment_cx</span>
            .<span class="ident">borrow_mut</span>()
            .<span class="ident">register_predicate_obligation</span>(<span class="self">self</span>, <span class="ident">obligation</span>);
    }

    <span class="kw">fn</span> <span class="ident">register_predicates</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">obligations</span>: <span class="ident">I</span>)
    <span class="kw">where</span> <span class="ident">I</span>: <span class="ident">IntoIterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">traits</span>::<span class="ident">PredicateObligation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span> {
        <span class="kw">for</span> <span class="ident">obligation</span> <span class="kw">in</span> <span class="ident">obligations</span> {
            <span class="self">self</span>.<span class="ident">register_predicate</span>(<span class="ident">obligation</span>);
        }
    }

    <span class="kw">fn</span> <span class="ident">register_infer_ok_obligations</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">infer_ok</span>: <span class="ident">InferOk</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span>, <span class="ident">T</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">T</span> {
        <span class="self">self</span>.<span class="ident">register_predicates</span>(<span class="ident">infer_ok</span>.<span class="ident">obligations</span>);
        <span class="ident">infer_ok</span>.<span class="ident">value</span>
    }

    <span class="kw">fn</span> <span class="ident">normalize_associated_types_in</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                        <span class="ident">span</span>: <span class="ident">Span</span>,
                                        <span class="ident">body_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>,
                                        <span class="ident">param_env</span>: <span class="ident">ty</span>::<span class="ident">ParamEnv</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                        <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">T</span>) <span class="op">-&gt;</span> <span class="ident">T</span>
        <span class="kw">where</span> <span class="ident">T</span> : <span class="ident">TypeFoldable</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="kw">let</span> <span class="ident">ok</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">normalize_associated_types_in_as_infer_ok</span>(<span class="ident">span</span>, <span class="ident">body_id</span>, <span class="ident">param_env</span>, <span class="ident">value</span>);
        <span class="self">self</span>.<span class="ident">register_infer_ok_obligations</span>(<span class="ident">ok</span>)
    }

    <span class="kw">fn</span> <span class="ident">normalize_associated_types_in_as_infer_ok</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                                    <span class="ident">span</span>: <span class="ident">Span</span>,
                                                    <span class="ident">body_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>,
                                                    <span class="ident">param_env</span>: <span class="ident">ty</span>::<span class="ident">ParamEnv</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                                    <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">T</span>)
                                                    <span class="op">-&gt;</span> <span class="ident">InferOk</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span>, <span class="ident">T</span><span class="op">&gt;</span>
        <span class="kw">where</span> <span class="ident">T</span> : <span class="ident">TypeFoldable</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;normalize_associated_types_in(value={:?})&quot;</span>, <span class="ident">value</span>);
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">selcx</span> <span class="op">=</span> <span class="ident">traits</span>::<span class="ident">SelectionContext</span>::<span class="ident">new</span>(<span class="self">self</span>);
        <span class="kw">let</span> <span class="ident">cause</span> <span class="op">=</span> <span class="ident">ObligationCause</span>::<span class="ident">misc</span>(<span class="ident">span</span>, <span class="ident">body_id</span>);
        <span class="kw">let</span> <span class="ident">traits</span>::<span class="ident">Normalized</span> { <span class="ident">value</span>, <span class="ident">obligations</span> } <span class="op">=</span>
            <span class="ident">traits</span>::<span class="ident">normalize</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">selcx</span>, <span class="ident">param_env</span>, <span class="ident">cause</span>, <span class="ident">value</span>);
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;normalize_associated_types_in: result={:?} predicates={:?}&quot;</span>,
            <span class="ident">value</span>,
            <span class="ident">obligations</span>);
        <span class="ident">InferOk</span> { <span class="ident">value</span>, <span class="ident">obligations</span> }
    }

    <span class="doccomment">/// Replace any late-bound regions bound in `value` with</span>
    <span class="doccomment">/// free variants attached to `all_outlive_scope`.</span>
    <span class="kw">fn</span> <span class="ident">liberate_late_bound_regions</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
        <span class="ident">all_outlive_scope</span>: <span class="ident">DefId</span>,
        <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">Binder</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>)
        <span class="op">-&gt;</span> <span class="ident">T</span>
        <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">TypeFoldable</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">replace_late_bound_regions</span>(<span class="ident">value</span>, <span class="op">|</span><span class="ident">br</span><span class="op">|</span> {
            <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">mk_region</span>(<span class="ident">ty</span>::<span class="ident">ReFree</span>(<span class="ident">ty</span>::<span class="ident">FreeRegion</span> {
                <span class="ident">scope</span>: <span class="ident">all_outlive_scope</span>,
                <span class="ident">bound_region</span>: <span class="ident">br</span>
            }))
        }).<span class="number">0</span>
    }
}

<span class="kw">struct</span> <span class="ident">CheckItemTypesVisitor</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>: <span class="lifetime">&#39;a</span><span class="op">&gt;</span> { <span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> }

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">ItemLikeVisitor</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">CheckItemTypesVisitor</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">visit_item</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">i</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">hir</span>::<span class="ident">Item</span>) {
        <span class="ident">check_item_type</span>(<span class="self">self</span>.<span class="ident">tcx</span>, <span class="ident">i</span>);
    }
    <span class="kw">fn</span> <span class="ident">visit_trait_item</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, _: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">hir</span>::<span class="ident">TraitItem</span>) { }
    <span class="kw">fn</span> <span class="ident">visit_impl_item</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, _: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">hir</span>::<span class="ident">ImplItem</span>) { }
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_wf_new</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">ErrorReported</span><span class="op">&gt;</span> {
    <span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">track_errors</span>(<span class="op">||</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">visit</span> <span class="op">=</span> <span class="ident">wfcheck</span>::<span class="ident">CheckTypeWellFormedVisitor</span>::<span class="ident">new</span>(<span class="ident">tcx</span>);
        <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">krate</span>().<span class="ident">visit_all_item_likes</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">visit</span>.<span class="ident">as_deep_visitor</span>());
    })
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_item_types</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">ErrorReported</span><span class="op">&gt;</span> {
    <span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">track_errors</span>(<span class="op">||</span> {
        <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">krate</span>().<span class="ident">visit_all_item_likes</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">CheckItemTypesVisitor</span> { <span class="ident">tcx</span> });
    })
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_item_bodies</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">CompileIncomplete</span><span class="op">&gt;</span> {
    <span class="ident">tcx</span>.<span class="ident">typeck_item_bodies</span>(<span class="ident">LOCAL_CRATE</span>)
}

<span class="kw">fn</span> <span class="ident">typeck_item_bodies</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">crate_num</span>: <span class="ident">CrateNum</span>)
                                <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">CompileIncomplete</span><span class="op">&gt;</span>
{
    <span class="macro">debug_assert</span><span class="macro">!</span>(<span class="ident">crate_num</span> <span class="op">==</span> <span class="ident">LOCAL_CRATE</span>);
    <span class="prelude-val">Ok</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">track_errors</span>(<span class="op">||</span> {
        <span class="kw">for</span> <span class="ident">body_owner_def_id</span> <span class="kw">in</span> <span class="ident">tcx</span>.<span class="ident">body_owners</span>() {
            <span class="ident">ty</span>::<span class="ident">maps</span>::<span class="ident">queries</span>::<span class="ident">typeck_tables_of</span>::<span class="ident">ensure</span>(<span class="ident">tcx</span>, <span class="ident">body_owner_def_id</span>);
        }
    })<span class="question-mark">?</span>)
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">provide</span>(<span class="ident">providers</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Providers</span>) {
    <span class="kw-2">*</span><span class="ident">providers</span> <span class="op">=</span> <span class="ident">Providers</span> {
        <span class="ident">typeck_item_bodies</span>,
        <span class="ident">typeck_tables_of</span>,
        <span class="ident">has_typeck_tables</span>,
        <span class="ident">closure_kind</span>,
        <span class="ident">generator_sig</span>,
        <span class="ident">adt_destructor</span>,
        <span class="ident">used_trait_imports</span>,
        ..<span class="kw-2">*</span><span class="ident">providers</span>
    };
}

<span class="kw">fn</span> <span class="ident">generator_sig</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                          <span class="ident">def_id</span>: <span class="ident">DefId</span>)
                          <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ty</span>::<span class="ident">PolyGenSig</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span> {
    <span class="kw">let</span> <span class="ident">node_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">as_local_node_id</span>(<span class="ident">def_id</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">hir_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">node_to_hir_id</span>(<span class="ident">node_id</span>);
    <span class="ident">tcx</span>.<span class="ident">typeck_tables_of</span>(<span class="ident">def_id</span>).<span class="ident">generator_sigs</span>()[<span class="ident">hir_id</span>].<span class="ident">map</span>(<span class="op">|</span><span class="ident">s</span><span class="op">|</span> <span class="ident">ty</span>::<span class="ident">Binder</span>(<span class="ident">s</span>))
}

<span class="kw">fn</span> <span class="ident">closure_kind</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                          <span class="ident">def_id</span>: <span class="ident">DefId</span>)
                          <span class="op">-&gt;</span> <span class="ident">ty</span>::<span class="ident">ClosureKind</span> {
    <span class="kw">let</span> <span class="ident">node_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">as_local_node_id</span>(<span class="ident">def_id</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">hir_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">node_to_hir_id</span>(<span class="ident">node_id</span>);
    <span class="ident">tcx</span>.<span class="ident">typeck_tables_of</span>(<span class="ident">def_id</span>).<span class="ident">closure_kinds</span>()[<span class="ident">hir_id</span>].<span class="number">0</span>
}

<span class="kw">fn</span> <span class="ident">adt_destructor</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                            <span class="ident">def_id</span>: <span class="ident">DefId</span>)
                            <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ty</span>::<span class="ident">Destructor</span><span class="op">&gt;</span> {
    <span class="ident">tcx</span>.<span class="ident">calculate_dtor</span>(<span class="ident">def_id</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dropck</span>::<span class="ident">check_drop_impl</span>)
}

<span class="doccomment">/// If this def-id is a &quot;primary tables entry&quot;, returns `Some((body_id, decl))`</span>
<span class="doccomment">/// with information about it&#39;s body-id and fn-decl (if any). Otherwise,</span>
<span class="doccomment">/// returns `None`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// If this function returns &quot;some&quot;, then `typeck_tables(def_id)` will</span>
<span class="doccomment">/// succeed; if it returns `None`, then `typeck_tables(def_id)` may or</span>
<span class="doccomment">/// may not succeed.  In some cases where this function returns `None`</span>
<span class="doccomment">/// (notably closures), `typeck_tables(def_id)` would wind up</span>
<span class="doccomment">/// redirecting to the owning function.</span>
<span class="kw">fn</span> <span class="ident">primary_body_of</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                             <span class="ident">id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>)
                             <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span>(<span class="ident">hir</span>::<span class="ident">BodyId</span>, <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">hir</span>::<span class="ident">FnDecl</span><span class="op">&gt;</span>)<span class="op">&gt;</span>
{
    <span class="kw">match</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">get</span>(<span class="ident">id</span>) {
        <span class="ident">hir</span>::<span class="ident">map</span>::<span class="ident">NodeItem</span>(<span class="ident">item</span>) <span class="op">=&gt;</span> {
            <span class="kw">match</span> <span class="ident">item</span>.<span class="ident">node</span> {
                <span class="ident">hir</span>::<span class="ident">ItemConst</span>(_, <span class="ident">body</span>) <span class="op">|</span>
                <span class="ident">hir</span>::<span class="ident">ItemStatic</span>(_, _, <span class="ident">body</span>) <span class="op">=&gt;</span>
                    <span class="prelude-val">Some</span>((<span class="ident">body</span>, <span class="prelude-val">None</span>)),
                <span class="ident">hir</span>::<span class="ident">ItemFn</span>(<span class="kw-2">ref</span> <span class="ident">decl</span>, .., <span class="ident">body</span>) <span class="op">=&gt;</span>
                    <span class="prelude-val">Some</span>((<span class="ident">body</span>, <span class="prelude-val">Some</span>(<span class="ident">decl</span>))),
                _ <span class="op">=&gt;</span>
                    <span class="prelude-val">None</span>,
            }
        }
        <span class="ident">hir</span>::<span class="ident">map</span>::<span class="ident">NodeTraitItem</span>(<span class="ident">item</span>) <span class="op">=&gt;</span> {
            <span class="kw">match</span> <span class="ident">item</span>.<span class="ident">node</span> {
                <span class="ident">hir</span>::<span class="ident">TraitItemKind</span>::<span class="ident">Const</span>(_, <span class="prelude-val">Some</span>(<span class="ident">body</span>)) <span class="op">=&gt;</span>
                    <span class="prelude-val">Some</span>((<span class="ident">body</span>, <span class="prelude-val">None</span>)),
                <span class="ident">hir</span>::<span class="ident">TraitItemKind</span>::<span class="ident">Method</span>(<span class="kw-2">ref</span> <span class="ident">sig</span>, <span class="ident">hir</span>::<span class="ident">TraitMethod</span>::<span class="ident">Provided</span>(<span class="ident">body</span>)) <span class="op">=&gt;</span>
                    <span class="prelude-val">Some</span>((<span class="ident">body</span>, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">sig</span>.<span class="ident">decl</span>))),
                _ <span class="op">=&gt;</span>
                    <span class="prelude-val">None</span>,
            }
        }
        <span class="ident">hir</span>::<span class="ident">map</span>::<span class="ident">NodeImplItem</span>(<span class="ident">item</span>) <span class="op">=&gt;</span> {
            <span class="kw">match</span> <span class="ident">item</span>.<span class="ident">node</span> {
                <span class="ident">hir</span>::<span class="ident">ImplItemKind</span>::<span class="ident">Const</span>(_, <span class="ident">body</span>) <span class="op">=&gt;</span>
                    <span class="prelude-val">Some</span>((<span class="ident">body</span>, <span class="prelude-val">None</span>)),
                <span class="ident">hir</span>::<span class="ident">ImplItemKind</span>::<span class="ident">Method</span>(<span class="kw-2">ref</span> <span class="ident">sig</span>, <span class="ident">body</span>) <span class="op">=&gt;</span>
                    <span class="prelude-val">Some</span>((<span class="ident">body</span>, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">sig</span>.<span class="ident">decl</span>))),
                _ <span class="op">=&gt;</span>
                    <span class="prelude-val">None</span>,
            }
        }
        <span class="ident">hir</span>::<span class="ident">map</span>::<span class="ident">NodeExpr</span>(<span class="ident">expr</span>) <span class="op">=&gt;</span> {
            <span class="comment">// FIXME(eddyb) Closures should have separate</span>
            <span class="comment">// function definition IDs and expression IDs.</span>
            <span class="comment">// Type-checking should not let closures get</span>
            <span class="comment">// this far in a constant position.</span>
            <span class="comment">// Assume that everything other than closures</span>
            <span class="comment">// is a constant &quot;initializer&quot; expression.</span>
            <span class="kw">match</span> <span class="ident">expr</span>.<span class="ident">node</span> {
                <span class="ident">hir</span>::<span class="ident">ExprClosure</span>(..) <span class="op">=&gt;</span>
                    <span class="prelude-val">None</span>,
                _ <span class="op">=&gt;</span>
                    <span class="prelude-val">Some</span>((<span class="ident">hir</span>::<span class="ident">BodyId</span> { <span class="ident">node_id</span>: <span class="ident">expr</span>.<span class="ident">id</span> }, <span class="prelude-val">None</span>)),
            }
        }
        _ <span class="op">=&gt;</span> <span class="prelude-val">None</span>,
    }
}

<span class="kw">fn</span> <span class="ident">has_typeck_tables</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                               <span class="ident">def_id</span>: <span class="ident">DefId</span>)
                               <span class="op">-&gt;</span> <span class="ident">bool</span> {
    <span class="comment">// Closures&#39; tables come from their outermost function,</span>
    <span class="comment">// as they are part of the same &quot;inference environment&quot;.</span>
    <span class="kw">let</span> <span class="ident">outer_def_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">closure_base_def_id</span>(<span class="ident">def_id</span>);
    <span class="kw">if</span> <span class="ident">outer_def_id</span> <span class="op">!=</span> <span class="ident">def_id</span> {
        <span class="kw">return</span> <span class="ident">tcx</span>.<span class="ident">has_typeck_tables</span>(<span class="ident">outer_def_id</span>);
    }

    <span class="kw">let</span> <span class="ident">id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">as_local_node_id</span>(<span class="ident">def_id</span>).<span class="ident">unwrap</span>();
    <span class="ident">primary_body_of</span>(<span class="ident">tcx</span>, <span class="ident">id</span>).<span class="ident">is_some</span>()
}

<span class="kw">fn</span> <span class="ident">used_trait_imports</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                              <span class="ident">def_id</span>: <span class="ident">DefId</span>)
                              <span class="op">-&gt;</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">DefIdSet</span><span class="op">&gt;</span> {
    <span class="ident">tcx</span>.<span class="ident">typeck_tables_of</span>(<span class="ident">def_id</span>).<span class="ident">used_trait_imports</span>.<span class="ident">clone</span>()
}

<span class="kw">fn</span> <span class="ident">typeck_tables_of</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                              <span class="ident">def_id</span>: <span class="ident">DefId</span>)
                              <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">ty</span>::<span class="ident">TypeckTables</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="comment">// Closures&#39; tables come from their outermost function,</span>
    <span class="comment">// as they are part of the same &quot;inference environment&quot;.</span>
    <span class="kw">let</span> <span class="ident">outer_def_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">closure_base_def_id</span>(<span class="ident">def_id</span>);
    <span class="kw">if</span> <span class="ident">outer_def_id</span> <span class="op">!=</span> <span class="ident">def_id</span> {
        <span class="kw">return</span> <span class="ident">tcx</span>.<span class="ident">typeck_tables_of</span>(<span class="ident">outer_def_id</span>);
    }

    <span class="kw">let</span> <span class="ident">id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">as_local_node_id</span>(<span class="ident">def_id</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">span</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">span</span>(<span class="ident">id</span>);

    <span class="comment">// Figure out what primary body this item has.</span>
    <span class="kw">let</span> (<span class="ident">body_id</span>, <span class="ident">fn_decl</span>) <span class="op">=</span> <span class="ident">primary_body_of</span>(<span class="ident">tcx</span>, <span class="ident">id</span>).<span class="ident">unwrap_or_else</span>(<span class="op">||</span> {
        <span class="macro">span_bug</span><span class="macro">!</span>(<span class="ident">span</span>, <span class="string">&quot;can&#39;t type-check body of {:?}&quot;</span>, <span class="ident">def_id</span>);
    });
    <span class="kw">let</span> <span class="ident">body</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">body</span>(<span class="ident">body_id</span>);

    <span class="kw">let</span> <span class="ident">tables</span> <span class="op">=</span> <span class="ident">Inherited</span>::<span class="ident">build</span>(<span class="ident">tcx</span>, <span class="ident">def_id</span>).<span class="ident">enter</span>(<span class="op">|</span><span class="ident">inh</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">param_env</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">param_env</span>(<span class="ident">def_id</span>);
        <span class="kw">let</span> <span class="ident">fcx</span> <span class="op">=</span> <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">decl</span>) <span class="op">=</span> <span class="ident">fn_decl</span> {
            <span class="kw">let</span> <span class="ident">fn_sig</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">fn_sig</span>(<span class="ident">def_id</span>);

            <span class="ident">check_abi</span>(<span class="ident">tcx</span>, <span class="ident">span</span>, <span class="ident">fn_sig</span>.<span class="ident">abi</span>());

            <span class="comment">// Compute the fty from point of view of inside fn.</span>
            <span class="kw">let</span> <span class="ident">fn_sig</span> <span class="op">=</span>
                <span class="ident">inh</span>.<span class="ident">liberate_late_bound_regions</span>(<span class="ident">def_id</span>, <span class="kw-2">&amp;</span><span class="ident">fn_sig</span>);
            <span class="kw">let</span> <span class="ident">fn_sig</span> <span class="op">=</span>
                <span class="ident">inh</span>.<span class="ident">normalize_associated_types_in</span>(<span class="ident">body</span>.<span class="ident">value</span>.<span class="ident">span</span>,
                                                  <span class="ident">body_id</span>.<span class="ident">node_id</span>,
                                                  <span class="ident">param_env</span>,
                                                  <span class="kw-2">&amp;</span><span class="ident">fn_sig</span>);

            <span class="ident">check_fn</span>(<span class="kw-2">&amp;</span><span class="ident">inh</span>, <span class="ident">param_env</span>, <span class="ident">fn_sig</span>, <span class="ident">decl</span>, <span class="ident">id</span>, <span class="ident">body</span>, <span class="bool-val">false</span>).<span class="number">0</span>
        } <span class="kw">else</span> {
            <span class="kw">let</span> <span class="ident">fcx</span> <span class="op">=</span> <span class="ident">FnCtxt</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">inh</span>, <span class="ident">param_env</span>, <span class="ident">body</span>.<span class="ident">value</span>.<span class="ident">id</span>);
            <span class="kw">let</span> <span class="ident">expected_type</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">type_of</span>(<span class="ident">def_id</span>);
            <span class="kw">let</span> <span class="ident">expected_type</span> <span class="op">=</span> <span class="ident">fcx</span>.<span class="ident">normalize_associated_types_in</span>(<span class="ident">body</span>.<span class="ident">value</span>.<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="ident">expected_type</span>);
            <span class="ident">fcx</span>.<span class="ident">require_type_is_sized</span>(<span class="ident">expected_type</span>, <span class="ident">body</span>.<span class="ident">value</span>.<span class="ident">span</span>, <span class="ident">traits</span>::<span class="ident">ConstSized</span>);

            <span class="comment">// Gather locals in statics (because of block expressions).</span>
            <span class="comment">// This is technically unnecessary because locals in static items are forbidden,</span>
            <span class="comment">// but prevents type checking from blowing up before const checking can properly</span>
            <span class="comment">// emit an error.</span>
            <span class="ident">GatherLocalsVisitor</span> { <span class="ident">fcx</span>: <span class="kw-2">&amp;</span><span class="ident">fcx</span> }.<span class="ident">visit_body</span>(<span class="ident">body</span>);

            <span class="ident">fcx</span>.<span class="ident">check_expr_coercable_to_type</span>(<span class="kw-2">&amp;</span><span class="ident">body</span>.<span class="ident">value</span>, <span class="ident">expected_type</span>);

            <span class="ident">fcx</span>
        };

        <span class="ident">fcx</span>.<span class="ident">select_all_obligations_and_apply_defaults</span>();
        <span class="ident">fcx</span>.<span class="ident">closure_analyze</span>(<span class="ident">body</span>);
        <span class="ident">fcx</span>.<span class="ident">select_obligations_where_possible</span>();
        <span class="ident">fcx</span>.<span class="ident">check_casts</span>();
        <span class="ident">fcx</span>.<span class="ident">resolve_generator_interiors</span>(<span class="ident">def_id</span>);
        <span class="ident">fcx</span>.<span class="ident">select_all_obligations_or_error</span>();

        <span class="kw">if</span> <span class="ident">fn_decl</span>.<span class="ident">is_some</span>() {
            <span class="ident">fcx</span>.<span class="ident">regionck_fn</span>(<span class="ident">id</span>, <span class="ident">body</span>);
        } <span class="kw">else</span> {
            <span class="ident">fcx</span>.<span class="ident">regionck_expr</span>(<span class="ident">body</span>);
        }

        <span class="ident">fcx</span>.<span class="ident">resolve_type_vars_in_body</span>(<span class="ident">body</span>)
    });

    <span class="comment">// Consistency check our TypeckTables instance can hold all ItemLocalIds</span>
    <span class="comment">// it will need to hold.</span>
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">tables</span>.<span class="ident">local_id_root</span>,
               <span class="prelude-val">Some</span>(<span class="ident">DefId</span>::<span class="ident">local</span>(<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">definitions</span>().<span class="ident">node_to_hir_id</span>(<span class="ident">id</span>).<span class="ident">owner</span>)));
    <span class="ident">tables</span>
}

<span class="kw">fn</span> <span class="ident">check_abi</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">span</span>: <span class="ident">Span</span>, <span class="ident">abi</span>: <span class="ident">Abi</span>) {
    <span class="kw">if</span> <span class="op">!</span><span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">target</span>.<span class="ident">target</span>.<span class="ident">is_abi_supported</span>(<span class="ident">abi</span>) {
        <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">span</span>, <span class="ident">E0570</span>,
            <span class="string">&quot;The ABI `{}` is not supported for the current target&quot;</span>, <span class="ident">abi</span>).<span class="ident">emit</span>()
    }
}

<span class="kw">struct</span> <span class="ident">GatherLocalsVisitor</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>: <span class="lifetime">&#39;a</span><span class="op">+</span><span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span>: <span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">fcx</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">GatherLocalsVisitor</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">assign</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">span</span>: <span class="ident">Span</span>, <span class="ident">nid</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>, <span class="ident">ty_opt</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="ident">ty_opt</span> {
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> {
                <span class="comment">// infer the variable&#39;s type</span>
                <span class="kw">let</span> <span class="ident">var_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">fcx</span>.<span class="ident">next_ty_var</span>(<span class="ident">TypeVariableOrigin</span>::<span class="ident">TypeInference</span>(<span class="ident">span</span>));
                <span class="self">self</span>.<span class="ident">fcx</span>.<span class="ident">locals</span>.<span class="ident">borrow_mut</span>().<span class="ident">insert</span>(<span class="ident">nid</span>, <span class="ident">var_ty</span>);
                <span class="ident">var_ty</span>
            }
            <span class="prelude-val">Some</span>(<span class="ident">typ</span>) <span class="op">=&gt;</span> {
                <span class="comment">// take type that the user specified</span>
                <span class="self">self</span>.<span class="ident">fcx</span>.<span class="ident">locals</span>.<span class="ident">borrow_mut</span>().<span class="ident">insert</span>(<span class="ident">nid</span>, <span class="ident">typ</span>);
                <span class="ident">typ</span>
            }
        }
    }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">Visitor</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">GatherLocalsVisitor</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">nested_visit_map</span><span class="op">&lt;</span><span class="lifetime">&#39;this</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;this</span> <span class="kw-2">mut</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">NestedVisitorMap</span><span class="op">&lt;</span><span class="lifetime">&#39;this</span>, <span class="lifetime">&#39;gcx</span><span class="op">&gt;</span> {
        <span class="ident">NestedVisitorMap</span>::<span class="prelude-val">None</span>
    }

    <span class="comment">// Add explicitly-declared locals.</span>
    <span class="kw">fn</span> <span class="ident">visit_local</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">local</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Local</span>) {
        <span class="kw">let</span> <span class="ident">o_ty</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">local</span>.<span class="ident">ty</span> {
            <span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="ident">ty</span>) <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="self">self</span>.<span class="ident">fcx</span>.<span class="ident">to_ty</span>(<span class="kw-2">&amp;</span><span class="ident">ty</span>)),
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> <span class="prelude-val">None</span>
        };
        <span class="self">self</span>.<span class="ident">assign</span>(<span class="ident">local</span>.<span class="ident">span</span>, <span class="ident">local</span>.<span class="ident">id</span>, <span class="ident">o_ty</span>);
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;Local variable {:?} is assigned type {}&quot;</span>,
               <span class="ident">local</span>.<span class="ident">pat</span>,
               <span class="self">self</span>.<span class="ident">fcx</span>.<span class="ident">ty_to_string</span>(
                   <span class="self">self</span>.<span class="ident">fcx</span>.<span class="ident">locals</span>.<span class="ident">borrow</span>().<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">local</span>.<span class="ident">id</span>).<span class="ident">unwrap</span>().<span class="ident">clone</span>()));
        <span class="ident">intravisit</span>::<span class="ident">walk_local</span>(<span class="self">self</span>, <span class="ident">local</span>);
    }

    <span class="comment">// Add pattern bindings.</span>
    <span class="kw">fn</span> <span class="ident">visit_pat</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Pat</span>) {
        <span class="kw">if</span> <span class="kw">let</span> <span class="ident">PatKind</span>::<span class="ident">Binding</span>(_, _, <span class="kw-2">ref</span> <span class="ident">path1</span>, _) <span class="op">=</span> <span class="ident">p</span>.<span class="ident">node</span> {
            <span class="kw">let</span> <span class="ident">var_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">assign</span>(<span class="ident">p</span>.<span class="ident">span</span>, <span class="ident">p</span>.<span class="ident">id</span>, <span class="prelude-val">None</span>);

            <span class="self">self</span>.<span class="ident">fcx</span>.<span class="ident">require_type_is_sized</span>(<span class="ident">var_ty</span>, <span class="ident">p</span>.<span class="ident">span</span>,
                                           <span class="ident">traits</span>::<span class="ident">VariableType</span>(<span class="ident">p</span>.<span class="ident">id</span>));

            <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;Pattern binding {} is assigned to {} with type {:?}&quot;</span>,
                   <span class="ident">path1</span>.<span class="ident">node</span>,
                   <span class="self">self</span>.<span class="ident">fcx</span>.<span class="ident">ty_to_string</span>(
                       <span class="self">self</span>.<span class="ident">fcx</span>.<span class="ident">locals</span>.<span class="ident">borrow</span>().<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">id</span>).<span class="ident">unwrap</span>().<span class="ident">clone</span>()),
                   <span class="ident">var_ty</span>);
        }
        <span class="ident">intravisit</span>::<span class="ident">walk_pat</span>(<span class="self">self</span>, <span class="ident">p</span>);
    }

    <span class="comment">// Don&#39;t descend into the bodies of nested closures</span>
    <span class="kw">fn</span> <span class="ident">visit_fn</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, _: <span class="ident">intravisit</span>::<span class="ident">FnKind</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span><span class="op">&gt;</span>, _: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">FnDecl</span>,
                _: <span class="ident">hir</span>::<span class="ident">BodyId</span>, _: <span class="ident">Span</span>, _: <span class="ident">ast</span>::<span class="ident">NodeId</span>) { }
}

<span class="doccomment">/// Helper used for fns and closures. Does the grungy work of checking a function</span>
<span class="doccomment">/// body and returns the function context used for that purpose, since in the case of a fn item</span>
<span class="doccomment">/// there is still a bit more to do.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// * ...</span>
<span class="doccomment">/// * inherited: other fields inherited from the enclosing fn (if any)</span>
<span class="kw">fn</span> <span class="ident">check_fn</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">inherited</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Inherited</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                            <span class="ident">param_env</span>: <span class="ident">ty</span>::<span class="ident">ParamEnv</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                            <span class="ident">fn_sig</span>: <span class="ident">ty</span>::<span class="ident">FnSig</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                            <span class="ident">decl</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">FnDecl</span>,
                            <span class="ident">fn_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>,
                            <span class="ident">body</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Body</span>,
                            <span class="ident">can_be_generator</span>: <span class="ident">bool</span>)
                            <span class="op">-&gt;</span> (<span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ty</span>::<span class="ident">GeneratorInterior</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>)
{
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fn_sig</span> <span class="op">=</span> <span class="ident">fn_sig</span>.<span class="ident">clone</span>();

    <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;check_fn(sig={:?}, fn_id={}, param_env={:?})&quot;</span>, <span class="ident">fn_sig</span>, <span class="ident">fn_id</span>, <span class="ident">param_env</span>);

    <span class="comment">// Create the function context.  This is either derived from scratch or,</span>
    <span class="comment">// in the case of function expressions, based on the outer context.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fcx</span> <span class="op">=</span> <span class="ident">FnCtxt</span>::<span class="ident">new</span>(<span class="ident">inherited</span>, <span class="ident">param_env</span>, <span class="ident">body</span>.<span class="ident">value</span>.<span class="ident">id</span>);
    <span class="kw-2">*</span><span class="ident">fcx</span>.<span class="ident">ps</span>.<span class="ident">borrow_mut</span>() <span class="op">=</span> <span class="ident">UnsafetyState</span>::<span class="ident">function</span>(<span class="ident">fn_sig</span>.<span class="ident">unsafety</span>, <span class="ident">fn_id</span>);

    <span class="kw">let</span> <span class="ident">ret_ty</span> <span class="op">=</span> <span class="ident">fn_sig</span>.<span class="ident">output</span>();
    <span class="ident">fcx</span>.<span class="ident">require_type_is_sized</span>(<span class="ident">ret_ty</span>, <span class="ident">decl</span>.<span class="ident">output</span>.<span class="ident">span</span>(), <span class="ident">traits</span>::<span class="ident">SizedReturnType</span>);
    <span class="kw">let</span> <span class="ident">ret_ty</span> <span class="op">=</span> <span class="ident">fcx</span>.<span class="ident">instantiate_anon_types</span>(<span class="kw-2">&amp;</span><span class="ident">ret_ty</span>);
    <span class="ident">fcx</span>.<span class="ident">ret_coercion</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="ident">CoerceMany</span>::<span class="ident">new</span>(<span class="ident">ret_ty</span>)));
    <span class="ident">fn_sig</span> <span class="op">=</span> <span class="ident">fcx</span>.<span class="ident">tcx</span>.<span class="ident">mk_fn_sig</span>(
        <span class="ident">fn_sig</span>.<span class="ident">inputs</span>().<span class="ident">iter</span>().<span class="ident">cloned</span>(),
        <span class="ident">ret_ty</span>,
        <span class="ident">fn_sig</span>.<span class="ident">variadic</span>,
        <span class="ident">fn_sig</span>.<span class="ident">unsafety</span>,
        <span class="ident">fn_sig</span>.<span class="ident">abi</span>
    );

    <span class="kw">let</span> <span class="ident">span</span> <span class="op">=</span> <span class="ident">body</span>.<span class="ident">value</span>.<span class="ident">span</span>;

    <span class="kw">if</span> <span class="ident">body</span>.<span class="ident">is_generator</span> <span class="op">&amp;&amp;</span> <span class="ident">can_be_generator</span> {
        <span class="ident">fcx</span>.<span class="ident">yield_ty</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">fcx</span>.<span class="ident">next_ty_var</span>(<span class="ident">TypeVariableOrigin</span>::<span class="ident">TypeInference</span>(<span class="ident">span</span>)));
    }

    <span class="ident">GatherLocalsVisitor</span> { <span class="ident">fcx</span>: <span class="kw-2">&amp;</span><span class="ident">fcx</span>, }.<span class="ident">visit_body</span>(<span class="ident">body</span>);

    <span class="comment">// Add formal parameters.</span>
    <span class="kw">for</span> (<span class="ident">arg_ty</span>, <span class="ident">arg</span>) <span class="kw">in</span> <span class="ident">fn_sig</span>.<span class="ident">inputs</span>().<span class="ident">iter</span>().<span class="ident">zip</span>(<span class="kw-2">&amp;</span><span class="ident">body</span>.<span class="ident">arguments</span>) {
        <span class="comment">// Check the pattern.</span>
        <span class="ident">fcx</span>.<span class="ident">check_pat_walk</span>(<span class="kw-2">&amp;</span><span class="ident">arg</span>.<span class="ident">pat</span>, <span class="ident">arg_ty</span>,
            <span class="ident">ty</span>::<span class="ident">BindingMode</span>::<span class="ident">BindByValue</span>(<span class="ident">hir</span>::<span class="ident">Mutability</span>::<span class="ident">MutImmutable</span>), <span class="bool-val">true</span>);

        <span class="comment">// Check that argument is Sized.</span>
        <span class="comment">// The check for a non-trivial pattern is a hack to avoid duplicate warnings</span>
        <span class="comment">// for simple cases like `fn foo(x: Trait)`,</span>
        <span class="comment">// where we would error once on the parameter as a whole, and once on the binding `x`.</span>
        <span class="kw">if</span> <span class="ident">arg</span>.<span class="ident">pat</span>.<span class="ident">simple_name</span>().<span class="ident">is_none</span>() {
            <span class="ident">fcx</span>.<span class="ident">require_type_is_sized</span>(<span class="ident">arg_ty</span>, <span class="ident">decl</span>.<span class="ident">output</span>.<span class="ident">span</span>(), <span class="ident">traits</span>::<span class="ident">MiscObligation</span>);
        }

        <span class="ident">fcx</span>.<span class="ident">write_ty</span>(<span class="ident">arg</span>.<span class="ident">hir_id</span>, <span class="ident">arg_ty</span>);
    }

    <span class="kw">let</span> <span class="ident">fn_hir_id</span> <span class="op">=</span> <span class="ident">fcx</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">node_to_hir_id</span>(<span class="ident">fn_id</span>);
    <span class="kw">let</span> <span class="ident">gen_ty</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">can_be_generator</span> <span class="op">&amp;&amp;</span> <span class="ident">body</span>.<span class="ident">is_generator</span> {
        <span class="kw">let</span> <span class="ident">gen_sig</span> <span class="op">=</span> <span class="ident">ty</span>::<span class="ident">GenSig</span> {
            <span class="ident">yield_ty</span>: <span class="ident">fcx</span>.<span class="ident">yield_ty</span>.<span class="ident">unwrap</span>(),
            <span class="ident">return_ty</span>: <span class="ident">ret_ty</span>,
        };
        <span class="ident">inherited</span>.<span class="ident">tables</span>.<span class="ident">borrow_mut</span>().<span class="ident">generator_sigs_mut</span>().<span class="ident">insert</span>(<span class="ident">fn_hir_id</span>, <span class="prelude-val">Some</span>(<span class="ident">gen_sig</span>));

        <span class="kw">let</span> <span class="ident">witness</span> <span class="op">=</span> <span class="ident">fcx</span>.<span class="ident">next_ty_var</span>(<span class="ident">TypeVariableOrigin</span>::<span class="ident">MiscVariable</span>(<span class="ident">span</span>));
        <span class="ident">fcx</span>.<span class="ident">deferred_generator_interiors</span>.<span class="ident">borrow_mut</span>().<span class="ident">push</span>((<span class="ident">body</span>.<span class="ident">id</span>(), <span class="ident">witness</span>));
        <span class="kw">let</span> <span class="ident">interior</span> <span class="op">=</span> <span class="ident">ty</span>::<span class="ident">GeneratorInterior</span>::<span class="ident">new</span>(<span class="ident">witness</span>);

        <span class="ident">inherited</span>.<span class="ident">tables</span>.<span class="ident">borrow_mut</span>().<span class="ident">generator_interiors_mut</span>().<span class="ident">insert</span>(<span class="ident">fn_hir_id</span>, <span class="ident">interior</span>);

        <span class="prelude-val">Some</span>(<span class="ident">interior</span>)
    } <span class="kw">else</span> {
        <span class="ident">inherited</span>.<span class="ident">tables</span>.<span class="ident">borrow_mut</span>().<span class="ident">generator_sigs_mut</span>().<span class="ident">insert</span>(<span class="ident">fn_hir_id</span>, <span class="prelude-val">None</span>);
        <span class="prelude-val">None</span>
    };
    <span class="ident">inherited</span>.<span class="ident">tables</span>.<span class="ident">borrow_mut</span>().<span class="ident">liberated_fn_sigs_mut</span>().<span class="ident">insert</span>(<span class="ident">fn_hir_id</span>, <span class="ident">fn_sig</span>);

    <span class="ident">fcx</span>.<span class="ident">check_return_expr</span>(<span class="kw-2">&amp;</span><span class="ident">body</span>.<span class="ident">value</span>);

    <span class="comment">// Finalize the return check by taking the LUB of the return types</span>
    <span class="comment">// we saw and assigning it to the expected return type. This isn&#39;t</span>
    <span class="comment">// really expected to fail, since the coercions would have failed</span>
    <span class="comment">// earlier when trying to find a LUB.</span>
    <span class="comment">//</span>
    <span class="comment">// However, the behavior around `!` is sort of complex. In the</span>
    <span class="comment">// event that the `actual_return_ty` comes back as `!`, that</span>
    <span class="comment">// indicates that the fn either does not return or &quot;returns&quot; only</span>
    <span class="comment">// values of type `!`. In this case, if there is an expected</span>
    <span class="comment">// return type that is *not* `!`, that should be ok. But if the</span>
    <span class="comment">// return type is being inferred, we want to &quot;fallback&quot; to `!`:</span>
    <span class="comment">//</span>
    <span class="comment">//     let x = move || panic!();</span>
    <span class="comment">//</span>
    <span class="comment">// To allow for that, I am creating a type variable with diverging</span>
    <span class="comment">// fallback. This was deemed ever so slightly better than unifying</span>
    <span class="comment">// the return value with `!` because it allows for the caller to</span>
    <span class="comment">// make more assumptions about the return type (e.g., they could do</span>
    <span class="comment">//</span>
    <span class="comment">//     let y: Option&lt;u32&gt; = Some(x());</span>
    <span class="comment">//</span>
    <span class="comment">// which would then cause this return type to become `u32`, not</span>
    <span class="comment">// `!`).</span>
    <span class="kw">let</span> <span class="ident">coercion</span> <span class="op">=</span> <span class="ident">fcx</span>.<span class="ident">ret_coercion</span>.<span class="ident">take</span>().<span class="ident">unwrap</span>().<span class="ident">into_inner</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">actual_return_ty</span> <span class="op">=</span> <span class="ident">coercion</span>.<span class="ident">complete</span>(<span class="kw-2">&amp;</span><span class="ident">fcx</span>);
    <span class="kw">if</span> <span class="ident">actual_return_ty</span>.<span class="ident">is_never</span>() {
        <span class="ident">actual_return_ty</span> <span class="op">=</span> <span class="ident">fcx</span>.<span class="ident">next_diverging_ty_var</span>(
            <span class="ident">TypeVariableOrigin</span>::<span class="ident">DivergingFn</span>(<span class="ident">span</span>));
    }
    <span class="ident">fcx</span>.<span class="ident">demand_suptype</span>(<span class="ident">span</span>, <span class="ident">ret_ty</span>, <span class="ident">actual_return_ty</span>);

    (<span class="ident">fcx</span>, <span class="ident">gen_ty</span>)
}

<span class="kw">fn</span> <span class="ident">check_struct</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                          <span class="ident">id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>,
                          <span class="ident">span</span>: <span class="ident">Span</span>) {
    <span class="kw">let</span> <span class="ident">def_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">id</span>);
    <span class="kw">let</span> <span class="ident">def</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">adt_def</span>(<span class="ident">def_id</span>);
    <span class="ident">def</span>.<span class="ident">destructor</span>(<span class="ident">tcx</span>); <span class="comment">// force the destructor to be evaluated</span>
    <span class="ident">check_representable</span>(<span class="ident">tcx</span>, <span class="ident">span</span>, <span class="ident">def_id</span>);

    <span class="kw">if</span> <span class="ident">def</span>.<span class="ident">repr</span>.<span class="ident">simd</span>() {
        <span class="ident">check_simd</span>(<span class="ident">tcx</span>, <span class="ident">span</span>, <span class="ident">def_id</span>);
    }

    <span class="ident">check_packed</span>(<span class="ident">tcx</span>, <span class="ident">span</span>, <span class="ident">def_id</span>);
}

<span class="kw">fn</span> <span class="ident">check_union</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                         <span class="ident">id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>,
                         <span class="ident">span</span>: <span class="ident">Span</span>) {
    <span class="kw">let</span> <span class="ident">def_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">id</span>);
    <span class="kw">let</span> <span class="ident">def</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">adt_def</span>(<span class="ident">def_id</span>);
    <span class="ident">def</span>.<span class="ident">destructor</span>(<span class="ident">tcx</span>); <span class="comment">// force the destructor to be evaluated</span>
    <span class="ident">check_representable</span>(<span class="ident">tcx</span>, <span class="ident">span</span>, <span class="ident">def_id</span>);

    <span class="ident">check_packed</span>(<span class="ident">tcx</span>, <span class="ident">span</span>, <span class="ident">def_id</span>);
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_item_type</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>,<span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">it</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">hir</span>::<span class="ident">Item</span>) {
    <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;check_item_type(it.id={}, it.name={})&quot;</span>,
           <span class="ident">it</span>.<span class="ident">id</span>,
           <span class="ident">tcx</span>.<span class="ident">item_path_str</span>(<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">it</span>.<span class="ident">id</span>)));
    <span class="kw">let</span> <span class="ident">_indenter</span> <span class="op">=</span> <span class="ident">indenter</span>();
    <span class="kw">match</span> <span class="ident">it</span>.<span class="ident">node</span> {
      <span class="comment">// Consts can play a role in type-checking, so they are included here.</span>
      <span class="ident">hir</span>::<span class="ident">ItemStatic</span>(..) <span class="op">|</span>
      <span class="ident">hir</span>::<span class="ident">ItemConst</span>(..) <span class="op">=&gt;</span> {
        <span class="ident">tcx</span>.<span class="ident">typeck_tables_of</span>(<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">it</span>.<span class="ident">id</span>));
      }
      <span class="ident">hir</span>::<span class="ident">ItemEnum</span>(<span class="kw-2">ref</span> <span class="ident">enum_definition</span>, _) <span class="op">=&gt;</span> {
        <span class="ident">check_enum</span>(<span class="ident">tcx</span>,
                   <span class="ident">it</span>.<span class="ident">span</span>,
                   <span class="kw-2">&amp;</span><span class="ident">enum_definition</span>.<span class="ident">variants</span>,
                   <span class="ident">it</span>.<span class="ident">id</span>);
      }
      <span class="ident">hir</span>::<span class="ident">ItemFn</span>(..) <span class="op">=&gt;</span> {} <span class="comment">// entirely within check_item_body</span>
      <span class="ident">hir</span>::<span class="ident">ItemImpl</span>(.., <span class="kw-2">ref</span> <span class="ident">impl_item_refs</span>) <span class="op">=&gt;</span> {
          <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;ItemImpl {} with id {}&quot;</span>, <span class="ident">it</span>.<span class="ident">name</span>, <span class="ident">it</span>.<span class="ident">id</span>);
          <span class="kw">let</span> <span class="ident">impl_def_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">it</span>.<span class="ident">id</span>);
          <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">impl_trait_ref</span>) <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">impl_trait_ref</span>(<span class="ident">impl_def_id</span>) {
              <span class="ident">check_impl_items_against_trait</span>(<span class="ident">tcx</span>,
                                             <span class="ident">it</span>.<span class="ident">span</span>,
                                             <span class="ident">impl_def_id</span>,
                                             <span class="ident">impl_trait_ref</span>,
                                             <span class="ident">impl_item_refs</span>);
              <span class="kw">let</span> <span class="ident">trait_def_id</span> <span class="op">=</span> <span class="ident">impl_trait_ref</span>.<span class="ident">def_id</span>;
              <span class="ident">check_on_unimplemented</span>(<span class="ident">tcx</span>, <span class="ident">trait_def_id</span>, <span class="ident">it</span>);
          }
      }
      <span class="ident">hir</span>::<span class="ident">ItemTrait</span>(..) <span class="op">=&gt;</span> {
        <span class="kw">let</span> <span class="ident">def_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">it</span>.<span class="ident">id</span>);
        <span class="ident">check_on_unimplemented</span>(<span class="ident">tcx</span>, <span class="ident">def_id</span>, <span class="ident">it</span>);
      }
      <span class="ident">hir</span>::<span class="ident">ItemStruct</span>(..) <span class="op">=&gt;</span> {
        <span class="ident">check_struct</span>(<span class="ident">tcx</span>, <span class="ident">it</span>.<span class="ident">id</span>, <span class="ident">it</span>.<span class="ident">span</span>);
      }
      <span class="ident">hir</span>::<span class="ident">ItemUnion</span>(..) <span class="op">=&gt;</span> {
        <span class="ident">check_union</span>(<span class="ident">tcx</span>, <span class="ident">it</span>.<span class="ident">id</span>, <span class="ident">it</span>.<span class="ident">span</span>);
      }
      <span class="ident">hir</span>::<span class="ident">ItemTy</span>(_, <span class="kw-2">ref</span> <span class="ident">generics</span>) <span class="op">=&gt;</span> {
        <span class="kw">let</span> <span class="ident">def_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">it</span>.<span class="ident">id</span>);
        <span class="kw">let</span> <span class="ident">pty_ty</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">type_of</span>(<span class="ident">def_id</span>);
        <span class="ident">check_bounds_are_used</span>(<span class="ident">tcx</span>, <span class="ident">generics</span>, <span class="ident">pty_ty</span>);
      }
      <span class="ident">hir</span>::<span class="ident">ItemForeignMod</span>(<span class="kw-2">ref</span> <span class="ident">m</span>) <span class="op">=&gt;</span> {
        <span class="ident">check_abi</span>(<span class="ident">tcx</span>, <span class="ident">it</span>.<span class="ident">span</span>, <span class="ident">m</span>.<span class="ident">abi</span>);

        <span class="kw">if</span> <span class="ident">m</span>.<span class="ident">abi</span> <span class="op">==</span> <span class="ident">Abi</span>::<span class="ident">RustIntrinsic</span> {
            <span class="kw">for</span> <span class="ident">item</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">m</span>.<span class="ident">items</span> {
                <span class="ident">intrinsic</span>::<span class="ident">check_intrinsic_type</span>(<span class="ident">tcx</span>, <span class="ident">item</span>);
            }
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">m</span>.<span class="ident">abi</span> <span class="op">==</span> <span class="ident">Abi</span>::<span class="ident">PlatformIntrinsic</span> {
            <span class="kw">for</span> <span class="ident">item</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">m</span>.<span class="ident">items</span> {
                <span class="ident">intrinsic</span>::<span class="ident">check_platform_intrinsic_type</span>(<span class="ident">tcx</span>, <span class="ident">item</span>);
            }
        } <span class="kw">else</span> {
            <span class="kw">for</span> <span class="ident">item</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">m</span>.<span class="ident">items</span> {
                <span class="kw">let</span> <span class="ident">generics</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">generics_of</span>(<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">item</span>.<span class="ident">id</span>));
                <span class="kw">if</span> <span class="op">!</span><span class="ident">generics</span>.<span class="ident">types</span>.<span class="ident">is_empty</span>() {
                    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">item</span>.<span class="ident">span</span>, <span class="ident">E0044</span>,
                        <span class="string">&quot;foreign items may not have type parameters&quot;</span>);
                    <span class="macro">span_help</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">err</span>, <span class="ident">item</span>.<span class="ident">span</span>,
                        <span class="string">&quot;consider using specialization instead of \
                        type parameters&quot;</span>);
                    <span class="ident">err</span>.<span class="ident">emit</span>();
                }

                <span class="kw">if</span> <span class="kw">let</span> <span class="ident">hir</span>::<span class="ident">ForeignItemFn</span>(<span class="kw-2">ref</span> <span class="ident">fn_decl</span>, _, _) <span class="op">=</span> <span class="ident">item</span>.<span class="ident">node</span> {
                    <span class="ident">require_c_abi_if_variadic</span>(<span class="ident">tcx</span>, <span class="ident">fn_decl</span>, <span class="ident">m</span>.<span class="ident">abi</span>, <span class="ident">item</span>.<span class="ident">span</span>);
                }
            }
        }
      }
      _ <span class="op">=&gt;</span> {<span class="comment">/* nothing to do */</span> }
    }
}

<span class="kw">fn</span> <span class="ident">check_on_unimplemented</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                    <span class="ident">trait_def_id</span>: <span class="ident">DefId</span>,
                                    <span class="ident">item</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Item</span>) {
    <span class="kw">let</span> <span class="ident">item_def_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">item</span>.<span class="ident">id</span>);
    <span class="comment">// an error would be reported if this fails.</span>
    <span class="kw">let</span> _ <span class="op">=</span> <span class="ident">traits</span>::<span class="ident">OnUnimplementedDirective</span>::<span class="ident">of_item</span>(<span class="ident">tcx</span>, <span class="ident">trait_def_id</span>, <span class="ident">item_def_id</span>);
}

<span class="kw">fn</span> <span class="ident">report_forbidden_specialization</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                             <span class="ident">impl_item</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">ImplItem</span>,
                                             <span class="ident">parent_impl</span>: <span class="ident">DefId</span>)
{
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="macro">struct_span_err</span><span class="macro">!</span>(
        <span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">impl_item</span>.<span class="ident">span</span>, <span class="ident">E0520</span>,
        <span class="string">&quot;`{}` specializes an item from a parent `impl`, but \
         that item is not marked `default`&quot;</span>,
        <span class="ident">impl_item</span>.<span class="ident">name</span>);
    <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">impl_item</span>.<span class="ident">span</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;cannot specialize default item `{}`&quot;</span>,
                                            <span class="ident">impl_item</span>.<span class="ident">name</span>));

    <span class="kw">match</span> <span class="ident">tcx</span>.<span class="ident">span_of_impl</span>(<span class="ident">parent_impl</span>) {
        <span class="prelude-val">Ok</span>(<span class="ident">span</span>) <span class="op">=&gt;</span> {
            <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">span</span>, <span class="string">&quot;parent `impl` is here&quot;</span>);
            <span class="ident">err</span>.<span class="ident">note</span>(<span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;to specialize, `{}` in the parent `impl` must be marked `default`&quot;</span>,
                              <span class="ident">impl_item</span>.<span class="ident">name</span>));
        }
        <span class="prelude-val">Err</span>(<span class="ident">cname</span>) <span class="op">=&gt;</span> {
            <span class="ident">err</span>.<span class="ident">note</span>(<span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;parent implementation is in crate `{}`&quot;</span>, <span class="ident">cname</span>));
        }
    }

    <span class="ident">err</span>.<span class="ident">emit</span>();
}

<span class="kw">fn</span> <span class="ident">check_specialization_validity</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                           <span class="ident">trait_def</span>: <span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">TraitDef</span>,
                                           <span class="ident">trait_item</span>: <span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">AssociatedItem</span>,
                                           <span class="ident">impl_id</span>: <span class="ident">DefId</span>,
                                           <span class="ident">impl_item</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">ImplItem</span>)
{
    <span class="kw">let</span> <span class="ident">ancestors</span> <span class="op">=</span> <span class="ident">trait_def</span>.<span class="ident">ancestors</span>(<span class="ident">tcx</span>, <span class="ident">impl_id</span>);

    <span class="kw">let</span> <span class="ident">kind</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">impl_item</span>.<span class="ident">node</span> {
        <span class="ident">hir</span>::<span class="ident">ImplItemKind</span>::<span class="ident">Const</span>(..) <span class="op">=&gt;</span> <span class="ident">ty</span>::<span class="ident">AssociatedKind</span>::<span class="ident">Const</span>,
        <span class="ident">hir</span>::<span class="ident">ImplItemKind</span>::<span class="ident">Method</span>(..) <span class="op">=&gt;</span> <span class="ident">ty</span>::<span class="ident">AssociatedKind</span>::<span class="ident">Method</span>,
        <span class="ident">hir</span>::<span class="ident">ImplItemKind</span>::<span class="ident">Type</span>(_) <span class="op">=&gt;</span> <span class="ident">ty</span>::<span class="ident">AssociatedKind</span>::<span class="ident">Type</span>
    };

    <span class="kw">let</span> <span class="ident">parent</span> <span class="op">=</span> <span class="ident">ancestors</span>.<span class="ident">defs</span>(<span class="ident">tcx</span>, <span class="ident">trait_item</span>.<span class="ident">name</span>, <span class="ident">kind</span>, <span class="ident">trait_def</span>.<span class="ident">def_id</span>).<span class="ident">skip</span>(<span class="number">1</span>).<span class="ident">next</span>()
        .<span class="ident">map</span>(<span class="op">|</span><span class="ident">node_item</span><span class="op">|</span> <span class="ident">node_item</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">parent</span><span class="op">|</span> <span class="ident">parent</span>.<span class="ident">defaultness</span>));

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">parent</span>) <span class="op">=</span> <span class="ident">parent</span> {
        <span class="kw">if</span> <span class="ident">tcx</span>.<span class="ident">impl_item_is_final</span>(<span class="kw-2">&amp;</span><span class="ident">parent</span>) {
            <span class="ident">report_forbidden_specialization</span>(<span class="ident">tcx</span>, <span class="ident">impl_item</span>, <span class="ident">parent</span>.<span class="ident">node</span>.<span class="ident">def_id</span>());
        }
    }

}

<span class="kw">fn</span> <span class="ident">check_impl_items_against_trait</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                            <span class="ident">impl_span</span>: <span class="ident">Span</span>,
                                            <span class="ident">impl_id</span>: <span class="ident">DefId</span>,
                                            <span class="ident">impl_trait_ref</span>: <span class="ident">ty</span>::<span class="ident">TraitRef</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                            <span class="ident">impl_item_refs</span>: <span class="kw-2">&amp;</span>[<span class="ident">hir</span>::<span class="ident">ImplItemRef</span>]) {
    <span class="comment">// If the trait reference itself is erroneous (so the compilation is going</span>
    <span class="comment">// to fail), skip checking the items here -- the `impl_item` table in `tcx`</span>
    <span class="comment">// isn&#39;t populated for such impls.</span>
    <span class="kw">if</span> <span class="ident">impl_trait_ref</span>.<span class="ident">references_error</span>() { <span class="kw">return</span>; }

    <span class="comment">// Locate trait definition and items</span>
    <span class="kw">let</span> <span class="ident">trait_def</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">trait_def</span>(<span class="ident">impl_trait_ref</span>.<span class="ident">def_id</span>);
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">overridden_associated_type</span> <span class="op">=</span> <span class="prelude-val">None</span>;

    <span class="kw">let</span> <span class="ident">impl_items</span> <span class="op">=</span> <span class="op">||</span> <span class="ident">impl_item_refs</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">iiref</span><span class="op">|</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">impl_item</span>(<span class="ident">iiref</span>.<span class="ident">id</span>));

    <span class="comment">// Check existing impl methods to see if they are both present in trait</span>
    <span class="comment">// and compatible with trait signature</span>
    <span class="kw">for</span> <span class="ident">impl_item</span> <span class="kw">in</span> <span class="ident">impl_items</span>() {
        <span class="kw">let</span> <span class="ident">ty_impl_item</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">associated_item</span>(<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">impl_item</span>.<span class="ident">id</span>));
        <span class="kw">let</span> <span class="ident">ty_trait_item</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">associated_items</span>(<span class="ident">impl_trait_ref</span>.<span class="ident">def_id</span>)
            .<span class="ident">find</span>(<span class="op">|</span><span class="ident">ac</span><span class="op">|</span> <span class="ident">Namespace</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span><span class="ident">impl_item</span>.<span class="ident">node</span>) <span class="op">==</span> <span class="ident">Namespace</span>::<span class="ident">from</span>(<span class="ident">ac</span>.<span class="ident">kind</span>) <span class="op">&amp;&amp;</span>
                         <span class="ident">tcx</span>.<span class="ident">hygienic_eq</span>(<span class="ident">ty_impl_item</span>.<span class="ident">name</span>, <span class="ident">ac</span>.<span class="ident">name</span>, <span class="ident">impl_trait_ref</span>.<span class="ident">def_id</span>))
            .<span class="ident">or_else</span>(<span class="op">||</span> {
                <span class="comment">// Not compatible, but needed for the error message</span>
                <span class="ident">tcx</span>.<span class="ident">associated_items</span>(<span class="ident">impl_trait_ref</span>.<span class="ident">def_id</span>)
                   .<span class="ident">find</span>(<span class="op">|</span><span class="ident">ac</span><span class="op">|</span> <span class="ident">tcx</span>.<span class="ident">hygienic_eq</span>(<span class="ident">ty_impl_item</span>.<span class="ident">name</span>, <span class="ident">ac</span>.<span class="ident">name</span>, <span class="ident">impl_trait_ref</span>.<span class="ident">def_id</span>))
            });

        <span class="comment">// Check that impl definition matches trait definition</span>
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">ty_trait_item</span>) <span class="op">=</span> <span class="ident">ty_trait_item</span> {
            <span class="kw">match</span> <span class="ident">impl_item</span>.<span class="ident">node</span> {
                <span class="ident">hir</span>::<span class="ident">ImplItemKind</span>::<span class="ident">Const</span>(..) <span class="op">=&gt;</span> {
                    <span class="comment">// Find associated const definition.</span>
                    <span class="kw">if</span> <span class="ident">ty_trait_item</span>.<span class="ident">kind</span> <span class="op">==</span> <span class="ident">ty</span>::<span class="ident">AssociatedKind</span>::<span class="ident">Const</span> {
                        <span class="ident">compare_const_impl</span>(<span class="ident">tcx</span>,
                                           <span class="kw-2">&amp;</span><span class="ident">ty_impl_item</span>,
                                           <span class="ident">impl_item</span>.<span class="ident">span</span>,
                                           <span class="kw-2">&amp;</span><span class="ident">ty_trait_item</span>,
                                           <span class="ident">impl_trait_ref</span>);
                    } <span class="kw">else</span> {
                         <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">impl_item</span>.<span class="ident">span</span>, <span class="ident">E0323</span>,
                                  <span class="string">&quot;item `{}` is an associated const, \
                                  which doesn&#39;t match its trait `{}`&quot;</span>,
                                  <span class="ident">ty_impl_item</span>.<span class="ident">name</span>,
                                  <span class="ident">impl_trait_ref</span>);
                         <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">impl_item</span>.<span class="ident">span</span>, <span class="string">&quot;does not match trait&quot;</span>);
                         <span class="comment">// We can only get the spans from local trait definition</span>
                         <span class="comment">// Same for E0324 and E0325</span>
                         <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">trait_span</span>) <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">span_if_local</span>(<span class="ident">ty_trait_item</span>.<span class="ident">def_id</span>) {
                            <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">trait_span</span>, <span class="string">&quot;item in trait&quot;</span>);
                         }
                         <span class="ident">err</span>.<span class="ident">emit</span>()
                    }
                }
                <span class="ident">hir</span>::<span class="ident">ImplItemKind</span>::<span class="ident">Method</span>(..) <span class="op">=&gt;</span> {
                    <span class="kw">let</span> <span class="ident">trait_span</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">span_if_local</span>(<span class="ident">ty_trait_item</span>.<span class="ident">def_id</span>);
                    <span class="kw">if</span> <span class="ident">ty_trait_item</span>.<span class="ident">kind</span> <span class="op">==</span> <span class="ident">ty</span>::<span class="ident">AssociatedKind</span>::<span class="ident">Method</span> {
                        <span class="kw">let</span> <span class="ident">err_count</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">err_count</span>();
                        <span class="ident">compare_impl_method</span>(<span class="ident">tcx</span>,
                                            <span class="kw-2">&amp;</span><span class="ident">ty_impl_item</span>,
                                            <span class="ident">impl_item</span>.<span class="ident">span</span>,
                                            <span class="kw-2">&amp;</span><span class="ident">ty_trait_item</span>,
                                            <span class="ident">impl_trait_ref</span>,
                                            <span class="ident">trait_span</span>,
                                            <span class="bool-val">true</span>); <span class="comment">// start with old-broken-mode</span>
                        <span class="kw">if</span> <span class="ident">err_count</span> <span class="op">==</span> <span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">err_count</span>() {
                            <span class="comment">// old broken mode did not report an error. Try with the new mode.</span>
                            <span class="ident">compare_impl_method</span>(<span class="ident">tcx</span>,
                                                <span class="kw-2">&amp;</span><span class="ident">ty_impl_item</span>,
                                                <span class="ident">impl_item</span>.<span class="ident">span</span>,
                                                <span class="kw-2">&amp;</span><span class="ident">ty_trait_item</span>,
                                                <span class="ident">impl_trait_ref</span>,
                                                <span class="ident">trait_span</span>,
                                                <span class="bool-val">false</span>); <span class="comment">// use the new mode</span>
                        }
                    } <span class="kw">else</span> {
                        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">impl_item</span>.<span class="ident">span</span>, <span class="ident">E0324</span>,
                                  <span class="string">&quot;item `{}` is an associated method, \
                                  which doesn&#39;t match its trait `{}`&quot;</span>,
                                  <span class="ident">ty_impl_item</span>.<span class="ident">name</span>,
                                  <span class="ident">impl_trait_ref</span>);
                         <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">impl_item</span>.<span class="ident">span</span>, <span class="string">&quot;does not match trait&quot;</span>);
                         <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">trait_span</span>) <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">span_if_local</span>(<span class="ident">ty_trait_item</span>.<span class="ident">def_id</span>) {
                            <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">trait_span</span>, <span class="string">&quot;item in trait&quot;</span>);
                         }
                         <span class="ident">err</span>.<span class="ident">emit</span>()
                    }
                }
                <span class="ident">hir</span>::<span class="ident">ImplItemKind</span>::<span class="ident">Type</span>(_) <span class="op">=&gt;</span> {
                    <span class="kw">if</span> <span class="ident">ty_trait_item</span>.<span class="ident">kind</span> <span class="op">==</span> <span class="ident">ty</span>::<span class="ident">AssociatedKind</span>::<span class="ident">Type</span> {
                        <span class="kw">if</span> <span class="ident">ty_trait_item</span>.<span class="ident">defaultness</span>.<span class="ident">has_value</span>() {
                            <span class="ident">overridden_associated_type</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">impl_item</span>);
                        }
                    } <span class="kw">else</span> {
                        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">impl_item</span>.<span class="ident">span</span>, <span class="ident">E0325</span>,
                                  <span class="string">&quot;item `{}` is an associated type, \
                                  which doesn&#39;t match its trait `{}`&quot;</span>,
                                  <span class="ident">ty_impl_item</span>.<span class="ident">name</span>,
                                  <span class="ident">impl_trait_ref</span>);
                         <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">impl_item</span>.<span class="ident">span</span>, <span class="string">&quot;does not match trait&quot;</span>);
                         <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">trait_span</span>) <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">span_if_local</span>(<span class="ident">ty_trait_item</span>.<span class="ident">def_id</span>) {
                            <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">trait_span</span>, <span class="string">&quot;item in trait&quot;</span>);
                         }
                         <span class="ident">err</span>.<span class="ident">emit</span>()
                    }
                }
            }

            <span class="ident">check_specialization_validity</span>(<span class="ident">tcx</span>, <span class="ident">trait_def</span>, <span class="kw-2">&amp;</span><span class="ident">ty_trait_item</span>, <span class="ident">impl_id</span>, <span class="ident">impl_item</span>);
        }
    }

    <span class="comment">// Check for missing items from trait</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">missing_items</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">invalidated_items</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();
    <span class="kw">let</span> <span class="ident">associated_type_overridden</span> <span class="op">=</span> <span class="ident">overridden_associated_type</span>.<span class="ident">is_some</span>();
    <span class="kw">for</span> <span class="ident">trait_item</span> <span class="kw">in</span> <span class="ident">tcx</span>.<span class="ident">associated_items</span>(<span class="ident">impl_trait_ref</span>.<span class="ident">def_id</span>) {
        <span class="kw">let</span> <span class="ident">is_implemented</span> <span class="op">=</span> <span class="ident">trait_def</span>.<span class="ident">ancestors</span>(<span class="ident">tcx</span>, <span class="ident">impl_id</span>)
            .<span class="ident">defs</span>(<span class="ident">tcx</span>, <span class="ident">trait_item</span>.<span class="ident">name</span>, <span class="ident">trait_item</span>.<span class="ident">kind</span>, <span class="ident">impl_trait_ref</span>.<span class="ident">def_id</span>)
            .<span class="ident">next</span>()
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">node_item</span><span class="op">|</span> <span class="op">!</span><span class="ident">node_item</span>.<span class="ident">node</span>.<span class="ident">is_from_trait</span>())
            .<span class="ident">unwrap_or</span>(<span class="bool-val">false</span>);

        <span class="kw">if</span> <span class="op">!</span><span class="ident">is_implemented</span> {
            <span class="kw">if</span> <span class="op">!</span><span class="ident">trait_item</span>.<span class="ident">defaultness</span>.<span class="ident">has_value</span>() {
                <span class="ident">missing_items</span>.<span class="ident">push</span>(<span class="ident">trait_item</span>);
            } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">associated_type_overridden</span> {
                <span class="ident">invalidated_items</span>.<span class="ident">push</span>(<span class="ident">trait_item</span>.<span class="ident">name</span>);
            }
        }
    }

    <span class="kw">if</span> <span class="op">!</span><span class="ident">missing_items</span>.<span class="ident">is_empty</span>() {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">impl_span</span>, <span class="ident">E0046</span>,
            <span class="string">&quot;not all trait items implemented, missing: `{}`&quot;</span>,
            <span class="ident">missing_items</span>.<span class="ident">iter</span>()
                  .<span class="ident">map</span>(<span class="op">|</span><span class="ident">trait_item</span><span class="op">|</span> <span class="ident">trait_item</span>.<span class="ident">name</span>.<span class="ident">to_string</span>())
                  .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>().<span class="ident">join</span>(<span class="string">&quot;`, `&quot;</span>));
        <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">impl_span</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;missing `{}` in implementation&quot;</span>,
                <span class="ident">missing_items</span>.<span class="ident">iter</span>()
                    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">trait_item</span><span class="op">|</span> <span class="ident">trait_item</span>.<span class="ident">name</span>.<span class="ident">to_string</span>())
                    .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>().<span class="ident">join</span>(<span class="string">&quot;`, `&quot;</span>)));
        <span class="kw">for</span> <span class="ident">trait_item</span> <span class="kw">in</span> <span class="ident">missing_items</span> {
            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">span</span>) <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">span_if_local</span>(<span class="ident">trait_item</span>.<span class="ident">def_id</span>) {
                <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">span</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;`{}` from trait&quot;</span>, <span class="ident">trait_item</span>.<span class="ident">name</span>));
            } <span class="kw">else</span> {
                <span class="ident">err</span>.<span class="ident">note_trait_signature</span>(<span class="ident">trait_item</span>.<span class="ident">name</span>.<span class="ident">to_string</span>(),
                                         <span class="ident">trait_item</span>.<span class="ident">signature</span>(<span class="kw-2">&amp;</span><span class="ident">tcx</span>));
            }
        }
        <span class="ident">err</span>.<span class="ident">emit</span>();
    }

    <span class="kw">if</span> <span class="op">!</span><span class="ident">invalidated_items</span>.<span class="ident">is_empty</span>() {
        <span class="kw">let</span> <span class="ident">invalidator</span> <span class="op">=</span> <span class="ident">overridden_associated_type</span>.<span class="ident">unwrap</span>();
        <span class="macro">span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">invalidator</span>.<span class="ident">span</span>, <span class="ident">E0399</span>,
                  <span class="string">&quot;the following trait items need to be reimplemented \
                   as `{}` was overridden: `{}`&quot;</span>,
                  <span class="ident">invalidator</span>.<span class="ident">name</span>,
                  <span class="ident">invalidated_items</span>.<span class="ident">iter</span>()
                                   .<span class="ident">map</span>(<span class="op">|</span><span class="ident">name</span><span class="op">|</span> <span class="ident">name</span>.<span class="ident">to_string</span>())
                                   .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>().<span class="ident">join</span>(<span class="string">&quot;`, `&quot;</span>))
    }
}

<span class="doccomment">/// Checks whether a type can be represented in memory. In particular, it</span>
<span class="doccomment">/// identifies types that contain themselves without indirection through a</span>
<span class="doccomment">/// pointer, which would mean their size is unbounded.</span>
<span class="kw">fn</span> <span class="ident">check_representable</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                 <span class="ident">sp</span>: <span class="ident">Span</span>,
                                 <span class="ident">item_def_id</span>: <span class="ident">DefId</span>)
                                 <span class="op">-&gt;</span> <span class="ident">bool</span> {
    <span class="kw">let</span> <span class="ident">rty</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">type_of</span>(<span class="ident">item_def_id</span>);

    <span class="comment">// Check that it is possible to represent this type. This call identifies</span>
    <span class="comment">// (1) types that contain themselves and (2) types that contain a different</span>
    <span class="comment">// recursive type. It is only necessary to throw an error on those that</span>
    <span class="comment">// contain themselves. For case 2, there must be an inner type that will be</span>
    <span class="comment">// caught by case 1.</span>
    <span class="kw">match</span> <span class="ident">rty</span>.<span class="ident">is_representable</span>(<span class="ident">tcx</span>, <span class="ident">sp</span>) {
        <span class="ident">Representability</span>::<span class="ident">SelfRecursive</span>(<span class="ident">spans</span>) <span class="op">=&gt;</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">recursive_type_with_infinite_size_error</span>(<span class="ident">item_def_id</span>);
            <span class="kw">for</span> <span class="ident">span</span> <span class="kw">in</span> <span class="ident">spans</span> {
                <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">span</span>, <span class="string">&quot;recursive without indirection&quot;</span>);
            }
            <span class="ident">err</span>.<span class="ident">emit</span>();
            <span class="kw">return</span> <span class="bool-val">false</span>
        }
        <span class="ident">Representability</span>::<span class="ident">Representable</span> <span class="op">|</span> <span class="ident">Representability</span>::<span class="ident">ContainsRecursive</span> <span class="op">=&gt;</span> (),
    }
    <span class="kw">return</span> <span class="bool-val">true</span>
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_simd</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">sp</span>: <span class="ident">Span</span>, <span class="ident">def_id</span>: <span class="ident">DefId</span>) {
    <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">type_of</span>(<span class="ident">def_id</span>);
    <span class="kw">match</span> <span class="ident">t</span>.<span class="ident">sty</span> {
        <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">def</span>, <span class="ident">substs</span>) <span class="kw">if</span> <span class="ident">def</span>.<span class="ident">is_struct</span>() <span class="op">=&gt;</span> {
            <span class="kw">let</span> <span class="ident">fields</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">def</span>.<span class="ident">struct_variant</span>().<span class="ident">fields</span>;
            <span class="kw">if</span> <span class="ident">fields</span>.<span class="ident">is_empty</span>() {
                <span class="macro">span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">sp</span>, <span class="ident">E0075</span>, <span class="string">&quot;SIMD vector cannot be empty&quot;</span>);
                <span class="kw">return</span>;
            }
            <span class="kw">let</span> <span class="ident">e</span> <span class="op">=</span> <span class="ident">fields</span>[<span class="number">0</span>].<span class="ident">ty</span>(<span class="ident">tcx</span>, <span class="ident">substs</span>);
            <span class="kw">if</span> <span class="op">!</span><span class="ident">fields</span>.<span class="ident">iter</span>().<span class="ident">all</span>(<span class="op">|</span><span class="ident">f</span><span class="op">|</span> <span class="ident">f</span>.<span class="ident">ty</span>(<span class="ident">tcx</span>, <span class="ident">substs</span>) <span class="op">==</span> <span class="ident">e</span>) {
                <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">sp</span>, <span class="ident">E0076</span>, <span class="string">&quot;SIMD vector should be homogeneous&quot;</span>)
                                .<span class="ident">span_label</span>(<span class="ident">sp</span>, <span class="string">&quot;SIMD elements must have the same type&quot;</span>)
                                .<span class="ident">emit</span>();
                <span class="kw">return</span>;
            }
            <span class="kw">match</span> <span class="ident">e</span>.<span class="ident">sty</span> {
                <span class="ident">ty</span>::<span class="ident">TyParam</span>(_) <span class="op">=&gt;</span> { <span class="comment">/* struct&lt;T&gt;(T, T, T, T) is ok */</span> }
                _ <span class="kw">if</span> <span class="ident">e</span>.<span class="ident">is_machine</span>()  <span class="op">=&gt;</span> { <span class="comment">/* struct(u8, u8, u8, u8) is ok */</span> }
                _ <span class="op">=&gt;</span> {
                    <span class="macro">span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">sp</span>, <span class="ident">E0077</span>,
                              <span class="string">&quot;SIMD vector element type should be machine type&quot;</span>);
                    <span class="kw">return</span>;
                }
            }
        }
        _ <span class="op">=&gt;</span> ()
    }
}

<span class="kw">fn</span> <span class="ident">check_packed</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">sp</span>: <span class="ident">Span</span>, <span class="ident">def_id</span>: <span class="ident">DefId</span>) {
    <span class="kw">if</span> <span class="ident">tcx</span>.<span class="ident">adt_def</span>(<span class="ident">def_id</span>).<span class="ident">repr</span>.<span class="ident">packed</span>() {
        <span class="kw">if</span> <span class="ident">tcx</span>.<span class="ident">adt_def</span>(<span class="ident">def_id</span>).<span class="ident">repr</span>.<span class="ident">align</span> <span class="op">&gt;</span> <span class="number">0</span> {
            <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">sp</span>, <span class="ident">E0587</span>,
                             <span class="string">&quot;type has conflicting packed and align representation hints&quot;</span>).<span class="ident">emit</span>();
        }
        <span class="kw">else</span> <span class="kw">if</span> <span class="ident">check_packed_inner</span>(<span class="ident">tcx</span>, <span class="ident">def_id</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Vec</span>::<span class="ident">new</span>()) {
            <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">sp</span>, <span class="ident">E0588</span>,
                <span class="string">&quot;packed type cannot transitively contain a `[repr(align)]` type&quot;</span>).<span class="ident">emit</span>();
        }
    }
}

<span class="kw">fn</span> <span class="ident">check_packed_inner</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                <span class="ident">def_id</span>: <span class="ident">DefId</span>,
                                <span class="ident">stack</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">DefId</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
    <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">type_of</span>(<span class="ident">def_id</span>);
    <span class="kw">if</span> <span class="ident">stack</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">def_id</span>) {
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;check_packed_inner: {:?} is recursive&quot;</span>, <span class="ident">t</span>);
        <span class="kw">return</span> <span class="bool-val">false</span>;
    }
    <span class="kw">match</span> <span class="ident">t</span>.<span class="ident">sty</span> {
        <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">def</span>, <span class="ident">substs</span>) <span class="kw">if</span> <span class="ident">def</span>.<span class="ident">is_struct</span>() <span class="op">||</span> <span class="ident">def</span>.<span class="ident">is_union</span>() <span class="op">=&gt;</span> {
            <span class="kw">if</span> <span class="ident">tcx</span>.<span class="ident">adt_def</span>(<span class="ident">def</span>.<span class="ident">did</span>).<span class="ident">repr</span>.<span class="ident">align</span> <span class="op">&gt;</span> <span class="number">0</span> {
                <span class="kw">return</span> <span class="bool-val">true</span>;
            }
            <span class="comment">// push struct def_id before checking fields</span>
            <span class="ident">stack</span>.<span class="ident">push</span>(<span class="ident">def_id</span>);
            <span class="kw">for</span> <span class="ident">field</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">def</span>.<span class="ident">struct_variant</span>().<span class="ident">fields</span> {
                <span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">field</span>.<span class="ident">ty</span>(<span class="ident">tcx</span>, <span class="ident">substs</span>);
                <span class="kw">match</span> <span class="ident">f</span>.<span class="ident">sty</span> {
                    <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">def</span>, _) <span class="op">=&gt;</span> {
                        <span class="kw">if</span> <span class="ident">check_packed_inner</span>(<span class="ident">tcx</span>, <span class="ident">def</span>.<span class="ident">did</span>, <span class="ident">stack</span>) {
                            <span class="kw">return</span> <span class="bool-val">true</span>;
                        }
                    }
                    _ <span class="op">=&gt;</span> ()
                }
            }
            <span class="comment">// only need to pop if not early out</span>
            <span class="ident">stack</span>.<span class="ident">pop</span>();
        }
        _ <span class="op">=&gt;</span> ()
    }
    <span class="bool-val">false</span>
}

<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">trivial_numeric_casts</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_enum</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                            <span class="ident">sp</span>: <span class="ident">Span</span>,
                            <span class="ident">vs</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> [<span class="ident">hir</span>::<span class="ident">Variant</span>],
                            <span class="ident">id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>) {
    <span class="kw">let</span> <span class="ident">def_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">id</span>);
    <span class="kw">let</span> <span class="ident">def</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">adt_def</span>(<span class="ident">def_id</span>);
    <span class="ident">def</span>.<span class="ident">destructor</span>(<span class="ident">tcx</span>); <span class="comment">// force the destructor to be evaluated</span>

    <span class="kw">if</span> <span class="ident">vs</span>.<span class="ident">is_empty</span>() <span class="op">&amp;&amp;</span> <span class="ident">tcx</span>.<span class="ident">has_attr</span>(<span class="ident">def_id</span>, <span class="string">&quot;repr&quot;</span>) {
        <span class="macro">struct_span_err</span><span class="macro">!</span>(
            <span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">sp</span>, <span class="ident">E0084</span>,
            <span class="string">&quot;unsupported representation for zero-variant enum&quot;</span>)
            .<span class="ident">span_label</span>(<span class="ident">sp</span>, <span class="string">&quot;unsupported enum representation&quot;</span>)
            .<span class="ident">emit</span>();
    }

    <span class="kw">let</span> <span class="ident">repr_type_ty</span> <span class="op">=</span> <span class="ident">def</span>.<span class="ident">repr</span>.<span class="ident">discr_type</span>().<span class="ident">to_ty</span>(<span class="ident">tcx</span>);
    <span class="kw">if</span> <span class="ident">repr_type_ty</span> <span class="op">==</span> <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">i128</span> <span class="op">||</span> <span class="ident">repr_type_ty</span> <span class="op">==</span> <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">u128</span> {
        <span class="kw">if</span> <span class="op">!</span><span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">features</span>.<span class="ident">borrow</span>().<span class="ident">repr128</span> {
            <span class="ident">emit_feature_err</span>(<span class="kw-2">&amp;</span><span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">parse_sess</span>,
                             <span class="string">&quot;repr128&quot;</span>,
                             <span class="ident">sp</span>,
                             <span class="ident">GateIssue</span>::<span class="ident">Language</span>,
                             <span class="string">&quot;repr with 128-bit type is unstable&quot;</span>);
        }
    }

    <span class="kw">for</span> <span class="ident">v</span> <span class="kw">in</span> <span class="ident">vs</span> {
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">e</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">node</span>.<span class="ident">disr_expr</span> {
            <span class="ident">tcx</span>.<span class="ident">typeck_tables_of</span>(<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">e</span>.<span class="ident">node_id</span>));
        }
    }

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">disr_vals</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">ConstInt</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();
    <span class="kw">for</span> (<span class="ident">discr</span>, <span class="ident">v</span>) <span class="kw">in</span> <span class="ident">def</span>.<span class="ident">discriminants</span>(<span class="ident">tcx</span>).<span class="ident">zip</span>(<span class="ident">vs</span>) {
        <span class="comment">// Check for duplicate discriminant values</span>
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">i</span>) <span class="op">=</span> <span class="ident">disr_vals</span>.<span class="ident">iter</span>().<span class="ident">position</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span> <span class="op">==</span> <span class="ident">discr</span>) {
            <span class="kw">let</span> <span class="ident">variant_i_node_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">as_local_node_id</span>(<span class="ident">def</span>.<span class="ident">variants</span>[<span class="ident">i</span>].<span class="ident">did</span>).<span class="ident">unwrap</span>();
            <span class="kw">let</span> <span class="ident">variant_i</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">expect_variant</span>(<span class="ident">variant_i_node_id</span>);
            <span class="kw">let</span> <span class="ident">i_span</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">variant_i</span>.<span class="ident">node</span>.<span class="ident">disr_expr</span> {
                <span class="prelude-val">Some</span>(<span class="ident">expr</span>) <span class="op">=&gt;</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">span</span>(<span class="ident">expr</span>.<span class="ident">node_id</span>),
                <span class="prelude-val">None</span> <span class="op">=&gt;</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">span</span>(<span class="ident">variant_i_node_id</span>)
            };
            <span class="kw">let</span> <span class="ident">span</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">v</span>.<span class="ident">node</span>.<span class="ident">disr_expr</span> {
                <span class="prelude-val">Some</span>(<span class="ident">expr</span>) <span class="op">=&gt;</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">span</span>(<span class="ident">expr</span>.<span class="ident">node_id</span>),
                <span class="prelude-val">None</span> <span class="op">=&gt;</span> <span class="ident">v</span>.<span class="ident">span</span>
            };
            <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">span</span>, <span class="ident">E0081</span>,
                             <span class="string">&quot;discriminant value `{}` already exists&quot;</span>, <span class="ident">disr_vals</span>[<span class="ident">i</span>])
                .<span class="ident">span_label</span>(<span class="ident">i_span</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;first use of `{}`&quot;</span>, <span class="ident">disr_vals</span>[<span class="ident">i</span>]))
                .<span class="ident">span_label</span>(<span class="ident">span</span> , <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;enum already has `{}`&quot;</span>, <span class="ident">disr_vals</span>[<span class="ident">i</span>]))
                .<span class="ident">emit</span>();
        }
        <span class="ident">disr_vals</span>.<span class="ident">push</span>(<span class="ident">discr</span>);
    }

    <span class="ident">check_representable</span>(<span class="ident">tcx</span>, <span class="ident">sp</span>, <span class="ident">def_id</span>);
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">AstConv</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">tcx</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> { <span class="self">self</span>.<span class="ident">tcx</span> }

    <span class="kw">fn</span> <span class="ident">get_type_parameter_bounds</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, _: <span class="ident">Span</span>, <span class="ident">def_id</span>: <span class="ident">DefId</span>)
                                 <span class="op">-&gt;</span> <span class="ident">ty</span>::<span class="ident">GenericPredicates</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="kw">let</span> <span class="ident">tcx</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>;
        <span class="kw">let</span> <span class="ident">node_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">as_local_node_id</span>(<span class="ident">def_id</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">item_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">ty_param_owner</span>(<span class="ident">node_id</span>);
        <span class="kw">let</span> <span class="ident">item_def_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">local_def_id</span>(<span class="ident">item_id</span>);
        <span class="kw">let</span> <span class="ident">generics</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">generics_of</span>(<span class="ident">item_def_id</span>);
        <span class="kw">let</span> <span class="ident">index</span> <span class="op">=</span> <span class="ident">generics</span>.<span class="ident">type_param_to_index</span>[<span class="kw-2">&amp;</span><span class="ident">def_id</span>.<span class="ident">index</span>];
        <span class="ident">ty</span>::<span class="ident">GenericPredicates</span> {
            <span class="ident">parent</span>: <span class="prelude-val">None</span>,
            <span class="ident">predicates</span>: <span class="self">self</span>.<span class="ident">param_env</span>.<span class="ident">caller_bounds</span>.<span class="ident">iter</span>().<span class="ident">filter</span>(<span class="op">|</span><span class="ident">predicate</span><span class="op">|</span> {
                <span class="kw">match</span> <span class="kw-2">*</span><span class="kw-2">*</span><span class="ident">predicate</span> {
                    <span class="ident">ty</span>::<span class="ident">Predicate</span>::<span class="ident">Trait</span>(<span class="kw-2">ref</span> <span class="ident">data</span>) <span class="op">=&gt;</span> {
                        <span class="ident">data</span>.<span class="number">0</span>.<span class="ident">self_ty</span>().<span class="ident">is_param</span>(<span class="ident">index</span>)
                    }
                    _ <span class="op">=&gt;</span> <span class="bool-val">false</span>
                }
            }).<span class="ident">cloned</span>().<span class="ident">collect</span>()
        }
    }

    <span class="kw">fn</span> <span class="ident">re_infer</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">span</span>: <span class="ident">Span</span>, <span class="ident">def</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">RegionParameterDef</span><span class="op">&gt;</span>)
                <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ty</span>::<span class="ident">Region</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span> {
        <span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">def</span> {
            <span class="prelude-val">Some</span>(<span class="ident">def</span>) <span class="op">=&gt;</span> <span class="ident">infer</span>::<span class="ident">EarlyBoundRegion</span>(<span class="ident">span</span>, <span class="ident">def</span>.<span class="ident">name</span>),
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> <span class="ident">infer</span>::<span class="ident">MiscVariable</span>(<span class="ident">span</span>)
        };
        <span class="prelude-val">Some</span>(<span class="self">self</span>.<span class="ident">next_region_var</span>(<span class="ident">v</span>))
    }

    <span class="kw">fn</span> <span class="ident">ty_infer</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">span</span>: <span class="ident">Span</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">next_ty_var</span>(<span class="ident">TypeVariableOrigin</span>::<span class="ident">TypeInference</span>(<span class="ident">span</span>))
    }

    <span class="kw">fn</span> <span class="ident">ty_infer_for_def</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                        <span class="ident">ty_param_def</span>: <span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">TypeParameterDef</span>,
                        <span class="ident">substs</span>: <span class="kw-2">&amp;</span>[<span class="ident">Kind</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>],
                        <span class="ident">span</span>: <span class="ident">Span</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">type_var_for_def</span>(<span class="ident">span</span>, <span class="ident">ty_param_def</span>, <span class="ident">substs</span>)
    }

    <span class="kw">fn</span> <span class="ident">projected_ty_from_poly_trait_ref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                        <span class="ident">span</span>: <span class="ident">Span</span>,
                                        <span class="ident">item_def_id</span>: <span class="ident">DefId</span>,
                                        <span class="ident">poly_trait_ref</span>: <span class="ident">ty</span>::<span class="ident">PolyTraitRef</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
                                        <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="kw">let</span> (<span class="ident">trait_ref</span>, _) <span class="op">=</span>
            <span class="self">self</span>.<span class="ident">replace_late_bound_regions_with_fresh_var</span>(
                <span class="ident">span</span>,
                <span class="ident">infer</span>::<span class="ident">LateBoundRegionConversionTime</span>::<span class="ident">AssocTypeProjection</span>(<span class="ident">item_def_id</span>),
                <span class="kw-2">&amp;</span><span class="ident">poly_trait_ref</span>);

        <span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">mk_projection</span>(<span class="ident">item_def_id</span>, <span class="ident">trait_ref</span>.<span class="ident">substs</span>)
    }

    <span class="kw">fn</span> <span class="ident">normalize_ty</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">span</span>: <span class="ident">Span</span>, <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="ident">ty</span>.<span class="ident">has_escaping_regions</span>() {
            <span class="ident">ty</span> <span class="comment">// FIXME: normalization and escaping regions</span>
        } <span class="kw">else</span> {
            <span class="self">self</span>.<span class="ident">normalize_associated_types_in</span>(<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="ident">ty</span>)
        }
    }

    <span class="kw">fn</span> <span class="ident">set_tainted_by_errors</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="self">self</span>.<span class="ident">infcx</span>.<span class="ident">set_tainted_by_errors</span>()
    }

    <span class="kw">fn</span> <span class="ident">record_ty</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">hir_id</span>: <span class="ident">hir</span>::<span class="ident">HirId</span>, <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">_span</span>: <span class="ident">Span</span>) {
        <span class="self">self</span>.<span class="ident">write_ty</span>(<span class="ident">hir_id</span>, <span class="ident">ty</span>)
    }
}

<span class="doccomment">/// Controls whether the arguments are tupled. This is used for the call</span>
<span class="doccomment">/// operator.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Tupling means that all call-side arguments are packed into a tuple and</span>
<span class="doccomment">/// passed as a single parameter. For example, if tupling is enabled, this</span>
<span class="doccomment">/// function:</span>
<span class="doccomment">///</span>
<span class="doccomment">///     fn f(x: (isize, isize))</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Can be called as:</span>
<span class="doccomment">///</span>
<span class="doccomment">///     f(1, 2);</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Instead of:</span>
<span class="doccomment">///</span>
<span class="doccomment">///     f((1, 2));</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">enum</span> <span class="ident">TupleArgumentsFlag</span> {
    <span class="ident">DontTupleArguments</span>,
    <span class="ident">TupleArguments</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> <span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">inh</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Inherited</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
               <span class="ident">param_env</span>: <span class="ident">ty</span>::<span class="ident">ParamEnv</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
               <span class="ident">body_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>)
               <span class="op">-&gt;</span> <span class="ident">FnCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="ident">FnCtxt</span> {
            <span class="ident">body_id</span>,
            <span class="ident">param_env</span>,
            <span class="ident">err_count_on_creation</span>: <span class="ident">inh</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">err_count</span>(),
            <span class="ident">ret_coercion</span>: <span class="prelude-val">None</span>,
            <span class="ident">yield_ty</span>: <span class="prelude-val">None</span>,
            <span class="ident">ps</span>: <span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="ident">UnsafetyState</span>::<span class="ident">function</span>(<span class="ident">hir</span>::<span class="ident">Unsafety</span>::<span class="ident">Normal</span>,
                                                     <span class="ident">ast</span>::<span class="ident">CRATE_NODE_ID</span>)),
            <span class="ident">diverges</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="ident">Diverges</span>::<span class="ident">Maybe</span>),
            <span class="ident">has_errors</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="bool-val">false</span>),
            <span class="ident">enclosing_breakables</span>: <span class="ident">RefCell</span>::<span class="ident">new</span>(<span class="ident">EnclosingBreakables</span> {
                <span class="ident">stack</span>: <span class="ident">Vec</span>::<span class="ident">new</span>(),
                <span class="ident">by_id</span>: <span class="ident">NodeMap</span>(),
            }),
            <span class="ident">inh</span>,
        }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">sess</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span><span class="ident">Session</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">err_count_since_creation</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">usize</span> {
        <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">err_count</span>() <span class="op">-</span> <span class="self">self</span>.<span class="ident">err_count_on_creation</span>
    }

    <span class="doccomment">/// Produce warning on the given node, if the current point in the</span>
    <span class="doccomment">/// function is unreachable, and there hasn&#39;t been another warning.</span>
    <span class="kw">fn</span> <span class="ident">warn_if_unreachable</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>, <span class="ident">span</span>: <span class="ident">Span</span>, <span class="ident">kind</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) {
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>() <span class="op">==</span> <span class="ident">Diverges</span>::<span class="ident">Always</span> {
            <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="ident">Diverges</span>::<span class="ident">WarnedAlways</span>);

            <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;warn_if_unreachable: id={:?} span={:?} kind={}&quot;</span>, <span class="ident">id</span>, <span class="ident">span</span>, <span class="ident">kind</span>);

            <span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">lint_node</span>(
                <span class="ident">lint</span>::<span class="ident">builtin</span>::<span class="ident">UNREACHABLE_CODE</span>,
                <span class="ident">id</span>, <span class="ident">span</span>,
                <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;unreachable {}&quot;</span>, <span class="ident">kind</span>));
        }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">cause</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                 <span class="ident">span</span>: <span class="ident">Span</span>,
                 <span class="ident">code</span>: <span class="ident">ObligationCauseCode</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
                 <span class="op">-&gt;</span> <span class="ident">ObligationCause</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="ident">ObligationCause</span>::<span class="ident">new</span>(<span class="ident">span</span>, <span class="self">self</span>.<span class="ident">body_id</span>, <span class="ident">code</span>)
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">misc</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">span</span>: <span class="ident">Span</span>) <span class="op">-&gt;</span> <span class="ident">ObligationCause</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">cause</span>(<span class="ident">span</span>, <span class="ident">ObligationCauseCode</span>::<span class="ident">MiscObligation</span>)
    }

    <span class="doccomment">/// Resolves type variables in `ty` if possible. Unlike the infcx</span>
    <span class="doccomment">/// version (resolve_type_vars_if_possible), this version will</span>
    <span class="doccomment">/// also select obligations if it seems useful, in an effort</span>
    <span class="doccomment">/// to get more type information.</span>
    <span class="kw">fn</span> <span class="ident">resolve_type_vars_with_obligations</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="kw-2">mut</span> <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;resolve_type_vars_with_obligations(ty={:?})&quot;</span>, <span class="ident">ty</span>);

        <span class="comment">// No TyInfer()? Nothing needs doing.</span>
        <span class="kw">if</span> <span class="op">!</span><span class="ident">ty</span>.<span class="ident">has_infer_types</span>() {
            <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;resolve_type_vars_with_obligations: ty={:?}&quot;</span>, <span class="ident">ty</span>);
            <span class="kw">return</span> <span class="ident">ty</span>;
        }

        <span class="comment">// If `ty` is a type variable, see whether we already know what it is.</span>
        <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="kw-2">&amp;</span><span class="ident">ty</span>);
        <span class="kw">if</span> <span class="op">!</span><span class="ident">ty</span>.<span class="ident">has_infer_types</span>() {
            <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;resolve_type_vars_with_obligations: ty={:?}&quot;</span>, <span class="ident">ty</span>);
            <span class="kw">return</span> <span class="ident">ty</span>;
        }

        <span class="comment">// If not, try resolving pending obligations as much as</span>
        <span class="comment">// possible. This can help substantially when there are</span>
        <span class="comment">// indirect dependencies that don&#39;t seem worth tracking</span>
        <span class="comment">// precisely.</span>
        <span class="self">self</span>.<span class="ident">select_obligations_where_possible</span>();
        <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="kw-2">&amp;</span><span class="ident">ty</span>);

        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;resolve_type_vars_with_obligations: ty={:?}&quot;</span>, <span class="ident">ty</span>);
        <span class="ident">ty</span>
    }

    <span class="kw">fn</span> <span class="ident">record_deferred_call_resolution</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                       <span class="ident">closure_def_id</span>: <span class="ident">DefId</span>,
                                       <span class="ident">r</span>: <span class="ident">DeferredCallResolution</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">deferred_call_resolutions</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">deferred_call_resolutions</span>.<span class="ident">borrow_mut</span>();
        <span class="ident">deferred_call_resolutions</span>.<span class="ident">entry</span>(<span class="ident">closure_def_id</span>).<span class="ident">or_insert</span>(<span class="macro">vec</span><span class="macro">!</span>[]).<span class="ident">push</span>(<span class="ident">r</span>);
    }

    <span class="kw">fn</span> <span class="ident">remove_deferred_call_resolutions</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                        <span class="ident">closure_def_id</span>: <span class="ident">DefId</span>)
                                        <span class="op">-&gt;</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">DeferredCallResolution</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>
    {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">deferred_call_resolutions</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">deferred_call_resolutions</span>.<span class="ident">borrow_mut</span>();
        <span class="ident">deferred_call_resolutions</span>.<span class="ident">remove</span>(<span class="kw-2">&amp;</span><span class="ident">closure_def_id</span>).<span class="ident">unwrap_or</span>(<span class="macro">vec</span><span class="macro">!</span>[])
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">tag</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">String</span> {
        <span class="kw">let</span> <span class="ident">self_ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">FnCtxt</span> <span class="op">=</span> <span class="self">self</span>;
        <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">self_ptr</span>)
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">local_ty</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">span</span>: <span class="ident">Span</span>, <span class="ident">nid</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="self">self</span>.<span class="ident">locals</span>.<span class="ident">borrow</span>().<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">nid</span>) {
            <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">t</span>) <span class="op">=&gt;</span> <span class="ident">t</span>,
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> {
                <span class="macro">span_bug</span><span class="macro">!</span>(<span class="ident">span</span>, <span class="string">&quot;no type for local variable {}&quot;</span>,
                          <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">node_to_string</span>(<span class="ident">nid</span>));
            }
        }
    }

    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">write_ty</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">id</span>: <span class="ident">hir</span>::<span class="ident">HirId</span>, <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) {
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;write_ty({:?}, {:?}) in fcx {}&quot;</span>,
               <span class="ident">id</span>, <span class="self">self</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="kw-2">&amp;</span><span class="ident">ty</span>), <span class="self">self</span>.<span class="ident">tag</span>());
        <span class="self">self</span>.<span class="ident">tables</span>.<span class="ident">borrow_mut</span>().<span class="ident">node_types_mut</span>().<span class="ident">insert</span>(<span class="ident">id</span>, <span class="ident">ty</span>);

        <span class="kw">if</span> <span class="ident">ty</span>.<span class="ident">references_error</span>() {
            <span class="self">self</span>.<span class="ident">has_errors</span>.<span class="ident">set</span>(<span class="bool-val">true</span>);
            <span class="self">self</span>.<span class="ident">set_tainted_by_errors</span>();
        }
    }

    <span class="comment">// The NodeId and the ItemLocalId must identify the same item. We just pass</span>
    <span class="comment">// both of them for consistency checking.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">write_method_call</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                             <span class="ident">hir_id</span>: <span class="ident">hir</span>::<span class="ident">HirId</span>,
                             <span class="ident">method</span>: <span class="ident">MethodCallee</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) {
        <span class="self">self</span>.<span class="ident">tables</span>
            .<span class="ident">borrow_mut</span>()
            .<span class="ident">type_dependent_defs_mut</span>()
            .<span class="ident">insert</span>(<span class="ident">hir_id</span>, <span class="ident">Def</span>::<span class="ident">Method</span>(<span class="ident">method</span>.<span class="ident">def_id</span>));
        <span class="self">self</span>.<span class="ident">write_substs</span>(<span class="ident">hir_id</span>, <span class="ident">method</span>.<span class="ident">substs</span>);
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">write_substs</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">node_id</span>: <span class="ident">hir</span>::<span class="ident">HirId</span>, <span class="ident">substs</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">Substs</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) {
        <span class="kw">if</span> <span class="op">!</span><span class="ident">substs</span>.<span class="ident">is_noop</span>() {
            <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;write_substs({:?}, {:?}) in fcx {}&quot;</span>,
                   <span class="ident">node_id</span>,
                   <span class="ident">substs</span>,
                   <span class="self">self</span>.<span class="ident">tag</span>());

            <span class="self">self</span>.<span class="ident">tables</span>.<span class="ident">borrow_mut</span>().<span class="ident">node_substs_mut</span>().<span class="ident">insert</span>(<span class="ident">node_id</span>, <span class="ident">substs</span>);
        }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">apply_adjustments</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Expr</span>, <span class="ident">adj</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Adjustment</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>) {
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;apply_adjustments(expr={:?}, adj={:?})&quot;</span>, <span class="ident">expr</span>, <span class="ident">adj</span>);

        <span class="kw">if</span> <span class="ident">adj</span>.<span class="ident">is_empty</span>() {
            <span class="kw">return</span>;
        }

        <span class="kw">match</span> <span class="self">self</span>.<span class="ident">tables</span>.<span class="ident">borrow_mut</span>().<span class="ident">adjustments_mut</span>().<span class="ident">entry</span>(<span class="ident">expr</span>.<span class="ident">hir_id</span>) {
            <span class="ident">Entry</span>::<span class="ident">Vacant</span>(<span class="ident">entry</span>) <span class="op">=&gt;</span> { <span class="ident">entry</span>.<span class="ident">insert</span>(<span class="ident">adj</span>); },
            <span class="ident">Entry</span>::<span class="ident">Occupied</span>(<span class="kw-2">mut</span> <span class="ident">entry</span>) <span class="op">=&gt;</span> {
                <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot; - composing on top of {:?}&quot;</span>, <span class="ident">entry</span>.<span class="ident">get</span>());
                <span class="kw">match</span> (<span class="kw-2">&amp;</span><span class="ident">entry</span>.<span class="ident">get</span>()[..], <span class="kw-2">&amp;</span><span class="ident">adj</span>[..]) {
                    <span class="comment">// Applying any adjustment on top of a NeverToAny</span>
                    <span class="comment">// is a valid NeverToAny adjustment, because it can&#39;t</span>
                    <span class="comment">// be reached.</span>
                    (<span class="kw-2">&amp;</span>[<span class="ident">Adjustment</span> { <span class="ident">kind</span>: <span class="ident">Adjust</span>::<span class="ident">NeverToAny</span>, .. }], _) <span class="op">=&gt;</span> <span class="kw">return</span>,
                    (<span class="kw-2">&amp;</span>[
                        <span class="ident">Adjustment</span> { <span class="ident">kind</span>: <span class="ident">Adjust</span>::<span class="ident">Deref</span>(_), .. },
                        <span class="ident">Adjustment</span> { <span class="ident">kind</span>: <span class="ident">Adjust</span>::<span class="ident">Borrow</span>(<span class="ident">AutoBorrow</span>::<span class="ident">Ref</span>(..)), .. },
                    ], <span class="kw-2">&amp;</span>[
                        <span class="ident">Adjustment</span> { <span class="ident">kind</span>: <span class="ident">Adjust</span>::<span class="ident">Deref</span>(_), .. },
                        .. <span class="comment">// Any following adjustments are allowed.</span>
                    ]) <span class="op">=&gt;</span> {
                        <span class="comment">// A reborrow has no effect before a dereference.</span>
                    }
                    <span class="comment">// FIXME: currently we never try to compose autoderefs</span>
                    <span class="comment">// and ReifyFnPointer/UnsafeFnPointer, but we could.</span>
                    _ <span class="op">=&gt;</span>
                        <span class="macro">bug</span><span class="macro">!</span>(<span class="string">&quot;while adjusting {:?}, can&#39;t compose {:?} and {:?}&quot;</span>,
                             <span class="ident">expr</span>, <span class="ident">entry</span>.<span class="ident">get</span>(), <span class="ident">adj</span>)
                };
                <span class="kw-2">*</span><span class="ident">entry</span>.<span class="ident">get_mut</span>() <span class="op">=</span> <span class="ident">adj</span>;
            }
        }
    }

    <span class="doccomment">/// Basically whenever we are converting from a type scheme into</span>
    <span class="doccomment">/// the fn body space, we always want to normalize associated</span>
    <span class="doccomment">/// types as well. This function combines the two.</span>
    <span class="kw">fn</span> <span class="ident">instantiate_type_scheme</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                  <span class="ident">span</span>: <span class="ident">Span</span>,
                                  <span class="ident">substs</span>: <span class="kw-2">&amp;</span><span class="ident">Substs</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                  <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">T</span>)
                                  <span class="op">-&gt;</span> <span class="ident">T</span>
        <span class="kw">where</span> <span class="ident">T</span> : <span class="ident">TypeFoldable</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">value</span>.<span class="ident">subst</span>(<span class="self">self</span>.<span class="ident">tcx</span>, <span class="ident">substs</span>);
        <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">normalize_associated_types_in</span>(<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="ident">value</span>);
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;instantiate_type_scheme(value={:?}, substs={:?}) = {:?}&quot;</span>,
               <span class="ident">value</span>,
               <span class="ident">substs</span>,
               <span class="ident">result</span>);
        <span class="ident">result</span>
    }

    <span class="doccomment">/// As `instantiate_type_scheme`, but for the bounds found in a</span>
    <span class="doccomment">/// generic type scheme.</span>
    <span class="kw">fn</span> <span class="ident">instantiate_bounds</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">span</span>: <span class="ident">Span</span>, <span class="ident">def_id</span>: <span class="ident">DefId</span>, <span class="ident">substs</span>: <span class="kw-2">&amp;</span><span class="ident">Substs</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
                          <span class="op">-&gt;</span> <span class="ident">ty</span>::<span class="ident">InstantiatedPredicates</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">bounds</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">predicates_of</span>(<span class="ident">def_id</span>);
        <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">bounds</span>.<span class="ident">instantiate</span>(<span class="self">self</span>.<span class="ident">tcx</span>, <span class="ident">substs</span>);
        <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">normalize_associated_types_in</span>(<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="ident">result</span>);
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;instantiate_bounds(bounds={:?}, substs={:?}) = {:?}&quot;</span>,
               <span class="ident">bounds</span>,
               <span class="ident">substs</span>,
               <span class="ident">result</span>);
        <span class="ident">result</span>
    }

    <span class="doccomment">/// Replace all anonymized types with fresh inference variables</span>
    <span class="doccomment">/// and record them for writeback.</span>
    <span class="kw">fn</span> <span class="ident">instantiate_anon_types</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">TypeFoldable</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">T</span>) <span class="op">-&gt;</span> <span class="ident">T</span> {
        <span class="ident">value</span>.<span class="ident">fold_with</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BottomUpFolder</span> { <span class="ident">tcx</span>: <span class="self">self</span>.<span class="ident">tcx</span>, <span class="ident">fldop</span>: <span class="op">|</span><span class="ident">ty</span><span class="op">|</span> {
            <span class="kw">if</span> <span class="kw">let</span> <span class="ident">ty</span>::<span class="ident">TyAnon</span>(<span class="ident">def_id</span>, <span class="ident">substs</span>) <span class="op">=</span> <span class="ident">ty</span>.<span class="ident">sty</span> {
                <span class="comment">// Use the same type variable if the exact same TyAnon appears more</span>
                <span class="comment">// than once in the return type (e.g. if it&#39;s passed to a type alias).</span>
                <span class="kw">let</span> <span class="ident">id</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">as_local_node_id</span>(<span class="ident">def_id</span>).<span class="ident">unwrap</span>();
                <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">ty_var</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">anon_types</span>.<span class="ident">borrow</span>().<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">id</span>) {
                    <span class="kw">return</span> <span class="ident">ty_var</span>;
                }
                <span class="kw">let</span> <span class="ident">span</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">def_span</span>(<span class="ident">def_id</span>);
                <span class="kw">let</span> <span class="ident">ty_var</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">next_ty_var</span>(<span class="ident">TypeVariableOrigin</span>::<span class="ident">TypeInference</span>(<span class="ident">span</span>));
                <span class="self">self</span>.<span class="ident">anon_types</span>.<span class="ident">borrow_mut</span>().<span class="ident">insert</span>(<span class="ident">id</span>, <span class="ident">ty_var</span>);

                <span class="kw">let</span> <span class="ident">predicates_of</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">predicates_of</span>(<span class="ident">def_id</span>);
                <span class="kw">let</span> <span class="ident">bounds</span> <span class="op">=</span> <span class="ident">predicates_of</span>.<span class="ident">instantiate</span>(<span class="self">self</span>.<span class="ident">tcx</span>, <span class="ident">substs</span>);

                <span class="kw">for</span> <span class="ident">predicate</span> <span class="kw">in</span> <span class="ident">bounds</span>.<span class="ident">predicates</span> {
                    <span class="comment">// Change the predicate to refer to the type variable,</span>
                    <span class="comment">// which will be the concrete type, instead of the TyAnon.</span>
                    <span class="comment">// This also instantiates nested `impl Trait`.</span>
                    <span class="kw">let</span> <span class="ident">predicate</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">instantiate_anon_types</span>(<span class="kw-2">&amp;</span><span class="ident">predicate</span>);

                    <span class="comment">// Require that the predicate holds for the concrete type.</span>
                    <span class="kw">let</span> <span class="ident">cause</span> <span class="op">=</span> <span class="ident">traits</span>::<span class="ident">ObligationCause</span>::<span class="ident">new</span>(<span class="ident">span</span>, <span class="self">self</span>.<span class="ident">body_id</span>,
                                                             <span class="ident">traits</span>::<span class="ident">SizedReturnType</span>);
                    <span class="self">self</span>.<span class="ident">register_predicate</span>(<span class="ident">traits</span>::<span class="ident">Obligation</span>::<span class="ident">new</span>(<span class="ident">cause</span>,
                                                                    <span class="self">self</span>.<span class="ident">param_env</span>,
                                                                    <span class="ident">predicate</span>));
                }

                <span class="ident">ty_var</span>
            } <span class="kw">else</span> {
                <span class="ident">ty</span>
            }
        }})
    }

    <span class="kw">fn</span> <span class="ident">normalize_associated_types_in</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">span</span>: <span class="ident">Span</span>, <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">T</span>) <span class="op">-&gt;</span> <span class="ident">T</span>
        <span class="kw">where</span> <span class="ident">T</span> : <span class="ident">TypeFoldable</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="self">self</span>.<span class="ident">inh</span>.<span class="ident">normalize_associated_types_in</span>(<span class="ident">span</span>, <span class="self">self</span>.<span class="ident">body_id</span>, <span class="self">self</span>.<span class="ident">param_env</span>, <span class="ident">value</span>)
    }

    <span class="kw">fn</span> <span class="ident">normalize_associated_types_in_as_infer_ok</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">span</span>: <span class="ident">Span</span>, <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">T</span>)
                                                    <span class="op">-&gt;</span> <span class="ident">InferOk</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span>, <span class="ident">T</span><span class="op">&gt;</span>
        <span class="kw">where</span> <span class="ident">T</span> : <span class="ident">TypeFoldable</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="self">self</span>.<span class="ident">inh</span>.<span class="ident">normalize_associated_types_in_as_infer_ok</span>(<span class="ident">span</span>,
                                                           <span class="self">self</span>.<span class="ident">body_id</span>,
                                                           <span class="self">self</span>.<span class="ident">param_env</span>,
                                                           <span class="ident">value</span>)
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">require_type_meets</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                              <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                              <span class="ident">span</span>: <span class="ident">Span</span>,
                              <span class="ident">code</span>: <span class="ident">traits</span>::<span class="ident">ObligationCauseCode</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                              <span class="ident">def_id</span>: <span class="ident">DefId</span>)
    {
        <span class="self">self</span>.<span class="ident">register_bound</span>(
            <span class="ident">ty</span>,
            <span class="ident">def_id</span>,
            <span class="ident">traits</span>::<span class="ident">ObligationCause</span>::<span class="ident">new</span>(<span class="ident">span</span>, <span class="self">self</span>.<span class="ident">body_id</span>, <span class="ident">code</span>));
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">require_type_is_sized</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                 <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                 <span class="ident">span</span>: <span class="ident">Span</span>,
                                 <span class="ident">code</span>: <span class="ident">traits</span>::<span class="ident">ObligationCauseCode</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
    {
        <span class="kw">let</span> <span class="ident">lang_item</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">require_lang_item</span>(<span class="ident">lang_items</span>::<span class="ident">SizedTraitLangItem</span>);
        <span class="self">self</span>.<span class="ident">require_type_meets</span>(<span class="ident">ty</span>, <span class="ident">span</span>, <span class="ident">code</span>, <span class="ident">lang_item</span>);
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">register_bound</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                          <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                          <span class="ident">def_id</span>: <span class="ident">DefId</span>,
                          <span class="ident">cause</span>: <span class="ident">traits</span>::<span class="ident">ObligationCause</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
    {
        <span class="self">self</span>.<span class="ident">fulfillment_cx</span>.<span class="ident">borrow_mut</span>()
                           .<span class="ident">register_bound</span>(<span class="self">self</span>, <span class="self">self</span>.<span class="ident">param_env</span>, <span class="ident">ty</span>, <span class="ident">def_id</span>, <span class="ident">cause</span>);
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">to_ty</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">ast_t</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Ty</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="ident">AstConv</span>::<span class="ident">ast_ty_to_ty</span>(<span class="self">self</span>, <span class="ident">ast_t</span>);
        <span class="self">self</span>.<span class="ident">register_wf_obligation</span>(<span class="ident">t</span>, <span class="ident">ast_t</span>.<span class="ident">span</span>, <span class="ident">traits</span>::<span class="ident">MiscObligation</span>);
        <span class="ident">t</span>
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">node_ty</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">id</span>: <span class="ident">hir</span>::<span class="ident">HirId</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="self">self</span>.<span class="ident">tables</span>.<span class="ident">borrow</span>().<span class="ident">node_types</span>().<span class="ident">get</span>(<span class="ident">id</span>) {
            <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">t</span>) <span class="op">=&gt;</span> <span class="ident">t</span>,
            <span class="prelude-val">None</span> <span class="kw">if</span> <span class="self">self</span>.<span class="ident">is_tainted_by_errors</span>() <span class="op">=&gt;</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>,
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="ident">node_id</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">definitions</span>().<span class="ident">find_node_for_hir_id</span>(<span class="ident">id</span>);
                <span class="macro">bug</span><span class="macro">!</span>(<span class="string">&quot;no type for node {}: {} in fcx {}&quot;</span>,
                     <span class="ident">node_id</span>, <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">node_to_string</span>(<span class="ident">node_id</span>),
                     <span class="self">self</span>.<span class="ident">tag</span>());
            }
        }
    }

    <span class="doccomment">/// Registers an obligation for checking later, during regionck, that the type `ty` must</span>
    <span class="doccomment">/// outlive the region `r`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">register_wf_obligation</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                  <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                  <span class="ident">span</span>: <span class="ident">Span</span>,
                                  <span class="ident">code</span>: <span class="ident">traits</span>::<span class="ident">ObligationCauseCode</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
    {
        <span class="comment">// WF obligations never themselves fail, so no real need to give a detailed cause:</span>
        <span class="kw">let</span> <span class="ident">cause</span> <span class="op">=</span> <span class="ident">traits</span>::<span class="ident">ObligationCause</span>::<span class="ident">new</span>(<span class="ident">span</span>, <span class="self">self</span>.<span class="ident">body_id</span>, <span class="ident">code</span>);
        <span class="self">self</span>.<span class="ident">register_predicate</span>(<span class="ident">traits</span>::<span class="ident">Obligation</span>::<span class="ident">new</span>(<span class="ident">cause</span>,
                                                        <span class="self">self</span>.<span class="ident">param_env</span>,
                                                        <span class="ident">ty</span>::<span class="ident">Predicate</span>::<span class="ident">WellFormed</span>(<span class="ident">ty</span>)));
    }

    <span class="doccomment">/// Registers obligations that all types appearing in `substs` are well-formed.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">add_wf_bounds</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">substs</span>: <span class="kw-2">&amp;</span><span class="ident">Substs</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Expr</span>)
    {
        <span class="kw">for</span> <span class="ident">ty</span> <span class="kw">in</span> <span class="ident">substs</span>.<span class="ident">types</span>() {
            <span class="self">self</span>.<span class="ident">register_wf_obligation</span>(<span class="ident">ty</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">traits</span>::<span class="ident">MiscObligation</span>);
        }
    }

    <span class="doccomment">/// Given a fully substituted set of bounds (`generic_bounds`), and the values with which each</span>
    <span class="doccomment">/// type/region parameter was instantiated (`substs`), creates and registers suitable</span>
    <span class="doccomment">/// trait/region obligations.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// For example, if there is a function:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// fn foo&lt;&#39;a,T:&#39;a&gt;(...)</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// and a reference:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// let f = foo;</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Then we will create a fresh region variable `&#39;$0` and a fresh type variable `$1` for `&#39;a`</span>
    <span class="doccomment">/// and `T`. This routine will add a region obligation `$1:&#39;$0` and register it locally.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">add_obligations_for_parameters</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                          <span class="ident">cause</span>: <span class="ident">traits</span>::<span class="ident">ObligationCause</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                          <span class="ident">predicates</span>: <span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">InstantiatedPredicates</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
    {
        <span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">predicates</span>.<span class="ident">has_escaping_regions</span>());

        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;add_obligations_for_parameters(predicates={:?})&quot;</span>,
               <span class="ident">predicates</span>);

        <span class="kw">for</span> <span class="ident">obligation</span> <span class="kw">in</span> <span class="ident">traits</span>::<span class="ident">predicates_for_generics</span>(<span class="ident">cause</span>, <span class="self">self</span>.<span class="ident">param_env</span>, <span class="ident">predicates</span>) {
            <span class="self">self</span>.<span class="ident">register_predicate</span>(<span class="ident">obligation</span>);
        }
    }

    <span class="comment">// FIXME(arielb1): use this instead of field.ty everywhere</span>
    <span class="comment">// Only for fields! Returns &lt;none&gt; for methods&gt;</span>
    <span class="comment">// Indifferent to privacy flags</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">field_ty</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                    <span class="ident">span</span>: <span class="ident">Span</span>,
                    <span class="ident">field</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">ty</span>::<span class="ident">FieldDef</span>,
                    <span class="ident">substs</span>: <span class="kw-2">&amp;</span><span class="ident">Substs</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
                    <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="self">self</span>.<span class="ident">normalize_associated_types_in</span>(<span class="ident">span</span>,
                                           <span class="kw-2">&amp;</span><span class="ident">field</span>.<span class="ident">ty</span>(<span class="self">self</span>.<span class="ident">tcx</span>, <span class="ident">substs</span>))
    }

    <span class="kw">fn</span> <span class="ident">check_casts</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">deferred_cast_checks</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">deferred_cast_checks</span>.<span class="ident">borrow_mut</span>();
        <span class="kw">for</span> <span class="ident">cast</span> <span class="kw">in</span> <span class="ident">deferred_cast_checks</span>.<span class="ident">drain</span>(..) {
            <span class="ident">cast</span>.<span class="ident">check</span>(<span class="self">self</span>);
        }
    }

    <span class="kw">fn</span> <span class="ident">resolve_generator_interiors</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">def_id</span>: <span class="ident">DefId</span>) {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">deferred_generator_interiors</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">deferred_generator_interiors</span>.<span class="ident">borrow_mut</span>();
        <span class="kw">for</span> (<span class="ident">body_id</span>, <span class="ident">witness</span>) <span class="kw">in</span> <span class="ident">deferred_generator_interiors</span>.<span class="ident">drain</span>(..) {
            <span class="ident">generator_interior</span>::<span class="ident">resolve_interior</span>(<span class="self">self</span>, <span class="ident">def_id</span>, <span class="ident">body_id</span>, <span class="ident">witness</span>);
        }
    }

    <span class="doccomment">/// Apply &quot;fallbacks&quot; to some types</span>
    <span class="doccomment">/// unconstrained types get replaced with ! or  () (depending on whether</span>
    <span class="doccomment">/// feature(never_type) is enabled), unconstrained ints with i32, and</span>
    <span class="doccomment">/// unconstrained floats with f64.</span>
    <span class="kw">fn</span> <span class="ident">default_type_parameters</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">ty</span>::<span class="ident">error</span>::<span class="ident">UnconstrainedNumeric</span>::<span class="ident">Neither</span>;
        <span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">ty</span>::<span class="ident">error</span>::<span class="ident">UnconstrainedNumeric</span>::{<span class="ident">UnconstrainedInt</span>, <span class="ident">UnconstrainedFloat</span>};

        <span class="comment">// Defaulting inference variables becomes very dubious if we have</span>
        <span class="comment">// encountered type-checking errors. Therefore, if we think we saw</span>
        <span class="comment">// some errors in this function, just resolve all uninstanted type</span>
        <span class="comment">// varibles to TyError.</span>
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">is_tainted_by_errors</span>() {
            <span class="kw">for</span> <span class="ident">ty</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">unsolved_variables</span>() {
                <span class="kw">if</span> <span class="kw">let</span> <span class="ident">ty</span>::<span class="ident">TyInfer</span>(_) <span class="op">=</span> <span class="self">self</span>.<span class="ident">shallow_resolve</span>(<span class="ident">ty</span>).<span class="ident">sty</span> {
                    <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;default_type_parameters: defaulting `{:?}` to error&quot;</span>, <span class="ident">ty</span>);
                    <span class="self">self</span>.<span class="ident">demand_eqtype</span>(<span class="ident">syntax_pos</span>::<span class="ident">DUMMY_SP</span>, <span class="kw-2">*</span><span class="ident">ty</span>, <span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">types</span>.<span class="ident">err</span>);
                }
            }
            <span class="kw">return</span>;
        }

        <span class="kw">for</span> <span class="ident">ty</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">unsolved_variables</span>() {
            <span class="kw">let</span> <span class="ident">resolved</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="ident">ty</span>);
            <span class="kw">if</span> <span class="self">self</span>.<span class="ident">type_var_diverges</span>(<span class="ident">resolved</span>) {
                <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;default_type_parameters: defaulting `{:?}` to `!` because it diverges&quot;</span>,
                       <span class="ident">resolved</span>);
                <span class="self">self</span>.<span class="ident">demand_eqtype</span>(<span class="ident">syntax_pos</span>::<span class="ident">DUMMY_SP</span>, <span class="kw-2">*</span><span class="ident">ty</span>,
                                   <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">mk_diverging_default</span>());
            } <span class="kw">else</span> {
                <span class="kw">match</span> <span class="self">self</span>.<span class="ident">type_is_unconstrained_numeric</span>(<span class="ident">resolved</span>) {
                    <span class="ident">UnconstrainedInt</span> <span class="op">=&gt;</span> {
                        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;default_type_parameters: defaulting `{:?}` to `i32`&quot;</span>,
                               <span class="ident">resolved</span>);
                        <span class="self">self</span>.<span class="ident">demand_eqtype</span>(<span class="ident">syntax_pos</span>::<span class="ident">DUMMY_SP</span>, <span class="kw-2">*</span><span class="ident">ty</span>, <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">i32</span>)
                    },
                    <span class="ident">UnconstrainedFloat</span> <span class="op">=&gt;</span> {
                        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;default_type_parameters: defaulting `{:?}` to `f32`&quot;</span>,
                               <span class="ident">resolved</span>);
                        <span class="self">self</span>.<span class="ident">demand_eqtype</span>(<span class="ident">syntax_pos</span>::<span class="ident">DUMMY_SP</span>, <span class="kw-2">*</span><span class="ident">ty</span>, <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">f64</span>)
                    }
                    <span class="ident">Neither</span> <span class="op">=&gt;</span> { }
                }
            }
        }
    }

    <span class="comment">// Implements type inference fallback algorithm</span>
    <span class="kw">fn</span> <span class="ident">select_all_obligations_and_apply_defaults</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="self">self</span>.<span class="ident">select_obligations_where_possible</span>();
        <span class="self">self</span>.<span class="ident">default_type_parameters</span>();
        <span class="self">self</span>.<span class="ident">select_obligations_where_possible</span>();
    }

    <span class="kw">fn</span> <span class="ident">select_all_obligations_or_error</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;select_all_obligations_or_error&quot;</span>);

        <span class="comment">// upvar inference should have ensured that all deferred call</span>
        <span class="comment">// resolutions are handled by now.</span>
        <span class="macro">assert</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">deferred_call_resolutions</span>.<span class="ident">borrow</span>().<span class="ident">is_empty</span>());

        <span class="self">self</span>.<span class="ident">select_all_obligations_and_apply_defaults</span>();

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fulfillment_cx</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">fulfillment_cx</span>.<span class="ident">borrow_mut</span>();

        <span class="kw">match</span> <span class="ident">fulfillment_cx</span>.<span class="ident">select_all_or_error</span>(<span class="self">self</span>) {
            <span class="prelude-val">Ok</span>(()) <span class="op">=&gt;</span> { }
            <span class="prelude-val">Err</span>(<span class="ident">errors</span>) <span class="op">=&gt;</span> { <span class="self">self</span>.<span class="ident">report_fulfillment_errors</span>(<span class="kw-2">&amp;</span><span class="ident">errors</span>, <span class="self">self</span>.<span class="ident">inh</span>.<span class="ident">body_id</span>); }
        }
    }

    <span class="doccomment">/// Select as many obligations as we can at present.</span>
    <span class="kw">fn</span> <span class="ident">select_obligations_where_possible</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="kw">match</span> <span class="self">self</span>.<span class="ident">fulfillment_cx</span>.<span class="ident">borrow_mut</span>().<span class="ident">select_where_possible</span>(<span class="self">self</span>) {
            <span class="prelude-val">Ok</span>(()) <span class="op">=&gt;</span> { }
            <span class="prelude-val">Err</span>(<span class="ident">errors</span>) <span class="op">=&gt;</span> { <span class="self">self</span>.<span class="ident">report_fulfillment_errors</span>(<span class="kw-2">&amp;</span><span class="ident">errors</span>, <span class="self">self</span>.<span class="ident">inh</span>.<span class="ident">body_id</span>); }
        }
    }

    <span class="doccomment">/// For the overloaded lvalue expressions (`*x`, `x[3]`), the trait</span>
    <span class="doccomment">/// returns a type of `&amp;T`, but the actual type we assign to the</span>
    <span class="doccomment">/// *expression* is `T`. So this function just peels off the return</span>
    <span class="doccomment">/// type by one layer to yield `T`.</span>
    <span class="kw">fn</span> <span class="ident">make_overloaded_lvalue_return_type</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                          <span class="ident">method</span>: <span class="ident">MethodCallee</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
                                          <span class="op">-&gt;</span> <span class="ident">ty</span>::<span class="ident">TypeAndMut</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="comment">// extract method return type, which will be &amp;T;</span>
        <span class="kw">let</span> <span class="ident">ret_ty</span> <span class="op">=</span> <span class="ident">method</span>.<span class="ident">sig</span>.<span class="ident">output</span>();

        <span class="comment">// method returns &amp;T, but the type as visible to user is T, so deref</span>
        <span class="ident">ret_ty</span>.<span class="ident">builtin_deref</span>(<span class="bool-val">true</span>, <span class="ident">NoPreference</span>).<span class="ident">unwrap</span>()
    }

    <span class="kw">fn</span> <span class="ident">lookup_indexing</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                       <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Expr</span>,
                       <span class="ident">base_expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                       <span class="ident">base_ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                       <span class="ident">idx_ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                       <span class="ident">lvalue_pref</span>: <span class="ident">LvaluePreference</span>)
                       <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span>(<span class="comment">/*index type*/</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="comment">/*element type*/</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)<span class="op">&gt;</span>
    {
        <span class="comment">// FIXME(#18741) -- this is almost but not quite the same as the</span>
        <span class="comment">// autoderef that normal method probing does. They could likely be</span>
        <span class="comment">// consolidated.</span>

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">autoderef</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">autoderef</span>(<span class="ident">base_expr</span>.<span class="ident">span</span>, <span class="ident">base_ty</span>);
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">result</span> <span class="op">=</span> <span class="prelude-val">None</span>;
        <span class="kw">while</span> <span class="ident">result</span>.<span class="ident">is_none</span>() <span class="op">&amp;&amp;</span> <span class="ident">autoderef</span>.<span class="ident">next</span>().<span class="ident">is_some</span>() {
            <span class="ident">result</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">try_index_step</span>(<span class="ident">expr</span>, <span class="ident">base_expr</span>, <span class="kw-2">&amp;</span><span class="ident">autoderef</span>, <span class="ident">lvalue_pref</span>, <span class="ident">idx_ty</span>);
        }
        <span class="ident">autoderef</span>.<span class="ident">finalize</span>();
        <span class="ident">result</span>
    }

    <span class="doccomment">/// To type-check `base_expr[index_expr]`, we progressively autoderef</span>
    <span class="doccomment">/// (and otherwise adjust) `base_expr`, looking for a type which either</span>
    <span class="doccomment">/// supports builtin indexing or overloaded indexing.</span>
    <span class="doccomment">/// This loop implements one step in that search; the autoderef loop</span>
    <span class="doccomment">/// is implemented by `lookup_indexing`.</span>
    <span class="kw">fn</span> <span class="ident">try_index_step</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                      <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Expr</span>,
                      <span class="ident">base_expr</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Expr</span>,
                      <span class="ident">autoderef</span>: <span class="kw-2">&amp;</span><span class="ident">Autoderef</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                      <span class="ident">lvalue_pref</span>: <span class="ident">LvaluePreference</span>,
                      <span class="ident">index_ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
                      <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span>(<span class="comment">/*index type*/</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="comment">/*element type*/</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)<span class="op">&gt;</span>
    {
        <span class="kw">let</span> <span class="ident">adjusted_ty</span> <span class="op">=</span> <span class="ident">autoderef</span>.<span class="ident">unambiguous_final_ty</span>();
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \
                               index_ty={:?})&quot;</span>,
               <span class="ident">expr</span>,
               <span class="ident">base_expr</span>,
               <span class="ident">adjusted_ty</span>,
               <span class="ident">index_ty</span>);

        <span class="comment">// First, try built-in indexing.</span>
        <span class="kw">match</span> (<span class="ident">adjusted_ty</span>.<span class="ident">builtin_index</span>(), <span class="kw-2">&amp;</span><span class="ident">index_ty</span>.<span class="ident">sty</span>) {
            (<span class="prelude-val">Some</span>(<span class="ident">ty</span>), <span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">TyUint</span>(<span class="ident">ast</span>::<span class="ident">UintTy</span>::<span class="ident">Us</span>)) <span class="op">|</span> (<span class="prelude-val">Some</span>(<span class="ident">ty</span>), <span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">TyInfer</span>(<span class="ident">ty</span>::<span class="ident">IntVar</span>(_))) <span class="op">=&gt;</span> {
                <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;try_index_step: success, using built-in indexing&quot;</span>);
                <span class="kw">let</span> <span class="ident">adjustments</span> <span class="op">=</span> <span class="ident">autoderef</span>.<span class="ident">adjust_steps</span>(<span class="ident">lvalue_pref</span>);
                <span class="self">self</span>.<span class="ident">apply_adjustments</span>(<span class="ident">base_expr</span>, <span class="ident">adjustments</span>);
                <span class="kw">return</span> <span class="prelude-val">Some</span>((<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">usize</span>, <span class="ident">ty</span>));
            }
            _ <span class="op">=&gt;</span> {}
        }

        <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="ident">unsize</span> <span class="kw">in</span> <span class="kw-2">&amp;</span>[<span class="bool-val">false</span>, <span class="bool-val">true</span>] {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">self_ty</span> <span class="op">=</span> <span class="ident">adjusted_ty</span>;
            <span class="kw">if</span> <span class="ident">unsize</span> {
                <span class="comment">// We only unsize arrays here.</span>
                <span class="kw">if</span> <span class="kw">let</span> <span class="ident">ty</span>::<span class="ident">TyArray</span>(<span class="ident">element_ty</span>, _) <span class="op">=</span> <span class="ident">adjusted_ty</span>.<span class="ident">sty</span> {
                    <span class="ident">self_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">mk_slice</span>(<span class="ident">element_ty</span>);
                } <span class="kw">else</span> {
                    <span class="kw">continue</span>;
                }
            }

            <span class="comment">// If some lookup succeeds, write callee into table and extract index/element</span>
            <span class="comment">// type from the method signature.</span>
            <span class="comment">// If some lookup succeeded, install method in table</span>
            <span class="kw">let</span> <span class="ident">input_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">next_ty_var</span>(<span class="ident">TypeVariableOrigin</span>::<span class="ident">AutoDeref</span>(<span class="ident">base_expr</span>.<span class="ident">span</span>));
            <span class="kw">let</span> <span class="ident">method</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">try_overloaded_lvalue_op</span>(
                <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">self_ty</span>, <span class="kw-2">&amp;</span>[<span class="ident">input_ty</span>], <span class="ident">lvalue_pref</span>, <span class="ident">LvalueOp</span>::<span class="ident">Index</span>);

            <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">method</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">ok</span><span class="op">|</span> {
                <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;try_index_step: success, using overloaded indexing&quot;</span>);
                <span class="kw">let</span> <span class="ident">method</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">register_infer_ok_obligations</span>(<span class="ident">ok</span>);

                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">adjustments</span> <span class="op">=</span> <span class="ident">autoderef</span>.<span class="ident">adjust_steps</span>(<span class="ident">lvalue_pref</span>);
                <span class="kw">if</span> <span class="kw">let</span> <span class="ident">ty</span>::<span class="ident">TyRef</span>(<span class="ident">region</span>, <span class="ident">mt</span>) <span class="op">=</span> <span class="ident">method</span>.<span class="ident">sig</span>.<span class="ident">inputs</span>()[<span class="number">0</span>].<span class="ident">sty</span> {
                    <span class="ident">adjustments</span>.<span class="ident">push</span>(<span class="ident">Adjustment</span> {
                        <span class="ident">kind</span>: <span class="ident">Adjust</span>::<span class="ident">Borrow</span>(<span class="ident">AutoBorrow</span>::<span class="ident">Ref</span>(<span class="ident">region</span>, <span class="ident">mt</span>.<span class="ident">mutbl</span>)),
                        <span class="ident">target</span>: <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">mk_ref</span>(<span class="ident">region</span>, <span class="ident">ty</span>::<span class="ident">TypeAndMut</span> {
                            <span class="ident">mutbl</span>: <span class="ident">mt</span>.<span class="ident">mutbl</span>,
                            <span class="ident">ty</span>: <span class="ident">adjusted_ty</span>
                        })
                    });
                }
                <span class="kw">if</span> <span class="ident">unsize</span> {
                    <span class="ident">adjustments</span>.<span class="ident">push</span>(<span class="ident">Adjustment</span> {
                        <span class="ident">kind</span>: <span class="ident">Adjust</span>::<span class="ident">Unsize</span>,
                        <span class="ident">target</span>: <span class="ident">method</span>.<span class="ident">sig</span>.<span class="ident">inputs</span>()[<span class="number">0</span>]
                    });
                }
                <span class="self">self</span>.<span class="ident">apply_adjustments</span>(<span class="ident">base_expr</span>, <span class="ident">adjustments</span>);

                <span class="self">self</span>.<span class="ident">write_method_call</span>(<span class="ident">expr</span>.<span class="ident">hir_id</span>, <span class="ident">method</span>);
                (<span class="ident">input_ty</span>, <span class="self">self</span>.<span class="ident">make_overloaded_lvalue_return_type</span>(<span class="ident">method</span>).<span class="ident">ty</span>)
            });
            <span class="kw">if</span> <span class="ident">result</span>.<span class="ident">is_some</span>() {
                <span class="kw">return</span> <span class="ident">result</span>;
            }
        }

        <span class="prelude-val">None</span>
    }

    <span class="kw">fn</span> <span class="ident">resolve_lvalue_op</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">op</span>: <span class="ident">LvalueOp</span>, <span class="ident">is_mut</span>: <span class="ident">bool</span>) <span class="op">-&gt;</span> (<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">DefId</span><span class="op">&gt;</span>, <span class="ident">Symbol</span>) {
        <span class="kw">let</span> (<span class="ident">tr</span>, <span class="ident">name</span>) <span class="op">=</span> <span class="kw">match</span> (<span class="ident">op</span>, <span class="ident">is_mut</span>) {
            (<span class="ident">LvalueOp</span>::<span class="ident">Deref</span>, <span class="bool-val">false</span>) <span class="op">=&gt;</span>
                (<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">lang_items</span>().<span class="ident">deref_trait</span>(), <span class="string">&quot;deref&quot;</span>),
            (<span class="ident">LvalueOp</span>::<span class="ident">Deref</span>, <span class="bool-val">true</span>) <span class="op">=&gt;</span>
                (<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">lang_items</span>().<span class="ident">deref_mut_trait</span>(), <span class="string">&quot;deref_mut&quot;</span>),
            (<span class="ident">LvalueOp</span>::<span class="ident">Index</span>, <span class="bool-val">false</span>) <span class="op">=&gt;</span>
                (<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">lang_items</span>().<span class="ident">index_trait</span>(), <span class="string">&quot;index&quot;</span>),
            (<span class="ident">LvalueOp</span>::<span class="ident">Index</span>, <span class="bool-val">true</span>) <span class="op">=&gt;</span>
                (<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">lang_items</span>().<span class="ident">index_mut_trait</span>(), <span class="string">&quot;index_mut&quot;</span>),
        };
        (<span class="ident">tr</span>, <span class="ident">Symbol</span>::<span class="ident">intern</span>(<span class="ident">name</span>))
    }

    <span class="kw">fn</span> <span class="ident">try_overloaded_lvalue_op</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                <span class="ident">span</span>: <span class="ident">Span</span>,
                                <span class="ident">base_ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                <span class="ident">arg_tys</span>: <span class="kw-2">&amp;</span>[<span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>],
                                <span class="ident">lvalue_pref</span>: <span class="ident">LvaluePreference</span>,
                                <span class="ident">op</span>: <span class="ident">LvalueOp</span>)
                                <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">InferOk</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span>, <span class="ident">MethodCallee</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span>
    {
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;try_overloaded_lvalue_op({:?},{:?},{:?},{:?})&quot;</span>,
               <span class="ident">span</span>,
               <span class="ident">base_ty</span>,
               <span class="ident">lvalue_pref</span>,
               <span class="ident">op</span>);

        <span class="comment">// Try Mut first, if preferred.</span>
        <span class="kw">let</span> (<span class="ident">mut_tr</span>, <span class="ident">mut_op</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_lvalue_op</span>(<span class="ident">op</span>, <span class="bool-val">true</span>);
        <span class="kw">let</span> <span class="ident">method</span> <span class="op">=</span> <span class="kw">match</span> (<span class="ident">lvalue_pref</span>, <span class="ident">mut_tr</span>) {
            (<span class="ident">PreferMutLvalue</span>, <span class="prelude-val">Some</span>(<span class="ident">trait_did</span>)) <span class="op">=&gt;</span> {
                <span class="self">self</span>.<span class="ident">lookup_method_in_trait</span>(<span class="ident">span</span>, <span class="ident">mut_op</span>, <span class="ident">trait_did</span>, <span class="ident">base_ty</span>, <span class="prelude-val">Some</span>(<span class="ident">arg_tys</span>))
            }
            _ <span class="op">=&gt;</span> <span class="prelude-val">None</span>,
        };

        <span class="comment">// Otherwise, fall back to the immutable version.</span>
        <span class="kw">let</span> (<span class="ident">imm_tr</span>, <span class="ident">imm_op</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_lvalue_op</span>(<span class="ident">op</span>, <span class="bool-val">false</span>);
        <span class="kw">let</span> <span class="ident">method</span> <span class="op">=</span> <span class="kw">match</span> (<span class="ident">method</span>, <span class="ident">imm_tr</span>) {
            (<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="ident">trait_did</span>)) <span class="op">=&gt;</span> {
                <span class="self">self</span>.<span class="ident">lookup_method_in_trait</span>(<span class="ident">span</span>, <span class="ident">imm_op</span>, <span class="ident">trait_did</span>, <span class="ident">base_ty</span>, <span class="prelude-val">Some</span>(<span class="ident">arg_tys</span>))
            }
            (<span class="ident">method</span>, _) <span class="op">=&gt;</span> <span class="ident">method</span>,
        };

        <span class="ident">method</span>
    }

    <span class="kw">fn</span> <span class="ident">check_method_argument_types</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                   <span class="ident">sp</span>: <span class="ident">Span</span>,
                                   <span class="ident">expr_sp</span>: <span class="ident">Span</span>,
                                   <span class="ident">method</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">MethodCallee</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, ()<span class="op">&gt;</span>,
                                   <span class="ident">args_no_rcvr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> [<span class="ident">hir</span>::<span class="ident">Expr</span>],
                                   <span class="ident">tuple_arguments</span>: <span class="ident">TupleArgumentsFlag</span>,
                                   <span class="ident">expected</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
                                   <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">has_error</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">method</span> {
            <span class="prelude-val">Ok</span>(<span class="ident">method</span>) <span class="op">=&gt;</span> {
                <span class="ident">method</span>.<span class="ident">substs</span>.<span class="ident">references_error</span>() <span class="op">||</span> <span class="ident">method</span>.<span class="ident">sig</span>.<span class="ident">references_error</span>()
            }
            <span class="prelude-val">Err</span>(_) <span class="op">=&gt;</span> <span class="bool-val">true</span>
        };
        <span class="kw">if</span> <span class="ident">has_error</span> {
            <span class="kw">let</span> <span class="ident">err_inputs</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">err_args</span>(<span class="ident">args_no_rcvr</span>.<span class="ident">len</span>());

            <span class="kw">let</span> <span class="ident">err_inputs</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">tuple_arguments</span> {
                <span class="ident">DontTupleArguments</span> <span class="op">=&gt;</span> <span class="ident">err_inputs</span>,
                <span class="ident">TupleArguments</span> <span class="op">=&gt;</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">intern_tup</span>(<span class="kw-2">&amp;</span><span class="ident">err_inputs</span>[..], <span class="bool-val">false</span>)],
            };

            <span class="self">self</span>.<span class="ident">check_argument_types</span>(<span class="ident">sp</span>, <span class="ident">expr_sp</span>, <span class="kw-2">&amp;</span><span class="ident">err_inputs</span>[..], <span class="kw-2">&amp;</span>[], <span class="ident">args_no_rcvr</span>,
                                      <span class="bool-val">false</span>, <span class="ident">tuple_arguments</span>, <span class="prelude-val">None</span>);
            <span class="kw">return</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>;
        }

        <span class="kw">let</span> <span class="ident">method</span> <span class="op">=</span> <span class="ident">method</span>.<span class="ident">unwrap</span>();
        <span class="comment">// HACK(eddyb) ignore self in the definition (see above).</span>
        <span class="kw">let</span> <span class="ident">expected_arg_tys</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">expected_inputs_for_expected_output</span>(
            <span class="ident">sp</span>,
            <span class="ident">expected</span>,
            <span class="ident">method</span>.<span class="ident">sig</span>.<span class="ident">output</span>(),
            <span class="kw-2">&amp;</span><span class="ident">method</span>.<span class="ident">sig</span>.<span class="ident">inputs</span>()[<span class="number">1</span>..]
        );
        <span class="self">self</span>.<span class="ident">check_argument_types</span>(<span class="ident">sp</span>, <span class="ident">expr_sp</span>, <span class="kw-2">&amp;</span><span class="ident">method</span>.<span class="ident">sig</span>.<span class="ident">inputs</span>()[<span class="number">1</span>..], <span class="kw-2">&amp;</span><span class="ident">expected_arg_tys</span>[..],
                                  <span class="ident">args_no_rcvr</span>, <span class="ident">method</span>.<span class="ident">sig</span>.<span class="ident">variadic</span>, <span class="ident">tuple_arguments</span>,
                                  <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">span_if_local</span>(<span class="ident">method</span>.<span class="ident">def_id</span>));
        <span class="ident">method</span>.<span class="ident">sig</span>.<span class="ident">output</span>()
    }

    <span class="doccomment">/// Generic function that factors out common logic from function calls,</span>
    <span class="doccomment">/// method calls and overloaded operators.</span>
    <span class="kw">fn</span> <span class="ident">check_argument_types</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                            <span class="ident">sp</span>: <span class="ident">Span</span>,
                            <span class="ident">expr_sp</span>: <span class="ident">Span</span>,
                            <span class="ident">fn_inputs</span>: <span class="kw-2">&amp;</span>[<span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>],
                            <span class="ident">expected_arg_tys</span>: <span class="kw-2">&amp;</span>[<span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>],
                            <span class="ident">args</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> [<span class="ident">hir</span>::<span class="ident">Expr</span>],
                            <span class="ident">variadic</span>: <span class="ident">bool</span>,
                            <span class="ident">tuple_arguments</span>: <span class="ident">TupleArgumentsFlag</span>,
                            <span class="ident">def_span</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Span</span><span class="op">&gt;</span>) {
        <span class="kw">let</span> <span class="ident">tcx</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>;

        <span class="comment">// Grab the argument types, supplying fresh type variables</span>
        <span class="comment">// if the wrong number of arguments were supplied</span>
        <span class="kw">let</span> <span class="ident">supplied_arg_count</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">tuple_arguments</span> <span class="op">==</span> <span class="ident">DontTupleArguments</span> {
            <span class="ident">args</span>.<span class="ident">len</span>()
        } <span class="kw">else</span> {
            <span class="number">1</span>
        };

        <span class="comment">// All the input types from the fn signature must outlive the call</span>
        <span class="comment">// so as to validate implied bounds.</span>
        <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="ident">fn_input_ty</span> <span class="kw">in</span> <span class="ident">fn_inputs</span> {
            <span class="self">self</span>.<span class="ident">register_wf_obligation</span>(<span class="ident">fn_input_ty</span>, <span class="ident">sp</span>, <span class="ident">traits</span>::<span class="ident">MiscObligation</span>);
        }

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">expected_arg_tys</span> <span class="op">=</span> <span class="ident">expected_arg_tys</span>;
        <span class="kw">let</span> <span class="ident">expected_arg_count</span> <span class="op">=</span> <span class="ident">fn_inputs</span>.<span class="ident">len</span>();

        <span class="kw">let</span> <span class="ident">sp_args</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">args</span>.<span class="ident">len</span>() <span class="op">&gt;</span> <span class="number">0</span> {
            <span class="kw">let</span> (<span class="ident">first</span>, <span class="ident">args</span>) <span class="op">=</span> <span class="ident">args</span>.<span class="ident">split_at</span>(<span class="number">1</span>);
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sp_tmp</span> <span class="op">=</span> <span class="ident">first</span>[<span class="number">0</span>].<span class="ident">span</span>;
            <span class="kw">for</span> <span class="ident">arg</span> <span class="kw">in</span> <span class="ident">args</span> {
                <span class="kw">let</span> <span class="ident">sp_opt</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">sess</span>().<span class="ident">codemap</span>().<span class="ident">merge_spans</span>(<span class="ident">sp_tmp</span>, <span class="ident">arg</span>.<span class="ident">span</span>);
                <span class="kw">if</span> <span class="op">!</span> <span class="ident">sp_opt</span>.<span class="ident">is_some</span>() {
                    <span class="kw">break</span>;
                }
                <span class="ident">sp_tmp</span> <span class="op">=</span> <span class="ident">sp_opt</span>.<span class="ident">unwrap</span>();
            };
            <span class="ident">sp_tmp</span>
        } <span class="kw">else</span> {
            <span class="ident">sp</span>
        };

        <span class="kw">fn</span> <span class="ident">parameter_count_error</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">sess</span>: <span class="kw-2">&amp;</span><span class="ident">Session</span>,
                                       <span class="ident">sp</span>: <span class="ident">Span</span>,
                                       <span class="ident">expr_sp</span>: <span class="ident">Span</span>,
                                       <span class="ident">expected_count</span>: <span class="ident">usize</span>,
                                       <span class="ident">arg_count</span>: <span class="ident">usize</span>,
                                       <span class="ident">error_code</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>,
                                       <span class="ident">variadic</span>: <span class="ident">bool</span>,
                                       <span class="ident">def_span</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Span</span><span class="op">&gt;</span>,
                                       <span class="ident">sugg_unit</span>: <span class="ident">bool</span>) {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="ident">sess</span>.<span class="ident">struct_span_err_with_code</span>(<span class="ident">sp</span>,
                <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;this function takes {}{} parameter{} but {} parameter{} supplied&quot;</span>,
                    <span class="kw">if</span> <span class="ident">variadic</span> {<span class="string">&quot;at least &quot;</span>} <span class="kw">else</span> {<span class="string">&quot;&quot;</span>},
                    <span class="ident">expected_count</span>,
                    <span class="kw">if</span> <span class="ident">expected_count</span> <span class="op">==</span> <span class="number">1</span> {<span class="string">&quot;&quot;</span>} <span class="kw">else</span> {<span class="string">&quot;s&quot;</span>},
                    <span class="ident">arg_count</span>,
                    <span class="kw">if</span> <span class="ident">arg_count</span> <span class="op">==</span> <span class="number">1</span> {<span class="string">&quot; was&quot;</span>} <span class="kw">else</span> {<span class="string">&quot;s were&quot;</span>}),
                <span class="ident">error_code</span>);

            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">def_s</span>) <span class="op">=</span> <span class="ident">def_span</span> {
                <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">def_s</span>, <span class="string">&quot;defined here&quot;</span>);
            }
            <span class="kw">if</span> <span class="ident">sugg_unit</span> {
                <span class="kw">let</span> <span class="ident">sugg_span</span> <span class="op">=</span> <span class="ident">expr_sp</span>.<span class="ident">end_point</span>();
                <span class="comment">// remove closing `)` from the span</span>
                <span class="kw">let</span> <span class="ident">sugg_span</span> <span class="op">=</span> <span class="ident">sugg_span</span>.<span class="ident">with_hi</span>(<span class="ident">sugg_span</span>.<span class="ident">lo</span>());
                <span class="ident">err</span>.<span class="ident">span_suggestion</span>(
                    <span class="ident">sugg_span</span>,
                    <span class="string">&quot;expected the unit value `()`; create it with empty parentheses&quot;</span>,
                    <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;()&quot;</span>));
            } <span class="kw">else</span> {
                <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">sp</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;expected {}{} parameter{}&quot;</span>,
                                            <span class="kw">if</span> <span class="ident">variadic</span> {<span class="string">&quot;at least &quot;</span>} <span class="kw">else</span> {<span class="string">&quot;&quot;</span>},
                                            <span class="ident">expected_count</span>,
                                            <span class="kw">if</span> <span class="ident">expected_count</span> <span class="op">==</span> <span class="number">1</span> {<span class="string">&quot;&quot;</span>} <span class="kw">else</span> {<span class="string">&quot;s&quot;</span>}));
            }
            <span class="ident">err</span>.<span class="ident">emit</span>();
        }

        <span class="kw">let</span> <span class="ident">formal_tys</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">tuple_arguments</span> <span class="op">==</span> <span class="ident">TupleArguments</span> {
            <span class="kw">let</span> <span class="ident">tuple_type</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">structurally_resolved_type</span>(<span class="ident">sp</span>, <span class="ident">fn_inputs</span>[<span class="number">0</span>]);
            <span class="kw">match</span> <span class="ident">tuple_type</span>.<span class="ident">sty</span> {
                <span class="ident">ty</span>::<span class="ident">TyTuple</span>(<span class="ident">arg_types</span>, _) <span class="kw">if</span> <span class="ident">arg_types</span>.<span class="ident">len</span>() <span class="op">!=</span> <span class="ident">args</span>.<span class="ident">len</span>() <span class="op">=&gt;</span> {
                    <span class="ident">parameter_count_error</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">sp_args</span>, <span class="ident">expr_sp</span>, <span class="ident">arg_types</span>.<span class="ident">len</span>(), <span class="ident">args</span>.<span class="ident">len</span>(),
                                          <span class="string">&quot;E0057&quot;</span>, <span class="bool-val">false</span>, <span class="ident">def_span</span>, <span class="bool-val">false</span>);
                    <span class="ident">expected_arg_tys</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[];
                    <span class="self">self</span>.<span class="ident">err_args</span>(<span class="ident">args</span>.<span class="ident">len</span>())
                }
                <span class="ident">ty</span>::<span class="ident">TyTuple</span>(<span class="ident">arg_types</span>, _) <span class="op">=&gt;</span> {
                    <span class="ident">expected_arg_tys</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">expected_arg_tys</span>.<span class="ident">get</span>(<span class="number">0</span>) {
                        <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">ty</span>) <span class="op">=&gt;</span> <span class="kw">match</span> <span class="ident">ty</span>.<span class="ident">sty</span> {
                            <span class="ident">ty</span>::<span class="ident">TyTuple</span>(<span class="kw-2">ref</span> <span class="ident">tys</span>, _) <span class="op">=&gt;</span> <span class="kw-2">&amp;</span><span class="ident">tys</span>,
                            _ <span class="op">=&gt;</span> <span class="kw-2">&amp;</span>[]
                        },
                        <span class="prelude-val">None</span> <span class="op">=&gt;</span> <span class="kw-2">&amp;</span>[]
                    };
                    <span class="ident">arg_types</span>.<span class="ident">to_vec</span>()
                }
                _ <span class="op">=&gt;</span> {
                    <span class="macro">span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">sp</span>, <span class="ident">E0059</span>,
                        <span class="string">&quot;cannot use call notation; the first type parameter \
                         for the function trait is neither a tuple nor unit&quot;</span>);
                    <span class="ident">expected_arg_tys</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[];
                    <span class="self">self</span>.<span class="ident">err_args</span>(<span class="ident">args</span>.<span class="ident">len</span>())
                }
            }
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">expected_arg_count</span> <span class="op">==</span> <span class="ident">supplied_arg_count</span> {
            <span class="ident">fn_inputs</span>.<span class="ident">to_vec</span>()
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">variadic</span> {
            <span class="kw">if</span> <span class="ident">supplied_arg_count</span> <span class="op">&gt;=</span> <span class="ident">expected_arg_count</span> {
                <span class="ident">fn_inputs</span>.<span class="ident">to_vec</span>()
            } <span class="kw">else</span> {
                <span class="ident">parameter_count_error</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">sp_args</span>, <span class="ident">expr_sp</span>, <span class="ident">expected_arg_count</span>,
                                      <span class="ident">supplied_arg_count</span>, <span class="string">&quot;E0060&quot;</span>, <span class="bool-val">true</span>, <span class="ident">def_span</span>, <span class="bool-val">false</span>);
                <span class="ident">expected_arg_tys</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[];
                <span class="self">self</span>.<span class="ident">err_args</span>(<span class="ident">supplied_arg_count</span>)
            }
        } <span class="kw">else</span> {
            <span class="comment">// is the missing argument of type `()`?</span>
            <span class="kw">let</span> <span class="ident">sugg_unit</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">expected_arg_tys</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">1</span> <span class="op">&amp;&amp;</span> <span class="ident">supplied_arg_count</span> <span class="op">==</span> <span class="number">0</span> {
                <span class="self">self</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="kw-2">&amp;</span><span class="ident">expected_arg_tys</span>[<span class="number">0</span>]).<span class="ident">is_nil</span>()
            } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">fn_inputs</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">1</span> <span class="op">&amp;&amp;</span> <span class="ident">supplied_arg_count</span> <span class="op">==</span> <span class="number">0</span> {
                <span class="self">self</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="kw-2">&amp;</span><span class="ident">fn_inputs</span>[<span class="number">0</span>]).<span class="ident">is_nil</span>()
            } <span class="kw">else</span> {
                <span class="bool-val">false</span>
            };
            <span class="ident">parameter_count_error</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">sp_args</span>, <span class="ident">expr_sp</span>, <span class="ident">expected_arg_count</span>,
                                  <span class="ident">supplied_arg_count</span>, <span class="string">&quot;E0061&quot;</span>, <span class="bool-val">false</span>, <span class="ident">def_span</span>, <span class="ident">sugg_unit</span>);
            <span class="ident">expected_arg_tys</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[];
            <span class="self">self</span>.<span class="ident">err_args</span>(<span class="ident">supplied_arg_count</span>)
        };

        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;check_argument_types: formal_tys={:?}&quot;</span>,
               <span class="ident">formal_tys</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="self">self</span>.<span class="ident">ty_to_string</span>(<span class="kw-2">*</span><span class="ident">t</span>)).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;&gt;</span>());

        <span class="comment">// Check the arguments.</span>
        <span class="comment">// We do this in a pretty awful way: first we typecheck any arguments</span>
        <span class="comment">// that are not closures, then we typecheck the closures. This is so</span>
        <span class="comment">// that we have more information about the types of arguments when we</span>
        <span class="comment">// typecheck the functions. This isn&#39;t really the right way to do this.</span>
        <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="ident">check_closures</span> <span class="kw">in</span> <span class="kw-2">&amp;</span>[<span class="bool-val">false</span>, <span class="bool-val">true</span>] {
            <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;check_closures={}&quot;</span>, <span class="ident">check_closures</span>);

            <span class="comment">// More awful hacks: before we check argument types, try to do</span>
            <span class="comment">// an &quot;opportunistic&quot; vtable resolution of any trait bounds on</span>
            <span class="comment">// the call. This helps coercions.</span>
            <span class="kw">if</span> <span class="ident">check_closures</span> {
                <span class="self">self</span>.<span class="ident">select_obligations_where_possible</span>();
            }

            <span class="comment">// For variadic functions, we don&#39;t have a declared type for all of</span>
            <span class="comment">// the arguments hence we only do our usual type checking with</span>
            <span class="comment">// the arguments who&#39;s types we do know.</span>
            <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">variadic</span> {
                <span class="ident">expected_arg_count</span>
            } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">tuple_arguments</span> <span class="op">==</span> <span class="ident">TupleArguments</span> {
                <span class="ident">args</span>.<span class="ident">len</span>()
            } <span class="kw">else</span> {
                <span class="ident">supplied_arg_count</span>
            };
            <span class="kw">for</span> (<span class="ident">i</span>, <span class="ident">arg</span>) <span class="kw">in</span> <span class="ident">args</span>.<span class="ident">iter</span>().<span class="ident">take</span>(<span class="ident">t</span>).<span class="ident">enumerate</span>() {
                <span class="comment">// Warn only for the first loop (the &quot;no closures&quot; one).</span>
                <span class="comment">// Closure arguments themselves can&#39;t be diverging, but</span>
                <span class="comment">// a previous argument can, e.g. `foo(panic!(), || {})`.</span>
                <span class="kw">if</span> <span class="op">!</span><span class="ident">check_closures</span> {
                    <span class="self">self</span>.<span class="ident">warn_if_unreachable</span>(<span class="ident">arg</span>.<span class="ident">id</span>, <span class="ident">arg</span>.<span class="ident">span</span>, <span class="string">&quot;expression&quot;</span>);
                }

                <span class="kw">let</span> <span class="ident">is_closure</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">arg</span>.<span class="ident">node</span> {
                    <span class="ident">hir</span>::<span class="ident">ExprClosure</span>(..) <span class="op">=&gt;</span> <span class="bool-val">true</span>,
                    _ <span class="op">=&gt;</span> <span class="bool-val">false</span>
                };

                <span class="kw">if</span> <span class="ident">is_closure</span> <span class="op">!=</span> <span class="ident">check_closures</span> {
                    <span class="kw">continue</span>;
                }

                <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;checking the argument&quot;</span>);
                <span class="kw">let</span> <span class="ident">formal_ty</span> <span class="op">=</span> <span class="ident">formal_tys</span>[<span class="ident">i</span>];

                <span class="comment">// The special-cased logic below has three functions:</span>
                <span class="comment">// 1. Provide as good of an expected type as possible.</span>
                <span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="ident">expected_arg_tys</span>.<span class="ident">get</span>(<span class="ident">i</span>).<span class="ident">map</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">ty</span><span class="op">|</span> {
                    <span class="ident">Expectation</span>::<span class="ident">rvalue_hint</span>(<span class="self">self</span>, <span class="ident">ty</span>)
                });

                <span class="kw">let</span> <span class="ident">checked_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_expectation</span>(
                    <span class="kw-2">&amp;</span><span class="ident">arg</span>,
                    <span class="ident">expected</span>.<span class="ident">unwrap_or</span>(<span class="ident">ExpectHasType</span>(<span class="ident">formal_ty</span>)));

                <span class="comment">// 2. Coerce to the most detailed type that could be coerced</span>
                <span class="comment">//    to, which is `expected_ty` if `rvalue_hint` returns an</span>
                <span class="comment">//    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.</span>
                <span class="kw">let</span> <span class="ident">coerce_ty</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span>.<span class="ident">only_has_type</span>(<span class="self">self</span>));
                <span class="self">self</span>.<span class="ident">demand_coerce</span>(<span class="kw-2">&amp;</span><span class="ident">arg</span>, <span class="ident">checked_ty</span>, <span class="ident">coerce_ty</span>.<span class="ident">unwrap_or</span>(<span class="ident">formal_ty</span>));

                <span class="comment">// 3. Relate the expected type and the formal one,</span>
                <span class="comment">//    if the expected type was used for the coercion.</span>
                <span class="ident">coerce_ty</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">ty</span><span class="op">|</span> <span class="self">self</span>.<span class="ident">demand_suptype</span>(<span class="ident">arg</span>.<span class="ident">span</span>, <span class="ident">formal_ty</span>, <span class="ident">ty</span>));
            }
        }

        <span class="comment">// We also need to make sure we at least write the ty of the other</span>
        <span class="comment">// arguments which we skipped above.</span>
        <span class="kw">if</span> <span class="ident">variadic</span> {
            <span class="kw">fn</span> <span class="ident">variadic_error</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">Session</span>, <span class="ident">span</span>: <span class="ident">Span</span>, <span class="ident">t</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">cast_ty</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) {
                <span class="macro">type_error_struct</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">span</span>, <span class="ident">t</span>, <span class="ident">E0617</span>,
                                   <span class="string">&quot;can&#39;t pass `{}` to variadic function, cast to `{}`&quot;</span>,
                                   <span class="ident">t</span>, <span class="ident">cast_ty</span>).<span class="ident">emit</span>();
            }

            <span class="kw">for</span> <span class="ident">arg</span> <span class="kw">in</span> <span class="ident">args</span>.<span class="ident">iter</span>().<span class="ident">skip</span>(<span class="ident">expected_arg_count</span>) {
                <span class="kw">let</span> <span class="ident">arg_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr</span>(<span class="kw-2">&amp;</span><span class="ident">arg</span>);

                <span class="comment">// There are a few types which get autopromoted when passed via varargs</span>
                <span class="comment">// in C but we just error out instead and require explicit casts.</span>
                <span class="kw">let</span> <span class="ident">arg_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">structurally_resolved_type</span>(<span class="ident">arg</span>.<span class="ident">span</span>, <span class="ident">arg_ty</span>);
                <span class="kw">match</span> <span class="ident">arg_ty</span>.<span class="ident">sty</span> {
                    <span class="ident">ty</span>::<span class="ident">TyFloat</span>(<span class="ident">ast</span>::<span class="ident">FloatTy</span>::<span class="ident">F32</span>) <span class="op">=&gt;</span> {
                        <span class="ident">variadic_error</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">arg</span>.<span class="ident">span</span>, <span class="ident">arg_ty</span>, <span class="string">&quot;c_double&quot;</span>);
                    }
                    <span class="ident">ty</span>::<span class="ident">TyInt</span>(<span class="ident">ast</span>::<span class="ident">IntTy</span>::<span class="ident">I8</span>) <span class="op">|</span> <span class="ident">ty</span>::<span class="ident">TyInt</span>(<span class="ident">ast</span>::<span class="ident">IntTy</span>::<span class="ident">I16</span>) <span class="op">|</span> <span class="ident">ty</span>::<span class="ident">TyBool</span> <span class="op">=&gt;</span> {
                        <span class="ident">variadic_error</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">arg</span>.<span class="ident">span</span>, <span class="ident">arg_ty</span>, <span class="string">&quot;c_int&quot;</span>);
                    }
                    <span class="ident">ty</span>::<span class="ident">TyUint</span>(<span class="ident">ast</span>::<span class="ident">UintTy</span>::<span class="ident">U8</span>) <span class="op">|</span> <span class="ident">ty</span>::<span class="ident">TyUint</span>(<span class="ident">ast</span>::<span class="ident">UintTy</span>::<span class="ident">U16</span>) <span class="op">=&gt;</span> {
                        <span class="ident">variadic_error</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">arg</span>.<span class="ident">span</span>, <span class="ident">arg_ty</span>, <span class="string">&quot;c_uint&quot;</span>);
                    }
                    <span class="ident">ty</span>::<span class="ident">TyFnDef</span>(..) <span class="op">=&gt;</span> {
                        <span class="kw">let</span> <span class="ident">ptr_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">mk_fn_ptr</span>(<span class="ident">arg_ty</span>.<span class="ident">fn_sig</span>(<span class="self">self</span>.<span class="ident">tcx</span>));
                        <span class="kw">let</span> <span class="ident">ptr_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="kw-2">&amp;</span><span class="ident">ptr_ty</span>);
                        <span class="ident">variadic_error</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">arg</span>.<span class="ident">span</span>, <span class="ident">arg_ty</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">ptr_ty</span>));
                    }
                    _ <span class="op">=&gt;</span> {}
                }
            }
        }
    }

    <span class="kw">fn</span> <span class="ident">err_args</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">len</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span> {
        (<span class="number">0</span>..<span class="ident">len</span>).<span class="ident">map</span>(<span class="op">|</span>_<span class="op">|</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>).<span class="ident">collect</span>()
    }

    <span class="comment">// AST fragment checking</span>
    <span class="kw">fn</span> <span class="ident">check_lit</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                 <span class="ident">lit</span>: <span class="kw-2">&amp;</span><span class="ident">ast</span>::<span class="ident">Lit</span>,
                 <span class="ident">expected</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
                 <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="kw">let</span> <span class="ident">tcx</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>;

        <span class="kw">match</span> <span class="ident">lit</span>.<span class="ident">node</span> {
            <span class="ident">ast</span>::<span class="ident">LitKind</span>::<span class="ident">Str</span>(..) <span class="op">=&gt;</span> <span class="ident">tcx</span>.<span class="ident">mk_static_str</span>(),
            <span class="ident">ast</span>::<span class="ident">LitKind</span>::<span class="ident">ByteStr</span>(<span class="kw-2">ref</span> <span class="ident">v</span>) <span class="op">=&gt;</span> {
                <span class="ident">tcx</span>.<span class="ident">mk_imm_ref</span>(<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">re_static</span>,
                                <span class="ident">tcx</span>.<span class="ident">mk_array</span>(<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">u8</span>, <span class="ident">v</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span>))
            }
            <span class="ident">ast</span>::<span class="ident">LitKind</span>::<span class="ident">Byte</span>(_) <span class="op">=&gt;</span> <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">u8</span>,
            <span class="ident">ast</span>::<span class="ident">LitKind</span>::<span class="ident">Char</span>(_) <span class="op">=&gt;</span> <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">char</span>,
            <span class="ident">ast</span>::<span class="ident">LitKind</span>::<span class="ident">Int</span>(_, <span class="ident">ast</span>::<span class="ident">LitIntType</span>::<span class="ident">Signed</span>(<span class="ident">t</span>)) <span class="op">=&gt;</span> <span class="ident">tcx</span>.<span class="ident">mk_mach_int</span>(<span class="ident">t</span>),
            <span class="ident">ast</span>::<span class="ident">LitKind</span>::<span class="ident">Int</span>(_, <span class="ident">ast</span>::<span class="ident">LitIntType</span>::<span class="ident">Unsigned</span>(<span class="ident">t</span>)) <span class="op">=&gt;</span> <span class="ident">tcx</span>.<span class="ident">mk_mach_uint</span>(<span class="ident">t</span>),
            <span class="ident">ast</span>::<span class="ident">LitKind</span>::<span class="ident">Int</span>(_, <span class="ident">ast</span>::<span class="ident">LitIntType</span>::<span class="ident">Unsuffixed</span>) <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="ident">opt_ty</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">to_option</span>(<span class="self">self</span>).<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">ty</span><span class="op">|</span> {
                    <span class="kw">match</span> <span class="ident">ty</span>.<span class="ident">sty</span> {
                        <span class="ident">ty</span>::<span class="ident">TyInt</span>(_) <span class="op">|</span> <span class="ident">ty</span>::<span class="ident">TyUint</span>(_) <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">ty</span>),
                        <span class="ident">ty</span>::<span class="ident">TyChar</span> <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">u8</span>),
                        <span class="ident">ty</span>::<span class="ident">TyRawPtr</span>(..) <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">usize</span>),
                        <span class="ident">ty</span>::<span class="ident">TyFnDef</span>(..) <span class="op">|</span> <span class="ident">ty</span>::<span class="ident">TyFnPtr</span>(_) <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">usize</span>),
                        _ <span class="op">=&gt;</span> <span class="prelude-val">None</span>
                    }
                });
                <span class="ident">opt_ty</span>.<span class="ident">unwrap_or_else</span>(
                    <span class="op">||</span> <span class="ident">tcx</span>.<span class="ident">mk_int_var</span>(<span class="self">self</span>.<span class="ident">next_int_var_id</span>()))
            }
            <span class="ident">ast</span>::<span class="ident">LitKind</span>::<span class="ident">Float</span>(_, <span class="ident">t</span>) <span class="op">=&gt;</span> <span class="ident">tcx</span>.<span class="ident">mk_mach_float</span>(<span class="ident">t</span>),
            <span class="ident">ast</span>::<span class="ident">LitKind</span>::<span class="ident">FloatUnsuffixed</span>(_) <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="ident">opt_ty</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">to_option</span>(<span class="self">self</span>).<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">ty</span><span class="op">|</span> {
                    <span class="kw">match</span> <span class="ident">ty</span>.<span class="ident">sty</span> {
                        <span class="ident">ty</span>::<span class="ident">TyFloat</span>(_) <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">ty</span>),
                        _ <span class="op">=&gt;</span> <span class="prelude-val">None</span>
                    }
                });
                <span class="ident">opt_ty</span>.<span class="ident">unwrap_or_else</span>(
                    <span class="op">||</span> <span class="ident">tcx</span>.<span class="ident">mk_float_var</span>(<span class="self">self</span>.<span class="ident">next_float_var_id</span>()))
            }
            <span class="ident">ast</span>::<span class="ident">LitKind</span>::<span class="ident">Bool</span>(_) <span class="op">=&gt;</span> <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">bool</span>
        }
    }

    <span class="kw">fn</span> <span class="ident">check_expr_eq_type</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                          <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                          <span class="ident">expected</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) {
        <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_hint</span>(<span class="ident">expr</span>, <span class="ident">expected</span>);
        <span class="self">self</span>.<span class="ident">demand_eqtype</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">expected</span>, <span class="ident">ty</span>);
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_expr_has_type_or_error</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                        <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                                        <span class="ident">expected</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">check_expr_meets_expectation_or_error</span>(<span class="ident">expr</span>, <span class="ident">ExpectHasType</span>(<span class="ident">expected</span>))
    }

    <span class="kw">fn</span> <span class="ident">check_expr_meets_expectation_or_error</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                             <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                                             <span class="ident">expected</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">expected_ty</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">to_option</span>(<span class="kw-2">&amp;</span><span class="self">self</span>).<span class="ident">unwrap_or</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">bool</span>);
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_expectation</span>(<span class="ident">expr</span>, <span class="ident">expected</span>);

        <span class="comment">// While we don&#39;t allow *arbitrary* coercions here, we *do* allow</span>
        <span class="comment">// coercions from ! to `expected`.</span>
        <span class="kw">if</span> <span class="ident">ty</span>.<span class="ident">is_never</span>() {
            <span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="self">self</span>.<span class="ident">tables</span>.<span class="ident">borrow</span>().<span class="ident">adjustments</span>().<span class="ident">contains_key</span>(<span class="ident">expr</span>.<span class="ident">hir_id</span>),
                    <span class="string">&quot;expression with never type wound up being adjusted&quot;</span>);
            <span class="kw">let</span> <span class="ident">adj_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">next_diverging_ty_var</span>(
                <span class="ident">TypeVariableOrigin</span>::<span class="ident">AdjustmentType</span>(<span class="ident">expr</span>.<span class="ident">span</span>));
            <span class="self">self</span>.<span class="ident">apply_adjustments</span>(<span class="ident">expr</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">Adjustment</span> {
                <span class="ident">kind</span>: <span class="ident">Adjust</span>::<span class="ident">NeverToAny</span>,
                <span class="ident">target</span>: <span class="ident">adj_ty</span>
            }]);
            <span class="ident">ty</span> <span class="op">=</span> <span class="ident">adj_ty</span>;
        }

        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">err</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">demand_suptype_diag</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">expected_ty</span>, <span class="ident">ty</span>) {
            <span class="comment">// Add help to type error if this is an `if` condition with an assignment</span>
            <span class="kw">match</span> (<span class="ident">expected</span>, <span class="kw-2">&amp;</span><span class="ident">expr</span>.<span class="ident">node</span>) {
                (<span class="ident">ExpectIfCondition</span>, <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">ExprAssign</span>(<span class="kw-2">ref</span> <span class="ident">lhs</span>, <span class="kw-2">ref</span> <span class="ident">rhs</span>)) <span class="op">=&gt;</span> {
                    <span class="kw">let</span> <span class="ident">msg</span> <span class="op">=</span> <span class="string">&quot;try comparing for equality&quot;</span>;
                    <span class="kw">if</span> <span class="kw">let</span> (<span class="prelude-val">Ok</span>(<span class="ident">left</span>), <span class="prelude-val">Ok</span>(<span class="ident">right</span>)) <span class="op">=</span> (
                        <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">codemap</span>().<span class="ident">span_to_snippet</span>(<span class="ident">lhs</span>.<span class="ident">span</span>),
                        <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">codemap</span>().<span class="ident">span_to_snippet</span>(<span class="ident">rhs</span>.<span class="ident">span</span>))
                    {
                        <span class="ident">err</span>.<span class="ident">span_suggestion</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">msg</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{} == {}&quot;</span>, <span class="ident">left</span>, <span class="ident">right</span>));
                    } <span class="kw">else</span> {
                        <span class="ident">err</span>.<span class="ident">help</span>(<span class="ident">msg</span>);
                    }
                }
                _ <span class="op">=&gt;</span> (),
            }
            <span class="ident">err</span>.<span class="ident">emit</span>();
        }
        <span class="ident">ty</span>
    }

    <span class="kw">fn</span> <span class="ident">check_expr_coercable_to_type</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                    <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                                    <span class="ident">expected</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_hint</span>(<span class="ident">expr</span>, <span class="ident">expected</span>);
        <span class="self">self</span>.<span class="ident">demand_coerce</span>(<span class="ident">expr</span>, <span class="ident">ty</span>, <span class="ident">expected</span>);
        <span class="ident">ty</span>
    }

    <span class="kw">fn</span> <span class="ident">check_expr_with_hint</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                            <span class="ident">expected</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">check_expr_with_expectation</span>(<span class="ident">expr</span>, <span class="ident">ExpectHasType</span>(<span class="ident">expected</span>))
    }

    <span class="kw">fn</span> <span class="ident">check_expr_with_expectation</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                   <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                                   <span class="ident">expected</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">check_expr_with_expectation_and_lvalue_pref</span>(<span class="ident">expr</span>, <span class="ident">expected</span>, <span class="ident">NoPreference</span>)
    }

    <span class="kw">fn</span> <span class="ident">check_expr</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">check_expr_with_expectation</span>(<span class="ident">expr</span>, <span class="ident">NoExpectation</span>)
    }

    <span class="kw">fn</span> <span class="ident">check_expr_with_lvalue_pref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                                   <span class="ident">lvalue_pref</span>: <span class="ident">LvaluePreference</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">check_expr_with_expectation_and_lvalue_pref</span>(<span class="ident">expr</span>, <span class="ident">NoExpectation</span>, <span class="ident">lvalue_pref</span>)
    }

    <span class="comment">// determine the `self` type, using fresh variables for all variables</span>
    <span class="comment">// declared on the impl declaration e.g., `impl&lt;A,B&gt; for Vec&lt;(A,B)&gt;`</span>
    <span class="comment">// would return ($0, $1) where $0 and $1 are freshly instantiated type</span>
    <span class="comment">// variables.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">impl_self_ty</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                        <span class="ident">span</span>: <span class="ident">Span</span>, <span class="comment">// (potential) receiver for this impl</span>
                        <span class="ident">did</span>: <span class="ident">DefId</span>)
                        <span class="op">-&gt;</span> <span class="ident">TypeAndSubsts</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">ity</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">type_of</span>(<span class="ident">did</span>);
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;impl_self_ty: ity={:?}&quot;</span>, <span class="ident">ity</span>);

        <span class="kw">let</span> <span class="ident">substs</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">fresh_substs_for_item</span>(<span class="ident">span</span>, <span class="ident">did</span>);
        <span class="kw">let</span> <span class="ident">substd_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">instantiate_type_scheme</span>(<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="ident">substs</span>, <span class="kw-2">&amp;</span><span class="ident">ity</span>);

        <span class="ident">TypeAndSubsts</span> { <span class="ident">substs</span>: <span class="ident">substs</span>, <span class="ident">ty</span>: <span class="ident">substd_ty</span> }
    }

    <span class="doccomment">/// Unifies the output type with the expected type early, for more coercions</span>
    <span class="doccomment">/// and forward type information on the input expressions.</span>
    <span class="kw">fn</span> <span class="ident">expected_inputs_for_expected_output</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                           <span class="ident">call_span</span>: <span class="ident">Span</span>,
                                           <span class="ident">expected_ret</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                           <span class="ident">formal_ret</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                           <span class="ident">formal_args</span>: <span class="kw-2">&amp;</span>[<span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>])
                                           <span class="op">-&gt;</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span> {
        <span class="kw">let</span> <span class="ident">formal_ret</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_type_vars_with_obligations</span>(<span class="ident">formal_ret</span>);
        <span class="kw">let</span> <span class="ident">expected_args</span> <span class="op">=</span> <span class="ident">expected_ret</span>.<span class="ident">only_has_type</span>(<span class="self">self</span>).<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">ret_ty</span><span class="op">|</span> {
            <span class="self">self</span>.<span class="ident">fudge_regions_if_ok</span>(<span class="kw-2">&amp;</span><span class="ident">RegionVariableOrigin</span>::<span class="ident">Coercion</span>(<span class="ident">call_span</span>), <span class="op">||</span> {
                <span class="comment">// Attempt to apply a subtyping relationship between the formal</span>
                <span class="comment">// return type (likely containing type variables if the function</span>
                <span class="comment">// is polymorphic) and the expected return type.</span>
                <span class="comment">// No argument expectations are produced if unification fails.</span>
                <span class="kw">let</span> <span class="ident">origin</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">misc</span>(<span class="ident">call_span</span>);
                <span class="kw">let</span> <span class="ident">ures</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">at</span>(<span class="kw-2">&amp;</span><span class="ident">origin</span>, <span class="self">self</span>.<span class="ident">param_env</span>).<span class="ident">sup</span>(<span class="ident">ret_ty</span>, <span class="ident">formal_ret</span>);

                <span class="comment">// FIXME(#15760) can&#39;t use try! here, FromError doesn&#39;t default</span>
                <span class="comment">// to identity so the resulting type is not constrained.</span>
                <span class="kw">match</span> <span class="ident">ures</span> {
                    <span class="prelude-val">Ok</span>(<span class="ident">ok</span>) <span class="op">=&gt;</span> {
                        <span class="comment">// Process any obligations locally as much as</span>
                        <span class="comment">// we can.  We don&#39;t care if some things turn</span>
                        <span class="comment">// out unconstrained or ambiguous, as we&#39;re</span>
                        <span class="comment">// just trying to get hints here.</span>
                        <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">save_and_restore_in_snapshot_flag</span>(<span class="op">|</span>_<span class="op">|</span> {
                            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fulfill</span> <span class="op">=</span> <span class="ident">FulfillmentContext</span>::<span class="ident">new</span>();
                            <span class="kw">let</span> <span class="ident">ok</span> <span class="op">=</span> <span class="ident">ok</span>; <span class="comment">// FIXME(#30046)</span>
                            <span class="kw">for</span> <span class="ident">obligation</span> <span class="kw">in</span> <span class="ident">ok</span>.<span class="ident">obligations</span> {
                                <span class="ident">fulfill</span>.<span class="ident">register_predicate_obligation</span>(<span class="self">self</span>, <span class="ident">obligation</span>);
                            }
                            <span class="ident">fulfill</span>.<span class="ident">select_where_possible</span>(<span class="self">self</span>)
                        });

                        <span class="kw">match</span> <span class="ident">result</span> {
                            <span class="prelude-val">Ok</span>(()) <span class="op">=&gt;</span> { }
                            <span class="prelude-val">Err</span>(_) <span class="op">=&gt;</span> <span class="kw">return</span> <span class="prelude-val">Err</span>(()),
                        }
                    }
                    <span class="prelude-val">Err</span>(_) <span class="op">=&gt;</span> <span class="kw">return</span> <span class="prelude-val">Err</span>(()),
                }

                <span class="comment">// Record all the argument types, with the substitutions</span>
                <span class="comment">// produced from the above subtyping unification.</span>
                <span class="prelude-val">Ok</span>(<span class="ident">formal_args</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">ty</span><span class="op">|</span> {
                    <span class="self">self</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="ident">ty</span>)
                }).<span class="ident">collect</span>())
            }).<span class="ident">ok</span>()
        }).<span class="ident">unwrap_or</span>(<span class="macro">vec</span><span class="macro">!</span>[]);
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;expected_inputs_for_expected_output(formal={:?} -&gt; {:?}, expected={:?} -&gt; {:?})&quot;</span>,
               <span class="ident">formal_args</span>, <span class="ident">formal_ret</span>,
               <span class="ident">expected_args</span>, <span class="ident">expected_ret</span>);
        <span class="ident">expected_args</span>
    }

    <span class="comment">// Checks a method call.</span>
    <span class="kw">fn</span> <span class="ident">check_method_call</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                         <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                         <span class="ident">segment</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">PathSegment</span>,
                         <span class="ident">span</span>: <span class="ident">Span</span>,
                         <span class="ident">args</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> [<span class="ident">hir</span>::<span class="ident">Expr</span>],
                         <span class="ident">expected</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                         <span class="ident">lvalue_pref</span>: <span class="ident">LvaluePreference</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">rcvr</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">args</span>[<span class="number">0</span>];
        <span class="kw">let</span> <span class="ident">rcvr_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_lvalue_pref</span>(<span class="kw-2">&amp;</span><span class="ident">rcvr</span>, <span class="ident">lvalue_pref</span>);
        <span class="comment">// no need to check for bot/err -- callee does that</span>
        <span class="kw">let</span> <span class="ident">rcvr_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">structurally_resolved_type</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">rcvr_t</span>);

        <span class="kw">let</span> <span class="ident">method</span> <span class="op">=</span> <span class="kw">match</span> <span class="self">self</span>.<span class="ident">lookup_method</span>(<span class="ident">rcvr_t</span>,
                                              <span class="ident">segment</span>,
                                              <span class="ident">span</span>,
                                              <span class="ident">expr</span>,
                                              <span class="ident">rcvr</span>) {
            <span class="prelude-val">Ok</span>(<span class="ident">method</span>) <span class="op">=&gt;</span> {
                <span class="self">self</span>.<span class="ident">write_method_call</span>(<span class="ident">expr</span>.<span class="ident">hir_id</span>, <span class="ident">method</span>);
                <span class="prelude-val">Ok</span>(<span class="ident">method</span>)
            }
            <span class="prelude-val">Err</span>(<span class="ident">error</span>) <span class="op">=&gt;</span> {
                <span class="kw">if</span> <span class="ident">segment</span>.<span class="ident">name</span> <span class="op">!=</span> <span class="ident">keywords</span>::<span class="ident">Invalid</span>.<span class="ident">name</span>() {
                    <span class="self">self</span>.<span class="ident">report_method_error</span>(<span class="ident">span</span>,
                                             <span class="ident">rcvr_t</span>,
                                             <span class="ident">segment</span>.<span class="ident">name</span>,
                                             <span class="prelude-val">Some</span>(<span class="ident">rcvr</span>),
                                             <span class="ident">error</span>,
                                             <span class="prelude-val">Some</span>(<span class="ident">args</span>));
                }
                <span class="prelude-val">Err</span>(())
            }
        };

        <span class="comment">// Call the generic checker.</span>
        <span class="self">self</span>.<span class="ident">check_method_argument_types</span>(<span class="ident">span</span>,
                                         <span class="ident">expr</span>.<span class="ident">span</span>,
                                         <span class="ident">method</span>,
                                         <span class="kw-2">&amp;</span><span class="ident">args</span>[<span class="number">1</span>..],
                                         <span class="ident">DontTupleArguments</span>,
                                         <span class="ident">expected</span>)
    }

    <span class="kw">fn</span> <span class="ident">check_return_expr</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">return_expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>) {
        <span class="kw">let</span> <span class="ident">ret_coercion</span> <span class="op">=</span>
            <span class="self">self</span>.<span class="ident">ret_coercion</span>
                .<span class="ident">as_ref</span>()
                .<span class="ident">unwrap_or_else</span>(<span class="op">||</span> <span class="macro">span_bug</span><span class="macro">!</span>(<span class="ident">return_expr</span>.<span class="ident">span</span>,
                                             <span class="string">&quot;check_return_expr called outside fn body&quot;</span>));

        <span class="kw">let</span> <span class="ident">ret_ty</span> <span class="op">=</span> <span class="ident">ret_coercion</span>.<span class="ident">borrow</span>().<span class="ident">expected_ty</span>();
        <span class="kw">let</span> <span class="ident">return_expr_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_hint</span>(<span class="ident">return_expr</span>, <span class="ident">ret_ty</span>.<span class="ident">clone</span>());
        <span class="ident">ret_coercion</span>.<span class="ident">borrow_mut</span>()
                    .<span class="ident">coerce</span>(<span class="self">self</span>,
                            <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">cause</span>(<span class="ident">return_expr</span>.<span class="ident">span</span>,
                                        <span class="ident">ObligationCauseCode</span>::<span class="ident">ReturnType</span>(<span class="ident">return_expr</span>.<span class="ident">id</span>)),
                            <span class="ident">return_expr</span>,
                            <span class="ident">return_expr_ty</span>,
                            <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>());
    }


    <span class="comment">// A generic function for checking the then and else in an if</span>
    <span class="comment">// or if-else.</span>
    <span class="kw">fn</span> <span class="ident">check_then_else</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                       <span class="ident">cond_expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                       <span class="ident">then_expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                       <span class="ident">opt_else_expr</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span><span class="op">&gt;</span>,
                       <span class="ident">sp</span>: <span class="ident">Span</span>,
                       <span class="ident">expected</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">cond_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_meets_expectation_or_error</span>(<span class="ident">cond_expr</span>, <span class="ident">ExpectIfCondition</span>);
        <span class="kw">let</span> <span class="ident">cond_diverges</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>();
        <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="ident">Diverges</span>::<span class="ident">Maybe</span>);

        <span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">adjust_for_branches</span>(<span class="self">self</span>);
        <span class="kw">let</span> <span class="ident">then_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_expectation</span>(<span class="ident">then_expr</span>, <span class="ident">expected</span>);
        <span class="kw">let</span> <span class="ident">then_diverges</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>();
        <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="ident">Diverges</span>::<span class="ident">Maybe</span>);

        <span class="comment">// We&#39;ve already taken the expected type&#39;s preferences</span>
        <span class="comment">// into account when typing the `then` branch. To figure</span>
        <span class="comment">// out the initial shot at a LUB, we thus only consider</span>
        <span class="comment">// `expected` if it represents a *hard* constraint</span>
        <span class="comment">// (`only_has_type`); otherwise, we just go with a</span>
        <span class="comment">// fresh type variable.</span>
        <span class="kw">let</span> <span class="ident">coerce_to_ty</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">coercion_target_type</span>(<span class="self">self</span>, <span class="ident">sp</span>);
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">coerce</span>: <span class="ident">DynamicCoerceMany</span> <span class="op">=</span> <span class="ident">CoerceMany</span>::<span class="ident">new</span>(<span class="ident">coerce_to_ty</span>);

        <span class="kw">let</span> <span class="ident">if_cause</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">cause</span>(<span class="ident">sp</span>, <span class="ident">ObligationCauseCode</span>::<span class="ident">IfExpression</span>);
        <span class="ident">coerce</span>.<span class="ident">coerce</span>(<span class="self">self</span>, <span class="kw-2">&amp;</span><span class="ident">if_cause</span>, <span class="ident">then_expr</span>, <span class="ident">then_ty</span>, <span class="ident">then_diverges</span>);

        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">else_expr</span>) <span class="op">=</span> <span class="ident">opt_else_expr</span> {
            <span class="kw">let</span> <span class="ident">else_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_expectation</span>(<span class="ident">else_expr</span>, <span class="ident">expected</span>);
            <span class="kw">let</span> <span class="ident">else_diverges</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>();

            <span class="ident">coerce</span>.<span class="ident">coerce</span>(<span class="self">self</span>, <span class="kw-2">&amp;</span><span class="ident">if_cause</span>, <span class="ident">else_expr</span>, <span class="ident">else_ty</span>, <span class="ident">else_diverges</span>);

            <span class="comment">// We won&#39;t diverge unless both branches do (or the condition does).</span>
            <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="ident">cond_diverges</span> <span class="op">|</span> <span class="ident">then_diverges</span> <span class="op">&amp;</span> <span class="ident">else_diverges</span>);
        } <span class="kw">else</span> {
            <span class="kw">let</span> <span class="ident">else_cause</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">cause</span>(<span class="ident">sp</span>, <span class="ident">ObligationCauseCode</span>::<span class="ident">IfExpressionWithNoElse</span>);
            <span class="ident">coerce</span>.<span class="ident">coerce_forced_unit</span>(<span class="self">self</span>, <span class="kw-2">&amp;</span><span class="ident">else_cause</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="op">|</span>_<span class="op">|</span> (), <span class="bool-val">true</span>);

            <span class="comment">// If the condition is false we can&#39;t diverge.</span>
            <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="ident">cond_diverges</span>);
        }

        <span class="kw">let</span> <span class="ident">result_ty</span> <span class="op">=</span> <span class="ident">coerce</span>.<span class="ident">complete</span>(<span class="self">self</span>);
        <span class="kw">if</span> <span class="ident">cond_ty</span>.<span class="ident">references_error</span>() {
            <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
        } <span class="kw">else</span> {
            <span class="ident">result_ty</span>
        }
    }

    <span class="comment">// Check field access expressions</span>
    <span class="kw">fn</span> <span class="ident">check_field</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                   <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                   <span class="ident">lvalue_pref</span>: <span class="ident">LvaluePreference</span>,
                   <span class="ident">base</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                   <span class="ident">field</span>: <span class="kw-2">&amp;</span><span class="ident">Spanned</span><span class="op">&lt;</span><span class="ident">ast</span>::<span class="ident">Name</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">expr_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_lvalue_pref</span>(<span class="ident">base</span>, <span class="ident">lvalue_pref</span>);
        <span class="kw">let</span> <span class="ident">expr_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">structurally_resolved_type</span>(<span class="ident">expr</span>.<span class="ident">span</span>,
                                                     <span class="ident">expr_t</span>);
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">private_candidate</span> <span class="op">=</span> <span class="prelude-val">None</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">autoderef</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">autoderef</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">expr_t</span>);
        <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">base_t</span>, _)) <span class="op">=</span> <span class="ident">autoderef</span>.<span class="ident">next</span>() {
            <span class="kw">match</span> <span class="ident">base_t</span>.<span class="ident">sty</span> {
                <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">base_def</span>, <span class="ident">substs</span>) <span class="kw">if</span> <span class="op">!</span><span class="ident">base_def</span>.<span class="ident">is_enum</span>() <span class="op">=&gt;</span> {
                    <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;struct named {:?}&quot;</span>,  <span class="ident">base_t</span>);
                    <span class="kw">let</span> (<span class="ident">ident</span>, <span class="ident">def_scope</span>) <span class="op">=</span>
                        <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">adjust</span>(<span class="ident">field</span>.<span class="ident">node</span>, <span class="ident">base_def</span>.<span class="ident">did</span>, <span class="self">self</span>.<span class="ident">body_id</span>);
                    <span class="kw">let</span> <span class="ident">fields</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">base_def</span>.<span class="ident">struct_variant</span>().<span class="ident">fields</span>;
                    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">field</span>) <span class="op">=</span> <span class="ident">fields</span>.<span class="ident">iter</span>().<span class="ident">find</span>(<span class="op">|</span><span class="ident">f</span><span class="op">|</span> <span class="ident">f</span>.<span class="ident">name</span>.<span class="ident">to_ident</span>() <span class="op">==</span> <span class="ident">ident</span>) {
                        <span class="kw">let</span> <span class="ident">field_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">field_ty</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">field</span>, <span class="ident">substs</span>);
                        <span class="kw">if</span> <span class="ident">field</span>.<span class="ident">vis</span>.<span class="ident">is_accessible_from</span>(<span class="ident">def_scope</span>, <span class="self">self</span>.<span class="ident">tcx</span>) {
                            <span class="kw">let</span> <span class="ident">adjustments</span> <span class="op">=</span> <span class="ident">autoderef</span>.<span class="ident">adjust_steps</span>(<span class="ident">lvalue_pref</span>);
                            <span class="self">self</span>.<span class="ident">apply_adjustments</span>(<span class="ident">base</span>, <span class="ident">adjustments</span>);
                            <span class="ident">autoderef</span>.<span class="ident">finalize</span>();

                            <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">check_stability</span>(<span class="ident">field</span>.<span class="ident">did</span>, <span class="ident">expr</span>.<span class="ident">id</span>, <span class="ident">expr</span>.<span class="ident">span</span>);

                            <span class="kw">return</span> <span class="ident">field_ty</span>;
                        }
                        <span class="ident">private_candidate</span> <span class="op">=</span> <span class="prelude-val">Some</span>((<span class="ident">base_def</span>.<span class="ident">did</span>, <span class="ident">field_ty</span>));
                    }
                }
                _ <span class="op">=&gt;</span> {}
            }
        }
        <span class="ident">autoderef</span>.<span class="ident">unambiguous_final_ty</span>();

        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">did</span>, <span class="ident">field_ty</span>)) <span class="op">=</span> <span class="ident">private_candidate</span> {
            <span class="kw">let</span> <span class="ident">struct_path</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">item_path_str</span>(<span class="ident">did</span>);
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">sess</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">E0616</span>,
                                           <span class="string">&quot;field `{}` of struct `{}` is private&quot;</span>,
                                           <span class="ident">field</span>.<span class="ident">node</span>, <span class="ident">struct_path</span>);
            <span class="comment">// Also check if an accessible method exists, which is often what is meant.</span>
            <span class="kw">if</span> <span class="self">self</span>.<span class="ident">method_exists</span>(<span class="ident">field</span>.<span class="ident">span</span>, <span class="ident">field</span>.<span class="ident">node</span>, <span class="ident">expr_t</span>, <span class="ident">expr</span>.<span class="ident">id</span>, <span class="bool-val">false</span>) {
                <span class="ident">err</span>.<span class="ident">note</span>(<span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;a method `{}` also exists, perhaps you wish to call it&quot;</span>,
                                  <span class="ident">field</span>.<span class="ident">node</span>));
            }
            <span class="ident">err</span>.<span class="ident">emit</span>();
            <span class="ident">field_ty</span>
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">field</span>.<span class="ident">node</span> <span class="op">==</span> <span class="ident">keywords</span>::<span class="ident">Invalid</span>.<span class="ident">name</span>() {
            <span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">types</span>.<span class="ident">err</span>
        } <span class="kw">else</span> <span class="kw">if</span> <span class="self">self</span>.<span class="ident">method_exists</span>(<span class="ident">field</span>.<span class="ident">span</span>, <span class="ident">field</span>.<span class="ident">node</span>, <span class="ident">expr_t</span>, <span class="ident">expr</span>.<span class="ident">id</span>, <span class="bool-val">true</span>) {
            <span class="macro">type_error_struct</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">sess</span>, <span class="ident">field</span>.<span class="ident">span</span>, <span class="ident">expr_t</span>, <span class="ident">E0615</span>,
                              <span class="string">&quot;attempted to take value of method `{}` on type `{}`&quot;</span>,
                              <span class="ident">field</span>.<span class="ident">node</span>, <span class="ident">expr_t</span>)
                .<span class="ident">help</span>(<span class="string">&quot;maybe a `()` to call it is missing?&quot;</span>)
                .<span class="ident">emit</span>();
            <span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">types</span>.<span class="ident">err</span>
        } <span class="kw">else</span> {
            <span class="kw">if</span> <span class="op">!</span><span class="ident">expr_t</span>.<span class="ident">is_primitive_ty</span>() {
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">no_such_field_err</span>(<span class="ident">field</span>.<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="ident">field</span>.<span class="ident">node</span>, <span class="ident">expr_t</span>);

                <span class="kw">match</span> <span class="ident">expr_t</span>.<span class="ident">sty</span> {
                    <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">def</span>, _) <span class="kw">if</span> <span class="op">!</span><span class="ident">def</span>.<span class="ident">is_enum</span>() <span class="op">=&gt;</span> {
                        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">suggested_field_name</span>) <span class="op">=</span>
                            <span class="self">Self</span>::<span class="ident">suggest_field_name</span>(<span class="ident">def</span>.<span class="ident">struct_variant</span>(), <span class="ident">field</span>, <span class="macro">vec</span><span class="macro">!</span>[]) {
                                <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">field</span>.<span class="ident">span</span>,
                                               <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;did you mean `{}`?&quot;</span>, <span class="ident">suggested_field_name</span>));
                            } <span class="kw">else</span> {
                                <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">field</span>.<span class="ident">span</span>, <span class="string">&quot;unknown field&quot;</span>);
                                <span class="kw">let</span> <span class="ident">struct_variant_def</span> <span class="op">=</span> <span class="ident">def</span>.<span class="ident">struct_variant</span>();
                                <span class="kw">let</span> <span class="ident">field_names</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">available_field_names</span>(<span class="ident">struct_variant_def</span>);
                                <span class="kw">if</span> <span class="op">!</span><span class="ident">field_names</span>.<span class="ident">is_empty</span>() {
                                    <span class="ident">err</span>.<span class="ident">note</span>(<span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;available fields are: {}&quot;</span>,
                                                      <span class="self">self</span>.<span class="ident">name_series_display</span>(<span class="ident">field_names</span>)));
                                }
                            };
                    }
                    <span class="ident">ty</span>::<span class="ident">TyRawPtr</span>(..) <span class="op">=&gt;</span> {
                        <span class="ident">err</span>.<span class="ident">note</span>(<span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;`{0}` is a native pointer; perhaps you need to deref \
                                           with `(*{0}).{1}`&quot;</span>,
                                          <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">node_to_pretty_string</span>(<span class="ident">base</span>.<span class="ident">id</span>),
                                          <span class="ident">field</span>.<span class="ident">node</span>));
                    }
                    _ <span class="op">=&gt;</span> {}
                }
                <span class="ident">err</span>
            } <span class="kw">else</span> {
                <span class="macro">type_error_struct</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">sess</span>, <span class="ident">field</span>.<span class="ident">span</span>, <span class="ident">expr_t</span>, <span class="ident">E0610</span>,
                                   <span class="string">&quot;`{}` is a primitive type and therefore doesn&#39;t have fields&quot;</span>,
                                   <span class="ident">expr_t</span>)
            }.<span class="ident">emit</span>();
            <span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">types</span>.<span class="ident">err</span>
        }
    }

    <span class="comment">// Return an hint about the closest match in field names</span>
    <span class="kw">fn</span> <span class="ident">suggest_field_name</span>(<span class="ident">variant</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">ty</span>::<span class="ident">VariantDef</span>,
                          <span class="ident">field</span>: <span class="kw-2">&amp;</span><span class="ident">Spanned</span><span class="op">&lt;</span><span class="ident">ast</span>::<span class="ident">Name</span><span class="op">&gt;</span>,
                          <span class="ident">skip</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">InternedString</span><span class="op">&gt;</span>)
                          <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Symbol</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">field</span>.<span class="ident">node</span>.<span class="ident">as_str</span>();
        <span class="kw">let</span> <span class="ident">names</span> <span class="op">=</span> <span class="ident">variant</span>.<span class="ident">fields</span>.<span class="ident">iter</span>().<span class="ident">filter_map</span>(<span class="op">|</span><span class="ident">field</span><span class="op">|</span> {
            <span class="comment">// ignore already set fields and private fields from non-local crates</span>
            <span class="kw">if</span> <span class="ident">skip</span>.<span class="ident">iter</span>().<span class="ident">any</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">x</span> <span class="op">==</span> <span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">as_str</span>()) <span class="op">||</span>
               (<span class="ident">variant</span>.<span class="ident">did</span>.<span class="ident">krate</span> <span class="op">!=</span> <span class="ident">LOCAL_CRATE</span> <span class="op">&amp;&amp;</span> <span class="ident">field</span>.<span class="ident">vis</span> <span class="op">!=</span> <span class="ident">Visibility</span>::<span class="ident">Public</span>) {
                <span class="prelude-val">None</span>
            } <span class="kw">else</span> {
                <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">field</span>.<span class="ident">name</span>)
            }
        });

        <span class="ident">find_best_match_for_name</span>(<span class="ident">names</span>, <span class="kw-2">&amp;</span><span class="ident">name</span>, <span class="prelude-val">None</span>)
    }

    <span class="kw">fn</span> <span class="ident">available_field_names</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">variant</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">ty</span>::<span class="ident">VariantDef</span>) <span class="op">-&gt;</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">ast</span>::<span class="ident">Name</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">available</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();
        <span class="kw">for</span> <span class="ident">field</span> <span class="kw">in</span> <span class="ident">variant</span>.<span class="ident">fields</span>.<span class="ident">iter</span>() {
            <span class="kw">let</span> (_, <span class="ident">def_scope</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">adjust</span>(<span class="ident">field</span>.<span class="ident">name</span>, <span class="ident">variant</span>.<span class="ident">did</span>, <span class="self">self</span>.<span class="ident">body_id</span>);
            <span class="kw">if</span> <span class="ident">field</span>.<span class="ident">vis</span>.<span class="ident">is_accessible_from</span>(<span class="ident">def_scope</span>, <span class="self">self</span>.<span class="ident">tcx</span>) {
                <span class="ident">available</span>.<span class="ident">push</span>(<span class="ident">field</span>.<span class="ident">name</span>);
            }
        }
        <span class="ident">available</span>
    }

    <span class="kw">fn</span> <span class="ident">name_series_display</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">names</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">ast</span>::<span class="ident">Name</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">String</span> {
        <span class="comment">// dynamic limit, to never omit just one field</span>
        <span class="kw">let</span> <span class="ident">limit</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">names</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">6</span> { <span class="number">6</span> } <span class="kw">else</span> { <span class="number">5</span> };
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">display</span> <span class="op">=</span> <span class="ident">names</span>.<span class="ident">iter</span>().<span class="ident">take</span>(<span class="ident">limit</span>)
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">n</span><span class="op">|</span> <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;`{}`&quot;</span>, <span class="ident">n</span>)).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>().<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>);
        <span class="kw">if</span> <span class="ident">names</span>.<span class="ident">len</span>() <span class="op">&gt;</span> <span class="ident">limit</span> {
            <span class="ident">display</span> <span class="op">=</span> <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{} ... and {} others&quot;</span>, <span class="ident">display</span>, <span class="ident">names</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="ident">limit</span>);
        }
        <span class="ident">display</span>
    }

    <span class="comment">// Check tuple index expressions</span>
    <span class="kw">fn</span> <span class="ident">check_tup_field</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                       <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                       <span class="ident">lvalue_pref</span>: <span class="ident">LvaluePreference</span>,
                       <span class="ident">base</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                       <span class="ident">idx</span>: <span class="ident">codemap</span>::<span class="ident">Spanned</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">expr_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_lvalue_pref</span>(<span class="ident">base</span>, <span class="ident">lvalue_pref</span>);
        <span class="kw">let</span> <span class="ident">expr_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">structurally_resolved_type</span>(<span class="ident">expr</span>.<span class="ident">span</span>,
                                                     <span class="ident">expr_t</span>);
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">private_candidate</span> <span class="op">=</span> <span class="prelude-val">None</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">tuple_like</span> <span class="op">=</span> <span class="bool-val">false</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">autoderef</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">autoderef</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">expr_t</span>);
        <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">base_t</span>, _)) <span class="op">=</span> <span class="ident">autoderef</span>.<span class="ident">next</span>() {
            <span class="kw">let</span> <span class="ident">field</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">base_t</span>.<span class="ident">sty</span> {
                <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">base_def</span>, <span class="ident">substs</span>) <span class="kw">if</span> <span class="ident">base_def</span>.<span class="ident">is_struct</span>() <span class="op">=&gt;</span> {
                    <span class="ident">tuple_like</span> <span class="op">=</span> <span class="ident">base_def</span>.<span class="ident">struct_variant</span>().<span class="ident">ctor_kind</span> <span class="op">==</span> <span class="ident">CtorKind</span>::<span class="ident">Fn</span>;
                    <span class="kw">if</span> <span class="op">!</span><span class="ident">tuple_like</span> { <span class="kw">continue</span> }

                    <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;tuple struct named {:?}&quot;</span>,  <span class="ident">base_t</span>);
                    <span class="kw">let</span> <span class="ident">ident</span> <span class="op">=</span> <span class="ident">ast</span>::<span class="ident">Ident</span> {
                        <span class="ident">name</span>: <span class="ident">Symbol</span>::<span class="ident">intern</span>(<span class="kw-2">&amp;</span><span class="ident">idx</span>.<span class="ident">node</span>.<span class="ident">to_string</span>()),
                        <span class="ident">ctxt</span>: <span class="ident">idx</span>.<span class="ident">span</span>.<span class="ident">ctxt</span>().<span class="ident">modern</span>(),
                    };
                    <span class="kw">let</span> (<span class="ident">ident</span>, <span class="ident">def_scope</span>) <span class="op">=</span>
                        <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">adjust_ident</span>(<span class="ident">ident</span>, <span class="ident">base_def</span>.<span class="ident">did</span>, <span class="self">self</span>.<span class="ident">body_id</span>);
                    <span class="kw">let</span> <span class="ident">fields</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">base_def</span>.<span class="ident">struct_variant</span>().<span class="ident">fields</span>;
                    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">field</span>) <span class="op">=</span> <span class="ident">fields</span>.<span class="ident">iter</span>().<span class="ident">find</span>(<span class="op">|</span><span class="ident">f</span><span class="op">|</span> <span class="ident">f</span>.<span class="ident">name</span>.<span class="ident">to_ident</span>() <span class="op">==</span> <span class="ident">ident</span>) {
                        <span class="kw">let</span> <span class="ident">field_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">field_ty</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">field</span>, <span class="ident">substs</span>);
                        <span class="kw">if</span> <span class="ident">field</span>.<span class="ident">vis</span>.<span class="ident">is_accessible_from</span>(<span class="ident">def_scope</span>, <span class="self">self</span>.<span class="ident">tcx</span>) {
                            <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">check_stability</span>(<span class="ident">field</span>.<span class="ident">did</span>, <span class="ident">expr</span>.<span class="ident">id</span>, <span class="ident">expr</span>.<span class="ident">span</span>);
                            <span class="prelude-val">Some</span>(<span class="ident">field_ty</span>)
                        } <span class="kw">else</span> {
                            <span class="ident">private_candidate</span> <span class="op">=</span> <span class="prelude-val">Some</span>((<span class="ident">base_def</span>.<span class="ident">did</span>, <span class="ident">field_ty</span>));
                            <span class="prelude-val">None</span>
                        }
                    } <span class="kw">else</span> {
                        <span class="prelude-val">None</span>
                    }
                }
                <span class="ident">ty</span>::<span class="ident">TyTuple</span>(<span class="kw-2">ref</span> <span class="ident">v</span>, _) <span class="op">=&gt;</span> {
                    <span class="ident">tuple_like</span> <span class="op">=</span> <span class="bool-val">true</span>;
                    <span class="ident">v</span>.<span class="ident">get</span>(<span class="ident">idx</span>.<span class="ident">node</span>).<span class="ident">cloned</span>()
                }
                _ <span class="op">=&gt;</span> <span class="kw">continue</span>
            };

            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">field_ty</span>) <span class="op">=</span> <span class="ident">field</span> {
                <span class="kw">let</span> <span class="ident">adjustments</span> <span class="op">=</span> <span class="ident">autoderef</span>.<span class="ident">adjust_steps</span>(<span class="ident">lvalue_pref</span>);
                <span class="self">self</span>.<span class="ident">apply_adjustments</span>(<span class="ident">base</span>, <span class="ident">adjustments</span>);
                <span class="ident">autoderef</span>.<span class="ident">finalize</span>();
                <span class="kw">return</span> <span class="ident">field_ty</span>;
            }
        }
        <span class="ident">autoderef</span>.<span class="ident">unambiguous_final_ty</span>();

        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">did</span>, <span class="ident">field_ty</span>)) <span class="op">=</span> <span class="ident">private_candidate</span> {
            <span class="kw">let</span> <span class="ident">struct_path</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">item_path_str</span>(<span class="ident">did</span>);
            <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">sess</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">E0611</span>,
                             <span class="string">&quot;field `{}` of tuple-struct `{}` is private&quot;</span>,
                             <span class="ident">idx</span>.<span class="ident">node</span>, <span class="ident">struct_path</span>).<span class="ident">emit</span>();
            <span class="kw">return</span> <span class="ident">field_ty</span>;
        }

        <span class="kw">if</span> <span class="ident">tuple_like</span> {
            <span class="macro">type_error_struct</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">sess</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">expr_t</span>, <span class="ident">E0612</span>,
                <span class="string">&quot;attempted out-of-bounds tuple index `{}` on type `{}`&quot;</span>,
                <span class="ident">idx</span>.<span class="ident">node</span>, <span class="ident">expr_t</span>).<span class="ident">emit</span>();
        } <span class="kw">else</span> {
            <span class="self">self</span>.<span class="ident">no_such_field_err</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">idx</span>.<span class="ident">node</span>, <span class="ident">expr_t</span>).<span class="ident">emit</span>();
        }

        <span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">types</span>.<span class="ident">err</span>
    }

    <span class="kw">fn</span> <span class="ident">no_such_field_err</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Display</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">span</span>: <span class="ident">Span</span>, <span class="ident">field</span>: <span class="ident">T</span>, <span class="ident">expr_t</span>: <span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">TyS</span>)
        <span class="op">-&gt;</span> <span class="ident">DiagnosticBuilder</span> {
        <span class="macro">type_error_struct</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>().<span class="ident">sess</span>, <span class="ident">span</span>, <span class="ident">expr_t</span>, <span class="ident">E0609</span>,
                           <span class="string">&quot;no field `{}` on type `{}`&quot;</span>,
                           <span class="ident">field</span>, <span class="ident">expr_t</span>)
    }

    <span class="kw">fn</span> <span class="ident">report_unknown_field</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                            <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                            <span class="ident">variant</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">ty</span>::<span class="ident">VariantDef</span>,
                            <span class="ident">field</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Field</span>,
                            <span class="ident">skip_fields</span>: <span class="kw-2">&amp;</span>[<span class="ident">hir</span>::<span class="ident">Field</span>],
                            <span class="ident">kind_name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">type_error_struct_with_diag</span>(
            <span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">span</span>,
            <span class="op">|</span><span class="ident">actual</span><span class="op">|</span> <span class="kw">match</span> <span class="ident">ty</span>.<span class="ident">sty</span> {
                <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">adt</span>, ..) <span class="kw">if</span> <span class="ident">adt</span>.<span class="ident">is_enum</span>() <span class="op">=&gt;</span> {
                    <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">span</span>, <span class="ident">E0559</span>,
                                    <span class="string">&quot;{} `{}::{}` has no field named `{}`&quot;</span>,
                                    <span class="ident">kind_name</span>, <span class="ident">actual</span>, <span class="ident">variant</span>.<span class="ident">name</span>, <span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">node</span>)
                }
                _ <span class="op">=&gt;</span> {
                    <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">span</span>, <span class="ident">E0560</span>,
                                    <span class="string">&quot;{} `{}` has no field named `{}`&quot;</span>,
                                    <span class="ident">kind_name</span>, <span class="ident">actual</span>, <span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">node</span>)
                }
            },
            <span class="ident">ty</span>);
        <span class="comment">// prevent all specified fields from being suggested</span>
        <span class="kw">let</span> <span class="ident">skip_fields</span> <span class="op">=</span> <span class="ident">skip_fields</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="kw-2">ref</span> <span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">name</span>.<span class="ident">node</span>.<span class="ident">as_str</span>());
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">field_name</span>) <span class="op">=</span> <span class="self">Self</span>::<span class="ident">suggest_field_name</span>(<span class="ident">variant</span>,
                                                           <span class="kw-2">&amp;</span><span class="ident">field</span>.<span class="ident">name</span>,
                                                           <span class="ident">skip_fields</span>.<span class="ident">collect</span>()) {
            <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">span</span>,
                           <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;field does not exist - did you mean `{}`?&quot;</span>, <span class="ident">field_name</span>));
        } <span class="kw">else</span> {
            <span class="kw">match</span> <span class="ident">ty</span>.<span class="ident">sty</span> {
                <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">adt</span>, ..) <span class="op">=&gt;</span> {
                    <span class="kw">if</span> <span class="ident">adt</span>.<span class="ident">is_enum</span>() {
                        <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">span</span>,
                                       <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;`{}::{}` does not have this field&quot;</span>,
                                               <span class="ident">ty</span>, <span class="ident">variant</span>.<span class="ident">name</span>));
                    } <span class="kw">else</span> {
                        <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">span</span>,
                                       <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;`{}` does not have this field&quot;</span>, <span class="ident">ty</span>));
                    }
                    <span class="kw">let</span> <span class="ident">available_field_names</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">available_field_names</span>(<span class="ident">variant</span>);
                    <span class="kw">if</span> <span class="op">!</span><span class="ident">available_field_names</span>.<span class="ident">is_empty</span>() {
                        <span class="ident">err</span>.<span class="ident">note</span>(<span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;available fields are: {}&quot;</span>,
                                          <span class="self">self</span>.<span class="ident">name_series_display</span>(<span class="ident">available_field_names</span>)));
                    }
                }
                _ <span class="op">=&gt;</span> <span class="macro">bug</span><span class="macro">!</span>(<span class="string">&quot;non-ADT passed to report_unknown_field&quot;</span>)
            }
        };
        <span class="ident">err</span>.<span class="ident">emit</span>();
    }

    <span class="kw">fn</span> <span class="ident">check_expr_struct_fields</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                <span class="ident">adt_ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                <span class="ident">expected</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                <span class="ident">expr_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>,
                                <span class="ident">span</span>: <span class="ident">Span</span>,
                                <span class="ident">variant</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">ty</span>::<span class="ident">VariantDef</span>,
                                <span class="ident">ast_fields</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> [<span class="ident">hir</span>::<span class="ident">Field</span>],
                                <span class="ident">check_completeness</span>: <span class="ident">bool</span>) {
        <span class="kw">let</span> <span class="ident">tcx</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>;

        <span class="kw">let</span> <span class="ident">adt_ty_hint</span> <span class="op">=</span>
            <span class="self">self</span>.<span class="ident">expected_inputs_for_expected_output</span>(<span class="ident">span</span>, <span class="ident">expected</span>, <span class="ident">adt_ty</span>, <span class="kw-2">&amp;</span>[<span class="ident">adt_ty</span>])
                .<span class="ident">get</span>(<span class="number">0</span>).<span class="ident">cloned</span>().<span class="ident">unwrap_or</span>(<span class="ident">adt_ty</span>);
        <span class="comment">// re-link the regions that EIfEO can erase.</span>
        <span class="self">self</span>.<span class="ident">demand_eqtype</span>(<span class="ident">span</span>, <span class="ident">adt_ty_hint</span>, <span class="ident">adt_ty</span>);

        <span class="kw">let</span> (<span class="ident">substs</span>, <span class="ident">adt_kind</span>, <span class="ident">kind_name</span>) <span class="op">=</span> <span class="kw">match</span> <span class="kw-2">&amp;</span><span class="ident">adt_ty</span>.<span class="ident">sty</span>{
            <span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">adt</span>, <span class="ident">substs</span>) <span class="op">=&gt;</span> {
                (<span class="ident">substs</span>, <span class="ident">adt</span>.<span class="ident">adt_kind</span>(), <span class="ident">adt</span>.<span class="ident">variant_descr</span>())
            }
            _ <span class="op">=&gt;</span> <span class="macro">span_bug</span><span class="macro">!</span>(<span class="ident">span</span>, <span class="string">&quot;non-ADT passed to check_expr_struct_fields&quot;</span>)
        };

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">remaining_fields</span> <span class="op">=</span> <span class="ident">FxHashMap</span>();
        <span class="kw">for</span> <span class="ident">field</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">variant</span>.<span class="ident">fields</span> {
            <span class="ident">remaining_fields</span>.<span class="ident">insert</span>(<span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">to_ident</span>(), <span class="ident">field</span>);
        }

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">seen_fields</span> <span class="op">=</span> <span class="ident">FxHashMap</span>();

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">error_happened</span> <span class="op">=</span> <span class="bool-val">false</span>;

        <span class="comment">// Typecheck each field.</span>
        <span class="kw">for</span> <span class="ident">field</span> <span class="kw">in</span> <span class="ident">ast_fields</span> {
            <span class="kw">let</span> <span class="ident">ident</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">adjust</span>(<span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">node</span>, <span class="ident">variant</span>.<span class="ident">did</span>, <span class="self">self</span>.<span class="ident">body_id</span>).<span class="number">0</span>;
            <span class="kw">let</span> <span class="ident">field_type</span> <span class="op">=</span> <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">v_field</span>) <span class="op">=</span> <span class="ident">remaining_fields</span>.<span class="ident">remove</span>(<span class="kw-2">&amp;</span><span class="ident">ident</span>) {
                <span class="ident">seen_fields</span>.<span class="ident">insert</span>(<span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">node</span>, <span class="ident">field</span>.<span class="ident">span</span>);

                <span class="comment">// we don&#39;t look at stability attributes on</span>
                <span class="comment">// struct-like enums (yet...), but it&#39;s definitely not</span>
                <span class="comment">// a bug to have construct one.</span>
                <span class="kw">if</span> <span class="ident">adt_kind</span> <span class="op">!=</span> <span class="ident">ty</span>::<span class="ident">AdtKind</span>::<span class="ident">Enum</span> {
                    <span class="ident">tcx</span>.<span class="ident">check_stability</span>(<span class="ident">v_field</span>.<span class="ident">did</span>, <span class="ident">expr_id</span>, <span class="ident">field</span>.<span class="ident">span</span>);
                }

                <span class="self">self</span>.<span class="ident">field_ty</span>(<span class="ident">field</span>.<span class="ident">span</span>, <span class="ident">v_field</span>, <span class="ident">substs</span>)
            } <span class="kw">else</span> {
                <span class="ident">error_happened</span> <span class="op">=</span> <span class="bool-val">true</span>;
                <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(_) <span class="op">=</span> <span class="ident">variant</span>.<span class="ident">find_field_named</span>(<span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">node</span>) {
                    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>,
                                                <span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">span</span>,
                                                <span class="ident">E0062</span>,
                                                <span class="string">&quot;field `{}` specified more than once&quot;</span>,
                                                <span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">node</span>);

                    <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">span</span>, <span class="string">&quot;used more than once&quot;</span>);

                    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">prev_span</span>) <span class="op">=</span> <span class="ident">seen_fields</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">node</span>) {
                        <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="kw-2">*</span><span class="ident">prev_span</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;first use of `{}`&quot;</span>, <span class="ident">field</span>.<span class="ident">name</span>.<span class="ident">node</span>));
                    }

                    <span class="ident">err</span>.<span class="ident">emit</span>();
                } <span class="kw">else</span> {
                    <span class="self">self</span>.<span class="ident">report_unknown_field</span>(<span class="ident">adt_ty</span>, <span class="ident">variant</span>, <span class="ident">field</span>, <span class="ident">ast_fields</span>, <span class="ident">kind_name</span>);
                }

                <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
            };

            <span class="comment">// Make sure to give a type to the field even if there&#39;s</span>
            <span class="comment">// an error, so we can continue typechecking</span>
            <span class="self">self</span>.<span class="ident">check_expr_coercable_to_type</span>(<span class="kw-2">&amp;</span><span class="ident">field</span>.<span class="ident">expr</span>, <span class="ident">field_type</span>);
        }

        <span class="comment">// Make sure the programmer specified correct number of fields.</span>
        <span class="kw">if</span> <span class="ident">kind_name</span> <span class="op">==</span> <span class="string">&quot;union&quot;</span> {
            <span class="kw">if</span> <span class="ident">ast_fields</span>.<span class="ident">len</span>() <span class="op">!=</span> <span class="number">1</span> {
                <span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">span_err</span>(<span class="ident">span</span>, <span class="string">&quot;union expressions should have exactly one field&quot;</span>);
            }
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">check_completeness</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="ident">error_happened</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="ident">remaining_fields</span>.<span class="ident">is_empty</span>() {
            <span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="ident">remaining_fields</span>.<span class="ident">len</span>();

            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">displayable_field_names</span> <span class="op">=</span> <span class="ident">remaining_fields</span>
                                              .<span class="ident">keys</span>()
                                              .<span class="ident">map</span>(<span class="op">|</span><span class="ident">ident</span><span class="op">|</span> <span class="ident">ident</span>.<span class="ident">name</span>.<span class="ident">as_str</span>())
                                              .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>();

            <span class="ident">displayable_field_names</span>.<span class="ident">sort</span>();

            <span class="kw">let</span> <span class="ident">truncated_fields_error</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">len</span> <span class="op">&lt;=</span> <span class="number">3</span> {
                <span class="string">&quot;&quot;</span>.<span class="ident">to_string</span>()
            } <span class="kw">else</span> {
                <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot; and {} other field{}&quot;</span>, (<span class="ident">len</span> <span class="op">-</span> <span class="number">3</span>), <span class="kw">if</span> <span class="ident">len</span> <span class="op">-</span> <span class="number">3</span> <span class="op">==</span> <span class="number">1</span> {<span class="string">&quot;&quot;</span>} <span class="kw">else</span> {<span class="string">&quot;s&quot;</span>})
            };

            <span class="kw">let</span> <span class="ident">remaining_fields_names</span> <span class="op">=</span> <span class="ident">displayable_field_names</span>.<span class="ident">iter</span>().<span class="ident">take</span>(<span class="number">3</span>)
                                        .<span class="ident">map</span>(<span class="op">|</span><span class="ident">n</span><span class="op">|</span> <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;`{}`&quot;</span>, <span class="ident">n</span>))
                                        .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>()
                                        .<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>);

            <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">span</span>, <span class="ident">E0063</span>,
                             <span class="string">&quot;missing field{} {}{} in initializer of `{}`&quot;</span>,
                             <span class="kw">if</span> <span class="ident">remaining_fields</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">1</span> { <span class="string">&quot;&quot;</span> } <span class="kw">else</span> { <span class="string">&quot;s&quot;</span> },
                             <span class="ident">remaining_fields_names</span>,
                             <span class="ident">truncated_fields_error</span>,
                             <span class="ident">adt_ty</span>)
                .<span class="ident">span_label</span>(<span class="ident">span</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;missing {}{}&quot;</span>,
                                          <span class="ident">remaining_fields_names</span>,
                                          <span class="ident">truncated_fields_error</span>))
                .<span class="ident">emit</span>();
        }
    }

    <span class="kw">fn</span> <span class="ident">check_struct_fields_on_error</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                    <span class="ident">fields</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> [<span class="ident">hir</span>::<span class="ident">Field</span>],
                                    <span class="ident">base_expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&lt;</span><span class="ident">hir</span>::<span class="ident">Expr</span><span class="op">&gt;&gt;</span>) {
        <span class="kw">for</span> <span class="ident">field</span> <span class="kw">in</span> <span class="ident">fields</span> {
            <span class="self">self</span>.<span class="ident">check_expr</span>(<span class="kw-2">&amp;</span><span class="ident">field</span>.<span class="ident">expr</span>);
        }
        <span class="kw">match</span> <span class="kw-2">*</span><span class="ident">base_expr</span> {
            <span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="ident">base</span>) <span class="op">=&gt;</span> {
                <span class="self">self</span>.<span class="ident">check_expr</span>(<span class="kw-2">&amp;</span><span class="ident">base</span>);
            },
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> {}
        }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_struct_path</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                             <span class="ident">qpath</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">QPath</span>,
                             <span class="ident">node_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>)
                             <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx</span> <span class="ident">ty</span>::<span class="ident">VariantDef</span>,  <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)<span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">path_span</span> <span class="op">=</span> <span class="kw">match</span> <span class="kw-2">*</span><span class="ident">qpath</span> {
            <span class="ident">hir</span>::<span class="ident">QPath</span>::<span class="ident">Resolved</span>(_, <span class="kw-2">ref</span> <span class="ident">path</span>) <span class="op">=&gt;</span> <span class="ident">path</span>.<span class="ident">span</span>,
            <span class="ident">hir</span>::<span class="ident">QPath</span>::<span class="ident">TypeRelative</span>(<span class="kw-2">ref</span> <span class="ident">qself</span>, _) <span class="op">=&gt;</span> <span class="ident">qself</span>.<span class="ident">span</span>
        };
        <span class="kw">let</span> (<span class="ident">def</span>, <span class="ident">ty</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">finish_resolving_struct_path</span>(<span class="ident">qpath</span>, <span class="ident">path_span</span>, <span class="ident">node_id</span>);
        <span class="kw">let</span> <span class="ident">variant</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">def</span> {
            <span class="ident">Def</span>::<span class="prelude-val">Err</span> <span class="op">=&gt;</span> {
                <span class="self">self</span>.<span class="ident">set_tainted_by_errors</span>();
                <span class="kw">return</span> <span class="prelude-val">None</span>;
            }
            <span class="ident">Def</span>::<span class="ident">Variant</span>(..) <span class="op">=&gt;</span> {
                <span class="kw">match</span> <span class="ident">ty</span>.<span class="ident">sty</span> {
                    <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">adt</span>, <span class="ident">substs</span>) <span class="op">=&gt;</span> {
                        <span class="prelude-val">Some</span>((<span class="ident">adt</span>.<span class="ident">variant_of_def</span>(<span class="ident">def</span>), <span class="ident">adt</span>.<span class="ident">did</span>, <span class="ident">substs</span>))
                    }
                    _ <span class="op">=&gt;</span> <span class="macro">bug</span><span class="macro">!</span>(<span class="string">&quot;unexpected type: {:?}&quot;</span>, <span class="ident">ty</span>.<span class="ident">sty</span>)
                }
            }
            <span class="ident">Def</span>::<span class="ident">Struct</span>(..) <span class="op">|</span> <span class="ident">Def</span>::<span class="ident">Union</span>(..) <span class="op">|</span> <span class="ident">Def</span>::<span class="ident">TyAlias</span>(..) <span class="op">|</span>
            <span class="ident">Def</span>::<span class="ident">AssociatedTy</span>(..) <span class="op">|</span> <span class="ident">Def</span>::<span class="ident">SelfTy</span>(..) <span class="op">=&gt;</span> {
                <span class="kw">match</span> <span class="ident">ty</span>.<span class="ident">sty</span> {
                    <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">adt</span>, <span class="ident">substs</span>) <span class="kw">if</span> <span class="op">!</span><span class="ident">adt</span>.<span class="ident">is_enum</span>() <span class="op">=&gt;</span> {
                        <span class="prelude-val">Some</span>((<span class="ident">adt</span>.<span class="ident">struct_variant</span>(), <span class="ident">adt</span>.<span class="ident">did</span>, <span class="ident">substs</span>))
                    }
                    _ <span class="op">=&gt;</span> <span class="prelude-val">None</span>,
                }
            }
            _ <span class="op">=&gt;</span> <span class="macro">bug</span><span class="macro">!</span>(<span class="string">&quot;unexpected definition: {:?}&quot;</span>, <span class="ident">def</span>)
        };

        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">variant</span>, <span class="ident">did</span>, <span class="ident">substs</span>)) <span class="op">=</span> <span class="ident">variant</span> {
            <span class="comment">// Check bounds on type arguments used in the path.</span>
            <span class="kw">let</span> <span class="ident">bounds</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">instantiate_bounds</span>(<span class="ident">path_span</span>, <span class="ident">did</span>, <span class="ident">substs</span>);
            <span class="kw">let</span> <span class="ident">cause</span> <span class="op">=</span> <span class="ident">traits</span>::<span class="ident">ObligationCause</span>::<span class="ident">new</span>(<span class="ident">path_span</span>, <span class="self">self</span>.<span class="ident">body_id</span>,
                                                     <span class="ident">traits</span>::<span class="ident">ItemObligation</span>(<span class="ident">did</span>));
            <span class="self">self</span>.<span class="ident">add_obligations_for_parameters</span>(<span class="ident">cause</span>, <span class="kw-2">&amp;</span><span class="ident">bounds</span>);

            <span class="prelude-val">Some</span>((<span class="ident">variant</span>, <span class="ident">ty</span>))
        } <span class="kw">else</span> {
            <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">path_span</span>, <span class="ident">E0071</span>,
                             <span class="string">&quot;expected struct, variant or union type, found {}&quot;</span>,
                             <span class="ident">ty</span>.<span class="ident">sort_string</span>(<span class="self">self</span>.<span class="ident">tcx</span>))
                .<span class="ident">span_label</span>(<span class="ident">path_span</span>, <span class="string">&quot;not a struct&quot;</span>)
                .<span class="ident">emit</span>();
            <span class="prelude-val">None</span>
        }
    }

    <span class="kw">fn</span> <span class="ident">check_expr_struct</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                         <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Expr</span>,
                         <span class="ident">expected</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                         <span class="ident">qpath</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">QPath</span>,
                         <span class="ident">fields</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> [<span class="ident">hir</span>::<span class="ident">Field</span>],
                         <span class="ident">base_expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&lt;</span><span class="ident">hir</span>::<span class="ident">Expr</span><span class="op">&gt;&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="comment">// Find the relevant variant</span>
        <span class="kw">let</span> (<span class="ident">variant</span>, <span class="ident">struct_ty</span>) <span class="op">=</span>
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">variant_ty</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_struct_path</span>(<span class="ident">qpath</span>, <span class="ident">expr</span>.<span class="ident">id</span>) {
            <span class="ident">variant_ty</span>
        } <span class="kw">else</span> {
            <span class="self">self</span>.<span class="ident">check_struct_fields_on_error</span>(<span class="ident">fields</span>, <span class="ident">base_expr</span>);
            <span class="kw">return</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>;
        };

        <span class="kw">let</span> <span class="ident">path_span</span> <span class="op">=</span> <span class="kw">match</span> <span class="kw-2">*</span><span class="ident">qpath</span> {
            <span class="ident">hir</span>::<span class="ident">QPath</span>::<span class="ident">Resolved</span>(_, <span class="kw-2">ref</span> <span class="ident">path</span>) <span class="op">=&gt;</span> <span class="ident">path</span>.<span class="ident">span</span>,
            <span class="ident">hir</span>::<span class="ident">QPath</span>::<span class="ident">TypeRelative</span>(<span class="kw-2">ref</span> <span class="ident">qself</span>, _) <span class="op">=&gt;</span> <span class="ident">qself</span>.<span class="ident">span</span>
        };

        <span class="self">self</span>.<span class="ident">check_expr_struct_fields</span>(<span class="ident">struct_ty</span>, <span class="ident">expected</span>, <span class="ident">expr</span>.<span class="ident">id</span>, <span class="ident">path_span</span>, <span class="ident">variant</span>, <span class="ident">fields</span>,
                                      <span class="ident">base_expr</span>.<span class="ident">is_none</span>());
        <span class="kw">if</span> <span class="kw">let</span> <span class="kw-2">&amp;</span><span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="ident">base_expr</span>) <span class="op">=</span> <span class="ident">base_expr</span> {
            <span class="self">self</span>.<span class="ident">check_expr_has_type_or_error</span>(<span class="ident">base_expr</span>, <span class="ident">struct_ty</span>);
            <span class="kw">match</span> <span class="ident">struct_ty</span>.<span class="ident">sty</span> {
                <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">adt</span>, <span class="ident">substs</span>) <span class="kw">if</span> <span class="ident">adt</span>.<span class="ident">is_struct</span>() <span class="op">=&gt;</span> {
                    <span class="kw">let</span> <span class="ident">fru_field_types</span> <span class="op">=</span> <span class="ident">adt</span>.<span class="ident">struct_variant</span>().<span class="ident">fields</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">f</span><span class="op">|</span> {
                        <span class="self">self</span>.<span class="ident">normalize_associated_types_in</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="ident">f</span>.<span class="ident">ty</span>(<span class="self">self</span>.<span class="ident">tcx</span>, <span class="ident">substs</span>))
                    }).<span class="ident">collect</span>();

                    <span class="self">self</span>.<span class="ident">tables</span>
                        .<span class="ident">borrow_mut</span>()
                        .<span class="ident">fru_field_types_mut</span>()
                        .<span class="ident">insert</span>(<span class="ident">expr</span>.<span class="ident">hir_id</span>, <span class="ident">fru_field_types</span>);
                }
                _ <span class="op">=&gt;</span> {
                    <span class="macro">span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">base_expr</span>.<span class="ident">span</span>, <span class="ident">E0436</span>,
                              <span class="string">&quot;functional record update syntax requires a struct&quot;</span>);
                }
            }
        }
        <span class="self">self</span>.<span class="ident">require_type_is_sized</span>(<span class="ident">struct_ty</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">traits</span>::<span class="ident">StructInitializerSized</span>);
        <span class="ident">struct_ty</span>
    }


    <span class="doccomment">/// Invariant:</span>
    <span class="doccomment">/// If an expression has any sub-expressions that result in a type error,</span>
    <span class="doccomment">/// inspecting that expression&#39;s type with `ty.references_error()` will return</span>
    <span class="doccomment">/// true. Likewise, if an expression is known to diverge, inspecting its</span>
    <span class="doccomment">/// type with `ty::type_is_bot` will return true (n.b.: since Rust is</span>
    <span class="doccomment">/// strict, _|_ can appear in the type of an expression that does not,</span>
    <span class="doccomment">/// itself, diverge: for example, fn() -&gt; _|_.)</span>
    <span class="doccomment">/// Note that inspecting a type&#39;s structure *directly* may expose the fact</span>
    <span class="doccomment">/// that there are actually multiple representations for `TyError`, so avoid</span>
    <span class="doccomment">/// that when err needs to be handled differently.</span>
    <span class="kw">fn</span> <span class="ident">check_expr_with_expectation_and_lvalue_pref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                                   <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                                                   <span class="ident">expected</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                                   <span class="ident">lvalue_pref</span>: <span class="ident">LvaluePreference</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;&gt;&gt; typechecking: expr={:?} expected={:?}&quot;</span>,
               <span class="ident">expr</span>, <span class="ident">expected</span>);

        <span class="comment">// Warn for expressions after diverging siblings.</span>
        <span class="self">self</span>.<span class="ident">warn_if_unreachable</span>(<span class="ident">expr</span>.<span class="ident">id</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="string">&quot;expression&quot;</span>);

        <span class="comment">// Hide the outer diverging and has_errors flags.</span>
        <span class="kw">let</span> <span class="ident">old_diverges</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>();
        <span class="kw">let</span> <span class="ident">old_has_errors</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">has_errors</span>.<span class="ident">get</span>();
        <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="ident">Diverges</span>::<span class="ident">Maybe</span>);
        <span class="self">self</span>.<span class="ident">has_errors</span>.<span class="ident">set</span>(<span class="bool-val">false</span>);

        <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_kind</span>(<span class="ident">expr</span>, <span class="ident">expected</span>, <span class="ident">lvalue_pref</span>);

        <span class="comment">// Warn for non-block expressions with diverging children.</span>
        <span class="kw">match</span> <span class="ident">expr</span>.<span class="ident">node</span> {
            <span class="ident">hir</span>::<span class="ident">ExprBlock</span>(_) <span class="op">|</span>
            <span class="ident">hir</span>::<span class="ident">ExprLoop</span>(..) <span class="op">|</span> <span class="ident">hir</span>::<span class="ident">ExprWhile</span>(..) <span class="op">|</span>
            <span class="ident">hir</span>::<span class="ident">ExprIf</span>(..) <span class="op">|</span> <span class="ident">hir</span>::<span class="ident">ExprMatch</span>(..) <span class="op">=&gt;</span> {}

            _ <span class="op">=&gt;</span> <span class="self">self</span>.<span class="ident">warn_if_unreachable</span>(<span class="ident">expr</span>.<span class="ident">id</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="string">&quot;expression&quot;</span>)
        }

        <span class="comment">// Any expression that produces a value of type `!` must have diverged</span>
        <span class="kw">if</span> <span class="ident">ty</span>.<span class="ident">is_never</span>() {
            <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>() <span class="op">|</span> <span class="ident">Diverges</span>::<span class="ident">Always</span>);
        }

        <span class="comment">// Record the type, which applies it effects.</span>
        <span class="comment">// We need to do this after the warning above, so that</span>
        <span class="comment">// we don&#39;t warn for the diverging expression itself.</span>
        <span class="self">self</span>.<span class="ident">write_ty</span>(<span class="ident">expr</span>.<span class="ident">hir_id</span>, <span class="ident">ty</span>);

        <span class="comment">// Combine the diverging and has_error flags.</span>
        <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>() <span class="op">|</span> <span class="ident">old_diverges</span>);
        <span class="self">self</span>.<span class="ident">has_errors</span>.<span class="ident">set</span>(<span class="self">self</span>.<span class="ident">has_errors</span>.<span class="ident">get</span>() <span class="op">|</span> <span class="ident">old_has_errors</span>);

        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;type of {} is...&quot;</span>, <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">node_to_string</span>(<span class="ident">expr</span>.<span class="ident">id</span>));
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;... {:?}, expected is {:?}&quot;</span>, <span class="ident">ty</span>, <span class="ident">expected</span>);

        <span class="ident">ty</span>
    }

    <span class="kw">fn</span> <span class="ident">check_expr_kind</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                       <span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                       <span class="ident">expected</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                       <span class="ident">lvalue_pref</span>: <span class="ident">LvaluePreference</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">tcx</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>;
        <span class="kw">let</span> <span class="ident">id</span> <span class="op">=</span> <span class="ident">expr</span>.<span class="ident">id</span>;
        <span class="kw">match</span> <span class="ident">expr</span>.<span class="ident">node</span> {
          <span class="ident">hir</span>::<span class="ident">ExprBox</span>(<span class="kw-2">ref</span> <span class="ident">subexpr</span>) <span class="op">=&gt;</span> {
            <span class="kw">let</span> <span class="ident">expected_inner</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">to_option</span>(<span class="self">self</span>).<span class="ident">map_or</span>(<span class="ident">NoExpectation</span>, <span class="op">|</span><span class="ident">ty</span><span class="op">|</span> {
                <span class="kw">match</span> <span class="ident">ty</span>.<span class="ident">sty</span> {
                    <span class="ident">ty</span>::<span class="ident">TyAdt</span>(<span class="ident">def</span>, _) <span class="kw">if</span> <span class="ident">def</span>.<span class="ident">is_box</span>()
                        <span class="op">=&gt;</span> <span class="ident">Expectation</span>::<span class="ident">rvalue_hint</span>(<span class="self">self</span>, <span class="ident">ty</span>.<span class="ident">boxed_ty</span>()),
                    _ <span class="op">=&gt;</span> <span class="ident">NoExpectation</span>
                }
            });
            <span class="kw">let</span> <span class="ident">referent_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_expectation</span>(<span class="ident">subexpr</span>, <span class="ident">expected_inner</span>);
            <span class="ident">tcx</span>.<span class="ident">mk_box</span>(<span class="ident">referent_ty</span>)
          }

          <span class="ident">hir</span>::<span class="ident">ExprLit</span>(<span class="kw-2">ref</span> <span class="ident">lit</span>) <span class="op">=&gt;</span> {
            <span class="self">self</span>.<span class="ident">check_lit</span>(<span class="kw-2">&amp;</span><span class="ident">lit</span>, <span class="ident">expected</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprBinary</span>(<span class="ident">op</span>, <span class="kw-2">ref</span> <span class="ident">lhs</span>, <span class="kw-2">ref</span> <span class="ident">rhs</span>) <span class="op">=&gt;</span> {
            <span class="self">self</span>.<span class="ident">check_binop</span>(<span class="ident">expr</span>, <span class="ident">op</span>, <span class="ident">lhs</span>, <span class="ident">rhs</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprAssignOp</span>(<span class="ident">op</span>, <span class="kw-2">ref</span> <span class="ident">lhs</span>, <span class="kw-2">ref</span> <span class="ident">rhs</span>) <span class="op">=&gt;</span> {
            <span class="self">self</span>.<span class="ident">check_binop_assign</span>(<span class="ident">expr</span>, <span class="ident">op</span>, <span class="ident">lhs</span>, <span class="ident">rhs</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprUnary</span>(<span class="ident">unop</span>, <span class="kw-2">ref</span> <span class="ident">oprnd</span>) <span class="op">=&gt;</span> {
            <span class="kw">let</span> <span class="ident">expected_inner</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">unop</span> {
                <span class="ident">hir</span>::<span class="ident">UnNot</span> <span class="op">|</span> <span class="ident">hir</span>::<span class="ident">UnNeg</span> <span class="op">=&gt;</span> {
                    <span class="ident">expected</span>
                }
                <span class="ident">hir</span>::<span class="ident">UnDeref</span> <span class="op">=&gt;</span> {
                    <span class="ident">NoExpectation</span>
                }
            };
            <span class="kw">let</span> <span class="ident">lvalue_pref</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">unop</span> {
                <span class="ident">hir</span>::<span class="ident">UnDeref</span> <span class="op">=&gt;</span> <span class="ident">lvalue_pref</span>,
                _ <span class="op">=&gt;</span> <span class="ident">NoPreference</span>
            };
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">oprnd_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_expectation_and_lvalue_pref</span>(<span class="kw-2">&amp;</span><span class="ident">oprnd</span>,
                                                                               <span class="ident">expected_inner</span>,
                                                                               <span class="ident">lvalue_pref</span>);

            <span class="kw">if</span> <span class="op">!</span><span class="ident">oprnd_t</span>.<span class="ident">references_error</span>() {
                <span class="ident">oprnd_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">structurally_resolved_type</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">oprnd_t</span>);
                <span class="kw">match</span> <span class="ident">unop</span> {
                    <span class="ident">hir</span>::<span class="ident">UnDeref</span> <span class="op">=&gt;</span> {
                        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">mt</span>) <span class="op">=</span> <span class="ident">oprnd_t</span>.<span class="ident">builtin_deref</span>(<span class="bool-val">true</span>, <span class="ident">NoPreference</span>) {
                            <span class="ident">oprnd_t</span> <span class="op">=</span> <span class="ident">mt</span>.<span class="ident">ty</span>;
                        } <span class="kw">else</span> <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">ok</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">try_overloaded_deref</span>(
                                <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">oprnd_t</span>, <span class="ident">lvalue_pref</span>) {
                            <span class="kw">let</span> <span class="ident">method</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">register_infer_ok_obligations</span>(<span class="ident">ok</span>);
                            <span class="kw">if</span> <span class="kw">let</span> <span class="ident">ty</span>::<span class="ident">TyRef</span>(<span class="ident">region</span>, <span class="ident">mt</span>) <span class="op">=</span> <span class="ident">method</span>.<span class="ident">sig</span>.<span class="ident">inputs</span>()[<span class="number">0</span>].<span class="ident">sty</span> {
                                <span class="self">self</span>.<span class="ident">apply_adjustments</span>(<span class="ident">oprnd</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">Adjustment</span> {
                                    <span class="ident">kind</span>: <span class="ident">Adjust</span>::<span class="ident">Borrow</span>(<span class="ident">AutoBorrow</span>::<span class="ident">Ref</span>(<span class="ident">region</span>, <span class="ident">mt</span>.<span class="ident">mutbl</span>)),
                                    <span class="ident">target</span>: <span class="ident">method</span>.<span class="ident">sig</span>.<span class="ident">inputs</span>()[<span class="number">0</span>]
                                }]);
                            }
                            <span class="ident">oprnd_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">make_overloaded_lvalue_return_type</span>(<span class="ident">method</span>).<span class="ident">ty</span>;
                            <span class="self">self</span>.<span class="ident">write_method_call</span>(<span class="ident">expr</span>.<span class="ident">hir_id</span>, <span class="ident">method</span>);
                        } <span class="kw">else</span> {
                            <span class="macro">type_error_struct</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">oprnd_t</span>, <span class="ident">E0614</span>,
                                               <span class="string">&quot;type `{}` cannot be dereferenced&quot;</span>,
                                               <span class="ident">oprnd_t</span>).<span class="ident">emit</span>();
                            <span class="ident">oprnd_t</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>;
                        }
                    }
                    <span class="ident">hir</span>::<span class="ident">UnNot</span> <span class="op">=&gt;</span> {
                        <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_user_unop</span>(<span class="ident">expr</span>, <span class="ident">oprnd_t</span>, <span class="ident">unop</span>);
                        <span class="comment">// If it&#39;s builtin, we can reuse the type, this helps inference.</span>
                        <span class="kw">if</span> <span class="op">!</span>(<span class="ident">oprnd_t</span>.<span class="ident">is_integral</span>() <span class="op">||</span> <span class="ident">oprnd_t</span>.<span class="ident">sty</span> <span class="op">==</span> <span class="ident">ty</span>::<span class="ident">TyBool</span>) {
                            <span class="ident">oprnd_t</span> <span class="op">=</span> <span class="ident">result</span>;
                        }
                    }
                    <span class="ident">hir</span>::<span class="ident">UnNeg</span> <span class="op">=&gt;</span> {
                        <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_user_unop</span>(<span class="ident">expr</span>, <span class="ident">oprnd_t</span>, <span class="ident">unop</span>);
                        <span class="comment">// If it&#39;s builtin, we can reuse the type, this helps inference.</span>
                        <span class="kw">if</span> <span class="op">!</span>(<span class="ident">oprnd_t</span>.<span class="ident">is_integral</span>() <span class="op">||</span> <span class="ident">oprnd_t</span>.<span class="ident">is_fp</span>()) {
                            <span class="ident">oprnd_t</span> <span class="op">=</span> <span class="ident">result</span>;
                        }
                    }
                }
            }
            <span class="ident">oprnd_t</span>
          }
          <span class="ident">hir</span>::<span class="ident">ExprAddrOf</span>(<span class="ident">mutbl</span>, <span class="kw-2">ref</span> <span class="ident">oprnd</span>) <span class="op">=&gt;</span> {
            <span class="kw">let</span> <span class="ident">hint</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">only_has_type</span>(<span class="self">self</span>).<span class="ident">map_or</span>(<span class="ident">NoExpectation</span>, <span class="op">|</span><span class="ident">ty</span><span class="op">|</span> {
                <span class="kw">match</span> <span class="ident">ty</span>.<span class="ident">sty</span> {
                    <span class="ident">ty</span>::<span class="ident">TyRef</span>(_, <span class="kw-2">ref</span> <span class="ident">mt</span>) <span class="op">|</span> <span class="ident">ty</span>::<span class="ident">TyRawPtr</span>(<span class="kw-2">ref</span> <span class="ident">mt</span>) <span class="op">=&gt;</span> {
                        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">expr_is_lval</span>(<span class="kw-2">&amp;</span><span class="ident">oprnd</span>) {
                            <span class="comment">// Lvalues may legitimately have unsized types.</span>
                            <span class="comment">// For example, dereferences of a fat pointer and</span>
                            <span class="comment">// the last field of a struct can be unsized.</span>
                            <span class="ident">ExpectHasType</span>(<span class="ident">mt</span>.<span class="ident">ty</span>)
                        } <span class="kw">else</span> {
                            <span class="ident">Expectation</span>::<span class="ident">rvalue_hint</span>(<span class="self">self</span>, <span class="ident">mt</span>.<span class="ident">ty</span>)
                        }
                    }
                    _ <span class="op">=&gt;</span> <span class="ident">NoExpectation</span>
                }
            });
            <span class="kw">let</span> <span class="ident">lvalue_pref</span> <span class="op">=</span> <span class="ident">LvaluePreference</span>::<span class="ident">from_mutbl</span>(<span class="ident">mutbl</span>);
            <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_expectation_and_lvalue_pref</span>(<span class="kw-2">&amp;</span><span class="ident">oprnd</span>, <span class="ident">hint</span>, <span class="ident">lvalue_pref</span>);

            <span class="kw">let</span> <span class="ident">tm</span> <span class="op">=</span> <span class="ident">ty</span>::<span class="ident">TypeAndMut</span> { <span class="ident">ty</span>: <span class="ident">ty</span>, <span class="ident">mutbl</span>: <span class="ident">mutbl</span> };
            <span class="kw">if</span> <span class="ident">tm</span>.<span class="ident">ty</span>.<span class="ident">references_error</span>() {
                <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
            } <span class="kw">else</span> {
                <span class="comment">// Note: at this point, we cannot say what the best lifetime</span>
                <span class="comment">// is to use for resulting pointer.  We want to use the</span>
                <span class="comment">// shortest lifetime possible so as to avoid spurious borrowck</span>
                <span class="comment">// errors.  Moreover, the longest lifetime will depend on the</span>
                <span class="comment">// precise details of the value whose address is being taken</span>
                <span class="comment">// (and how long it is valid), which we don&#39;t know yet until type</span>
                <span class="comment">// inference is complete.</span>
                <span class="comment">//</span>
                <span class="comment">// Therefore, here we simply generate a region variable.  The</span>
                <span class="comment">// region inferencer will then select the ultimate value.</span>
                <span class="comment">// Finally, borrowck is charged with guaranteeing that the</span>
                <span class="comment">// value whose address was taken can actually be made to live</span>
                <span class="comment">// as long as it needs to live.</span>
                <span class="kw">let</span> <span class="ident">region</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">next_region_var</span>(<span class="ident">infer</span>::<span class="ident">AddrOfRegion</span>(<span class="ident">expr</span>.<span class="ident">span</span>));
                <span class="ident">tcx</span>.<span class="ident">mk_ref</span>(<span class="ident">region</span>, <span class="ident">tm</span>)
            }
          }
          <span class="ident">hir</span>::<span class="ident">ExprPath</span>(<span class="kw-2">ref</span> <span class="ident">qpath</span>) <span class="op">=&gt;</span> {
              <span class="kw">let</span> (<span class="ident">def</span>, <span class="ident">opt_ty</span>, <span class="ident">segments</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_ty_and_def_ufcs</span>(<span class="ident">qpath</span>,
                                                                         <span class="ident">expr</span>.<span class="ident">id</span>, <span class="ident">expr</span>.<span class="ident">span</span>);
              <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">def</span> <span class="op">!=</span> <span class="ident">Def</span>::<span class="prelude-val">Err</span> {
                  <span class="self">self</span>.<span class="ident">instantiate_value_path</span>(<span class="ident">segments</span>, <span class="ident">opt_ty</span>, <span class="ident">def</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">id</span>)
              } <span class="kw">else</span> {
                  <span class="self">self</span>.<span class="ident">set_tainted_by_errors</span>();
                  <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
              };

              <span class="comment">// We always require that the type provided as the value for</span>
              <span class="comment">// a type parameter outlives the moment of instantiation.</span>
              <span class="kw">let</span> <span class="ident">substs</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tables</span>.<span class="ident">borrow</span>().<span class="ident">node_substs</span>(<span class="ident">expr</span>.<span class="ident">hir_id</span>);
              <span class="self">self</span>.<span class="ident">add_wf_bounds</span>(<span class="ident">substs</span>, <span class="ident">expr</span>);

              <span class="ident">ty</span>
          }
          <span class="ident">hir</span>::<span class="ident">ExprInlineAsm</span>(_, <span class="kw-2">ref</span> <span class="ident">outputs</span>, <span class="kw-2">ref</span> <span class="ident">inputs</span>) <span class="op">=&gt;</span> {
              <span class="kw">for</span> <span class="ident">output</span> <span class="kw">in</span> <span class="ident">outputs</span> {
                  <span class="self">self</span>.<span class="ident">check_expr</span>(<span class="ident">output</span>);
              }
              <span class="kw">for</span> <span class="ident">input</span> <span class="kw">in</span> <span class="ident">inputs</span> {
                  <span class="self">self</span>.<span class="ident">check_expr</span>(<span class="ident">input</span>);
              }
              <span class="ident">tcx</span>.<span class="ident">mk_nil</span>()
          }
          <span class="ident">hir</span>::<span class="ident">ExprBreak</span>(<span class="ident">destination</span>, <span class="kw-2">ref</span> <span class="ident">expr_opt</span>) <span class="op">=&gt;</span> {
              <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">target_id</span>) <span class="op">=</span> <span class="ident">destination</span>.<span class="ident">target_id</span>.<span class="ident">opt_id</span>() {
                  <span class="kw">let</span> (<span class="ident">e_ty</span>, <span class="ident">e_diverges</span>, <span class="ident">cause</span>);
                  <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="op">=</span> <span class="kw-2">*</span><span class="ident">expr_opt</span> {
                      <span class="comment">// If this is a break with a value, we need to type-check</span>
                      <span class="comment">// the expression. Get an expected type from the loop context.</span>
                      <span class="kw">let</span> <span class="ident">opt_coerce_to</span> <span class="op">=</span> {
                          <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">enclosing_breakables</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">enclosing_breakables</span>.<span class="ident">borrow_mut</span>();
                          <span class="ident">enclosing_breakables</span>.<span class="ident">find_breakable</span>(<span class="ident">target_id</span>)
                                              .<span class="ident">coerce</span>
                                              .<span class="ident">as_ref</span>()
                                              .<span class="ident">map</span>(<span class="op">|</span><span class="ident">coerce</span><span class="op">|</span> <span class="ident">coerce</span>.<span class="ident">expected_ty</span>())
                      };

                      <span class="comment">// If the loop context is not a `loop { }`, then break with</span>
                      <span class="comment">// a value is illegal, and `opt_coerce_to` will be `None`.</span>
                      <span class="comment">// Just set expectation to error in that case.</span>
                      <span class="kw">let</span> <span class="ident">coerce_to</span> <span class="op">=</span> <span class="ident">opt_coerce_to</span>.<span class="ident">unwrap_or</span>(<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>);

                      <span class="comment">// Recurse without `enclosing_breakables` borrowed.</span>
                      <span class="ident">e_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_hint</span>(<span class="ident">e</span>, <span class="ident">coerce_to</span>);
                      <span class="ident">e_diverges</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>();
                      <span class="ident">cause</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">misc</span>(<span class="ident">e</span>.<span class="ident">span</span>);
                  } <span class="kw">else</span> {
                      <span class="comment">// Otherwise, this is a break *without* a value. That&#39;s</span>
                      <span class="comment">// always legal, and is equivalent to `break ()`.</span>
                      <span class="ident">e_ty</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">mk_nil</span>();
                      <span class="ident">e_diverges</span> <span class="op">=</span> <span class="ident">Diverges</span>::<span class="ident">Maybe</span>;
                      <span class="ident">cause</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">misc</span>(<span class="ident">expr</span>.<span class="ident">span</span>);
                  }

                  <span class="comment">// Now that we have type-checked `expr_opt`, borrow</span>
                  <span class="comment">// the `enclosing_loops` field and let&#39;s coerce the</span>
                  <span class="comment">// type of `expr_opt` into what is expected.</span>
                  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">enclosing_breakables</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">enclosing_breakables</span>.<span class="ident">borrow_mut</span>();
                  <span class="kw">let</span> <span class="ident">ctxt</span> <span class="op">=</span> <span class="ident">enclosing_breakables</span>.<span class="ident">find_breakable</span>(<span class="ident">target_id</span>);
                  <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">coerce</span>) <span class="op">=</span> <span class="ident">ctxt</span>.<span class="ident">coerce</span> {
                      <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="op">=</span> <span class="kw-2">*</span><span class="ident">expr_opt</span> {
                          <span class="ident">coerce</span>.<span class="ident">coerce</span>(<span class="self">self</span>, <span class="kw-2">&amp;</span><span class="ident">cause</span>, <span class="ident">e</span>, <span class="ident">e_ty</span>, <span class="ident">e_diverges</span>);
                      } <span class="kw">else</span> {
                          <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">e_ty</span>.<span class="ident">is_nil</span>());
                          <span class="ident">coerce</span>.<span class="ident">coerce_forced_unit</span>(<span class="self">self</span>, <span class="kw-2">&amp;</span><span class="ident">cause</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="op">|</span>_<span class="op">|</span> (), <span class="bool-val">true</span>);
                      }
                  } <span class="kw">else</span> {
                      <span class="comment">// If `ctxt.coerce` is `None`, we can just ignore</span>
                      <span class="comment">// the type of the expresison.  This is because</span>
                      <span class="comment">// either this was a break *without* a value, in</span>
                      <span class="comment">// which case it is always a legal type (`()`), or</span>
                      <span class="comment">// else an error would have been flagged by the</span>
                      <span class="comment">// `loops` pass for using break with an expression</span>
                      <span class="comment">// where you are not supposed to.</span>
                      <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">expr_opt</span>.<span class="ident">is_none</span>() <span class="op">||</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">err_count</span>() <span class="op">&gt;</span> <span class="number">0</span>);
                  }

                  <span class="ident">ctxt</span>.<span class="ident">may_break</span> <span class="op">=</span> <span class="bool-val">true</span>;
              } <span class="kw">else</span> {
                  <span class="comment">// Otherwise, we failed to find the enclosing loop;</span>
                  <span class="comment">// this can only happen if the `break` was not</span>
                  <span class="comment">// inside a loop at all, which is caught by the</span>
                  <span class="comment">// loop-checking pass.</span>
                  <span class="macro">assert</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">err_count</span>() <span class="op">&gt;</span> <span class="number">0</span>);

                  <span class="comment">// We still need to assign a type to the inner expression to</span>
                  <span class="comment">// prevent the ICE in #43162.</span>
                  <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="op">=</span> <span class="kw-2">*</span><span class="ident">expr_opt</span> {
                      <span class="self">self</span>.<span class="ident">check_expr_with_hint</span>(<span class="ident">e</span>, <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>);

                      <span class="comment">// ... except when we try to &#39;break rust;&#39;.</span>
                      <span class="comment">// ICE this expression in particular (see #43162).</span>
                      <span class="kw">if</span> <span class="kw">let</span> <span class="ident">hir</span>::<span class="ident">ExprPath</span>(<span class="ident">hir</span>::<span class="ident">QPath</span>::<span class="ident">Resolved</span>(_, <span class="kw-2">ref</span> <span class="ident">path</span>)) <span class="op">=</span> <span class="ident">e</span>.<span class="ident">node</span> {
                          <span class="kw">if</span> <span class="ident">path</span>.<span class="ident">segments</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">1</span> <span class="op">&amp;&amp;</span> <span class="ident">path</span>.<span class="ident">segments</span>[<span class="number">0</span>].<span class="ident">name</span> <span class="op">==</span> <span class="string">&quot;rust&quot;</span> {
                              <span class="ident">fatally_break_rust</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>);
                          }
                      }
                  }
              }

              <span class="comment">// the type of a `break` is always `!`, since it diverges</span>
              <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">never</span>
          }
          <span class="ident">hir</span>::<span class="ident">ExprAgain</span>(_) <span class="op">=&gt;</span> { <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">never</span> }
          <span class="ident">hir</span>::<span class="ident">ExprRet</span>(<span class="kw-2">ref</span> <span class="ident">expr_opt</span>) <span class="op">=&gt;</span> {
            <span class="kw">if</span> <span class="self">self</span>.<span class="ident">ret_coercion</span>.<span class="ident">is_none</span>() {
                <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">E0572</span>,
                                 <span class="string">&quot;return statement outside of function body&quot;</span>).<span class="ident">emit</span>();
            } <span class="kw">else</span> <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="op">=</span> <span class="kw-2">*</span><span class="ident">expr_opt</span> {
                <span class="self">self</span>.<span class="ident">check_return_expr</span>(<span class="ident">e</span>);
            } <span class="kw">else</span> {
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">coercion</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">ret_coercion</span>.<span class="ident">as_ref</span>().<span class="ident">unwrap</span>().<span class="ident">borrow_mut</span>();
                <span class="kw">let</span> <span class="ident">cause</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">cause</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">ObligationCauseCode</span>::<span class="ident">ReturnNoExpression</span>);
                <span class="ident">coercion</span>.<span class="ident">coerce_forced_unit</span>(<span class="self">self</span>, <span class="kw-2">&amp;</span><span class="ident">cause</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="op">|</span>_<span class="op">|</span> (), <span class="bool-val">true</span>);
            }
            <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">never</span>
          }
          <span class="ident">hir</span>::<span class="ident">ExprAssign</span>(<span class="kw-2">ref</span> <span class="ident">lhs</span>, <span class="kw-2">ref</span> <span class="ident">rhs</span>) <span class="op">=&gt;</span> {
            <span class="kw">let</span> <span class="ident">lhs_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_lvalue_pref</span>(<span class="kw-2">&amp;</span><span class="ident">lhs</span>, <span class="ident">PreferMutLvalue</span>);

            <span class="kw">let</span> <span class="ident">rhs_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_coercable_to_type</span>(<span class="kw-2">&amp;</span><span class="ident">rhs</span>, <span class="ident">lhs_ty</span>);

            <span class="kw">match</span> <span class="ident">expected</span> {
                <span class="ident">ExpectIfCondition</span> <span class="op">=&gt;</span> {
                    <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">delay_span_bug</span>(<span class="ident">lhs</span>.<span class="ident">span</span>, <span class="string">&quot;invalid lhs expression in if;\
                                                            expected error elsehwere&quot;</span>);
                }
                _ <span class="op">=&gt;</span> {
                    <span class="comment">// Only check this if not in an `if` condition, as the</span>
                    <span class="comment">// mistyped comparison help is more appropriate.</span>
                    <span class="kw">if</span> <span class="op">!</span><span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">expr_is_lval</span>(<span class="kw-2">&amp;</span><span class="ident">lhs</span>) {
                        <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">E0070</span>,
                                         <span class="string">&quot;invalid left-hand side expression&quot;</span>)
                            .<span class="ident">span_label</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="string">&quot;left-hand of expression not valid&quot;</span>)
                            .<span class="ident">emit</span>();
                    }
                }
            }

            <span class="self">self</span>.<span class="ident">require_type_is_sized</span>(<span class="ident">lhs_ty</span>, <span class="ident">lhs</span>.<span class="ident">span</span>, <span class="ident">traits</span>::<span class="ident">AssignmentLhsSized</span>);

            <span class="kw">if</span> <span class="ident">lhs_ty</span>.<span class="ident">references_error</span>() <span class="op">||</span> <span class="ident">rhs_ty</span>.<span class="ident">references_error</span>() {
                <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
            } <span class="kw">else</span> {
                <span class="ident">tcx</span>.<span class="ident">mk_nil</span>()
            }
          }
          <span class="ident">hir</span>::<span class="ident">ExprIf</span>(<span class="kw-2">ref</span> <span class="ident">cond</span>, <span class="kw-2">ref</span> <span class="ident">then_expr</span>, <span class="kw-2">ref</span> <span class="ident">opt_else_expr</span>) <span class="op">=&gt;</span> {
              <span class="self">self</span>.<span class="ident">check_then_else</span>(<span class="kw-2">&amp;</span><span class="ident">cond</span>, <span class="ident">then_expr</span>, <span class="ident">opt_else_expr</span>.<span class="ident">as_ref</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="kw-2">*</span><span class="ident">e</span>),
                                   <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">expected</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprWhile</span>(<span class="kw-2">ref</span> <span class="ident">cond</span>, <span class="kw-2">ref</span> <span class="ident">body</span>, _) <span class="op">=&gt;</span> {
              <span class="kw">let</span> <span class="ident">ctxt</span> <span class="op">=</span> <span class="ident">BreakableCtxt</span> {
                  <span class="comment">// cannot use break with a value from a while loop</span>
                  <span class="ident">coerce</span>: <span class="prelude-val">None</span>,
                  <span class="ident">may_break</span>: <span class="bool-val">true</span>,
              };

              <span class="self">self</span>.<span class="ident">with_breakable_ctxt</span>(<span class="ident">expr</span>.<span class="ident">id</span>, <span class="ident">ctxt</span>, <span class="op">||</span> {
                  <span class="self">self</span>.<span class="ident">check_expr_has_type_or_error</span>(<span class="kw-2">&amp;</span><span class="ident">cond</span>, <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">bool</span>);
                  <span class="kw">let</span> <span class="ident">cond_diverging</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>();
                  <span class="self">self</span>.<span class="ident">check_block_no_value</span>(<span class="kw-2">&amp;</span><span class="ident">body</span>);

                  <span class="comment">// We may never reach the body so it diverging means nothing.</span>
                  <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="ident">cond_diverging</span>);
              });

              <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">mk_nil</span>()
          }
          <span class="ident">hir</span>::<span class="ident">ExprLoop</span>(<span class="kw-2">ref</span> <span class="ident">body</span>, _, <span class="ident">source</span>) <span class="op">=&gt;</span> {
              <span class="kw">let</span> <span class="ident">coerce</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">source</span> {
                  <span class="comment">// you can only use break with a value from a normal `loop { }`</span>
                  <span class="ident">hir</span>::<span class="ident">LoopSource</span>::<span class="ident">Loop</span> <span class="op">=&gt;</span> {
                      <span class="kw">let</span> <span class="ident">coerce_to</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">coercion_target_type</span>(<span class="self">self</span>, <span class="ident">body</span>.<span class="ident">span</span>);
                      <span class="prelude-val">Some</span>(<span class="ident">CoerceMany</span>::<span class="ident">new</span>(<span class="ident">coerce_to</span>))
                  }

                  <span class="ident">hir</span>::<span class="ident">LoopSource</span>::<span class="ident">WhileLet</span> <span class="op">|</span>
                  <span class="ident">hir</span>::<span class="ident">LoopSource</span>::<span class="ident">ForLoop</span> <span class="op">=&gt;</span> {
                      <span class="prelude-val">None</span>
                  }
              };

              <span class="kw">let</span> <span class="ident">ctxt</span> <span class="op">=</span> <span class="ident">BreakableCtxt</span> {
                  <span class="ident">coerce</span>,
                  <span class="ident">may_break</span>: <span class="bool-val">false</span>, <span class="comment">// will get updated if/when we find a `break`</span>
              };

              <span class="kw">let</span> (<span class="ident">ctxt</span>, ()) <span class="op">=</span> <span class="self">self</span>.<span class="ident">with_breakable_ctxt</span>(<span class="ident">expr</span>.<span class="ident">id</span>, <span class="ident">ctxt</span>, <span class="op">||</span> {
                  <span class="self">self</span>.<span class="ident">check_block_no_value</span>(<span class="kw-2">&amp;</span><span class="ident">body</span>);
              });

              <span class="kw">if</span> <span class="ident">ctxt</span>.<span class="ident">may_break</span> {
                  <span class="comment">// No way to know whether it&#39;s diverging because</span>
                  <span class="comment">// of a `break` or an outer `break` or `return.</span>
                  <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="ident">Diverges</span>::<span class="ident">Maybe</span>);
              }

              <span class="comment">// If we permit break with a value, then result type is</span>
              <span class="comment">// the LUB of the breaks (possibly ! if none); else, it</span>
              <span class="comment">// is nil. This makes sense because infinite loops</span>
              <span class="comment">// (which would have type !) are only possible iff we</span>
              <span class="comment">// permit break with a value [1].</span>
              <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">ctxt</span>.<span class="ident">coerce</span>.<span class="ident">is_some</span>() <span class="op">||</span> <span class="ident">ctxt</span>.<span class="ident">may_break</span>); <span class="comment">// [1]</span>
              <span class="ident">ctxt</span>.<span class="ident">coerce</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">complete</span>(<span class="self">self</span>)).<span class="ident">unwrap_or</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">mk_nil</span>())
          }
          <span class="ident">hir</span>::<span class="ident">ExprMatch</span>(<span class="kw-2">ref</span> <span class="ident">discrim</span>, <span class="kw-2">ref</span> <span class="ident">arms</span>, <span class="ident">match_src</span>) <span class="op">=&gt;</span> {
            <span class="self">self</span>.<span class="ident">check_match</span>(<span class="ident">expr</span>, <span class="kw-2">&amp;</span><span class="ident">discrim</span>, <span class="ident">arms</span>, <span class="ident">expected</span>, <span class="ident">match_src</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprClosure</span>(<span class="ident">capture</span>, <span class="kw-2">ref</span> <span class="ident">decl</span>, <span class="ident">body_id</span>, _, _) <span class="op">=&gt;</span> {
              <span class="self">self</span>.<span class="ident">check_expr_closure</span>(<span class="ident">expr</span>, <span class="ident">capture</span>, <span class="kw-2">&amp;</span><span class="ident">decl</span>, <span class="ident">body_id</span>, <span class="ident">expected</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprBlock</span>(<span class="kw-2">ref</span> <span class="ident">body</span>) <span class="op">=&gt;</span> {
            <span class="self">self</span>.<span class="ident">check_block_with_expected</span>(<span class="kw-2">&amp;</span><span class="ident">body</span>, <span class="ident">expected</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprCall</span>(<span class="kw-2">ref</span> <span class="ident">callee</span>, <span class="kw-2">ref</span> <span class="ident">args</span>) <span class="op">=&gt;</span> {
              <span class="self">self</span>.<span class="ident">check_call</span>(<span class="ident">expr</span>, <span class="kw-2">&amp;</span><span class="ident">callee</span>, <span class="ident">args</span>, <span class="ident">expected</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprMethodCall</span>(<span class="kw-2">ref</span> <span class="ident">segment</span>, <span class="ident">span</span>, <span class="kw-2">ref</span> <span class="ident">args</span>) <span class="op">=&gt;</span> {
              <span class="self">self</span>.<span class="ident">check_method_call</span>(<span class="ident">expr</span>, <span class="ident">segment</span>, <span class="ident">span</span>, <span class="ident">args</span>, <span class="ident">expected</span>, <span class="ident">lvalue_pref</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprCast</span>(<span class="kw-2">ref</span> <span class="ident">e</span>, <span class="kw-2">ref</span> <span class="ident">t</span>) <span class="op">=&gt;</span> {
            <span class="comment">// Find the type of `e`. Supply hints based on the type we are casting to,</span>
            <span class="comment">// if appropriate.</span>
            <span class="kw">let</span> <span class="ident">t_cast</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">to_ty</span>(<span class="ident">t</span>);
            <span class="kw">let</span> <span class="ident">t_cast</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="kw-2">&amp;</span><span class="ident">t_cast</span>);
            <span class="kw">let</span> <span class="ident">t_expr</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_expectation</span>(<span class="ident">e</span>, <span class="ident">ExpectCastableToType</span>(<span class="ident">t_cast</span>));
            <span class="kw">let</span> <span class="ident">t_cast</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_type_vars_if_possible</span>(<span class="kw-2">&amp;</span><span class="ident">t_cast</span>);
            <span class="kw">let</span> <span class="ident">diverges</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>();

            <span class="comment">// Eagerly check for some obvious errors.</span>
            <span class="kw">if</span> <span class="ident">t_expr</span>.<span class="ident">references_error</span>() <span class="op">||</span> <span class="ident">t_cast</span>.<span class="ident">references_error</span>() {
                <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
            } <span class="kw">else</span> {
                <span class="comment">// Defer other checks until we&#39;re done type checking.</span>
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">deferred_cast_checks</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">deferred_cast_checks</span>.<span class="ident">borrow_mut</span>();
                <span class="kw">match</span> <span class="ident">cast</span>::<span class="ident">CastCheck</span>::<span class="ident">new</span>(<span class="self">self</span>, <span class="ident">e</span>, <span class="ident">t_expr</span>, <span class="ident">diverges</span>, <span class="ident">t_cast</span>, <span class="ident">t</span>.<span class="ident">span</span>, <span class="ident">expr</span>.<span class="ident">span</span>) {
                    <span class="prelude-val">Ok</span>(<span class="ident">cast_check</span>) <span class="op">=&gt;</span> {
                        <span class="ident">deferred_cast_checks</span>.<span class="ident">push</span>(<span class="ident">cast_check</span>);
                        <span class="ident">t_cast</span>
                    }
                    <span class="prelude-val">Err</span>(<span class="ident">ErrorReported</span>) <span class="op">=&gt;</span> {
                        <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
                    }
                }
            }
          }
          <span class="ident">hir</span>::<span class="ident">ExprType</span>(<span class="kw-2">ref</span> <span class="ident">e</span>, <span class="kw-2">ref</span> <span class="ident">t</span>) <span class="op">=&gt;</span> {
            <span class="kw">let</span> <span class="ident">typ</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">to_ty</span>(<span class="kw-2">&amp;</span><span class="ident">t</span>);
            <span class="self">self</span>.<span class="ident">check_expr_eq_type</span>(<span class="kw-2">&amp;</span><span class="ident">e</span>, <span class="ident">typ</span>);
            <span class="ident">typ</span>
          }
          <span class="ident">hir</span>::<span class="ident">ExprArray</span>(<span class="kw-2">ref</span> <span class="ident">args</span>) <span class="op">=&gt;</span> {
              <span class="kw">let</span> <span class="ident">uty</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">to_option</span>(<span class="self">self</span>).<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">uty</span><span class="op">|</span> {
                  <span class="kw">match</span> <span class="ident">uty</span>.<span class="ident">sty</span> {
                      <span class="ident">ty</span>::<span class="ident">TyArray</span>(<span class="ident">ty</span>, _) <span class="op">|</span> <span class="ident">ty</span>::<span class="ident">TySlice</span>(<span class="ident">ty</span>) <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">ty</span>),
                      _ <span class="op">=&gt;</span> <span class="prelude-val">None</span>
                  }
              });

              <span class="kw">let</span> <span class="ident">element_ty</span> <span class="op">=</span> <span class="kw">if</span> <span class="op">!</span><span class="ident">args</span>.<span class="ident">is_empty</span>() {
                  <span class="kw">let</span> <span class="ident">coerce_to</span> <span class="op">=</span> <span class="ident">uty</span>.<span class="ident">unwrap_or_else</span>(
                      <span class="op">||</span> <span class="self">self</span>.<span class="ident">next_ty_var</span>(<span class="ident">TypeVariableOrigin</span>::<span class="ident">TypeInference</span>(<span class="ident">expr</span>.<span class="ident">span</span>)));
                  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">coerce</span> <span class="op">=</span> <span class="ident">CoerceMany</span>::<span class="ident">with_coercion_sites</span>(<span class="ident">coerce_to</span>, <span class="ident">args</span>);
                  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>(), <span class="ident">Diverges</span>::<span class="ident">Maybe</span>);
                  <span class="kw">for</span> <span class="ident">e</span> <span class="kw">in</span> <span class="ident">args</span> {
                      <span class="kw">let</span> <span class="ident">e_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_hint</span>(<span class="ident">e</span>, <span class="ident">coerce_to</span>);
                      <span class="kw">let</span> <span class="ident">cause</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">misc</span>(<span class="ident">e</span>.<span class="ident">span</span>);
                      <span class="ident">coerce</span>.<span class="ident">coerce</span>(<span class="self">self</span>, <span class="kw-2">&amp;</span><span class="ident">cause</span>, <span class="ident">e</span>, <span class="ident">e_ty</span>, <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>());
                  }
                  <span class="ident">coerce</span>.<span class="ident">complete</span>(<span class="self">self</span>)
              } <span class="kw">else</span> {
                  <span class="self">self</span>.<span class="ident">next_ty_var</span>(<span class="ident">TypeVariableOrigin</span>::<span class="ident">TypeInference</span>(<span class="ident">expr</span>.<span class="ident">span</span>))
              };
              <span class="ident">tcx</span>.<span class="ident">mk_array</span>(<span class="ident">element_ty</span>, <span class="ident">args</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprRepeat</span>(<span class="kw-2">ref</span> <span class="ident">element</span>, <span class="ident">count</span>) <span class="op">=&gt;</span> {
            <span class="kw">let</span> <span class="ident">count_def_id</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">body_owner_def_id</span>(<span class="ident">count</span>);
            <span class="kw">let</span> <span class="ident">param_env</span> <span class="op">=</span> <span class="ident">ty</span>::<span class="ident">ParamEnv</span>::<span class="ident">empty</span>(<span class="ident">traits</span>::<span class="ident">Reveal</span>::<span class="ident">UserFacing</span>);
            <span class="kw">let</span> <span class="ident">substs</span> <span class="op">=</span> <span class="ident">Substs</span>::<span class="ident">identity_for_item</span>(<span class="ident">tcx</span>.<span class="ident">global_tcx</span>(), <span class="ident">count_def_id</span>);
            <span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">const_eval</span>(<span class="ident">param_env</span>.<span class="ident">and</span>((<span class="ident">count_def_id</span>, <span class="ident">substs</span>)));

            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">err</span>) <span class="op">=</span> <span class="ident">count</span> {
               <span class="ident">err</span>.<span class="ident">report</span>(<span class="ident">tcx</span>, <span class="ident">tcx</span>.<span class="ident">def_span</span>(<span class="ident">count_def_id</span>), <span class="string">&quot;constant expression&quot;</span>);
            }

            <span class="kw">let</span> <span class="ident">uty</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">expected</span> {
                <span class="ident">ExpectHasType</span>(<span class="ident">uty</span>) <span class="op">=&gt;</span> {
                    <span class="kw">match</span> <span class="ident">uty</span>.<span class="ident">sty</span> {
                        <span class="ident">ty</span>::<span class="ident">TyArray</span>(<span class="ident">ty</span>, _) <span class="op">|</span> <span class="ident">ty</span>::<span class="ident">TySlice</span>(<span class="ident">ty</span>) <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="ident">ty</span>),
                        _ <span class="op">=&gt;</span> <span class="prelude-val">None</span>
                    }
                }
                _ <span class="op">=&gt;</span> <span class="prelude-val">None</span>
            };

            <span class="kw">let</span> (<span class="ident">element_ty</span>, <span class="ident">t</span>) <span class="op">=</span> <span class="kw">match</span> <span class="ident">uty</span> {
                <span class="prelude-val">Some</span>(<span class="ident">uty</span>) <span class="op">=&gt;</span> {
                    <span class="self">self</span>.<span class="ident">check_expr_coercable_to_type</span>(<span class="kw-2">&amp;</span><span class="ident">element</span>, <span class="ident">uty</span>);
                    (<span class="ident">uty</span>, <span class="ident">uty</span>)
                }
                <span class="prelude-val">None</span> <span class="op">=&gt;</span> {
                    <span class="kw">let</span> <span class="ident">t</span>: <span class="ident">Ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">next_ty_var</span>(<span class="ident">TypeVariableOrigin</span>::<span class="ident">MiscVariable</span>(<span class="ident">element</span>.<span class="ident">span</span>));
                    <span class="kw">let</span> <span class="ident">element_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_has_type_or_error</span>(<span class="kw-2">&amp;</span><span class="ident">element</span>, <span class="ident">t</span>);
                    (<span class="ident">element_ty</span>, <span class="ident">t</span>)
                }
            };

            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">count</span>) <span class="op">=</span> <span class="ident">count</span> {
                <span class="kw">let</span> <span class="ident">zero_or_one</span> <span class="op">=</span> <span class="ident">count</span>.<span class="ident">val</span>.<span class="ident">to_const_int</span>().<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">count</span><span class="op">|</span> {
                    <span class="ident">count</span>.<span class="ident">to_u64</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">count</span><span class="op">|</span> <span class="ident">count</span> <span class="op">&lt;=</span> <span class="number">1</span>)
                }).<span class="ident">unwrap_or</span>(<span class="bool-val">false</span>);
                <span class="kw">if</span> <span class="op">!</span><span class="ident">zero_or_one</span> {
                    <span class="comment">// For [foo, ..n] where n &gt; 1, `foo` must have</span>
                    <span class="comment">// Copy type:</span>
                    <span class="kw">let</span> <span class="ident">lang_item</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">require_lang_item</span>(<span class="ident">lang_items</span>::<span class="ident">CopyTraitLangItem</span>);
                    <span class="self">self</span>.<span class="ident">require_type_meets</span>(<span class="ident">t</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">traits</span>::<span class="ident">RepeatVec</span>, <span class="ident">lang_item</span>);
                }
            }

            <span class="kw">if</span> <span class="ident">element_ty</span>.<span class="ident">references_error</span>() {
                <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
            } <span class="kw">else</span> <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">count</span>) <span class="op">=</span> <span class="ident">count</span> {
                <span class="ident">tcx</span>.<span class="ident">mk_ty</span>(<span class="ident">ty</span>::<span class="ident">TyArray</span>(<span class="ident">t</span>, <span class="ident">count</span>))
            } <span class="kw">else</span> {
                <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
            }
          }
          <span class="ident">hir</span>::<span class="ident">ExprTup</span>(<span class="kw-2">ref</span> <span class="ident">elts</span>) <span class="op">=&gt;</span> {
            <span class="kw">let</span> <span class="ident">flds</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">only_has_type</span>(<span class="self">self</span>).<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">ty</span><span class="op">|</span> {
                <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_type_vars_with_obligations</span>(<span class="ident">ty</span>);
                <span class="kw">match</span> <span class="ident">ty</span>.<span class="ident">sty</span> {
                    <span class="ident">ty</span>::<span class="ident">TyTuple</span>(<span class="kw-2">ref</span> <span class="ident">flds</span>, _) <span class="op">=&gt;</span> <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">flds</span>[..]),
                    _ <span class="op">=&gt;</span> <span class="prelude-val">None</span>
                }
            });

            <span class="kw">let</span> <span class="ident">elt_ts_iter</span> <span class="op">=</span> <span class="ident">elts</span>.<span class="ident">iter</span>().<span class="ident">enumerate</span>().<span class="ident">map</span>(<span class="op">|</span>(<span class="ident">i</span>, <span class="ident">e</span>)<span class="op">|</span> {
                <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">flds</span> {
                    <span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="ident">fs</span>) <span class="kw">if</span> <span class="ident">i</span> <span class="op">&lt;</span> <span class="ident">fs</span>.<span class="ident">len</span>() <span class="op">=&gt;</span> {
                        <span class="kw">let</span> <span class="ident">ety</span> <span class="op">=</span> <span class="ident">fs</span>[<span class="ident">i</span>];
                        <span class="self">self</span>.<span class="ident">check_expr_coercable_to_type</span>(<span class="kw-2">&amp;</span><span class="ident">e</span>, <span class="ident">ety</span>);
                        <span class="ident">ety</span>
                    }
                    _ <span class="op">=&gt;</span> {
                        <span class="self">self</span>.<span class="ident">check_expr_with_expectation</span>(<span class="kw-2">&amp;</span><span class="ident">e</span>, <span class="ident">NoExpectation</span>)
                    }
                };
                <span class="ident">t</span>
            });
            <span class="kw">let</span> <span class="ident">tuple</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">mk_tup</span>(<span class="ident">elt_ts_iter</span>, <span class="bool-val">false</span>);
            <span class="kw">if</span> <span class="ident">tuple</span>.<span class="ident">references_error</span>() {
                <span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
            } <span class="kw">else</span> {
                <span class="self">self</span>.<span class="ident">require_type_is_sized</span>(<span class="ident">tuple</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">traits</span>::<span class="ident">TupleInitializerSized</span>);
                <span class="ident">tuple</span>
            }
          }
          <span class="ident">hir</span>::<span class="ident">ExprStruct</span>(<span class="kw-2">ref</span> <span class="ident">qpath</span>, <span class="kw-2">ref</span> <span class="ident">fields</span>, <span class="kw-2">ref</span> <span class="ident">base_expr</span>) <span class="op">=&gt;</span> {
            <span class="self">self</span>.<span class="ident">check_expr_struct</span>(<span class="ident">expr</span>, <span class="ident">expected</span>, <span class="ident">qpath</span>, <span class="ident">fields</span>, <span class="ident">base_expr</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprField</span>(<span class="kw-2">ref</span> <span class="ident">base</span>, <span class="kw-2">ref</span> <span class="ident">field</span>) <span class="op">=&gt;</span> {
            <span class="self">self</span>.<span class="ident">check_field</span>(<span class="ident">expr</span>, <span class="ident">lvalue_pref</span>, <span class="kw-2">&amp;</span><span class="ident">base</span>, <span class="ident">field</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprTupField</span>(<span class="kw-2">ref</span> <span class="ident">base</span>, <span class="ident">idx</span>) <span class="op">=&gt;</span> {
            <span class="self">self</span>.<span class="ident">check_tup_field</span>(<span class="ident">expr</span>, <span class="ident">lvalue_pref</span>, <span class="kw-2">&amp;</span><span class="ident">base</span>, <span class="ident">idx</span>)
          }
          <span class="ident">hir</span>::<span class="ident">ExprIndex</span>(<span class="kw-2">ref</span> <span class="ident">base</span>, <span class="kw-2">ref</span> <span class="ident">idx</span>) <span class="op">=&gt;</span> {
              <span class="kw">let</span> <span class="ident">base_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_lvalue_pref</span>(<span class="kw-2">&amp;</span><span class="ident">base</span>, <span class="ident">lvalue_pref</span>);
              <span class="kw">let</span> <span class="ident">idx_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr</span>(<span class="kw-2">&amp;</span><span class="ident">idx</span>);

              <span class="kw">if</span> <span class="ident">base_t</span>.<span class="ident">references_error</span>() {
                  <span class="ident">base_t</span>
              } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">idx_t</span>.<span class="ident">references_error</span>() {
                  <span class="ident">idx_t</span>
              } <span class="kw">else</span> {
                  <span class="kw">let</span> <span class="ident">base_t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">structurally_resolved_type</span>(<span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">base_t</span>);
                  <span class="kw">match</span> <span class="self">self</span>.<span class="ident">lookup_indexing</span>(<span class="ident">expr</span>, <span class="ident">base</span>, <span class="ident">base_t</span>, <span class="ident">idx_t</span>, <span class="ident">lvalue_pref</span>) {
                      <span class="prelude-val">Some</span>((<span class="ident">index_ty</span>, <span class="ident">element_ty</span>)) <span class="op">=&gt;</span> {
                          <span class="self">self</span>.<span class="ident">demand_coerce</span>(<span class="ident">idx</span>, <span class="ident">idx_t</span>, <span class="ident">index_ty</span>);
                          <span class="ident">element_ty</span>
                      }
                      <span class="prelude-val">None</span> <span class="op">=&gt;</span> {
                          <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="macro">type_error_struct</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">base_t</span>, <span class="ident">E0608</span>,
                                                           <span class="string">&quot;cannot index into a value of type `{}`&quot;</span>,
                                                           <span class="ident">base_t</span>);
                          <span class="comment">// Try to give some advice about indexing tuples.</span>
                          <span class="kw">if</span> <span class="kw">let</span> <span class="ident">ty</span>::<span class="ident">TyTuple</span>(..) <span class="op">=</span> <span class="ident">base_t</span>.<span class="ident">sty</span> {
                              <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">needs_note</span> <span class="op">=</span> <span class="bool-val">true</span>;
                              <span class="comment">// If the index is an integer, we can show the actual</span>
                              <span class="comment">// fixed expression:</span>
                              <span class="kw">if</span> <span class="kw">let</span> <span class="ident">hir</span>::<span class="ident">ExprLit</span>(<span class="kw-2">ref</span> <span class="ident">lit</span>) <span class="op">=</span> <span class="ident">idx</span>.<span class="ident">node</span> {
                                  <span class="kw">if</span> <span class="kw">let</span> <span class="ident">ast</span>::<span class="ident">LitKind</span>::<span class="ident">Int</span>(<span class="ident">i</span>,
                                            <span class="ident">ast</span>::<span class="ident">LitIntType</span>::<span class="ident">Unsuffixed</span>) <span class="op">=</span> <span class="ident">lit</span>.<span class="ident">node</span> {
                                      <span class="kw">let</span> <span class="ident">snip</span> <span class="op">=</span> <span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">codemap</span>().<span class="ident">span_to_snippet</span>(<span class="ident">base</span>.<span class="ident">span</span>);
                                      <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">snip</span>) <span class="op">=</span> <span class="ident">snip</span> {
                                          <span class="ident">err</span>.<span class="ident">span_suggestion</span>(<span class="ident">expr</span>.<span class="ident">span</span>,
                                                              <span class="string">&quot;to access tuple elements, use&quot;</span>,
                                                              <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}.{}&quot;</span>, <span class="ident">snip</span>, <span class="ident">i</span>));
                                          <span class="ident">needs_note</span> <span class="op">=</span> <span class="bool-val">false</span>;
                                      }
                                  }
                              }
                              <span class="kw">if</span> <span class="ident">needs_note</span> {
                                  <span class="ident">err</span>.<span class="ident">help</span>(<span class="string">&quot;to access tuple elements, use tuple indexing \
                                            syntax (e.g. `tuple.0`)&quot;</span>);
                              }
                          }
                          <span class="ident">err</span>.<span class="ident">emit</span>();
                          <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
                      }
                  }
              }
           }
          <span class="ident">hir</span>::<span class="ident">ExprYield</span>(<span class="kw-2">ref</span> <span class="ident">value</span>) <span class="op">=&gt;</span> {
            <span class="kw">match</span> <span class="self">self</span>.<span class="ident">yield_ty</span> {
                <span class="prelude-val">Some</span>(<span class="ident">ty</span>) <span class="op">=&gt;</span> {
                    <span class="self">self</span>.<span class="ident">check_expr_coercable_to_type</span>(<span class="kw-2">&amp;</span><span class="ident">value</span>, <span class="ident">ty</span>);
                }
                <span class="prelude-val">None</span> <span class="op">=&gt;</span> {
                    <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">expr</span>.<span class="ident">span</span>, <span class="ident">E0627</span>,
                                 <span class="string">&quot;yield statement outside of generator literal&quot;</span>).<span class="ident">emit</span>();
                }
            }
            <span class="ident">tcx</span>.<span class="ident">mk_nil</span>()
          }
        }
    }

    <span class="comment">// Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.</span>
    <span class="comment">// The newly resolved definition is written into `type_dependent_defs`.</span>
    <span class="kw">fn</span> <span class="ident">finish_resolving_struct_path</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                    <span class="ident">qpath</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">QPath</span>,
                                    <span class="ident">path_span</span>: <span class="ident">Span</span>,
                                    <span class="ident">node_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>)
                                    <span class="op">-&gt;</span> (<span class="ident">Def</span>, <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>)
    {
        <span class="kw">match</span> <span class="kw-2">*</span><span class="ident">qpath</span> {
            <span class="ident">hir</span>::<span class="ident">QPath</span>::<span class="ident">Resolved</span>(<span class="kw-2">ref</span> <span class="ident">maybe_qself</span>, <span class="kw-2">ref</span> <span class="ident">path</span>) <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="ident">opt_self_ty</span> <span class="op">=</span> <span class="ident">maybe_qself</span>.<span class="ident">as_ref</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">qself</span><span class="op">|</span> <span class="self">self</span>.<span class="ident">to_ty</span>(<span class="ident">qself</span>));
                <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="ident">AstConv</span>::<span class="ident">def_to_ty</span>(<span class="self">self</span>, <span class="ident">opt_self_ty</span>, <span class="ident">path</span>, <span class="bool-val">true</span>);
                (<span class="ident">path</span>.<span class="ident">def</span>, <span class="ident">ty</span>)
            }
            <span class="ident">hir</span>::<span class="ident">QPath</span>::<span class="ident">TypeRelative</span>(<span class="kw-2">ref</span> <span class="ident">qself</span>, <span class="kw-2">ref</span> <span class="ident">segment</span>) <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">to_ty</span>(<span class="ident">qself</span>);

                <span class="kw">let</span> <span class="ident">def</span> <span class="op">=</span> <span class="kw">if</span> <span class="kw">let</span> <span class="ident">hir</span>::<span class="ident">TyPath</span>(<span class="ident">hir</span>::<span class="ident">QPath</span>::<span class="ident">Resolved</span>(_, <span class="kw-2">ref</span> <span class="ident">path</span>)) <span class="op">=</span> <span class="ident">qself</span>.<span class="ident">node</span> {
                    <span class="ident">path</span>.<span class="ident">def</span>
                } <span class="kw">else</span> {
                    <span class="ident">Def</span>::<span class="prelude-val">Err</span>
                };
                <span class="kw">let</span> (<span class="ident">ty</span>, <span class="ident">def</span>) <span class="op">=</span> <span class="ident">AstConv</span>::<span class="ident">associated_path_def_to_ty</span>(<span class="self">self</span>, <span class="ident">node_id</span>, <span class="ident">path_span</span>,
                                                                   <span class="ident">ty</span>, <span class="ident">def</span>, <span class="ident">segment</span>);

                <span class="comment">// Write back the new resolution.</span>
                <span class="kw">let</span> <span class="ident">hir_id</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">node_to_hir_id</span>(<span class="ident">node_id</span>);
                <span class="self">self</span>.<span class="ident">tables</span>.<span class="ident">borrow_mut</span>().<span class="ident">type_dependent_defs_mut</span>().<span class="ident">insert</span>(<span class="ident">hir_id</span>, <span class="ident">def</span>);

                (<span class="ident">def</span>, <span class="ident">ty</span>)
            }
        }
    }

    <span class="comment">// Resolve associated value path into a base type and associated constant or method definition.</span>
    <span class="comment">// The newly resolved definition is written into `type_dependent_defs`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">resolve_ty_and_def_ufcs</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                       <span class="ident">qpath</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="ident">hir</span>::<span class="ident">QPath</span>,
                                       <span class="ident">node_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>,
                                       <span class="ident">span</span>: <span class="ident">Span</span>)
                                       <span class="op">-&gt;</span> (<span class="ident">Def</span>, <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> [<span class="ident">hir</span>::<span class="ident">PathSegment</span>])
    {
        <span class="kw">let</span> (<span class="ident">ty</span>, <span class="ident">item_segment</span>) <span class="op">=</span> <span class="kw">match</span> <span class="kw-2">*</span><span class="ident">qpath</span> {
            <span class="ident">hir</span>::<span class="ident">QPath</span>::<span class="ident">Resolved</span>(<span class="kw-2">ref</span> <span class="ident">opt_qself</span>, <span class="kw-2">ref</span> <span class="ident">path</span>) <span class="op">=&gt;</span> {
                <span class="kw">return</span> (<span class="ident">path</span>.<span class="ident">def</span>,
                        <span class="ident">opt_qself</span>.<span class="ident">as_ref</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">qself</span><span class="op">|</span> <span class="self">self</span>.<span class="ident">to_ty</span>(<span class="ident">qself</span>)),
                        <span class="kw-2">&amp;</span><span class="ident">path</span>.<span class="ident">segments</span>[..]);
            }
            <span class="ident">hir</span>::<span class="ident">QPath</span>::<span class="ident">TypeRelative</span>(<span class="kw-2">ref</span> <span class="ident">qself</span>, <span class="kw-2">ref</span> <span class="ident">segment</span>) <span class="op">=&gt;</span> {
                (<span class="self">self</span>.<span class="ident">to_ty</span>(<span class="ident">qself</span>), <span class="ident">segment</span>)
            }
        };
        <span class="kw">let</span> <span class="ident">hir_id</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">node_to_hir_id</span>(<span class="ident">node_id</span>);
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">cached_def</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">tables</span>.<span class="ident">borrow</span>().<span class="ident">type_dependent_defs</span>().<span class="ident">get</span>(<span class="ident">hir_id</span>) {
            <span class="comment">// Return directly on cache hit. This is useful to avoid doubly reporting</span>
            <span class="comment">// errors with default match binding modes. See #44614.</span>
            <span class="kw">return</span> (<span class="kw-2">*</span><span class="ident">cached_def</span>, <span class="prelude-val">Some</span>(<span class="ident">ty</span>), <span class="ident">slice</span>::<span class="ident">ref_slice</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="kw-2">*</span><span class="ident">item_segment</span>))
        }
        <span class="kw">let</span> <span class="ident">item_name</span> <span class="op">=</span> <span class="ident">item_segment</span>.<span class="ident">name</span>;
        <span class="kw">let</span> <span class="ident">def</span> <span class="op">=</span> <span class="kw">match</span> <span class="self">self</span>.<span class="ident">resolve_ufcs</span>(<span class="ident">span</span>, <span class="ident">item_name</span>, <span class="ident">ty</span>, <span class="ident">node_id</span>) {
            <span class="prelude-val">Ok</span>(<span class="ident">def</span>) <span class="op">=&gt;</span> <span class="ident">def</span>,
            <span class="prelude-val">Err</span>(<span class="ident">error</span>) <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="ident">def</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">error</span> {
                    <span class="ident">method</span>::<span class="ident">MethodError</span>::<span class="ident">PrivateMatch</span>(<span class="ident">def</span>, _) <span class="op">=&gt;</span> <span class="ident">def</span>,
                    _ <span class="op">=&gt;</span> <span class="ident">Def</span>::<span class="prelude-val">Err</span>,
                };
                <span class="kw">if</span> <span class="ident">item_name</span> <span class="op">!=</span> <span class="ident">keywords</span>::<span class="ident">Invalid</span>.<span class="ident">name</span>() {
                    <span class="self">self</span>.<span class="ident">report_method_error</span>(<span class="ident">span</span>, <span class="ident">ty</span>, <span class="ident">item_name</span>, <span class="prelude-val">None</span>, <span class="ident">error</span>, <span class="prelude-val">None</span>);
                }
                <span class="ident">def</span>
            }
        };

        <span class="comment">// Write back the new resolution.</span>
        <span class="self">self</span>.<span class="ident">tables</span>.<span class="ident">borrow_mut</span>().<span class="ident">type_dependent_defs_mut</span>().<span class="ident">insert</span>(<span class="ident">hir_id</span>, <span class="ident">def</span>);
        (<span class="ident">def</span>, <span class="prelude-val">Some</span>(<span class="ident">ty</span>), <span class="ident">slice</span>::<span class="ident">ref_slice</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="kw-2">*</span><span class="ident">item_segment</span>))
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_decl_initializer</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                  <span class="ident">local</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Local</span>,
                                  <span class="ident">init</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="comment">// FIXME(tschottdorf): contains_explicit_ref_binding() must be removed</span>
        <span class="comment">// for #42640 (default match binding modes).</span>
        <span class="comment">//</span>
        <span class="comment">// See #44848.</span>
        <span class="kw">let</span> <span class="ident">ref_bindings</span> <span class="op">=</span> <span class="ident">local</span>.<span class="ident">pat</span>.<span class="ident">contains_explicit_ref_binding</span>();

        <span class="kw">let</span> <span class="ident">local_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">local_ty</span>(<span class="ident">init</span>.<span class="ident">span</span>, <span class="ident">local</span>.<span class="ident">id</span>);
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">m</span>) <span class="op">=</span> <span class="ident">ref_bindings</span> {
            <span class="comment">// Somewhat subtle: if we have a `ref` binding in the pattern,</span>
            <span class="comment">// we want to avoid introducing coercions for the RHS. This is</span>
            <span class="comment">// both because it helps preserve sanity and, in the case of</span>
            <span class="comment">// ref mut, for soundness (issue #23116). In particular, in</span>
            <span class="comment">// the latter case, we need to be clear that the type of the</span>
            <span class="comment">// referent for the reference that results is *equal to* the</span>
            <span class="comment">// type of the lvalue it is referencing, and not some</span>
            <span class="comment">// supertype thereof.</span>
            <span class="kw">let</span> <span class="ident">init_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_expr_with_lvalue_pref</span>(<span class="ident">init</span>, <span class="ident">LvaluePreference</span>::<span class="ident">from_mutbl</span>(<span class="ident">m</span>));
            <span class="self">self</span>.<span class="ident">demand_eqtype</span>(<span class="ident">init</span>.<span class="ident">span</span>, <span class="ident">init_ty</span>, <span class="ident">local_ty</span>);
            <span class="ident">init_ty</span>
        } <span class="kw">else</span> {
            <span class="self">self</span>.<span class="ident">check_expr_coercable_to_type</span>(<span class="ident">init</span>, <span class="ident">local_ty</span>)
        }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_decl_local</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">local</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Local</span>)  {
        <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">local_ty</span>(<span class="ident">local</span>.<span class="ident">span</span>, <span class="ident">local</span>.<span class="ident">id</span>);
        <span class="self">self</span>.<span class="ident">write_ty</span>(<span class="ident">local</span>.<span class="ident">hir_id</span>, <span class="ident">t</span>);

        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="ident">init</span>) <span class="op">=</span> <span class="ident">local</span>.<span class="ident">init</span> {
            <span class="kw">let</span> <span class="ident">init_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_decl_initializer</span>(<span class="ident">local</span>, <span class="kw-2">&amp;</span><span class="ident">init</span>);
            <span class="kw">if</span> <span class="ident">init_ty</span>.<span class="ident">references_error</span>() {
                <span class="self">self</span>.<span class="ident">write_ty</span>(<span class="ident">local</span>.<span class="ident">hir_id</span>, <span class="ident">init_ty</span>);
            }
        }

        <span class="self">self</span>.<span class="ident">check_pat_walk</span>(<span class="kw-2">&amp;</span><span class="ident">local</span>.<span class="ident">pat</span>, <span class="ident">t</span>,
                            <span class="ident">ty</span>::<span class="ident">BindingMode</span>::<span class="ident">BindByValue</span>(<span class="ident">hir</span>::<span class="ident">Mutability</span>::<span class="ident">MutImmutable</span>),
                            <span class="bool-val">true</span>);
        <span class="kw">let</span> <span class="ident">pat_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">node_ty</span>(<span class="ident">local</span>.<span class="ident">pat</span>.<span class="ident">hir_id</span>);
        <span class="kw">if</span> <span class="ident">pat_ty</span>.<span class="ident">references_error</span>() {
            <span class="self">self</span>.<span class="ident">write_ty</span>(<span class="ident">local</span>.<span class="ident">hir_id</span>, <span class="ident">pat_ty</span>);
        }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_stmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">stmt</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Stmt</span>) {
        <span class="comment">// Don&#39;t do all the complex logic below for DeclItem.</span>
        <span class="kw">match</span> <span class="ident">stmt</span>.<span class="ident">node</span> {
            <span class="ident">hir</span>::<span class="ident">StmtDecl</span>(<span class="kw-2">ref</span> <span class="ident">decl</span>, _) <span class="op">=&gt;</span> {
                <span class="kw">match</span> <span class="ident">decl</span>.<span class="ident">node</span> {
                    <span class="ident">hir</span>::<span class="ident">DeclLocal</span>(_) <span class="op">=&gt;</span> {}
                    <span class="ident">hir</span>::<span class="ident">DeclItem</span>(_) <span class="op">=&gt;</span> {
                        <span class="kw">return</span>;
                    }
                }
            }
            <span class="ident">hir</span>::<span class="ident">StmtExpr</span>(..) <span class="op">|</span> <span class="ident">hir</span>::<span class="ident">StmtSemi</span>(..) <span class="op">=&gt;</span> {}
        }

        <span class="self">self</span>.<span class="ident">warn_if_unreachable</span>(<span class="ident">stmt</span>.<span class="ident">node</span>.<span class="ident">id</span>(), <span class="ident">stmt</span>.<span class="ident">span</span>, <span class="string">&quot;statement&quot;</span>);

        <span class="comment">// Hide the outer diverging and has_errors flags.</span>
        <span class="kw">let</span> <span class="ident">old_diverges</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>();
        <span class="kw">let</span> <span class="ident">old_has_errors</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">has_errors</span>.<span class="ident">get</span>();
        <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="ident">Diverges</span>::<span class="ident">Maybe</span>);
        <span class="self">self</span>.<span class="ident">has_errors</span>.<span class="ident">set</span>(<span class="bool-val">false</span>);

        <span class="kw">match</span> <span class="ident">stmt</span>.<span class="ident">node</span> {
            <span class="ident">hir</span>::<span class="ident">StmtDecl</span>(<span class="kw-2">ref</span> <span class="ident">decl</span>, _) <span class="op">=&gt;</span> {
                <span class="kw">match</span> <span class="ident">decl</span>.<span class="ident">node</span> {
                    <span class="ident">hir</span>::<span class="ident">DeclLocal</span>(<span class="kw-2">ref</span> <span class="ident">l</span>) <span class="op">=&gt;</span> {
                        <span class="self">self</span>.<span class="ident">check_decl_local</span>(<span class="kw-2">&amp;</span><span class="ident">l</span>);
                    }
                    <span class="ident">hir</span>::<span class="ident">DeclItem</span>(_) <span class="op">=&gt;</span> {<span class="comment">/* ignore for now */</span>}
                }
            }
            <span class="ident">hir</span>::<span class="ident">StmtExpr</span>(<span class="kw-2">ref</span> <span class="ident">expr</span>, _) <span class="op">=&gt;</span> {
                <span class="comment">// Check with expected type of ()</span>
                <span class="self">self</span>.<span class="ident">check_expr_has_type_or_error</span>(<span class="kw-2">&amp;</span><span class="ident">expr</span>, <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">mk_nil</span>());
            }
            <span class="ident">hir</span>::<span class="ident">StmtSemi</span>(<span class="kw-2">ref</span> <span class="ident">expr</span>, _) <span class="op">=&gt;</span> {
                <span class="self">self</span>.<span class="ident">check_expr</span>(<span class="kw-2">&amp;</span><span class="ident">expr</span>);
            }
        }

        <span class="comment">// Combine the diverging and has_error flags.</span>
        <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>() <span class="op">|</span> <span class="ident">old_diverges</span>);
        <span class="self">self</span>.<span class="ident">has_errors</span>.<span class="ident">set</span>(<span class="self">self</span>.<span class="ident">has_errors</span>.<span class="ident">get</span>() <span class="op">|</span> <span class="ident">old_has_errors</span>);
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_block_no_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">blk</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Block</span>)  {
        <span class="kw">let</span> <span class="ident">unit</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">mk_nil</span>();
        <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">check_block_with_expected</span>(<span class="ident">blk</span>, <span class="ident">ExpectHasType</span>(<span class="ident">unit</span>));

        <span class="comment">// if the block produces a `!` value, that can always be</span>
        <span class="comment">// (effectively) coerced to unit.</span>
        <span class="kw">if</span> <span class="op">!</span><span class="ident">ty</span>.<span class="ident">is_never</span>() {
            <span class="self">self</span>.<span class="ident">demand_suptype</span>(<span class="ident">blk</span>.<span class="ident">span</span>, <span class="ident">unit</span>, <span class="ident">ty</span>);
        }
    }

    <span class="kw">fn</span> <span class="ident">check_block_with_expected</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                 <span class="ident">blk</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Block</span>,
                                 <span class="ident">expected</span>: <span class="ident">Expectation</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">prev</span> <span class="op">=</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fcx_ps</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">ps</span>.<span class="ident">borrow_mut</span>();
            <span class="kw">let</span> <span class="ident">unsafety_state</span> <span class="op">=</span> <span class="ident">fcx_ps</span>.<span class="ident">recurse</span>(<span class="ident">blk</span>);
            <span class="ident">replace</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">fcx_ps</span>, <span class="ident">unsafety_state</span>)
        };

        <span class="comment">// In some cases, blocks have just one exit, but other blocks</span>
        <span class="comment">// can be targeted by multiple breaks. This cannot happen in</span>
        <span class="comment">// normal Rust syntax today, but it can happen when we desugar</span>
        <span class="comment">// a `do catch { ... }` expression.</span>
        <span class="comment">//</span>
        <span class="comment">// Example 1:</span>
        <span class="comment">//</span>
        <span class="comment">//    &#39;a: { if true { break &#39;a Err(()); } Ok(()) }</span>
        <span class="comment">//</span>
        <span class="comment">// Here we would wind up with two coercions, one from</span>
        <span class="comment">// `Err(())` and the other from the tail expression</span>
        <span class="comment">// `Ok(())`. If the tail expression is omitted, that&#39;s a</span>
        <span class="comment">// &quot;forced unit&quot; -- unless the block diverges, in which</span>
        <span class="comment">// case we can ignore the tail expression (e.g., `&#39;a: {</span>
        <span class="comment">// break &#39;a 22; }` would not force the type of the block</span>
        <span class="comment">// to be `()`).</span>
        <span class="kw">let</span> <span class="ident">tail_expr</span> <span class="op">=</span> <span class="ident">blk</span>.<span class="ident">expr</span>.<span class="ident">as_ref</span>();
        <span class="kw">let</span> <span class="ident">coerce_to_ty</span> <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">coercion_target_type</span>(<span class="self">self</span>, <span class="ident">blk</span>.<span class="ident">span</span>);
        <span class="kw">let</span> <span class="ident">coerce</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">blk</span>.<span class="ident">targeted_by_break</span> {
            <span class="ident">CoerceMany</span>::<span class="ident">new</span>(<span class="ident">coerce_to_ty</span>)
        } <span class="kw">else</span> {
            <span class="kw">let</span> <span class="ident">tail_expr</span>: <span class="kw-2">&amp;</span>[<span class="ident">P</span><span class="op">&lt;</span><span class="ident">hir</span>::<span class="ident">Expr</span><span class="op">&gt;</span>] <span class="op">=</span> <span class="kw">match</span> <span class="ident">tail_expr</span> {
                <span class="prelude-val">Some</span>(<span class="ident">e</span>) <span class="op">=&gt;</span> <span class="ident">ref_slice</span>(<span class="ident">e</span>),
                <span class="prelude-val">None</span> <span class="op">=&gt;</span> <span class="kw-2">&amp;</span>[],
            };
            <span class="ident">CoerceMany</span>::<span class="ident">with_coercion_sites</span>(<span class="ident">coerce_to_ty</span>, <span class="ident">tail_expr</span>)
        };

        <span class="kw">let</span> <span class="ident">prev_diverges</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>();
        <span class="kw">let</span> <span class="ident">ctxt</span> <span class="op">=</span> <span class="ident">BreakableCtxt</span> {
            <span class="ident">coerce</span>: <span class="prelude-val">Some</span>(<span class="ident">coerce</span>),
            <span class="ident">may_break</span>: <span class="bool-val">false</span>,
        };

        <span class="kw">let</span> (<span class="ident">ctxt</span>, ()) <span class="op">=</span> <span class="self">self</span>.<span class="ident">with_breakable_ctxt</span>(<span class="ident">blk</span>.<span class="ident">id</span>, <span class="ident">ctxt</span>, <span class="op">||</span> {
            <span class="kw">for</span> <span class="ident">s</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">blk</span>.<span class="ident">stmts</span> {
                <span class="self">self</span>.<span class="ident">check_stmt</span>(<span class="ident">s</span>);
            }

            <span class="comment">// check the tail expression **without** holding the</span>
            <span class="comment">// `enclosing_breakables` lock below.</span>
            <span class="kw">let</span> <span class="ident">tail_expr_ty</span> <span class="op">=</span> <span class="ident">tail_expr</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="self">self</span>.<span class="ident">check_expr_with_expectation</span>(<span class="ident">t</span>, <span class="ident">expected</span>));

            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">enclosing_breakables</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">enclosing_breakables</span>.<span class="ident">borrow_mut</span>();
            <span class="kw">let</span> <span class="ident">ctxt</span> <span class="op">=</span> <span class="ident">enclosing_breakables</span>.<span class="ident">find_breakable</span>(<span class="ident">blk</span>.<span class="ident">id</span>);
            <span class="kw">let</span> <span class="ident">coerce</span> <span class="op">=</span> <span class="ident">ctxt</span>.<span class="ident">coerce</span>.<span class="ident">as_mut</span>().<span class="ident">unwrap</span>();
            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">tail_expr_ty</span>) <span class="op">=</span> <span class="ident">tail_expr_ty</span> {
                <span class="kw">let</span> <span class="ident">tail_expr</span> <span class="op">=</span> <span class="ident">tail_expr</span>.<span class="ident">unwrap</span>();
                <span class="kw">let</span> <span class="ident">cause</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">cause</span>(<span class="ident">tail_expr</span>.<span class="ident">span</span>,
                                       <span class="ident">ObligationCauseCode</span>::<span class="ident">BlockTailExpression</span>(<span class="ident">blk</span>.<span class="ident">id</span>));
                <span class="ident">coerce</span>.<span class="ident">coerce</span>(<span class="self">self</span>,
                              <span class="kw-2">&amp;</span><span class="ident">cause</span>,
                              <span class="ident">tail_expr</span>,
                              <span class="ident">tail_expr_ty</span>,
                              <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>());
            } <span class="kw">else</span> {
                <span class="comment">// Subtle: if there is no explicit tail expression,</span>
                <span class="comment">// that is typically equivalent to a tail expression</span>
                <span class="comment">// of `()` -- except if the block diverges. In that</span>
                <span class="comment">// case, there is no value supplied from the tail</span>
                <span class="comment">// expression (assuming there are no other breaks,</span>
                <span class="comment">// this implies that the type of the block will be</span>
                <span class="comment">// `!`).</span>
                <span class="comment">//</span>
                <span class="comment">// #41425 -- label the implicit `()` as being the</span>
                <span class="comment">// &quot;found type&quot; here, rather than the &quot;expected type&quot;.</span>
                <span class="kw">if</span> <span class="op">!</span><span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">get</span>().<span class="ident">always</span>() {
                    <span class="ident">coerce</span>.<span class="ident">coerce_forced_unit</span>(<span class="self">self</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">misc</span>(<span class="ident">blk</span>.<span class="ident">span</span>), <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="op">|</span><span class="ident">err</span><span class="op">|</span> {
                        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">expected_ty</span>) <span class="op">=</span> <span class="ident">expected</span>.<span class="ident">only_has_type</span>(<span class="self">self</span>) {
                            <span class="self">self</span>.<span class="ident">consider_hint_about_removing_semicolon</span>(<span class="ident">blk</span>,
                                                                        <span class="ident">expected_ty</span>,
                                                                        <span class="ident">err</span>);
                        }
                    }, <span class="bool-val">false</span>);
                }
            }
        });

        <span class="kw">if</span> <span class="ident">ctxt</span>.<span class="ident">may_break</span> {
            <span class="comment">// If we can break from the block, then the block&#39;s exit is always reachable</span>
            <span class="comment">// (... as long as the entry is reachable) - regardless of the tail of the block.</span>
            <span class="self">self</span>.<span class="ident">diverges</span>.<span class="ident">set</span>(<span class="ident">prev_diverges</span>);
        }

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ty</span> <span class="op">=</span> <span class="ident">ctxt</span>.<span class="ident">coerce</span>.<span class="ident">unwrap</span>().<span class="ident">complete</span>(<span class="self">self</span>);

        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">has_errors</span>.<span class="ident">get</span>() <span class="op">||</span> <span class="ident">ty</span>.<span class="ident">references_error</span>() {
            <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
        }

        <span class="self">self</span>.<span class="ident">write_ty</span>(<span class="ident">blk</span>.<span class="ident">hir_id</span>, <span class="ident">ty</span>);

        <span class="kw-2">*</span><span class="self">self</span>.<span class="ident">ps</span>.<span class="ident">borrow_mut</span>() <span class="op">=</span> <span class="ident">prev</span>;
        <span class="ident">ty</span>
    }

    <span class="doccomment">/// Given a `NodeId`, return the `FnDecl` of the method it is enclosed by and whether a</span>
    <span class="doccomment">/// suggestion can be made, `None` otherwise.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_fn_decl</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">blk_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span>(<span class="ident">hir</span>::<span class="ident">FnDecl</span>, <span class="ident">bool</span>)<span class="op">&gt;</span> {
        <span class="comment">// Get enclosing Fn, if it is a function or a trait method, unless there&#39;s a `loop` or</span>
        <span class="comment">// `while` before reaching it, as block tail returns are not available in them.</span>
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">fn_id</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">get_return_block</span>(<span class="ident">blk_id</span>) {
            <span class="kw">let</span> <span class="ident">parent</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">get</span>(<span class="ident">fn_id</span>);

            <span class="kw">if</span> <span class="kw">let</span> <span class="ident">Node</span>::<span class="ident">NodeItem</span>(<span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Item</span> {
                <span class="ident">name</span>, <span class="ident">node</span>: <span class="ident">hir</span>::<span class="ident">ItemFn</span>(<span class="kw-2">ref</span> <span class="ident">decl</span>, ..), ..
            }) <span class="op">=</span> <span class="ident">parent</span> {
                <span class="ident">decl</span>.<span class="ident">clone</span>().<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">decl</span><span class="op">|</span> {
                    <span class="comment">// This is less than ideal, it will not suggest a return type span on any</span>
                    <span class="comment">// method called `main`, regardless of whether it is actually the entry point,</span>
                    <span class="comment">// but it will still present it as the reason for the expected type.</span>
                    <span class="prelude-val">Some</span>((<span class="ident">decl</span>, <span class="ident">name</span> <span class="op">!=</span> <span class="ident">Symbol</span>::<span class="ident">intern</span>(<span class="string">&quot;main&quot;</span>)))
                })
            } <span class="kw">else</span> <span class="kw">if</span> <span class="kw">let</span> <span class="ident">Node</span>::<span class="ident">NodeTraitItem</span>(<span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">TraitItem</span> {
                <span class="ident">node</span>: <span class="ident">hir</span>::<span class="ident">TraitItemKind</span>::<span class="ident">Method</span>(<span class="ident">hir</span>::<span class="ident">MethodSig</span> {
                    <span class="kw-2">ref</span> <span class="ident">decl</span>, ..
                }, ..), ..
            }) <span class="op">=</span> <span class="ident">parent</span> {
                <span class="ident">decl</span>.<span class="ident">clone</span>().<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">decl</span><span class="op">|</span> {
                    <span class="prelude-val">Some</span>((<span class="ident">decl</span>, <span class="bool-val">true</span>))
                })
            } <span class="kw">else</span> <span class="kw">if</span> <span class="kw">let</span> <span class="ident">Node</span>::<span class="ident">NodeImplItem</span>(<span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">ImplItem</span> {
                <span class="ident">node</span>: <span class="ident">hir</span>::<span class="ident">ImplItemKind</span>::<span class="ident">Method</span>(<span class="ident">hir</span>::<span class="ident">MethodSig</span> {
                    <span class="kw-2">ref</span> <span class="ident">decl</span>, ..
                }, ..), ..
            }) <span class="op">=</span> <span class="ident">parent</span> {
                <span class="ident">decl</span>.<span class="ident">clone</span>().<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">decl</span><span class="op">|</span> {
                    <span class="prelude-val">Some</span>((<span class="ident">decl</span>, <span class="bool-val">false</span>))
                })
            } <span class="kw">else</span> {
                <span class="prelude-val">None</span>
            }
        } <span class="kw">else</span> {
            <span class="prelude-val">None</span>
        }
    }

    <span class="doccomment">/// On implicit return expressions with mismatched types, provide the following suggestions:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///  - Point out the method&#39;s return type as the reason for the expected type</span>
    <span class="doccomment">///  - Possible missing semicolon</span>
    <span class="doccomment">///  - Possible missing return type if the return type is the default, and not `fn main()`</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">suggest_mismatched_types_on_tail</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                            <span class="ident">err</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">DiagnosticBuilder</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                            <span class="ident">expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                                            <span class="ident">expected</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                            <span class="ident">found</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                            <span class="ident">cause_span</span>: <span class="ident">Span</span>,
                                            <span class="ident">blk_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>) {
        <span class="self">self</span>.<span class="ident">suggest_missing_semicolon</span>(<span class="ident">err</span>, <span class="ident">expression</span>, <span class="ident">expected</span>, <span class="ident">cause_span</span>);

        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">fn_decl</span>, <span class="ident">can_suggest</span>)) <span class="op">=</span> <span class="self">self</span>.<span class="ident">get_fn_decl</span>(<span class="ident">blk_id</span>) {
            <span class="self">self</span>.<span class="ident">suggest_missing_return_type</span>(<span class="ident">err</span>, <span class="kw-2">&amp;</span><span class="ident">fn_decl</span>, <span class="ident">expected</span>, <span class="ident">found</span>, <span class="ident">can_suggest</span>);
        }
    }

    <span class="doccomment">/// A common error is to forget to add a semicolon at the end of a block:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// fn foo() {</span>
    <span class="doccomment">///     bar_that_returns_u32()</span>
    <span class="doccomment">/// }</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This routine checks if the return expression in a block would make sense on its own as a</span>
    <span class="doccomment">/// statement and the return type has been left as default or has been specified as `()`. If so,</span>
    <span class="doccomment">/// it suggests adding a semicolon.</span>
    <span class="kw">fn</span> <span class="ident">suggest_missing_semicolon</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                     <span class="ident">err</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">DiagnosticBuilder</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                     <span class="ident">expression</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Expr</span>,
                                     <span class="ident">expected</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                     <span class="ident">cause_span</span>: <span class="ident">Span</span>) {
        <span class="kw">if</span> <span class="ident">expected</span>.<span class="ident">is_nil</span>() {
            <span class="comment">// `BlockTailExpression` only relevant if the tail expr would be</span>
            <span class="comment">// useful on its own.</span>
            <span class="kw">match</span> <span class="ident">expression</span>.<span class="ident">node</span> {
                <span class="ident">hir</span>::<span class="ident">ExprCall</span>(..) <span class="op">|</span>
                <span class="ident">hir</span>::<span class="ident">ExprMethodCall</span>(..) <span class="op">|</span>
                <span class="ident">hir</span>::<span class="ident">ExprIf</span>(..) <span class="op">|</span>
                <span class="ident">hir</span>::<span class="ident">ExprWhile</span>(..) <span class="op">|</span>
                <span class="ident">hir</span>::<span class="ident">ExprLoop</span>(..) <span class="op">|</span>
                <span class="ident">hir</span>::<span class="ident">ExprMatch</span>(..) <span class="op">|</span>
                <span class="ident">hir</span>::<span class="ident">ExprBlock</span>(..) <span class="op">=&gt;</span> {
                    <span class="kw">let</span> <span class="ident">sp</span> <span class="op">=</span> <span class="ident">cause_span</span>.<span class="ident">next_point</span>();
                    <span class="ident">err</span>.<span class="ident">span_suggestion</span>(<span class="ident">sp</span>,
                                        <span class="string">&quot;try adding a semicolon&quot;</span>,
                                        <span class="string">&quot;;&quot;</span>.<span class="ident">to_string</span>());
                }
                _ <span class="op">=&gt;</span> (),
            }
        }
    }


    <span class="doccomment">/// A possible error is to forget to add a return type that is needed:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// fn foo() {</span>
    <span class="doccomment">///     bar_that_returns_u32()</span>
    <span class="doccomment">/// }</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This routine checks if the return type is left as default, the method is not part of an</span>
    <span class="doccomment">/// `impl` block and that it isn&#39;t the `main` method. If so, it suggests setting the return</span>
    <span class="doccomment">/// type.</span>
    <span class="kw">fn</span> <span class="ident">suggest_missing_return_type</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                   <span class="ident">err</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">DiagnosticBuilder</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                   <span class="ident">fn_decl</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">FnDecl</span>,
                                   <span class="ident">expected</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                   <span class="ident">found</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                   <span class="ident">can_suggest</span>: <span class="ident">bool</span>) {
        <span class="comment">// Only suggest changing the return type for methods that</span>
        <span class="comment">// haven&#39;t set a return type at all (and aren&#39;t `fn main()` or an impl).</span>
        <span class="kw">match</span> (<span class="kw-2">&amp;</span><span class="ident">fn_decl</span>.<span class="ident">output</span>, <span class="ident">found</span>.<span class="ident">is_suggestable</span>(), <span class="ident">can_suggest</span>) {
            (<span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">FunctionRetTy</span>::<span class="ident">DefaultReturn</span>(<span class="ident">span</span>), <span class="bool-val">true</span>, <span class="bool-val">true</span>) <span class="op">=&gt;</span> {
                <span class="ident">err</span>.<span class="ident">span_suggestion</span>(<span class="ident">span</span>,
                                    <span class="string">&quot;try adding a return type&quot;</span>,
                                    <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;-&gt; {} &quot;</span>, <span class="ident">found</span>));
            }
            (<span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">FunctionRetTy</span>::<span class="ident">DefaultReturn</span>(<span class="ident">span</span>), <span class="bool-val">false</span>, <span class="bool-val">true</span>) <span class="op">=&gt;</span> {
                <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">span</span>, <span class="string">&quot;possibly return type missing here?&quot;</span>);
            }
            (<span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">FunctionRetTy</span>::<span class="ident">DefaultReturn</span>(<span class="ident">span</span>), _, _) <span class="op">=&gt;</span> {
                <span class="comment">// `fn main()` must return `()`, do not suggest changing return type</span>
                <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">span</span>, <span class="string">&quot;expected `()` because of default return type&quot;</span>);
            }
            (<span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">FunctionRetTy</span>::<span class="ident">Return</span>(<span class="kw-2">ref</span> <span class="ident">ty</span>), _, _) <span class="op">=&gt;</span> {
                <span class="comment">// Only point to return type if the expected type is the return type, as if they</span>
                <span class="comment">// are not, the expectation must have been caused by something else.</span>
                <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;suggest_missing_return_type: return type {:?} node {:?}&quot;</span>, <span class="ident">ty</span>, <span class="ident">ty</span>.<span class="ident">node</span>);
                <span class="kw">let</span> <span class="ident">sp</span> <span class="op">=</span> <span class="ident">ty</span>.<span class="ident">span</span>;
                <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="ident">AstConv</span>::<span class="ident">ast_ty_to_ty</span>(<span class="self">self</span>, <span class="ident">ty</span>);
                <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;suggest_missing_return_type: return type sty {:?}&quot;</span>, <span class="ident">ty</span>.<span class="ident">sty</span>);
                <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;suggest_missing_return_type: expected type sty {:?}&quot;</span>, <span class="ident">ty</span>.<span class="ident">sty</span>);
                <span class="kw">if</span> <span class="ident">ty</span>.<span class="ident">sty</span> <span class="op">==</span> <span class="ident">expected</span>.<span class="ident">sty</span> {
                    <span class="ident">err</span>.<span class="ident">span_label</span>(<span class="ident">sp</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;expected `{}` because of return type&quot;</span>,
                                               <span class="ident">expected</span>));
                }
            }
        }
    }


    <span class="doccomment">/// A common error is to add an extra semicolon:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// fn foo() -&gt; usize {</span>
    <span class="doccomment">///     22;</span>
    <span class="doccomment">/// }</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This routine checks if the final statement in a block is an</span>
    <span class="doccomment">/// expression with an explicit semicolon whose type is compatible</span>
    <span class="doccomment">/// with `expected_ty`. If so, it suggests removing the semicolon.</span>
    <span class="kw">fn</span> <span class="ident">consider_hint_about_removing_semicolon</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                              <span class="ident">blk</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;gcx</span> <span class="ident">hir</span>::<span class="ident">Block</span>,
                                              <span class="ident">expected_ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                              <span class="ident">err</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">DiagnosticBuilder</span>) {
        <span class="comment">// Be helpful when the user wrote `{... expr;}` and</span>
        <span class="comment">// taking the `;` off is enough to fix the error.</span>
        <span class="kw">let</span> <span class="ident">last_stmt</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">blk</span>.<span class="ident">stmts</span>.<span class="ident">last</span>() {
            <span class="prelude-val">Some</span>(<span class="ident">s</span>) <span class="op">=&gt;</span> <span class="ident">s</span>,
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> <span class="kw">return</span>,
        };
        <span class="kw">let</span> <span class="ident">last_expr</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">last_stmt</span>.<span class="ident">node</span> {
            <span class="ident">hir</span>::<span class="ident">StmtSemi</span>(<span class="kw-2">ref</span> <span class="ident">e</span>, _) <span class="op">=&gt;</span> <span class="ident">e</span>,
            _ <span class="op">=&gt;</span> <span class="kw">return</span>,
        };
        <span class="kw">let</span> <span class="ident">last_expr_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">node_ty</span>(<span class="ident">last_expr</span>.<span class="ident">hir_id</span>);
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">can_sub</span>(<span class="self">self</span>.<span class="ident">param_env</span>, <span class="ident">last_expr_ty</span>, <span class="ident">expected_ty</span>).<span class="ident">is_err</span>() {
            <span class="kw">return</span>;
        }
        <span class="kw">let</span> <span class="ident">original_span</span> <span class="op">=</span> <span class="ident">original_sp</span>(<span class="ident">last_stmt</span>.<span class="ident">span</span>, <span class="ident">blk</span>.<span class="ident">span</span>);
        <span class="kw">let</span> <span class="ident">span_semi</span> <span class="op">=</span> <span class="ident">original_span</span>.<span class="ident">with_lo</span>(<span class="ident">original_span</span>.<span class="ident">hi</span>() <span class="op">-</span> <span class="ident">BytePos</span>(<span class="number">1</span>));
        <span class="ident">err</span>.<span class="ident">span_suggestion</span>(<span class="ident">span_semi</span>, <span class="string">&quot;consider removing this semicolon&quot;</span>, <span class="string">&quot;&quot;</span>.<span class="ident">to_string</span>());
    }

    <span class="comment">// Instantiates the given path, which must refer to an item with the given</span>
    <span class="comment">// number of type parameters and type.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">instantiate_value_path</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                  <span class="ident">segments</span>: <span class="kw-2">&amp;</span>[<span class="ident">hir</span>::<span class="ident">PathSegment</span>],
                                  <span class="ident">opt_self_ty</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;&gt;</span>,
                                  <span class="ident">def</span>: <span class="ident">Def</span>,
                                  <span class="ident">span</span>: <span class="ident">Span</span>,
                                  <span class="ident">node_id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>)
                                  <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;instantiate_value_path(path={:?}, def={:?}, node_id={})&quot;</span>,
               <span class="ident">segments</span>,
               <span class="ident">def</span>,
               <span class="ident">node_id</span>);

        <span class="comment">// We need to extract the type parameters supplied by the user in</span>
        <span class="comment">// the path `path`. Due to the current setup, this is a bit of a</span>
        <span class="comment">// tricky-process; the problem is that resolve only tells us the</span>
        <span class="comment">// end-point of the path resolution, and not the intermediate steps.</span>
        <span class="comment">// Luckily, we can (at least for now) deduce the intermediate steps</span>
        <span class="comment">// just from the end-point.</span>
        <span class="comment">//</span>
        <span class="comment">// There are basically four cases to consider:</span>
        <span class="comment">//</span>
        <span class="comment">// 1. Reference to a constructor of enum variant or struct:</span>
        <span class="comment">//</span>
        <span class="comment">//        struct Foo&lt;T&gt;(...)</span>
        <span class="comment">//        enum E&lt;T&gt; { Foo(...) }</span>
        <span class="comment">//</span>
        <span class="comment">//    In these cases, the parameters are declared in the type</span>
        <span class="comment">//    space.</span>
        <span class="comment">//</span>
        <span class="comment">// 2. Reference to a fn item or a free constant:</span>
        <span class="comment">//</span>
        <span class="comment">//        fn foo&lt;T&gt;() { }</span>
        <span class="comment">//</span>
        <span class="comment">//    In this case, the path will again always have the form</span>
        <span class="comment">//    `a::b::foo::&lt;T&gt;` where only the final segment should have</span>
        <span class="comment">//    type parameters. However, in this case, those parameters are</span>
        <span class="comment">//    declared on a value, and hence are in the `FnSpace`.</span>
        <span class="comment">//</span>
        <span class="comment">// 3. Reference to a method or an associated constant:</span>
        <span class="comment">//</span>
        <span class="comment">//        impl&lt;A&gt; SomeStruct&lt;A&gt; {</span>
        <span class="comment">//            fn foo&lt;B&gt;(...)</span>
        <span class="comment">//        }</span>
        <span class="comment">//</span>
        <span class="comment">//    Here we can have a path like</span>
        <span class="comment">//    `a::b::SomeStruct::&lt;A&gt;::foo::&lt;B&gt;`, in which case parameters</span>
        <span class="comment">//    may appear in two places. The penultimate segment,</span>
        <span class="comment">//    `SomeStruct::&lt;A&gt;`, contains parameters in TypeSpace, and the</span>
        <span class="comment">//    final segment, `foo::&lt;B&gt;` contains parameters in fn space.</span>
        <span class="comment">//</span>
        <span class="comment">// 4. Reference to a local variable</span>
        <span class="comment">//</span>
        <span class="comment">//    Local variables can&#39;t have any type parameters.</span>
        <span class="comment">//</span>
        <span class="comment">// The first step then is to categorize the segments appropriately.</span>

        <span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">segments</span>.<span class="ident">is_empty</span>());

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ufcs_associated</span> <span class="op">=</span> <span class="prelude-val">None</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">type_segment</span> <span class="op">=</span> <span class="prelude-val">None</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fn_segment</span> <span class="op">=</span> <span class="prelude-val">None</span>;
        <span class="kw">match</span> <span class="ident">def</span> {
            <span class="comment">// Case 1. Reference to a struct/variant constructor.</span>
            <span class="ident">Def</span>::<span class="ident">StructCtor</span>(<span class="ident">def_id</span>, ..) <span class="op">|</span>
            <span class="ident">Def</span>::<span class="ident">VariantCtor</span>(<span class="ident">def_id</span>, ..) <span class="op">=&gt;</span> {
                <span class="comment">// Everything but the final segment should have no</span>
                <span class="comment">// parameters at all.</span>
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">generics</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">generics_of</span>(<span class="ident">def_id</span>);
                <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">def_id</span>) <span class="op">=</span> <span class="ident">generics</span>.<span class="ident">parent</span> {
                    <span class="comment">// Variant and struct constructors use the</span>
                    <span class="comment">// generics of their parent type definition.</span>
                    <span class="ident">generics</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">generics_of</span>(<span class="ident">def_id</span>);
                }
                <span class="ident">type_segment</span> <span class="op">=</span> <span class="prelude-val">Some</span>((<span class="ident">segments</span>.<span class="ident">last</span>().<span class="ident">unwrap</span>(), <span class="ident">generics</span>));
            }

            <span class="comment">// Case 2. Reference to a top-level value.</span>
            <span class="ident">Def</span>::<span class="ident">Fn</span>(<span class="ident">def_id</span>) <span class="op">|</span>
            <span class="ident">Def</span>::<span class="ident">Const</span>(<span class="ident">def_id</span>) <span class="op">|</span>
            <span class="ident">Def</span>::<span class="ident">Static</span>(<span class="ident">def_id</span>, _) <span class="op">=&gt;</span> {
                <span class="ident">fn_segment</span> <span class="op">=</span> <span class="prelude-val">Some</span>((<span class="ident">segments</span>.<span class="ident">last</span>().<span class="ident">unwrap</span>(),
                                   <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">generics_of</span>(<span class="ident">def_id</span>)));
            }

            <span class="comment">// Case 3. Reference to a method or associated const.</span>
            <span class="ident">Def</span>::<span class="ident">Method</span>(<span class="ident">def_id</span>) <span class="op">|</span>
            <span class="ident">Def</span>::<span class="ident">AssociatedConst</span>(<span class="ident">def_id</span>) <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="ident">container</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">associated_item</span>(<span class="ident">def_id</span>).<span class="ident">container</span>;
                <span class="kw">match</span> <span class="ident">container</span> {
                    <span class="ident">ty</span>::<span class="ident">TraitContainer</span>(<span class="ident">trait_did</span>) <span class="op">=&gt;</span> {
                        <span class="ident">callee</span>::<span class="ident">check_legal_trait_for_method_call</span>(<span class="self">self</span>.<span class="ident">tcx</span>, <span class="ident">span</span>, <span class="ident">trait_did</span>)
                    }
                    <span class="ident">ty</span>::<span class="ident">ImplContainer</span>(_) <span class="op">=&gt;</span> {}
                }

                <span class="kw">let</span> <span class="ident">generics</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">generics_of</span>(<span class="ident">def_id</span>);
                <span class="kw">if</span> <span class="ident">segments</span>.<span class="ident">len</span>() <span class="op">&gt;=</span> <span class="number">2</span> {
                    <span class="kw">let</span> <span class="ident">parent_generics</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">generics_of</span>(<span class="ident">generics</span>.<span class="ident">parent</span>.<span class="ident">unwrap</span>());
                    <span class="ident">type_segment</span> <span class="op">=</span> <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="ident">segments</span>[<span class="ident">segments</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="number">2</span>], <span class="ident">parent_generics</span>));
                } <span class="kw">else</span> {
                    <span class="comment">// `&lt;T&gt;::assoc` will end up here, and so can `T::assoc`.</span>
                    <span class="kw">let</span> <span class="ident">self_ty</span> <span class="op">=</span> <span class="ident">opt_self_ty</span>.<span class="ident">expect</span>(<span class="string">&quot;UFCS sugared assoc missing Self&quot;</span>);
                    <span class="ident">ufcs_associated</span> <span class="op">=</span> <span class="prelude-val">Some</span>((<span class="ident">container</span>, <span class="ident">self_ty</span>));
                }
                <span class="ident">fn_segment</span> <span class="op">=</span> <span class="prelude-val">Some</span>((<span class="ident">segments</span>.<span class="ident">last</span>().<span class="ident">unwrap</span>(), <span class="ident">generics</span>));
            }

            <span class="comment">// Case 4. Local variable, no generics.</span>
            <span class="ident">Def</span>::<span class="ident">Local</span>(..) <span class="op">|</span> <span class="ident">Def</span>::<span class="ident">Upvar</span>(..) <span class="op">=&gt;</span> {}

            _ <span class="op">=&gt;</span> <span class="macro">bug</span><span class="macro">!</span>(<span class="string">&quot;unexpected definition: {:?}&quot;</span>, <span class="ident">def</span>),
        }

        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;type_segment={:?} fn_segment={:?}&quot;</span>, <span class="ident">type_segment</span>, <span class="ident">fn_segment</span>);

        <span class="comment">// Now that we have categorized what space the parameters for each</span>
        <span class="comment">// segment belong to, let&#39;s sort out the parameters that the user</span>
        <span class="comment">// provided (if any) into their appropriate spaces. We&#39;ll also report</span>
        <span class="comment">// errors if type parameters are provided in an inappropriate place.</span>
        <span class="kw">let</span> <span class="ident">poly_segments</span> <span class="op">=</span> <span class="ident">type_segment</span>.<span class="ident">is_some</span>() <span class="kw">as</span> <span class="ident">usize</span> <span class="op">+</span>
                            <span class="ident">fn_segment</span>.<span class="ident">is_some</span>() <span class="kw">as</span> <span class="ident">usize</span>;
        <span class="ident">AstConv</span>::<span class="ident">prohibit_type_params</span>(<span class="self">self</span>, <span class="kw-2">&amp;</span><span class="ident">segments</span>[..<span class="ident">segments</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="ident">poly_segments</span>]);

        <span class="kw">match</span> <span class="ident">def</span> {
            <span class="ident">Def</span>::<span class="ident">Local</span>(<span class="ident">nid</span>) <span class="op">|</span> <span class="ident">Def</span>::<span class="ident">Upvar</span>(<span class="ident">nid</span>, ..) <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">local_ty</span>(<span class="ident">span</span>, <span class="ident">nid</span>);
                <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">normalize_associated_types_in</span>(<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="ident">ty</span>);
                <span class="self">self</span>.<span class="ident">write_ty</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">node_to_hir_id</span>(<span class="ident">node_id</span>), <span class="ident">ty</span>);
                <span class="kw">return</span> <span class="ident">ty</span>;
            }
            _ <span class="op">=&gt;</span> {}
        }

        <span class="comment">// Now we have to compare the types that the user *actually*</span>
        <span class="comment">// provided against the types that were *expected*. If the user</span>
        <span class="comment">// did not provide any types, then we want to substitute inference</span>
        <span class="comment">// variables. If the user provided some types, we may still need</span>
        <span class="comment">// to add defaults. If the user provided *too many* types, that&#39;s</span>
        <span class="comment">// a problem.</span>
        <span class="self">self</span>.<span class="ident">check_path_parameter_count</span>(<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">type_segment</span>, <span class="bool-val">false</span>);
        <span class="self">self</span>.<span class="ident">check_path_parameter_count</span>(<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">fn_segment</span>, <span class="bool-val">false</span>);
        <span class="self">self</span>.<span class="ident">check_impl_trait</span>(<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">fn_segment</span>);

        <span class="kw">let</span> (<span class="ident">fn_start</span>, <span class="ident">has_self</span>) <span class="op">=</span> <span class="kw">match</span> (<span class="ident">type_segment</span>, <span class="ident">fn_segment</span>) {
            (_, <span class="prelude-val">Some</span>((_, <span class="ident">generics</span>))) <span class="op">=&gt;</span> {
                (<span class="ident">generics</span>.<span class="ident">parent_count</span>(), <span class="ident">generics</span>.<span class="ident">has_self</span>)
            }
            (<span class="prelude-val">Some</span>((_, <span class="ident">generics</span>)), <span class="prelude-val">None</span>) <span class="op">=&gt;</span> {
                (<span class="ident">generics</span>.<span class="ident">own_count</span>(), <span class="ident">generics</span>.<span class="ident">has_self</span>)
            }
            (<span class="prelude-val">None</span>, <span class="prelude-val">None</span>) <span class="op">=&gt;</span> (<span class="number">0</span>, <span class="bool-val">false</span>)
        };
        <span class="kw">let</span> <span class="ident">substs</span> <span class="op">=</span> <span class="ident">Substs</span>::<span class="ident">for_item</span>(<span class="self">self</span>.<span class="ident">tcx</span>, <span class="ident">def</span>.<span class="ident">def_id</span>(), <span class="op">|</span><span class="ident">def</span>, _<span class="op">|</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">i</span> <span class="op">=</span> <span class="ident">def</span>.<span class="ident">index</span> <span class="kw">as</span> <span class="ident">usize</span>;

            <span class="kw">let</span> <span class="ident">segment</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">i</span> <span class="op">&lt;</span> <span class="ident">fn_start</span> {
                <span class="ident">i</span> <span class="op">-=</span> <span class="ident">has_self</span> <span class="kw">as</span> <span class="ident">usize</span>;
                <span class="ident">type_segment</span>
            } <span class="kw">else</span> {
                <span class="ident">i</span> <span class="op">-=</span> <span class="ident">fn_start</span>;
                <span class="ident">fn_segment</span>
            };
            <span class="kw">let</span> <span class="ident">lifetimes</span> <span class="op">=</span> <span class="ident">segment</span>.<span class="ident">map_or</span>(<span class="kw-2">&amp;</span>[][..], <span class="op">|</span>(<span class="ident">s</span>, _)<span class="op">|</span> {
                <span class="ident">s</span>.<span class="ident">parameters</span>.<span class="ident">as_ref</span>().<span class="ident">map_or</span>(<span class="kw-2">&amp;</span>[][..], <span class="op">|</span><span class="ident">p</span><span class="op">|</span> <span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">lifetimes</span>[..])
            });

            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">lifetime</span>) <span class="op">=</span> <span class="ident">lifetimes</span>.<span class="ident">get</span>(<span class="ident">i</span>) {
                <span class="ident">AstConv</span>::<span class="ident">ast_region_to_region</span>(<span class="self">self</span>, <span class="ident">lifetime</span>, <span class="prelude-val">Some</span>(<span class="ident">def</span>))
            } <span class="kw">else</span> {
                <span class="self">self</span>.<span class="ident">re_infer</span>(<span class="ident">span</span>, <span class="prelude-val">Some</span>(<span class="ident">def</span>)).<span class="ident">unwrap</span>()
            }
        }, <span class="op">|</span><span class="ident">def</span>, <span class="ident">substs</span><span class="op">|</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">i</span> <span class="op">=</span> <span class="ident">def</span>.<span class="ident">index</span> <span class="kw">as</span> <span class="ident">usize</span>;

            <span class="kw">let</span> <span class="ident">segment</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">i</span> <span class="op">&lt;</span> <span class="ident">fn_start</span> {
                <span class="comment">// Handle Self first, so we can adjust the index to match the AST.</span>
                <span class="kw">if</span> <span class="ident">has_self</span> <span class="op">&amp;&amp;</span> <span class="ident">i</span> <span class="op">==</span> <span class="number">0</span> {
                    <span class="kw">return</span> <span class="ident">opt_self_ty</span>.<span class="ident">unwrap_or_else</span>(<span class="op">||</span> {
                        <span class="self">self</span>.<span class="ident">type_var_for_def</span>(<span class="ident">span</span>, <span class="ident">def</span>, <span class="ident">substs</span>)
                    });
                }
                <span class="ident">i</span> <span class="op">-=</span> <span class="ident">has_self</span> <span class="kw">as</span> <span class="ident">usize</span>;
                <span class="ident">type_segment</span>
            } <span class="kw">else</span> {
                <span class="ident">i</span> <span class="op">-=</span> <span class="ident">fn_start</span>;
                <span class="ident">fn_segment</span>
            };
            <span class="kw">let</span> (<span class="ident">types</span>, <span class="ident">infer_types</span>) <span class="op">=</span> <span class="ident">segment</span>.<span class="ident">map_or</span>((<span class="kw-2">&amp;</span>[][..], <span class="bool-val">true</span>), <span class="op">|</span>(<span class="ident">s</span>, _)<span class="op">|</span> {
                (<span class="ident">s</span>.<span class="ident">parameters</span>.<span class="ident">as_ref</span>().<span class="ident">map_or</span>(<span class="kw-2">&amp;</span>[][..], <span class="op">|</span><span class="ident">p</span><span class="op">|</span> <span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">types</span>[..]), <span class="ident">s</span>.<span class="ident">infer_types</span>)
            });

            <span class="comment">// Skip over the lifetimes in the same segment.</span>
            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((_, <span class="ident">generics</span>)) <span class="op">=</span> <span class="ident">segment</span> {
                <span class="ident">i</span> <span class="op">-=</span> <span class="ident">generics</span>.<span class="ident">regions</span>.<span class="ident">len</span>();
            }

            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">ast_ty</span>) <span class="op">=</span> <span class="ident">types</span>.<span class="ident">get</span>(<span class="ident">i</span>) {
                <span class="comment">// A provided type parameter.</span>
                <span class="self">self</span>.<span class="ident">to_ty</span>(<span class="ident">ast_ty</span>)
            } <span class="kw">else</span> <span class="kw">if</span> <span class="op">!</span><span class="ident">infer_types</span> <span class="op">&amp;&amp;</span> <span class="ident">def</span>.<span class="ident">has_default</span> {
                <span class="comment">// No type parameter provided, but a default exists.</span>
                <span class="kw">let</span> <span class="ident">default</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">type_of</span>(<span class="ident">def</span>.<span class="ident">def_id</span>);
                <span class="self">self</span>.<span class="ident">normalize_ty</span>(
                    <span class="ident">span</span>,
                    <span class="ident">default</span>.<span class="ident">subst_spanned</span>(<span class="self">self</span>.<span class="ident">tcx</span>, <span class="ident">substs</span>, <span class="prelude-val">Some</span>(<span class="ident">span</span>))
                )
            } <span class="kw">else</span> {
                <span class="comment">// No type parameters were provided, we can infer all.</span>
                <span class="comment">// This can also be reached in some error cases:</span>
                <span class="comment">// We prefer to use inference variables instead of</span>
                <span class="comment">// TyError to let type inference recover somewhat.</span>
                <span class="self">self</span>.<span class="ident">type_var_for_def</span>(<span class="ident">span</span>, <span class="ident">def</span>, <span class="ident">substs</span>)
            }
        });

        <span class="comment">// The things we are substituting into the type should not contain</span>
        <span class="comment">// escaping late-bound regions, and nor should the base type scheme.</span>
        <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">type_of</span>(<span class="ident">def</span>.<span class="ident">def_id</span>());
        <span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">substs</span>.<span class="ident">has_escaping_regions</span>());
        <span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">ty</span>.<span class="ident">has_escaping_regions</span>());

        <span class="comment">// Add all the obligations that are required, substituting and</span>
        <span class="comment">// normalized appropriately.</span>
        <span class="kw">let</span> <span class="ident">bounds</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">instantiate_bounds</span>(<span class="ident">span</span>, <span class="ident">def</span>.<span class="ident">def_id</span>(), <span class="kw-2">&amp;</span><span class="ident">substs</span>);
        <span class="self">self</span>.<span class="ident">add_obligations_for_parameters</span>(
            <span class="ident">traits</span>::<span class="ident">ObligationCause</span>::<span class="ident">new</span>(<span class="ident">span</span>, <span class="self">self</span>.<span class="ident">body_id</span>, <span class="ident">traits</span>::<span class="ident">ItemObligation</span>(<span class="ident">def</span>.<span class="ident">def_id</span>())),
            <span class="kw-2">&amp;</span><span class="ident">bounds</span>);

        <span class="comment">// Substitute the values for the type parameters into the type of</span>
        <span class="comment">// the referenced item.</span>
        <span class="kw">let</span> <span class="ident">ty_substituted</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">instantiate_type_scheme</span>(<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="ident">substs</span>, <span class="kw-2">&amp;</span><span class="ident">ty</span>);

        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">ty</span>::<span class="ident">ImplContainer</span>(<span class="ident">impl_def_id</span>), <span class="ident">self_ty</span>)) <span class="op">=</span> <span class="ident">ufcs_associated</span> {
            <span class="comment">// In the case of `Foo&lt;T&gt;::method` and `&lt;Foo&lt;T&gt;&gt;::method`, if `method`</span>
            <span class="comment">// is inherent, there is no `Self` parameter, instead, the impl needs</span>
            <span class="comment">// type parameters, which we can infer by unifying the provided `Self`</span>
            <span class="comment">// with the substituted impl type.</span>
            <span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">type_of</span>(<span class="ident">impl_def_id</span>);

            <span class="kw">let</span> <span class="ident">impl_ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">instantiate_type_scheme</span>(<span class="ident">span</span>, <span class="kw-2">&amp;</span><span class="ident">substs</span>, <span class="kw-2">&amp;</span><span class="ident">ty</span>);
            <span class="kw">match</span> <span class="self">self</span>.<span class="ident">at</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">misc</span>(<span class="ident">span</span>), <span class="self">self</span>.<span class="ident">param_env</span>).<span class="ident">sup</span>(<span class="ident">impl_ty</span>, <span class="ident">self_ty</span>) {
                <span class="prelude-val">Ok</span>(<span class="ident">ok</span>) <span class="op">=&gt;</span> <span class="self">self</span>.<span class="ident">register_infer_ok_obligations</span>(<span class="ident">ok</span>),
                <span class="prelude-val">Err</span>(_) <span class="op">=&gt;</span> {
                    <span class="macro">span_bug</span><span class="macro">!</span>(<span class="ident">span</span>,
                        <span class="string">&quot;instantiate_value_path: (UFCS) {:?} was a subtype of {:?} but now is not?&quot;</span>,
                        <span class="ident">self_ty</span>,
                        <span class="ident">impl_ty</span>);
                }
            }
        }

        <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;instantiate_value_path: type of {:?} is {:?}&quot;</span>,
               <span class="ident">node_id</span>,
               <span class="ident">ty_substituted</span>);
        <span class="self">self</span>.<span class="ident">write_substs</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">hir</span>.<span class="ident">node_to_hir_id</span>(<span class="ident">node_id</span>), <span class="ident">substs</span>);
        <span class="ident">ty_substituted</span>
    }

    <span class="doccomment">/// Report errors if the provided parameters are too few or too many.</span>
    <span class="kw">fn</span> <span class="ident">check_path_parameter_count</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                                  <span class="ident">span</span>: <span class="ident">Span</span>,
                                  <span class="ident">segment</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span>(<span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">PathSegment</span>, <span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">Generics</span>)<span class="op">&gt;</span>,
                                  <span class="ident">is_method_call</span>: <span class="ident">bool</span>) {
        <span class="kw">let</span> (<span class="ident">lifetimes</span>, <span class="ident">types</span>, <span class="ident">infer_types</span>, <span class="ident">bindings</span>) <span class="op">=</span> <span class="ident">segment</span>.<span class="ident">map_or</span>(
            (<span class="kw-2">&amp;</span>[][..], <span class="kw-2">&amp;</span>[][..], <span class="bool-val">true</span>, <span class="kw-2">&amp;</span>[][..]),
            <span class="op">|</span>(<span class="ident">s</span>, _)<span class="op">|</span> <span class="ident">s</span>.<span class="ident">parameters</span>.<span class="ident">as_ref</span>().<span class="ident">map_or</span>(
                (<span class="kw-2">&amp;</span>[][..], <span class="kw-2">&amp;</span>[][..], <span class="ident">s</span>.<span class="ident">infer_types</span>, <span class="kw-2">&amp;</span>[][..]),
                <span class="op">|</span><span class="ident">p</span><span class="op">|</span> (<span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">lifetimes</span>[..], <span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">types</span>[..],
                     <span class="ident">s</span>.<span class="ident">infer_types</span>, <span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">bindings</span>[..])));
        <span class="kw">let</span> <span class="ident">infer_lifetimes</span> <span class="op">=</span> <span class="ident">lifetimes</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">0</span>;

        <span class="kw">let</span> <span class="ident">count_lifetime_params</span> <span class="op">=</span> <span class="op">|</span><span class="ident">n</span><span class="op">|</span> {
            <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{} lifetime parameter{}&quot;</span>, <span class="ident">n</span>, <span class="kw">if</span> <span class="ident">n</span> <span class="op">==</span> <span class="number">1</span> { <span class="string">&quot;&quot;</span> } <span class="kw">else</span> { <span class="string">&quot;s&quot;</span> })
        };
        <span class="kw">let</span> <span class="ident">count_type_params</span> <span class="op">=</span> <span class="op">|</span><span class="ident">n</span><span class="op">|</span> {
            <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{} type parameter{}&quot;</span>, <span class="ident">n</span>, <span class="kw">if</span> <span class="ident">n</span> <span class="op">==</span> <span class="number">1</span> { <span class="string">&quot;&quot;</span> } <span class="kw">else</span> { <span class="string">&quot;s&quot;</span> })
        };

        <span class="comment">// Check provided type parameters.</span>
        <span class="kw">let</span> <span class="ident">type_defs</span> <span class="op">=</span> <span class="ident">segment</span>.<span class="ident">map_or</span>(<span class="kw-2">&amp;</span>[][..], <span class="op">|</span>(_, <span class="ident">generics</span>)<span class="op">|</span> {
            <span class="kw">if</span> <span class="ident">generics</span>.<span class="ident">parent</span>.<span class="ident">is_none</span>() {
                <span class="kw-2">&amp;</span><span class="ident">generics</span>.<span class="ident">types</span>[<span class="ident">generics</span>.<span class="ident">has_self</span> <span class="kw">as</span> <span class="ident">usize</span>..]
            } <span class="kw">else</span> {
                <span class="kw-2">&amp;</span><span class="ident">generics</span>.<span class="ident">types</span>
            }
        });
        <span class="kw">let</span> <span class="ident">required_len</span> <span class="op">=</span> <span class="ident">type_defs</span>.<span class="ident">iter</span>().<span class="ident">take_while</span>(<span class="op">|</span><span class="ident">d</span><span class="op">|</span> <span class="op">!</span><span class="ident">d</span>.<span class="ident">has_default</span>).<span class="ident">count</span>();
        <span class="kw">if</span> <span class="ident">types</span>.<span class="ident">len</span>() <span class="op">&gt;</span> <span class="ident">type_defs</span>.<span class="ident">len</span>() {
            <span class="kw">let</span> <span class="ident">span</span> <span class="op">=</span> <span class="ident">types</span>[<span class="ident">type_defs</span>.<span class="ident">len</span>()].<span class="ident">span</span>;
            <span class="kw">let</span> <span class="ident">expected_text</span> <span class="op">=</span> <span class="ident">count_type_params</span>(<span class="ident">type_defs</span>.<span class="ident">len</span>());
            <span class="kw">let</span> <span class="ident">actual_text</span> <span class="op">=</span> <span class="ident">count_type_params</span>(<span class="ident">types</span>.<span class="ident">len</span>());
            <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">span</span>, <span class="ident">E0087</span>,
                             <span class="string">&quot;too many type parameters provided: \
                              expected at most {}, found {}&quot;</span>,
                             <span class="ident">expected_text</span>, <span class="ident">actual_text</span>)
                .<span class="ident">span_label</span>(<span class="ident">span</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;expected {}&quot;</span>, <span class="ident">expected_text</span>))
                .<span class="ident">emit</span>();

            <span class="comment">// To prevent derived errors to accumulate due to extra</span>
            <span class="comment">// type parameters, we force instantiate_value_path to</span>
            <span class="comment">// use inference variables instead of the provided types.</span>
            <span class="kw-2">*</span><span class="ident">segment</span> <span class="op">=</span> <span class="prelude-val">None</span>;
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">types</span>.<span class="ident">len</span>() <span class="op">&lt;</span> <span class="ident">required_len</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="ident">infer_types</span> {
            <span class="kw">let</span> <span class="ident">expected_text</span> <span class="op">=</span> <span class="ident">count_type_params</span>(<span class="ident">required_len</span>);
            <span class="kw">let</span> <span class="ident">actual_text</span> <span class="op">=</span> <span class="ident">count_type_params</span>(<span class="ident">types</span>.<span class="ident">len</span>());
            <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">span</span>, <span class="ident">E0089</span>,
                             <span class="string">&quot;too few type parameters provided: \
                              expected {}, found {}&quot;</span>,
                             <span class="ident">expected_text</span>, <span class="ident">actual_text</span>)
                .<span class="ident">span_label</span>(<span class="ident">span</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;expected {}&quot;</span>, <span class="ident">expected_text</span>))
                .<span class="ident">emit</span>();
        }

        <span class="kw">if</span> <span class="op">!</span><span class="ident">bindings</span>.<span class="ident">is_empty</span>() {
            <span class="ident">AstConv</span>::<span class="ident">prohibit_projection</span>(<span class="self">self</span>, <span class="ident">bindings</span>[<span class="number">0</span>].<span class="ident">span</span>);
        }

        <span class="comment">// Check provided lifetime parameters.</span>
        <span class="kw">let</span> <span class="ident">lifetime_defs</span> <span class="op">=</span> <span class="ident">segment</span>.<span class="ident">map_or</span>(<span class="kw-2">&amp;</span>[][..], <span class="op">|</span>(_, <span class="ident">generics</span>)<span class="op">|</span> <span class="kw-2">&amp;</span><span class="ident">generics</span>.<span class="ident">regions</span>);
        <span class="kw">let</span> <span class="ident">required_len</span> <span class="op">=</span> <span class="ident">lifetime_defs</span>.<span class="ident">len</span>();

        <span class="comment">// Prohibit explicit lifetime arguments if late bound lifetime parameters are present.</span>
        <span class="kw">let</span> <span class="ident">has_late_bound_lifetime_defs</span> <span class="op">=</span>
            <span class="ident">segment</span>.<span class="ident">map_or</span>(<span class="prelude-val">None</span>, <span class="op">|</span>(_, <span class="ident">generics</span>)<span class="op">|</span> <span class="ident">generics</span>.<span class="ident">has_late_bound_regions</span>);
        <span class="kw">if</span> <span class="kw">let</span> (<span class="prelude-val">Some</span>(<span class="ident">span_late</span>), <span class="bool-val">false</span>) <span class="op">=</span> (<span class="ident">has_late_bound_lifetime_defs</span>, <span class="ident">lifetimes</span>.<span class="ident">is_empty</span>()) {
            <span class="comment">// Report this as a lint only if no error was reported previously.</span>
            <span class="kw">let</span> <span class="ident">primary_msg</span> <span class="op">=</span> <span class="string">&quot;cannot specify lifetime arguments explicitly \
                               if late bound lifetime parameters are present&quot;</span>;
            <span class="kw">let</span> <span class="ident">note_msg</span> <span class="op">=</span> <span class="string">&quot;the late bound lifetime parameter is introduced here&quot;</span>;
            <span class="kw">if</span> <span class="op">!</span><span class="ident">is_method_call</span> <span class="op">&amp;&amp;</span> (<span class="ident">lifetimes</span>.<span class="ident">len</span>() <span class="op">&gt;</span> <span class="ident">lifetime_defs</span>.<span class="ident">len</span>() <span class="op">||</span>
                                   <span class="ident">lifetimes</span>.<span class="ident">len</span>() <span class="op">&lt;</span> <span class="ident">required_len</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="ident">infer_lifetimes</span>) {
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>.<span class="ident">struct_span_err</span>(<span class="ident">lifetimes</span>[<span class="number">0</span>].<span class="ident">span</span>, <span class="ident">primary_msg</span>);
                <span class="ident">err</span>.<span class="ident">span_note</span>(<span class="ident">span_late</span>, <span class="ident">note_msg</span>);
                <span class="ident">err</span>.<span class="ident">emit</span>();
                <span class="kw-2">*</span><span class="ident">segment</span> <span class="op">=</span> <span class="prelude-val">None</span>;
            } <span class="kw">else</span> {
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">multispan</span> <span class="op">=</span> <span class="ident">MultiSpan</span>::<span class="ident">from_span</span>(<span class="ident">lifetimes</span>[<span class="number">0</span>].<span class="ident">span</span>);
                <span class="ident">multispan</span>.<span class="ident">push_span_label</span>(<span class="ident">span_late</span>, <span class="ident">note_msg</span>.<span class="ident">to_string</span>());
                <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">lint_node</span>(<span class="ident">lint</span>::<span class="ident">builtin</span>::<span class="ident">LATE_BOUND_LIFETIME_ARGUMENTS</span>,
                                   <span class="ident">lifetimes</span>[<span class="number">0</span>].<span class="ident">id</span>, <span class="ident">multispan</span>, <span class="ident">primary_msg</span>);
            }
            <span class="kw">return</span>;
        }

        <span class="kw">if</span> <span class="ident">lifetimes</span>.<span class="ident">len</span>() <span class="op">&gt;</span> <span class="ident">lifetime_defs</span>.<span class="ident">len</span>() {
            <span class="kw">let</span> <span class="ident">span</span> <span class="op">=</span> <span class="ident">lifetimes</span>[<span class="ident">lifetime_defs</span>.<span class="ident">len</span>()].<span class="ident">span</span>;
            <span class="kw">let</span> <span class="ident">expected_text</span> <span class="op">=</span> <span class="ident">count_lifetime_params</span>(<span class="ident">lifetime_defs</span>.<span class="ident">len</span>());
            <span class="kw">let</span> <span class="ident">actual_text</span> <span class="op">=</span> <span class="ident">count_lifetime_params</span>(<span class="ident">lifetimes</span>.<span class="ident">len</span>());
            <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">span</span>, <span class="ident">E0088</span>,
                             <span class="string">&quot;too many lifetime parameters provided: \
                              expected at most {}, found {}&quot;</span>,
                             <span class="ident">expected_text</span>, <span class="ident">actual_text</span>)
                .<span class="ident">span_label</span>(<span class="ident">span</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;expected {}&quot;</span>, <span class="ident">expected_text</span>))
                .<span class="ident">emit</span>();
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">lifetimes</span>.<span class="ident">len</span>() <span class="op">&lt;</span> <span class="ident">required_len</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="ident">infer_lifetimes</span> {
            <span class="kw">let</span> <span class="ident">expected_text</span> <span class="op">=</span> <span class="ident">count_lifetime_params</span>(<span class="ident">lifetime_defs</span>.<span class="ident">len</span>());
            <span class="kw">let</span> <span class="ident">actual_text</span> <span class="op">=</span> <span class="ident">count_lifetime_params</span>(<span class="ident">lifetimes</span>.<span class="ident">len</span>());
            <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">span</span>, <span class="ident">E0090</span>,
                             <span class="string">&quot;too few lifetime parameters provided: \
                              expected {}, found {}&quot;</span>,
                             <span class="ident">expected_text</span>, <span class="ident">actual_text</span>)
                .<span class="ident">span_label</span>(<span class="ident">span</span>, <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;expected {}&quot;</span>, <span class="ident">expected_text</span>))
                .<span class="ident">emit</span>();
        }
    }

    <span class="doccomment">/// Report error if there is an explicit type parameter when using `impl Trait`.</span>
    <span class="kw">fn</span> <span class="ident">check_impl_trait</span>(<span class="kw-2">&amp;</span><span class="self">self</span>,
                        <span class="ident">span</span>: <span class="ident">Span</span>,
                        <span class="ident">segment</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span>(<span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">PathSegment</span>, <span class="kw-2">&amp;</span><span class="ident">ty</span>::<span class="ident">Generics</span>)<span class="op">&gt;</span>) {
        <span class="kw">use</span> <span class="ident">hir</span>::<span class="ident">SyntheticTyParamKind</span>::<span class="kw-2">*</span>;

        <span class="ident">segment</span>.<span class="ident">map</span>(<span class="op">|</span>(<span class="ident">path_segment</span>, <span class="ident">generics</span>)<span class="op">|</span> {
            <span class="kw">let</span> <span class="ident">explicit</span> <span class="op">=</span> <span class="op">!</span><span class="ident">path_segment</span>.<span class="ident">infer_types</span>;
            <span class="kw">let</span> <span class="ident">impl_trait</span> <span class="op">=</span> <span class="ident">generics</span>.<span class="ident">types</span>.<span class="ident">iter</span>()
                                           .<span class="ident">any</span>(<span class="op">|</span><span class="ident">ty_param</span><span class="op">|</span> {
                                               <span class="kw">match</span> <span class="ident">ty_param</span>.<span class="ident">synthetic</span> {
                                                   <span class="prelude-val">Some</span>(<span class="ident">ImplTrait</span>) <span class="op">=&gt;</span> <span class="bool-val">true</span>,
                                                   _ <span class="op">=&gt;</span> <span class="bool-val">false</span>,
                                               }
                                           });

            <span class="kw">if</span> <span class="ident">explicit</span> <span class="op">&amp;&amp;</span> <span class="ident">impl_trait</span> {
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">err</span> <span class="op">=</span> <span class="macro">struct_span_err</span><span class="macro">!</span> {
                    <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>,
                    <span class="ident">span</span>,
                    <span class="ident">E0632</span>,
                    <span class="string">&quot;cannot provide explicit type parameters when `impl Trait` is \
                    used in argument position.&quot;</span>
                };

                <span class="ident">err</span>.<span class="ident">emit</span>();
            }
        });
    }

    <span class="kw">fn</span> <span class="ident">structurally_resolve_type_or_else</span><span class="op">&lt;</span><span class="ident">F</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">sp</span>: <span class="ident">Span</span>, <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">f</span>: <span class="ident">F</span>)
                                            <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
        <span class="kw">where</span> <span class="ident">F</span>: <span class="ident">Fn</span>() <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>
    {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">resolve_type_vars_with_obligations</span>(<span class="ident">ty</span>);

        <span class="kw">if</span> <span class="ident">ty</span>.<span class="ident">is_ty_var</span>() {
            <span class="kw">let</span> <span class="ident">alternative</span> <span class="op">=</span> <span class="ident">f</span>();

            <span class="comment">// If not, error.</span>
            <span class="kw">if</span> <span class="ident">alternative</span>.<span class="ident">is_ty_var</span>() <span class="op">||</span> <span class="ident">alternative</span>.<span class="ident">references_error</span>() {
                <span class="kw">if</span> <span class="op">!</span><span class="self">self</span>.<span class="ident">is_tainted_by_errors</span>() {
                    <span class="macro">type_error_struct</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">sp</span>, <span class="ident">ty</span>, <span class="ident">E0619</span>,
                                       <span class="string">&quot;the type of this value must be known in this context&quot;</span>)
                        .<span class="ident">emit</span>();
                }
                <span class="self">self</span>.<span class="ident">demand_suptype</span>(<span class="ident">sp</span>, <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>, <span class="ident">ty</span>);
                <span class="ident">ty</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>;
            } <span class="kw">else</span> {
                <span class="self">self</span>.<span class="ident">demand_suptype</span>(<span class="ident">sp</span>, <span class="ident">alternative</span>, <span class="ident">ty</span>);
                <span class="ident">ty</span> <span class="op">=</span> <span class="ident">alternative</span>;
            }
        }

        <span class="ident">ty</span>
    }

    <span class="comment">// Resolves `typ` by a single level if `typ` is a type variable.  If no</span>
    <span class="comment">// resolution is possible, then an error is reported.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">structurally_resolved_type</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">sp</span>: <span class="ident">Span</span>, <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">structurally_resolve_type_or_else</span>(<span class="ident">sp</span>, <span class="ident">ty</span>, <span class="op">||</span> {
            <span class="self">self</span>.<span class="ident">tcx</span>.<span class="ident">types</span>.<span class="ident">err</span>
        })
    }

    <span class="kw">fn</span> <span class="ident">with_breakable_ctxt</span><span class="op">&lt;</span><span class="ident">F</span>: <span class="ident">FnOnce</span>() <span class="op">-&gt;</span> <span class="ident">R</span>, <span class="ident">R</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">id</span>: <span class="ident">ast</span>::<span class="ident">NodeId</span>,
                                        <span class="ident">ctxt</span>: <span class="ident">BreakableCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">f</span>: <span class="ident">F</span>)
                                   <span class="op">-&gt;</span> (<span class="ident">BreakableCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;gcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>, <span class="ident">R</span>) {
        <span class="kw">let</span> <span class="ident">index</span>;
        {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">enclosing_breakables</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">enclosing_breakables</span>.<span class="ident">borrow_mut</span>();
            <span class="ident">index</span> <span class="op">=</span> <span class="ident">enclosing_breakables</span>.<span class="ident">stack</span>.<span class="ident">len</span>();
            <span class="ident">enclosing_breakables</span>.<span class="ident">by_id</span>.<span class="ident">insert</span>(<span class="ident">id</span>, <span class="ident">index</span>);
            <span class="ident">enclosing_breakables</span>.<span class="ident">stack</span>.<span class="ident">push</span>(<span class="ident">ctxt</span>);
        }
        <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">f</span>();
        <span class="kw">let</span> <span class="ident">ctxt</span> <span class="op">=</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">enclosing_breakables</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">enclosing_breakables</span>.<span class="ident">borrow_mut</span>();
            <span class="macro">debug_assert</span><span class="macro">!</span>(<span class="ident">enclosing_breakables</span>.<span class="ident">stack</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="ident">index</span> <span class="op">+</span> <span class="number">1</span>);
            <span class="ident">enclosing_breakables</span>.<span class="ident">by_id</span>.<span class="ident">remove</span>(<span class="kw-2">&amp;</span><span class="ident">id</span>).<span class="ident">expect</span>(<span class="string">&quot;missing breakable context&quot;</span>);
            <span class="ident">enclosing_breakables</span>.<span class="ident">stack</span>.<span class="ident">pop</span>().<span class="ident">expect</span>(<span class="string">&quot;missing breakable context&quot;</span>)
        };
        (<span class="ident">ctxt</span>, <span class="ident">result</span>)
    }
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">check_bounds_are_used</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>(<span class="ident">tcx</span>: <span class="ident">TyCtxt</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;tcx</span>, <span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>,
                                       <span class="ident">generics</span>: <span class="kw-2">&amp;</span><span class="ident">hir</span>::<span class="ident">Generics</span>,
                                       <span class="ident">ty</span>: <span class="ident">Ty</span><span class="op">&lt;</span><span class="lifetime">&#39;tcx</span><span class="op">&gt;</span>) {
    <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;check_bounds_are_used(n_tps={}, ty={:?})&quot;</span>,
           <span class="ident">generics</span>.<span class="ident">ty_params</span>.<span class="ident">len</span>(),  <span class="ident">ty</span>);

    <span class="comment">// make a vector of booleans initially false, set to true when used</span>
    <span class="kw">if</span> <span class="ident">generics</span>.<span class="ident">ty_params</span>.<span class="ident">is_empty</span>() { <span class="kw">return</span>; }
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">tps_used</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="bool-val">false</span>; <span class="ident">generics</span>.<span class="ident">ty_params</span>.<span class="ident">len</span>()];

    <span class="kw">for</span> <span class="ident">leaf_ty</span> <span class="kw">in</span> <span class="ident">ty</span>.<span class="ident">walk</span>() {
        <span class="kw">if</span> <span class="kw">let</span> <span class="ident">ty</span>::<span class="ident">TyParam</span>(<span class="ident">ParamTy</span> {<span class="ident">idx</span>, ..}) <span class="op">=</span> <span class="ident">leaf_ty</span>.<span class="ident">sty</span> {
            <span class="macro">debug</span><span class="macro">!</span>(<span class="string">&quot;Found use of ty param num {}&quot;</span>, <span class="ident">idx</span>);
            <span class="ident">tps_used</span>[<span class="ident">idx</span> <span class="kw">as</span> <span class="ident">usize</span> <span class="op">-</span> <span class="ident">generics</span>.<span class="ident">lifetimes</span>.<span class="ident">len</span>()] <span class="op">=</span> <span class="bool-val">true</span>;
        }
    }

    <span class="kw">for</span> (<span class="kw-2">&amp;</span><span class="ident">used</span>, <span class="ident">param</span>) <span class="kw">in</span> <span class="ident">tps_used</span>.<span class="ident">iter</span>().<span class="ident">zip</span>(<span class="kw-2">&amp;</span><span class="ident">generics</span>.<span class="ident">ty_params</span>) {
        <span class="kw">if</span> <span class="op">!</span><span class="ident">used</span> {
            <span class="macro">struct_span_err</span><span class="macro">!</span>(<span class="ident">tcx</span>.<span class="ident">sess</span>, <span class="ident">param</span>.<span class="ident">span</span>, <span class="ident">E0091</span>,
                <span class="string">&quot;type parameter `{}` is unused&quot;</span>,
                <span class="ident">param</span>.<span class="ident">name</span>)
                .<span class="ident">span_label</span>(<span class="ident">param</span>.<span class="ident">span</span>, <span class="string">&quot;unused type parameter&quot;</span>)
                .<span class="ident">emit</span>();
        }
    }
}

<span class="kw">fn</span> <span class="ident">fatally_break_rust</span>(<span class="ident">sess</span>: <span class="kw-2">&amp;</span><span class="ident">Session</span>) {
    <span class="kw">let</span> <span class="ident">handler</span> <span class="op">=</span> <span class="ident">sess</span>.<span class="ident">diagnostic</span>();
    <span class="ident">handler</span>.<span class="ident">span_bug_no_panic</span>(
        <span class="ident">MultiSpan</span>::<span class="ident">new</span>(),
        <span class="string">&quot;It looks like you&#39;re trying to break rust; would you like some ICE?&quot;</span>,
    );
    <span class="ident">handler</span>.<span class="ident">note_without_error</span>(<span class="string">&quot;the compiler expectedly panicked. this is a feature.&quot;</span>);
    <span class="ident">handler</span>.<span class="ident">note_without_error</span>(
        <span class="string">&quot;we would appreciate a joke overview: \
        https://github.com/rust-lang/rust/issues/43162#issuecomment-320764675&quot;</span>
    );
    <span class="ident">handler</span>.<span class="ident">note_without_error</span>(<span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;rustc {} running on {}&quot;</span>,
        <span class="macro">option_env</span><span class="macro">!</span>(<span class="string">&quot;CFG_VERSION&quot;</span>).<span class="ident">unwrap_or</span>(<span class="string">&quot;unknown_version&quot;</span>),
        ::<span class="ident">session</span>::<span class="ident">config</span>::<span class="ident">host_triple</span>(),
    ));
}
</pre>
</section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>↑</dt>
                    <dd>Move up in search results</dd>
                    <dt>↓</dt>
                    <dd>Move down in search results</dd>
                    <dt>↹</dt>
                    <dd>Switch tab</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../../";
        window.currentCrate = "rustc_typeck";
    </script>
    <script src="../../../main.js"></script>
    <script defer src="../../../search-index.js"></script>
</body>
</html>