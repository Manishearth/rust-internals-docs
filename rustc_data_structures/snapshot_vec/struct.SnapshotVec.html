<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `SnapshotVec` struct in crate `rustc_data_structures`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, SnapshotVec">

    <title>rustc_data_structures::snapshot_vec::SnapshotVec - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    <link rel="shortcut icon" href="https://www.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../../rustc_data_structures/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='logo' width='100'></a>
        <p class='location'><a href='../index.html'>rustc_data_structures</a>::<wbr><a href='index.html'>snapshot_vec</a></p><script>window.sidebarCurrent = {name: 'SnapshotVec', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>rustc_data_structures</a>::<wbr><a href='index.html'>snapshot_vec</a>::<wbr><a class='struct' href=''>SnapshotVec</a></span><span class='out-of-band'><span class='since' title='Stable since Rust version '></span><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-1225' class='srclink' href='../../src/rustc_data_structures/src/librustc_data_structures/snapshot_vec.rs.html#43-46' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct SnapshotVec&lt;D:&nbsp;<a class='trait' href='../../rustc_data_structures/snapshot_vec/trait.SnapshotVecDelegate.html' title='rustc_data_structures::snapshot_vec::SnapshotVecDelegate'>SnapshotVecDelegate</a>&gt; {
    // some fields omitted
}</pre><div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl&lt;D:&nbsp;<a class='trait' href='../../rustc_data_structures/snapshot_vec/trait.SnapshotVecDelegate.html' title='rustc_data_structures::snapshot_vec::SnapshotVecDelegate'>SnapshotVecDelegate</a>&gt; <a class='struct' href='../../rustc_data_structures/snapshot_vec/struct.SnapshotVec.html' title='rustc_data_structures::snapshot_vec::SnapshotVec'>SnapshotVec</a>&lt;D&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a id='src-1237' class='srclink' href='../../src/rustc_data_structures/src/librustc_data_structures/snapshot_vec.rs.html#61-189' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new' class='method'><span id='new.v' class='invisible'><code>fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class='struct' href='../../rustc_data_structures/snapshot_vec/struct.SnapshotVec.html' title='rustc_data_structures::snapshot_vec::SnapshotVec'>SnapshotVec</a>&lt;D&gt;</code></span></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><h4 id='method.record' class='method'><span id='record.v' class='invisible'><code>fn <a href='#method.record' class='fnname'>record</a>(&amp;mut self, action: D::Undo)</code></span></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><h4 id='method.len' class='method'><span id='len.v' class='invisible'><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.usize.html'>usize</a></code></span></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><h4 id='method.push' class='method'><span id='push.v' class='invisible'><code>fn <a href='#method.push' class='fnname'>push</a>(&amp;mut self, elem: D::Value) -&gt; <a class='primitive' href='../../std/primitive.usize.html'>usize</a></code></span></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><h4 id='method.get' class='method'><span id='get.v' class='invisible'><code>fn <a href='#method.get' class='fnname'>get</a>(&amp;self, index: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; &amp;D::Value</code></span></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><h4 id='method.get_mut' class='method'><span id='get_mut.v' class='invisible'><code>fn <a href='#method.get_mut' class='fnname'>get_mut</a>(&amp;mut self, index: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; &amp;mut D::Value</code></span></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><div class='docblock'><p>Returns a mutable pointer into the vec; whatever changes you make here cannot be undone
automatically, so you should be sure call <code>record()</code> with some sort of suitable undo
action.</p>
</div><h4 id='method.set' class='method'><span id='set.v' class='invisible'><code>fn <a href='#method.set' class='fnname'>set</a>(&amp;mut self, index: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>, new_elem: D::Value)</code></span></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><div class='docblock'><p>Updates the element at the given index. The old value will saved (and perhaps restored) if
a snapshot is active.</p>
</div><h4 id='method.start_snapshot' class='method'><span id='start_snapshot.v' class='invisible'><code>fn <a href='#method.start_snapshot' class='fnname'>start_snapshot</a>(&amp;mut self) -&gt; <a class='struct' href='../../rustc_data_structures/snapshot_vec/struct.Snapshot.html' title='rustc_data_structures::snapshot_vec::Snapshot'>Snapshot</a></code></span></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><h4 id='method.actions_since_snapshot' class='method'><span id='actions_since_snapshot.v' class='invisible'><code>fn <a href='#method.actions_since_snapshot' class='fnname'>actions_since_snapshot</a>(&amp;self, snapshot: &amp;<a class='struct' href='../../rustc_data_structures/snapshot_vec/struct.Snapshot.html' title='rustc_data_structures::snapshot_vec::Snapshot'>Snapshot</a>) -&gt; <a class='primitive' href='../../std/primitive.slice.html'>&amp;[</a><a class='enum' href='../../rustc_data_structures/snapshot_vec/enum.UndoLog.html' title='rustc_data_structures::snapshot_vec::UndoLog'>UndoLog</a>&lt;D&gt;<a class='primitive' href='../../std/primitive.slice.html'>]</a></code></span></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><h4 id='method.rollback_to' class='method'><span id='rollback_to.v' class='invisible'><code>fn <a href='#method.rollback_to' class='fnname'>rollback_to</a>(&amp;mut self, snapshot: <a class='struct' href='../../rustc_data_structures/snapshot_vec/struct.Snapshot.html' title='rustc_data_structures::snapshot_vec::Snapshot'>Snapshot</a>)</code></span></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><h4 id='method.commit' class='method'><span id='commit.v' class='invisible'><code>fn <a href='#method.commit' class='fnname'>commit</a>(&amp;mut self, snapshot: <a class='struct' href='../../rustc_data_structures/snapshot_vec/struct.Snapshot.html' title='rustc_data_structures::snapshot_vec::Snapshot'>Snapshot</a>)</code></span></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><div class='docblock'><p>Commits all changes since the last snapshot. Of course, they
can still be undone if there is a snapshot further out.</p>
</div></div><h2 id='deref-methods'>Methods from <a class='trait' href='../../core/ops/trait.Deref.html' title='core::ops::Deref'>Deref</a>&lt;Target=<a class='primitive' href='../../std/primitive.slice.html'>[</a>D::Value<a class='primitive' href='../../std/primitive.slice.html'>]</a>&gt;</h2><div class='impl-items'><h4 id='method.len-1' class='method'><span id='len.v-1' class='invisible'><code>fn <a href='#method.len-1' class='fnname'>len</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.usize.html'>usize</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns the number of elements in the slice.</p>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>len</span>(), <span class='number'>3</span>);</pre>
</div><h4 id='method.is_empty' class='method'><span id='is_empty.v' class='invisible'><code>fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns true if the slice has a length of 0</p>

<h1 id='example-1' class='section-header'><a href='#example-1'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>a</span>.<span class='ident'>is_empty</span>());</pre>
</div><h4 id='method.first' class='method'><span id='first.v' class='invisible'><code>fn <a href='#method.first' class='fnname'>first</a>(&amp;self) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns the first element of a slice, or <code>None</code> if it is empty.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>10</span>), <span class='ident'>v</span>.<span class='ident'>first</span>());

<span class='kw'>let</span> <span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>i32</span>] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='prelude-val'>None</span>, <span class='ident'>w</span>.<span class='ident'>first</span>());</pre>
</div><h4 id='method.first_mut' class='method'><span id='first_mut.v' class='invisible'><code>fn <a href='#method.first_mut' class='fnname'>first_mut</a>(&amp;mut self) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;mut T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns a mutable pointer to the first element of a slice, or <code>None</code> if it is empty.</p>

<h1 id='examples-1' class='section-header'><a href='#examples-1'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>];

<span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>first</span>) <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>first_mut</span>() {
    <span class='op'>*</span><span class='ident'>first</span> <span class='op'>=</span> <span class='number'>5</span>;
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='kw-2'>&amp;</span>[<span class='number'>5</span>, <span class='number'>1</span>, <span class='number'>2</span>]);</pre>
</div><h4 id='method.split_first' class='method'><span id='split_first.v' class='invisible'><code>fn <a href='#method.split_first' class='fnname'>split_first</a>(&amp;self) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='../../std/primitive.tuple.html'>(</a>&amp;T, <a class='primitive' href='../../std/primitive.slice.html'>&amp;[T]</a><a class='primitive' href='../../std/primitive.tuple.html'>)</a>&gt;</code><div class='since' title='Stable since Rust version 1.5.0'>1.5.0</div></span></h4>
<div class='docblock'><p>Returns the first and all the rest of the elements of a slice.</p>

<h1 id='examples-2' class='section-header'><a href='#examples-2'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>];

<span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>((<span class='ident'>first</span>, <span class='ident'>elements</span>)) <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>split_first</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>first</span>, <span class='kw-2'>&amp;</span><span class='number'>0</span>);
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>elements</span>, <span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>2</span>]);
}</pre>
</div><h4 id='method.split_first_mut' class='method'><span id='split_first_mut.v' class='invisible'><code>fn <a href='#method.split_first_mut' class='fnname'>split_first_mut</a>(&amp;mut self) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='../../std/primitive.tuple.html'>(</a>&amp;mut T, <a class='primitive' href='../../std/primitive.slice.html'>&amp;mut [T]</a><a class='primitive' href='../../std/primitive.tuple.html'>)</a>&gt;</code><div class='since' title='Stable since Rust version 1.5.0'>1.5.0</div></span></h4>
<div class='docblock'><p>Returns the first and all the rest of the elements of a slice.</p>

<h1 id='examples-3' class='section-header'><a href='#examples-3'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>];

<span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>((<span class='ident'>first</span>, <span class='ident'>elements</span>)) <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>split_first_mut</span>() {
    <span class='op'>*</span><span class='ident'>first</span> <span class='op'>=</span> <span class='number'>3</span>;
    <span class='ident'>elements</span>[<span class='number'>0</span>] <span class='op'>=</span> <span class='number'>4</span>;
    <span class='ident'>elements</span>[<span class='number'>1</span>] <span class='op'>=</span> <span class='number'>5</span>;
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='kw-2'>&amp;</span>[<span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>]);</pre>
</div><h4 id='method.split_last' class='method'><span id='split_last.v' class='invisible'><code>fn <a href='#method.split_last' class='fnname'>split_last</a>(&amp;self) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='../../std/primitive.tuple.html'>(</a>&amp;T, <a class='primitive' href='../../std/primitive.slice.html'>&amp;[T]</a><a class='primitive' href='../../std/primitive.tuple.html'>)</a>&gt;</code><div class='since' title='Stable since Rust version 1.5.0'>1.5.0</div></span></h4>
<div class='docblock'><p>Returns the last and all the rest of the elements of a slice.</p>

<h1 id='examples-4' class='section-header'><a href='#examples-4'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>];

<span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>((<span class='ident'>last</span>, <span class='ident'>elements</span>)) <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>split_last</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>last</span>, <span class='kw-2'>&amp;</span><span class='number'>2</span>);
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>elements</span>, <span class='kw-2'>&amp;</span>[<span class='number'>0</span>, <span class='number'>1</span>]);
}</pre>
</div><h4 id='method.split_last_mut' class='method'><span id='split_last_mut.v' class='invisible'><code>fn <a href='#method.split_last_mut' class='fnname'>split_last_mut</a>(&amp;mut self) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='../../std/primitive.tuple.html'>(</a>&amp;mut T, <a class='primitive' href='../../std/primitive.slice.html'>&amp;mut [T]</a><a class='primitive' href='../../std/primitive.tuple.html'>)</a>&gt;</code><div class='since' title='Stable since Rust version 1.5.0'>1.5.0</div></span></h4>
<div class='docblock'><p>Returns the last and all the rest of the elements of a slice.</p>

<h1 id='examples-5' class='section-header'><a href='#examples-5'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>];

<span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>((<span class='ident'>last</span>, <span class='ident'>elements</span>)) <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>split_last_mut</span>() {
    <span class='op'>*</span><span class='ident'>last</span> <span class='op'>=</span> <span class='number'>3</span>;
    <span class='ident'>elements</span>[<span class='number'>0</span>] <span class='op'>=</span> <span class='number'>4</span>;
    <span class='ident'>elements</span>[<span class='number'>1</span>] <span class='op'>=</span> <span class='number'>5</span>;
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='kw-2'>&amp;</span>[<span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>3</span>]);</pre>
</div><h4 id='method.last' class='method'><span id='last.v' class='invisible'><code>fn <a href='#method.last' class='fnname'>last</a>(&amp;self) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns the last element of a slice, or <code>None</code> if it is empty.</p>

<h1 id='examples-6' class='section-header'><a href='#examples-6'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>30</span>), <span class='ident'>v</span>.<span class='ident'>last</span>());

<span class='kw'>let</span> <span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>i32</span>] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='prelude-val'>None</span>, <span class='ident'>w</span>.<span class='ident'>last</span>());</pre>
</div><h4 id='method.last_mut' class='method'><span id='last_mut.v' class='invisible'><code>fn <a href='#method.last_mut' class='fnname'>last_mut</a>(&amp;mut self) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;mut T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns a mutable pointer to the last item in the slice.</p>

<h1 id='examples-7' class='section-header'><a href='#examples-7'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>];

<span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>last</span>) <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>last_mut</span>() {
    <span class='op'>*</span><span class='ident'>last</span> <span class='op'>=</span> <span class='number'>10</span>;
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='kw-2'>&amp;</span>[<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>10</span>]);</pre>
</div><h4 id='method.get-1' class='method'><span id='get.v-1' class='invisible'><code>fn <a href='#method.get-1' class='fnname'>get</a>(&amp;self, index: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns the element of a slice at the given index, or <code>None</code> if the
index is out of bounds.</p>

<h1 id='examples-8' class='section-header'><a href='#examples-8'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>40</span>), <span class='ident'>v</span>.<span class='ident'>get</span>(<span class='number'>1</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='prelude-val'>None</span>, <span class='ident'>v</span>.<span class='ident'>get</span>(<span class='number'>3</span>));</pre>
</div><h4 id='method.get_mut-1' class='method'><span id='get_mut.v-1' class='invisible'><code>fn <a href='#method.get_mut-1' class='fnname'>get_mut</a>(&amp;mut self, index: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;mut T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns a mutable reference to the element at the given index.</p>

<h1 id='examples-9' class='section-header'><a href='#examples-9'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>];

<span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>elem</span>) <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>get_mut</span>(<span class='number'>1</span>) {
    <span class='op'>*</span><span class='ident'>elem</span> <span class='op'>=</span> <span class='number'>42</span>;
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='kw-2'>&amp;</span>[<span class='number'>0</span>, <span class='number'>42</span>, <span class='number'>2</span>]);</pre>

<p>or <code>None</code> if the index is out of bounds</p>
</div><h4 id='method.get_unchecked' class='method'><span id='get_unchecked.v' class='invisible'><code>unsafe fn <a href='#method.get_unchecked' class='fnname'>get_unchecked</a>(&amp;self, index: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; &amp;T</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns a pointer to the element at the given index, without doing
bounds checking. So use it very carefully!</p>

<h1 id='examples-10' class='section-header'><a href='#examples-10'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>4</span>];

<span class='kw'>unsafe</span> {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>.<span class='ident'>get_unchecked</span>(<span class='number'>1</span>), <span class='kw-2'>&amp;</span><span class='number'>2</span>);
}</pre>
</div><h4 id='method.get_unchecked_mut' class='method'><span id='get_unchecked_mut.v' class='invisible'><code>unsafe fn <a href='#method.get_unchecked_mut' class='fnname'>get_unchecked_mut</a>(&amp;mut self, index: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; &amp;mut T</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an unsafe mutable pointer to the element in index. So use it
very carefully!</p>

<h1 id='examples-11' class='section-header'><a href='#examples-11'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>4</span>];

<span class='kw'>unsafe</span> {
    <span class='kw'>let</span> <span class='ident'>elem</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>get_unchecked_mut</span>(<span class='number'>1</span>);
    <span class='op'>*</span><span class='ident'>elem</span> <span class='op'>=</span> <span class='number'>13</span>;
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>13</span>, <span class='number'>4</span>]);</pre>
</div><h4 id='method.as_ptr' class='method'><span id='as_ptr.v' class='invisible'><code>fn <a href='#method.as_ptr' class='fnname'>as_ptr</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.pointer.html'>*const T</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an raw pointer to the slice&#39;s buffer</p>

<p>The caller must ensure that the slice outlives the pointer this
function returns, or else it will end up pointing to garbage.</p>

<p>Modifying the slice may cause its buffer to be reallocated, which
would also make any pointers to it invalid.</p>

<h1 id='examples-12' class='section-header'><a href='#examples-12'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>4</span>];
<span class='kw'>let</span> <span class='ident'>x_ptr</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>as_ptr</span>();

<span class='kw'>unsafe</span> {
    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='ident'>x</span>.<span class='ident'>len</span>() {
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>.<span class='ident'>get_unchecked</span>(<span class='ident'>i</span>), <span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>x_ptr</span>.<span class='ident'>offset</span>(<span class='ident'>i</span> <span class='kw'>as</span> <span class='ident'>isize</span>));
    }
}</pre>
</div><h4 id='method.as_mut_ptr' class='method'><span id='as_mut_ptr.v' class='invisible'><code>fn <a href='#method.as_mut_ptr' class='fnname'>as_mut_ptr</a>(&amp;mut self) -&gt; <a class='primitive' href='../../std/primitive.pointer.html'>*mut T</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an unsafe mutable pointer to the slice&#39;s buffer.</p>

<p>The caller must ensure that the slice outlives the pointer this
function returns, or else it will end up pointing to garbage.</p>

<p>Modifying the slice may cause its buffer to be reallocated, which
would also make any pointers to it invalid.</p>

<h1 id='examples-13' class='section-header'><a href='#examples-13'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>4</span>];
<span class='kw'>let</span> <span class='ident'>x_ptr</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>as_mut_ptr</span>();

<span class='kw'>unsafe</span> {
    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='ident'>x</span>.<span class='ident'>len</span>() {
        <span class='op'>*</span><span class='ident'>x_ptr</span>.<span class='ident'>offset</span>(<span class='ident'>i</span> <span class='kw'>as</span> <span class='ident'>isize</span>) <span class='op'>+=</span> <span class='number'>2</span>;
    }
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='kw-2'>&amp;</span>[<span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>6</span>]);</pre>
</div><h4 id='method.swap' class='method'><span id='swap.v' class='invisible'><code>fn <a href='#method.swap' class='fnname'>swap</a>(&amp;mut self, a: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>, b: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>)</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Swaps two elements in a slice.</p>

<h1 id='arguments' class='section-header'><a href='#arguments'>Arguments</a></h1>
<ul>
<li>a - The index of the first element</li>
<li>b - The index of the second element</li>
</ul>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>Panics if <code>a</code> or <code>b</code> are out of bounds.</p>

<h1 id='examples-14' class='section-header'><a href='#examples-14'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='string'>&quot;a&quot;</span>, <span class='string'>&quot;b&quot;</span>, <span class='string'>&quot;c&quot;</span>, <span class='string'>&quot;d&quot;</span>];
<span class='ident'>v</span>.<span class='ident'>swap</span>(<span class='number'>1</span>, <span class='number'>3</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span> <span class='op'>==</span> [<span class='string'>&quot;a&quot;</span>, <span class='string'>&quot;d&quot;</span>, <span class='string'>&quot;c&quot;</span>, <span class='string'>&quot;b&quot;</span>]);</pre>
</div><h4 id='method.reverse' class='method'><span id='reverse.v' class='invisible'><code>fn <a href='#method.reverse' class='fnname'>reverse</a>(&amp;mut self)</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Reverse the order of elements in a slice, in place.</p>

<h1 id='example-2' class='section-header'><a href='#example-2'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='ident'>v</span>.<span class='ident'>reverse</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span> <span class='op'>==</span> [<span class='number'>3</span>, <span class='number'>2</span>, <span class='number'>1</span>]);</pre>
</div><h4 id='method.iter' class='method'><span id='iter.v' class='invisible'><code>fn <a href='#method.iter' class='fnname'>iter</a>(&amp;self) -&gt; <a class='struct' href='../../rustc_data_structures/control_flow_graph/struct.Iter.html' title='rustc_data_structures::control_flow_graph::Iter'>Iter</a>&lt;T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over the slice.</p>

<h1 id='examples-15' class='section-header'><a href='#examples-15'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>4</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>iterator</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>iter</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iterator</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>1</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iterator</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>2</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iterator</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>4</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iterator</span>.<span class='ident'>next</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h4 id='method.iter_mut' class='method'><span id='iter_mut.v' class='invisible'><code>fn <a href='#method.iter_mut' class='fnname'>iter_mut</a>(&amp;mut self) -&gt; <a class='struct' href='../../core/slice/struct.IterMut.html' title='core::slice::IterMut'>IterMut</a>&lt;T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator that allows modifying each value.</p>

<h1 id='examples-16' class='section-header'><a href='#examples-16'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>4</span>];
{
    <span class='kw'>let</span> <span class='ident'>iterator</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>iter_mut</span>();

    <span class='kw'>for</span> <span class='ident'>elem</span> <span class='kw'>in</span> <span class='ident'>iterator</span> {
        <span class='op'>*</span><span class='ident'>elem</span> <span class='op'>+=</span> <span class='number'>2</span>;
    }
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='kw-2'>&amp;</span>[<span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>6</span>]);</pre>
</div><h4 id='method.windows' class='method'><span id='windows.v' class='invisible'><code>fn <a href='#method.windows' class='fnname'>windows</a>(&amp;self, size: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; <a class='struct' href='../../core/slice/struct.Windows.html' title='core::slice::Windows'>Windows</a>&lt;T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over all contiguous windows of length
<code>size</code>. The windows overlap. If the slice is shorter than
<code>size</code>, the iterator returns no values.</p>

<h1 id='panics-1' class='section-header'><a href='#panics-1'>Panics</a></h1>
<p>Panics if <code>size</code> is 0.</p>

<h1 id='example-3' class='section-header'><a href='#example-3'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>slice</span> <span class='op'>=</span> [<span class='string'>&#39;r&#39;</span>, <span class='string'>&#39;u&#39;</span>, <span class='string'>&#39;s&#39;</span>, <span class='string'>&#39;t&#39;</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>iter</span> <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>windows</span>(<span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[<span class='string'>&#39;r&#39;</span>, <span class='string'>&#39;u&#39;</span>]);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[<span class='string'>&#39;u&#39;</span>, <span class='string'>&#39;s&#39;</span>]);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[<span class='string'>&#39;s&#39;</span>, <span class='string'>&#39;t&#39;</span>]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());</pre>

<p>If the slice is shorter than <code>size</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>slice</span> <span class='op'>=</span> [<span class='string'>&#39;f&#39;</span>, <span class='string'>&#39;o&#39;</span>, <span class='string'>&#39;o&#39;</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>iter</span> <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>windows</span>(<span class='number'>4</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());</pre>
</div><h4 id='method.chunks' class='method'><span id='chunks.v' class='invisible'><code>fn <a href='#method.chunks' class='fnname'>chunks</a>(&amp;self, size: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; <a class='struct' href='../../core/slice/struct.Chunks.html' title='core::slice::Chunks'>Chunks</a>&lt;T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over <code>size</code> elements of the slice at a
time. The chunks are slices and do not overlap. If <code>size</code> does not divide the
length of the slice, then the last chunk will not have length
<code>size</code>.</p>

<h1 id='panics-2' class='section-header'><a href='#panics-2'>Panics</a></h1>
<p>Panics if <code>size</code> is 0.</p>

<h1 id='example-4' class='section-header'><a href='#example-4'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>slice</span> <span class='op'>=</span> [<span class='string'>&#39;l&#39;</span>, <span class='string'>&#39;o&#39;</span>, <span class='string'>&#39;r&#39;</span>, <span class='string'>&#39;e&#39;</span>, <span class='string'>&#39;m&#39;</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>iter</span> <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>chunks</span>(<span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[<span class='string'>&#39;l&#39;</span>, <span class='string'>&#39;o&#39;</span>]);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[<span class='string'>&#39;r&#39;</span>, <span class='string'>&#39;e&#39;</span>]);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[<span class='string'>&#39;m&#39;</span>]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());</pre>
</div><h4 id='method.chunks_mut' class='method'><span id='chunks_mut.v' class='invisible'><code>fn <a href='#method.chunks_mut' class='fnname'>chunks_mut</a>(&amp;mut self, chunk_size: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; <a class='struct' href='../../core/slice/struct.ChunksMut.html' title='core::slice::ChunksMut'>ChunksMut</a>&lt;T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time.
The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not
have length <code>chunk_size</code>.</p>

<h1 id='panics-3' class='section-header'><a href='#panics-3'>Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>

<h1 id='examples-17' class='section-header'><a href='#examples-17'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>count</span> <span class='op'>=</span> <span class='number'>1</span>;

<span class='kw'>for</span> <span class='ident'>chunk</span> <span class='kw'>in</span> <span class='ident'>v</span>.<span class='ident'>chunks_mut</span>(<span class='number'>2</span>) {
    <span class='kw'>for</span> <span class='ident'>elem</span> <span class='kw'>in</span> <span class='ident'>chunk</span>.<span class='ident'>iter_mut</span>() {
        <span class='op'>*</span><span class='ident'>elem</span> <span class='op'>+=</span> <span class='ident'>count</span>;
    }
    <span class='ident'>count</span> <span class='op'>+=</span> <span class='number'>1</span>;
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>2</span>, <span class='number'>3</span>]);</pre>
</div><h4 id='method.split_at' class='method'><span id='split_at.v' class='invisible'><code>fn <a href='#method.split_at' class='fnname'>split_at</a>(&amp;self, mid: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; <a class='primitive' href='../../std/primitive.tuple.html'>(</a><a class='primitive' href='../../std/primitive.slice.html'>&amp;[T]</a>, <a class='primitive' href='../../std/primitive.slice.html'>&amp;[T]</a><a class='primitive' href='../../std/primitive.tuple.html'>)</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Divides one slice into two at an index.</p>

<p>The first will contain all indices from <code>[0, mid)</code> (excluding
the index <code>mid</code> itself) and the second will contain all
indices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>

<h1 id='panics-4' class='section-header'><a href='#panics-4'>Panics</a></h1>
<p>Panics if <code>mid &gt; len</code>.</p>

<h1 id='examples-18' class='section-header'><a href='#examples-18'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>, <span class='number'>20</span>, <span class='number'>50</span>];
<span class='kw'>let</span> (<span class='ident'>v1</span>, <span class='ident'>v2</span>) <span class='op'>=</span> <span class='ident'>v</span>.<span class='ident'>split_at</span>(<span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>([<span class='number'>10</span>, <span class='number'>40</span>], <span class='ident'>v1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>([<span class='number'>30</span>, <span class='number'>20</span>, <span class='number'>50</span>], <span class='ident'>v2</span>);</pre>
</div><h4 id='method.split_at_mut' class='method'><span id='split_at_mut.v' class='invisible'><code>fn <a href='#method.split_at_mut' class='fnname'>split_at_mut</a>(&amp;mut self, mid: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; <a class='primitive' href='../../std/primitive.tuple.html'>(</a><a class='primitive' href='../../std/primitive.slice.html'>&amp;mut [T]</a>, <a class='primitive' href='../../std/primitive.slice.html'>&amp;mut [T]</a><a class='primitive' href='../../std/primitive.tuple.html'>)</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Divides one <code>&amp;mut</code> into two at an index.</p>

<p>The first will contain all indices from <code>[0, mid)</code> (excluding
the index <code>mid</code> itself) and the second will contain all
indices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>

<h1 id='panics-5' class='section-header'><a href='#panics-5'>Panics</a></h1>
<p>Panics if <code>mid &gt; len</code>.</p>

<h1 id='examples-19' class='section-header'><a href='#examples-19'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>];

<span class='comment'>// scoped to restrict the lifetime of the borrows</span>
{
   <span class='kw'>let</span> (<span class='ident'>left</span>, <span class='ident'>right</span>) <span class='op'>=</span> <span class='ident'>v</span>.<span class='ident'>split_at_mut</span>(<span class='number'>0</span>);
   <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>left</span> <span class='op'>==</span> []);
   <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>right</span> <span class='op'>==</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>]);
}

{
    <span class='kw'>let</span> (<span class='ident'>left</span>, <span class='ident'>right</span>) <span class='op'>=</span> <span class='ident'>v</span>.<span class='ident'>split_at_mut</span>(<span class='number'>2</span>);
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>left</span> <span class='op'>==</span> [<span class='number'>1</span>, <span class='number'>2</span>]);
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>right</span> <span class='op'>==</span> [<span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>]);
}

{
    <span class='kw'>let</span> (<span class='ident'>left</span>, <span class='ident'>right</span>) <span class='op'>=</span> <span class='ident'>v</span>.<span class='ident'>split_at_mut</span>(<span class='number'>6</span>);
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>left</span> <span class='op'>==</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>]);
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>right</span> <span class='op'>==</span> []);
}</pre>
</div><h4 id='method.split' class='method'><span id='split.v' class='invisible'><code>fn <a href='#method.split' class='fnname'>split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class='struct' href='../../core/slice/struct.Split.html' title='core::slice::Split'>Split</a>&lt;T,&nbsp;F&gt; <span class='where'>where F: <a class='trait' href='../../core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;T) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code>. The matched element is not contained in the subslices.</p>

<h1 id='examples-20' class='section-header'><a href='#examples-20'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>slice</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>33</span>, <span class='number'>20</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>iter</span> <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>split</span>(<span class='op'>|</span><span class='ident'>num</span><span class='op'>|</span> <span class='ident'>num</span> <span class='op'>%</span> <span class='number'>3</span> <span class='op'>==</span> <span class='number'>0</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[<span class='number'>10</span>, <span class='number'>40</span>]);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[<span class='number'>20</span>]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());</pre>

<p>If the first element is matched, an empty slice will be the first item
returned by the iterator. Similarly, if the last element in the slice
is matched, an empty slice will be the last item returned by the
iterator:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>slice</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>33</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>iter</span> <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>split</span>(<span class='op'>|</span><span class='ident'>num</span><span class='op'>|</span> <span class='ident'>num</span> <span class='op'>%</span> <span class='number'>3</span> <span class='op'>==</span> <span class='number'>0</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[<span class='number'>10</span>, <span class='number'>40</span>]);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());</pre>

<p>If two matched elements are directly adjacent, an empty slice will be
present between them:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>slice</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>6</span>, <span class='number'>33</span>, <span class='number'>20</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>iter</span> <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>split</span>(<span class='op'>|</span><span class='ident'>num</span><span class='op'>|</span> <span class='ident'>num</span> <span class='op'>%</span> <span class='number'>3</span> <span class='op'>==</span> <span class='number'>0</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[<span class='number'>10</span>]);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[]);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span>[<span class='number'>20</span>]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());</pre>
</div><h4 id='method.split_mut' class='method'><span id='split_mut.v' class='invisible'><code>fn <a href='#method.split_mut' class='fnname'>split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class='struct' href='../../core/slice/struct.SplitMut.html' title='core::slice::SplitMut'>SplitMut</a>&lt;T,&nbsp;F&gt; <span class='where'>where F: <a class='trait' href='../../core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;T) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over mutable subslices separated by elements that
match <code>pred</code>. The matched element is not contained in the subslices.</p>

<h1 id='examples-21' class='section-header'><a href='#examples-21'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>, <span class='number'>20</span>, <span class='number'>60</span>, <span class='number'>50</span>];

<span class='kw'>for</span> <span class='ident'>group</span> <span class='kw'>in</span> <span class='ident'>v</span>.<span class='ident'>split_mut</span>(<span class='op'>|</span><span class='ident'>num</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>num</span> <span class='op'>%</span> <span class='number'>3</span> <span class='op'>==</span> <span class='number'>0</span>) {
    <span class='ident'>group</span>[<span class='number'>0</span>] <span class='op'>=</span> <span class='number'>1</span>;
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='number'>1</span>, <span class='number'>40</span>, <span class='number'>30</span>, <span class='number'>1</span>, <span class='number'>60</span>, <span class='number'>1</span>]);</pre>
</div><h4 id='method.splitn' class='method'><span id='splitn.v' class='invisible'><code>fn <a href='#method.splitn' class='fnname'>splitn</a>&lt;F&gt;(&amp;self, n: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>, pred: F) -&gt; <a class='struct' href='../../core/slice/struct.SplitN.html' title='core::slice::SplitN'>SplitN</a>&lt;T,&nbsp;F&gt; <span class='where'>where F: <a class='trait' href='../../core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;T) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code>, limited to returning at most <code>n</code> items.  The matched element is
not contained in the subslices.</p>

<p>The last element returned, if any, will contain the remainder of the
slice.</p>

<h1 id='examples-22' class='section-header'><a href='#examples-22'>Examples</a></h1>
<p>Print the slice split once by numbers divisible by 3 (i.e. <code>[10, 40]</code>,
<code>[20, 60, 50]</code>):</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>, <span class='number'>20</span>, <span class='number'>60</span>, <span class='number'>50</span>];

<span class='kw'>for</span> <span class='ident'>group</span> <span class='kw'>in</span> <span class='ident'>v</span>.<span class='ident'>splitn</span>(<span class='number'>2</span>, <span class='op'>|</span><span class='ident'>num</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>num</span> <span class='op'>%</span> <span class='number'>3</span> <span class='op'>==</span> <span class='number'>0</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>group</span>);
}</pre>
</div><h4 id='method.splitn_mut' class='method'><span id='splitn_mut.v' class='invisible'><code>fn <a href='#method.splitn_mut' class='fnname'>splitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>, pred: F) -&gt; <a class='struct' href='../../core/slice/struct.SplitNMut.html' title='core::slice::SplitNMut'>SplitNMut</a>&lt;T,&nbsp;F&gt; <span class='where'>where F: <a class='trait' href='../../core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;T) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code>, limited to returning at most <code>n</code> items.  The matched element is
not contained in the subslices.</p>

<p>The last element returned, if any, will contain the remainder of the
slice.</p>

<h1 id='examples-23' class='section-header'><a href='#examples-23'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>, <span class='number'>20</span>, <span class='number'>60</span>, <span class='number'>50</span>];

<span class='kw'>for</span> <span class='ident'>group</span> <span class='kw'>in</span> <span class='ident'>v</span>.<span class='ident'>splitn_mut</span>(<span class='number'>2</span>, <span class='op'>|</span><span class='ident'>num</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>num</span> <span class='op'>%</span> <span class='number'>3</span> <span class='op'>==</span> <span class='number'>0</span>) {
    <span class='ident'>group</span>[<span class='number'>0</span>] <span class='op'>=</span> <span class='number'>1</span>;
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='number'>1</span>, <span class='number'>40</span>, <span class='number'>30</span>, <span class='number'>1</span>, <span class='number'>60</span>, <span class='number'>50</span>]);</pre>
</div><h4 id='method.rsplitn' class='method'><span id='rsplitn.v' class='invisible'><code>fn <a href='#method.rsplitn' class='fnname'>rsplitn</a>&lt;F&gt;(&amp;self, n: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>, pred: F) -&gt; <a class='struct' href='../../core/slice/struct.RSplitN.html' title='core::slice::RSplitN'>RSplitN</a>&lt;T,&nbsp;F&gt; <span class='where'>where F: <a class='trait' href='../../core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;T) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code> limited to returning at most <code>n</code> items. This starts at the end of
the slice and works backwards.  The matched element is not contained in
the subslices.</p>

<p>The last element returned, if any, will contain the remainder of the
slice.</p>

<h1 id='examples-24' class='section-header'><a href='#examples-24'>Examples</a></h1>
<p>Print the slice split once, starting from the end, by numbers divisible
by 3 (i.e. <code>[50]</code>, <code>[10, 40, 30, 20]</code>):</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>, <span class='number'>20</span>, <span class='number'>60</span>, <span class='number'>50</span>];

<span class='kw'>for</span> <span class='ident'>group</span> <span class='kw'>in</span> <span class='ident'>v</span>.<span class='ident'>rsplitn</span>(<span class='number'>2</span>, <span class='op'>|</span><span class='ident'>num</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>num</span> <span class='op'>%</span> <span class='number'>3</span> <span class='op'>==</span> <span class='number'>0</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>group</span>);
}</pre>
</div><h4 id='method.rsplitn_mut' class='method'><span id='rsplitn_mut.v' class='invisible'><code>fn <a href='#method.rsplitn_mut' class='fnname'>rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>, pred: F) -&gt; <a class='struct' href='../../core/slice/struct.RSplitNMut.html' title='core::slice::RSplitNMut'>RSplitNMut</a>&lt;T,&nbsp;F&gt; <span class='where'>where F: <a class='trait' href='../../core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;T) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code> limited to returning at most <code>n</code> items. This starts at the end of
the slice and works backwards.  The matched element is not contained in
the subslices.</p>

<p>The last element returned, if any, will contain the remainder of the
slice.</p>

<h1 id='examples-25' class='section-header'><a href='#examples-25'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>, <span class='number'>20</span>, <span class='number'>60</span>, <span class='number'>50</span>];

<span class='kw'>for</span> <span class='ident'>group</span> <span class='kw'>in</span> <span class='ident'>s</span>.<span class='ident'>rsplitn_mut</span>(<span class='number'>2</span>, <span class='op'>|</span><span class='ident'>num</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>num</span> <span class='op'>%</span> <span class='number'>3</span> <span class='op'>==</span> <span class='number'>0</span>) {
    <span class='ident'>group</span>[<span class='number'>0</span>] <span class='op'>=</span> <span class='number'>1</span>;
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, [<span class='number'>1</span>, <span class='number'>40</span>, <span class='number'>30</span>, <span class='number'>20</span>, <span class='number'>60</span>, <span class='number'>1</span>]);</pre>
</div><h4 id='method.contains' class='method'><span id='contains.v' class='invisible'><code>fn <a href='#method.contains' class='fnname'>contains</a>(&amp;self, x: &amp;T) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a> <span class='where'>where T: <a class='trait' href='../../core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a>&lt;T&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns true if the slice contains an element with the given value.</p>

<h1 id='examples-26' class='section-header'><a href='#examples-26'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>];
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span>.<span class='ident'>contains</span>(<span class='kw-2'>&amp;</span><span class='number'>30</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>v</span>.<span class='ident'>contains</span>(<span class='kw-2'>&amp;</span><span class='number'>50</span>));</pre>
</div><h4 id='method.starts_with' class='method'><span id='starts_with.v' class='invisible'><code>fn <a href='#method.starts_with' class='fnname'>starts_with</a>(&amp;self, needle: <a class='primitive' href='../../std/primitive.slice.html'>&amp;[T]</a>) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a> <span class='where'>where T: <a class='trait' href='../../core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a>&lt;T&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns true if <code>needle</code> is a prefix of the slice.</p>

<h1 id='examples-27' class='section-header'><a href='#examples-27'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>];
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span>.<span class='ident'>starts_with</span>(<span class='kw-2'>&amp;</span>[<span class='number'>10</span>]));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span>.<span class='ident'>starts_with</span>(<span class='kw-2'>&amp;</span>[<span class='number'>10</span>, <span class='number'>40</span>]));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>v</span>.<span class='ident'>starts_with</span>(<span class='kw-2'>&amp;</span>[<span class='number'>50</span>]));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>v</span>.<span class='ident'>starts_with</span>(<span class='kw-2'>&amp;</span>[<span class='number'>10</span>, <span class='number'>50</span>]));</pre>
</div><h4 id='method.ends_with' class='method'><span id='ends_with.v' class='invisible'><code>fn <a href='#method.ends_with' class='fnname'>ends_with</a>(&amp;self, needle: <a class='primitive' href='../../std/primitive.slice.html'>&amp;[T]</a>) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a> <span class='where'>where T: <a class='trait' href='../../core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a>&lt;T&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns true if <code>needle</code> is a suffix of the slice.</p>

<h1 id='examples-28' class='section-header'><a href='#examples-28'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>];
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span>.<span class='ident'>ends_with</span>(<span class='kw-2'>&amp;</span>[<span class='number'>30</span>]));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span>.<span class='ident'>ends_with</span>(<span class='kw-2'>&amp;</span>[<span class='number'>40</span>, <span class='number'>30</span>]));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>v</span>.<span class='ident'>ends_with</span>(<span class='kw-2'>&amp;</span>[<span class='number'>50</span>]));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>v</span>.<span class='ident'>ends_with</span>(<span class='kw-2'>&amp;</span>[<span class='number'>50</span>, <span class='number'>30</span>]));</pre>
</div><h4 id='method.binary_search' class='method'><span id='binary_search.v' class='invisible'><code>fn <a href='#method.binary_search' class='fnname'>binary_search</a>(&amp;self, x: &amp;T) -&gt; <a class='enum' href='../../core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='../../std/primitive.usize.html'>usize</a>,&nbsp;<a class='primitive' href='../../std/primitive.usize.html'>usize</a>&gt; <span class='where'>where T: <a class='trait' href='../../core/cmp/trait.Ord.html' title='core::cmp::Ord'>Ord</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Binary search a sorted slice for a given element.</p>

<p>If the value is found then <code>Ok</code> is returned, containing the
index of the matching element; if the value is not found then
<code>Err</code> is returned, containing the index where a matching
element could be inserted while maintaining sorted order.</p>

<h1 id='example-5' class='section-header'><a href='#example-5'>Example</a></h1>
<p>Looks up a series of four elements. The first is found, with a
uniquely determined position; the second and third are not
found; the fourth could match any position in <code>[1,4]</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>1</span>, <span class='number'>1</span>, <span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>5</span>, <span class='number'>8</span>, <span class='number'>13</span>, <span class='number'>21</span>, <span class='number'>34</span>, <span class='number'>55</span>];

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>binary_search</span>(<span class='kw-2'>&amp;</span><span class='number'>13</span>),  <span class='prelude-val'>Ok</span>(<span class='number'>9</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>binary_search</span>(<span class='kw-2'>&amp;</span><span class='number'>4</span>),   <span class='prelude-val'>Err</span>(<span class='number'>7</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>binary_search</span>(<span class='kw-2'>&amp;</span><span class='number'>100</span>), <span class='prelude-val'>Err</span>(<span class='number'>13</span>));
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>binary_search</span>(<span class='kw-2'>&amp;</span><span class='number'>1</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='kw'>match</span> <span class='ident'>r</span> { <span class='prelude-val'>Ok</span>(<span class='number'>1</span>...<span class='number'>4</span>) <span class='op'>=&gt;</span> <span class='bool-val'>true</span>, _ <span class='op'>=&gt;</span> <span class='bool-val'>false</span>, });</pre>
</div><h4 id='method.binary_search_by' class='method'><span id='binary_search_by.v' class='invisible'><code>fn <a href='#method.binary_search_by' class='fnname'>binary_search_by</a>&lt;'a,&nbsp;F&gt;(&amp;'a self, f: F) -&gt; <a class='enum' href='../../core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='../../std/primitive.usize.html'>usize</a>,&nbsp;<a class='primitive' href='../../std/primitive.usize.html'>usize</a>&gt; <span class='where'>where F: <a class='trait' href='../../core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;'a T) -&gt; <a class='enum' href='../../core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Binary search a sorted slice with a comparator function.</p>

<p>The comparator function should implement an order consistent
with the sort order of the underlying slice, returning an
order code that indicates whether its argument is <code>Less</code>,
<code>Equal</code> or <code>Greater</code> the desired target.</p>

<p>If a matching value is found then returns <code>Ok</code>, containing
the index for the matched element; if no match is found then
<code>Err</code> is returned, containing the index where a matching
element could be inserted while maintaining sorted order.</p>

<h1 id='example-6' class='section-header'><a href='#example-6'>Example</a></h1>
<p>Looks up a series of four elements. The first is found, with a
uniquely determined position; the second and third are not
found; the fourth could match any position in <code>[1,4]</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>1</span>, <span class='number'>1</span>, <span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>5</span>, <span class='number'>8</span>, <span class='number'>13</span>, <span class='number'>21</span>, <span class='number'>34</span>, <span class='number'>55</span>];

<span class='kw'>let</span> <span class='ident'>seek</span> <span class='op'>=</span> <span class='number'>13</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>binary_search_by</span>(<span class='op'>|</span><span class='ident'>probe</span><span class='op'>|</span> <span class='ident'>probe</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>seek</span>)), <span class='prelude-val'>Ok</span>(<span class='number'>9</span>));
<span class='kw'>let</span> <span class='ident'>seek</span> <span class='op'>=</span> <span class='number'>4</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>binary_search_by</span>(<span class='op'>|</span><span class='ident'>probe</span><span class='op'>|</span> <span class='ident'>probe</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>seek</span>)), <span class='prelude-val'>Err</span>(<span class='number'>7</span>));
<span class='kw'>let</span> <span class='ident'>seek</span> <span class='op'>=</span> <span class='number'>100</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>binary_search_by</span>(<span class='op'>|</span><span class='ident'>probe</span><span class='op'>|</span> <span class='ident'>probe</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>seek</span>)), <span class='prelude-val'>Err</span>(<span class='number'>13</span>));
<span class='kw'>let</span> <span class='ident'>seek</span> <span class='op'>=</span> <span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>binary_search_by</span>(<span class='op'>|</span><span class='ident'>probe</span><span class='op'>|</span> <span class='ident'>probe</span>.<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>seek</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='kw'>match</span> <span class='ident'>r</span> { <span class='prelude-val'>Ok</span>(<span class='number'>1</span>...<span class='number'>4</span>) <span class='op'>=&gt;</span> <span class='bool-val'>true</span>, _ <span class='op'>=&gt;</span> <span class='bool-val'>false</span>, });</pre>
</div><h4 id='method.binary_search_by_key' class='method'><span id='binary_search_by_key.v' class='invisible'><code>fn <a href='#method.binary_search_by_key' class='fnname'>binary_search_by_key</a>&lt;'a,&nbsp;B,&nbsp;F&gt;(&amp;'a self, b: &amp;B, f: F) -&gt; <a class='enum' href='../../core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='../../std/primitive.usize.html'>usize</a>,&nbsp;<a class='primitive' href='../../std/primitive.usize.html'>usize</a>&gt; <span class='where'>where B: <a class='trait' href='../../core/cmp/trait.Ord.html' title='core::cmp::Ord'>Ord</a>, F: <a class='trait' href='../../core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;'a T) -&gt; B</span></code><div class='since' title='Stable since Rust version 1.10.0'>1.10.0</div></span></h4>
<div class='docblock'><p>Binary search a sorted slice with a key extraction function.</p>

<p>Assumes that the slice is sorted by the key, for instance with
<code>sort_by_key</code> using the same key extraction function.</p>

<p>If a matching value is found then returns <code>Ok</code>, containing the
index for the matched element; if no match is found then <code>Err</code>
is returned, containing the index where a matching element could
be inserted while maintaining sorted order.</p>

<h1 id='examples-29' class='section-header'><a href='#examples-29'>Examples</a></h1>
<p>Looks up a series of four elements in a slice of pairs sorted by
their second elements. The first is found, with a uniquely
determined position; the second and third are not found; the
fourth could match any position in <code>[1,4]</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> [(<span class='number'>0</span>, <span class='number'>0</span>), (<span class='number'>2</span>, <span class='number'>1</span>), (<span class='number'>4</span>, <span class='number'>1</span>), (<span class='number'>5</span>, <span class='number'>1</span>), (<span class='number'>3</span>, <span class='number'>1</span>),
         (<span class='number'>1</span>, <span class='number'>2</span>), (<span class='number'>2</span>, <span class='number'>3</span>), (<span class='number'>4</span>, <span class='number'>5</span>), (<span class='number'>5</span>, <span class='number'>8</span>), (<span class='number'>3</span>, <span class='number'>13</span>),
         (<span class='number'>1</span>, <span class='number'>21</span>), (<span class='number'>2</span>, <span class='number'>34</span>), (<span class='number'>4</span>, <span class='number'>55</span>)];

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>binary_search_by_key</span>(<span class='kw-2'>&amp;</span><span class='number'>13</span>, <span class='op'>|</span><span class='kw-2'>&amp;</span>(<span class='ident'>a</span>,<span class='ident'>b</span>)<span class='op'>|</span> <span class='ident'>b</span>),  <span class='prelude-val'>Ok</span>(<span class='number'>9</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>binary_search_by_key</span>(<span class='kw-2'>&amp;</span><span class='number'>4</span>, <span class='op'>|</span><span class='kw-2'>&amp;</span>(<span class='ident'>a</span>,<span class='ident'>b</span>)<span class='op'>|</span> <span class='ident'>b</span>),   <span class='prelude-val'>Err</span>(<span class='number'>7</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>binary_search_by_key</span>(<span class='kw-2'>&amp;</span><span class='number'>100</span>, <span class='op'>|</span><span class='kw-2'>&amp;</span>(<span class='ident'>a</span>,<span class='ident'>b</span>)<span class='op'>|</span> <span class='ident'>b</span>), <span class='prelude-val'>Err</span>(<span class='number'>13</span>));
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>binary_search_by_key</span>(<span class='kw-2'>&amp;</span><span class='number'>1</span>, <span class='op'>|</span><span class='kw-2'>&amp;</span>(<span class='ident'>a</span>,<span class='ident'>b</span>)<span class='op'>|</span> <span class='ident'>b</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='kw'>match</span> <span class='ident'>r</span> { <span class='prelude-val'>Ok</span>(<span class='number'>1</span>...<span class='number'>4</span>) <span class='op'>=&gt;</span> <span class='bool-val'>true</span>, _ <span class='op'>=&gt;</span> <span class='bool-val'>false</span>, });</pre>
</div><h4 id='method.sort' class='method'><span id='sort.v' class='invisible'><code>fn <a href='#method.sort' class='fnname'>sort</a>(&amp;mut self) <span class='where'>where T: <a class='trait' href='../../core/cmp/trait.Ord.html' title='core::cmp::Ord'>Ord</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>This is equivalent to <code>self.sort_by(|a, b| a.cmp(b))</code>.</p>

<p>This sort is stable and <code>O(n log n)</code> worst-case but allocates
approximately <code>2 * n</code> where <code>n</code> is the length of <code>self</code>.</p>

<h1 id='examples-30' class='section-header'><a href='#examples-30'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='op'>-</span><span class='number'>5</span>, <span class='number'>4</span>, <span class='number'>1</span>, <span class='op'>-</span><span class='number'>3</span>, <span class='number'>2</span>];

<span class='ident'>v</span>.<span class='ident'>sort</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span> <span class='op'>==</span> [<span class='op'>-</span><span class='number'>5</span>, <span class='op'>-</span><span class='number'>3</span>, <span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>4</span>]);</pre>
</div><h4 id='method.sort_by_key' class='method'><span id='sort_by_key.v' class='invisible'><code>fn <a href='#method.sort_by_key' class='fnname'>sort_by_key</a>&lt;B,&nbsp;F&gt;(&amp;mut self, f: F) <span class='where'>where B: <a class='trait' href='../../core/cmp/trait.Ord.html' title='core::cmp::Ord'>Ord</a>, F: <a class='trait' href='../../core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;T) -&gt; B</span></code><div class='since' title='Stable since Rust version 1.7.0'>1.7.0</div></span></h4>
<div class='docblock'><p>Sorts the slice, in place, using <code>key</code> to extract a key by which to
order the sort by.</p>

<p>This sort is stable and <code>O(n log n)</code> worst-case but allocates
approximately <code>2 * n</code>, where <code>n</code> is the length of <code>self</code>.</p>

<h1 id='examples-31' class='section-header'><a href='#examples-31'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='op'>-</span><span class='number'>5i32</span>, <span class='number'>4</span>, <span class='number'>1</span>, <span class='op'>-</span><span class='number'>3</span>, <span class='number'>2</span>];

<span class='ident'>v</span>.<span class='ident'>sort_by_key</span>(<span class='op'>|</span><span class='ident'>k</span><span class='op'>|</span> <span class='ident'>k</span>.<span class='ident'>abs</span>());
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span> <span class='op'>==</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='op'>-</span><span class='number'>3</span>, <span class='number'>4</span>, <span class='op'>-</span><span class='number'>5</span>]);</pre>
</div><h4 id='method.sort_by' class='method'><span id='sort_by.v' class='invisible'><code>fn <a href='#method.sort_by' class='fnname'>sort_by</a>&lt;F&gt;(&amp;mut self, compare: F) <span class='where'>where F: <a class='trait' href='../../core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;T, &amp;T) -&gt; <a class='enum' href='../../core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Sorts the slice, in place, using <code>compare</code> to compare
elements.</p>

<p>This sort is stable and <code>O(n log n)</code> worst-case but allocates
approximately <code>2 * n</code>, where <code>n</code> is the length of <code>self</code>.</p>

<h1 id='examples-32' class='section-header'><a href='#examples-32'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> [<span class='number'>5</span>, <span class='number'>4</span>, <span class='number'>1</span>, <span class='number'>3</span>, <span class='number'>2</span>];
<span class='ident'>v</span>.<span class='ident'>sort_by</span>(<span class='op'>|</span><span class='ident'>a</span>, <span class='ident'>b</span><span class='op'>|</span> <span class='ident'>a</span>.<span class='ident'>cmp</span>(<span class='ident'>b</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span> <span class='op'>==</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>]);

<span class='comment'>// reverse sorting</span>
<span class='ident'>v</span>.<span class='ident'>sort_by</span>(<span class='op'>|</span><span class='ident'>a</span>, <span class='ident'>b</span><span class='op'>|</span> <span class='ident'>b</span>.<span class='ident'>cmp</span>(<span class='ident'>a</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span> <span class='op'>==</span> [<span class='number'>5</span>, <span class='number'>4</span>, <span class='number'>3</span>, <span class='number'>2</span>, <span class='number'>1</span>]);</pre>
</div><h4 id='method.clone_from_slice' class='method'><span id='clone_from_slice.v' class='invisible'><code>fn <a href='#method.clone_from_slice' class='fnname'>clone_from_slice</a>(&amp;mut self, src: <a class='primitive' href='../../std/primitive.slice.html'>&amp;[T]</a>) <span class='where'>where T: <a class='trait' href='../../core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a></span></code><div class='since' title='Stable since Rust version 1.7.0'>1.7.0</div></span></h4>
<div class='docblock'><p>Copies the elements from <code>src</code> into <code>self</code>.</p>

<p>The length of <code>src</code> must be the same as <code>self</code>.</p>

<h1 id='panics-6' class='section-header'><a href='#panics-6'>Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>

<h1 id='example-7' class='section-header'><a href='#example-7'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>dst</span> <span class='op'>=</span> [<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>];
<span class='kw'>let</span> <span class='ident'>src</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='ident'>dst</span>.<span class='ident'>clone_from_slice</span>(<span class='kw-2'>&amp;</span><span class='ident'>src</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>dst</span> <span class='op'>==</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>]);</pre>
</div><h4 id='method.copy_from_slice' class='method'><span id='copy_from_slice.v' class='invisible'><code>fn <a href='#method.copy_from_slice' class='fnname'>copy_from_slice</a>(&amp;mut self, src: <a class='primitive' href='../../std/primitive.slice.html'>&amp;[T]</a>) <span class='where'>where T: <a class='trait' href='../../core/marker/trait.Copy.html' title='core::marker::Copy'>Copy</a></span></code><div class='since' title='Stable since Rust version 1.9.0'>1.9.0</div></span></h4>
<div class='docblock'><p>Copies all elements from <code>src</code> into <code>self</code>, using a memcpy.</p>

<p>The length of <code>src</code> must be the same as <code>self</code>.</p>

<h1 id='panics-7' class='section-header'><a href='#panics-7'>Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>

<h1 id='example-8' class='section-header'><a href='#example-8'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>dst</span> <span class='op'>=</span> [<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>];
<span class='kw'>let</span> <span class='ident'>src</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='ident'>dst</span>.<span class='ident'>copy_from_slice</span>(<span class='kw-2'>&amp;</span><span class='ident'>src</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>src</span>, <span class='ident'>dst</span>);</pre>
</div><h4 id='method.to_vec' class='method'><span id='to_vec.v' class='invisible'><code>fn <a href='#method.to_vec' class='fnname'>to_vec</a>(&amp;self) -&gt; <a class='struct' href='../../collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Copies <code>self</code> into a new <code>Vec</code>.</p>

<h1 id='examples-33' class='section-header'><a href='#examples-33'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> [<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>];
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>to_vec</span>();
<span class='comment'>// Here, `s` and `x` can be modified independently.</span></pre>
</div><h4 id='method.into_vec' class='method'><span id='into_vec.v' class='invisible'><code>fn <a href='#method.into_vec' class='fnname'>into_vec</a>(self: <a class='struct' href='../../alloc/boxed/struct.Box.html' title='alloc::boxed::Box'>Box</a>&lt;<a class='primitive' href='../../std/primitive.slice.html'>[</a>T<a class='primitive' href='../../std/primitive.slice.html'>]</a>&gt;) -&gt; <a class='struct' href='../../collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;T&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Converts <code>self</code> into a vector without clones or allocation.</p>

<h1 id='examples-34' class='section-header'><a href='#examples-34'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span>: <span class='ident'>Box</span><span class='op'>&lt;</span>[<span class='ident'>i32</span>]<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>([<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>]);
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>into_vec</span>();
<span class='comment'>// `s` cannot be used anymore because it has been converted into `x`.</span>

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='macro'>vec</span><span class='macro'>!</span>(<span class='number'>10</span>, <span class='number'>40</span>, <span class='number'>30</span>));</pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl&lt;D:&nbsp;<a class='trait' href='../../rustc_data_structures/snapshot_vec/trait.SnapshotVecDelegate.html' title='rustc_data_structures::snapshot_vec::SnapshotVecDelegate'>SnapshotVecDelegate</a>&gt; <a class='trait' href='../../core/ops/trait.Deref.html' title='core::ops::Deref'>Deref</a> for <a class='struct' href='../../rustc_data_structures/snapshot_vec/struct.SnapshotVec.html' title='rustc_data_structures::snapshot_vec::SnapshotVec'>SnapshotVec</a>&lt;D&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a id='src-1302' class='srclink' href='../../src/rustc_data_structures/src/librustc_data_structures/snapshot_vec.rs.html#191-196' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='associatedtype.Target' class='type'><span id='Target.t' class='invisible'><code>type <a href='../../core/ops/trait.Deref.html#associatedtype.Target' class='type'>Target</a> = <a class='primitive' href='../../std/primitive.slice.html'>[</a>D::Value<a class='primitive' href='../../std/primitive.slice.html'>]</a></code></span></h4>
<div class='docblock'><p>The resulting type after dereferencing</p>
</div><h4 id='method.deref' class='method'><span id='deref.v' class='invisible'><code>fn <a href='../../core/ops/trait.Deref.html#tymethod.deref' class='fnname'>deref</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.slice.html'>&amp;[</a>D::Value<a class='primitive' href='../../std/primitive.slice.html'>]</a></code></span></h4>
<div class='docblock'><p>The method called to dereference a value</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;D:&nbsp;<a class='trait' href='../../rustc_data_structures/snapshot_vec/trait.SnapshotVecDelegate.html' title='rustc_data_structures::snapshot_vec::SnapshotVecDelegate'>SnapshotVecDelegate</a>&gt; <a class='trait' href='../../core/ops/trait.DerefMut.html' title='core::ops::DerefMut'>DerefMut</a> for <a class='struct' href='../../rustc_data_structures/snapshot_vec/struct.SnapshotVec.html' title='rustc_data_structures::snapshot_vec::SnapshotVec'>SnapshotVec</a>&lt;D&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a id='src-1307' class='srclink' href='../../src/rustc_data_structures/src/librustc_data_structures/snapshot_vec.rs.html#198-202' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.deref_mut' class='method'><span id='deref_mut.v' class='invisible'><code>fn <a href='../../core/ops/trait.DerefMut.html#tymethod.deref_mut' class='fnname'>deref_mut</a>(&amp;mut self) -&gt; <a class='primitive' href='../../std/primitive.slice.html'>&amp;mut [</a>D::Value<a class='primitive' href='../../std/primitive.slice.html'>]</a></code></span></h4>
<div class='docblock'><p>The method called to mutably dereference a value</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;D:&nbsp;<a class='trait' href='../../rustc_data_structures/snapshot_vec/trait.SnapshotVecDelegate.html' title='rustc_data_structures::snapshot_vec::SnapshotVecDelegate'>SnapshotVecDelegate</a>&gt; <a class='trait' href='../../core/ops/trait.Index.html' title='core::ops::Index'>Index</a>&lt;<a class='primitive' href='../../std/primitive.usize.html'>usize</a>&gt; for <a class='struct' href='../../rustc_data_structures/snapshot_vec/struct.SnapshotVec.html' title='rustc_data_structures::snapshot_vec::SnapshotVec'>SnapshotVec</a>&lt;D&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a id='src-1311' class='srclink' href='../../src/rustc_data_structures/src/librustc_data_structures/snapshot_vec.rs.html#204-209' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='associatedtype.Output' class='type'><span id='Output.t' class='invisible'><code>type <a href='../../core/ops/trait.Index.html#associatedtype.Output' class='type'>Output</a> = D::Value</code></span></h4>
<div class='docblock'><p>The returned type after indexing</p>
</div><h4 id='method.index' class='method'><span id='index.v' class='invisible'><code>fn <a href='../../core/ops/trait.Index.html#tymethod.index' class='fnname'>index</a>(&amp;self, index: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; &amp;D::Value</code></span></h4>
<div class='docblock'><p>The method for the indexing (<code>Foo[Bar]</code>) operation</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;D:&nbsp;<a class='trait' href='../../rustc_data_structures/snapshot_vec/trait.SnapshotVecDelegate.html' title='rustc_data_structures::snapshot_vec::SnapshotVecDelegate'>SnapshotVecDelegate</a>&gt; <a class='trait' href='../../core/ops/trait.IndexMut.html' title='core::ops::IndexMut'>IndexMut</a>&lt;<a class='primitive' href='../../std/primitive.usize.html'>usize</a>&gt; for <a class='struct' href='../../rustc_data_structures/snapshot_vec/struct.SnapshotVec.html' title='rustc_data_structures::snapshot_vec::SnapshotVec'>SnapshotVec</a>&lt;D&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a id='src-1317' class='srclink' href='../../src/rustc_data_structures/src/librustc_data_structures/snapshot_vec.rs.html#211-215' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.index_mut' class='method'><span id='index_mut.v' class='invisible'><code>fn <a href='../../core/ops/trait.IndexMut.html#tymethod.index_mut' class='fnname'>index_mut</a>(&amp;mut self, index: <a class='primitive' href='../../std/primitive.usize.html'>usize</a>) -&gt; &amp;mut D::Value</code></span></h4>
<div class='docblock'><p>The method for the indexing (<code>Foo[Bar]</code>) operation</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;D:&nbsp;<a class='trait' href='../../rustc_data_structures/snapshot_vec/trait.SnapshotVecDelegate.html' title='rustc_data_structures::snapshot_vec::SnapshotVecDelegate'>SnapshotVecDelegate</a>&gt; <a class='trait' href='../../core/iter/traits/trait.Extend.html' title='core::iter::traits::Extend'>Extend</a>&lt;D::Value&gt; for <a class='struct' href='../../rustc_data_structures/snapshot_vec/struct.SnapshotVec.html' title='rustc_data_structures::snapshot_vec::SnapshotVec'>SnapshotVec</a>&lt;D&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a id='src-1322' class='srclink' href='../../src/rustc_data_structures/src/librustc_data_structures/snapshot_vec.rs.html#217-223' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.extend' class='method'><span id='extend.v' class='invisible'><code>fn <a href='../../core/iter/traits/trait.Extend.html#tymethod.extend' class='fnname'>extend</a>&lt;T&gt;(&amp;mut self, iterable: T) <span class='where'>where T: <a class='trait' href='../../core/iter/traits/trait.IntoIterator.html' title='core::iter::traits::IntoIterator'>IntoIterator</a>&lt;Item=D::Value&gt;</span></code></span></h4>
<div class='docblock'><p>Extends a collection with the contents of an iterator. <a href="../../core/iter/traits/trait.Extend.html#tymethod.extend">Read more</a></p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "rustc_data_structures";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script defer src="../../search-index.js"></script>
</body>
</html>