initSidebarItems({"macro":[["newtype_index",""]],"mod":[["accumulate_vec","A vector type intended to be used for collecting from iterators onto the stack."],["array_vec","A stack-allocated vector, allowing storage of N elements on the stack."],["base_n",""],["bitslice",""],["bitvec",""],["blake2b",""],["control_flow_graph",""],["flock","Simple file-locking apis for each OS."],["fx",""],["graph","A graph module for use in dataflow, region resolution, and elsewhere."],["indexed_set",""],["indexed_vec",""],["obligation_forest","The `ObligationForest` is a utility data structure used in trait matching to track the set of outstanding obligations (those not yet resolved to success or error). It also tracks the \"backtrace\" of each pending obligation (why we are trying to figure this out in the first place). See README.md for a general overview of how to use this class."],["sip128","This is a copy of `core::hash::sip` adapted to providing 128 bit hashes."],["small_vec","A vector type intended to be used for collecting from iterators onto the stack."],["snapshot_map",""],["snapshot_vec","A utility class for implementing \"snapshottable\" things; a snapshottable data structure permits you to take a snapshot (via `start_snapshot`) and then, after making some changes, elect either to rollback to the start of the snapshot or commit those changes."],["stable_hasher",""],["transitive_relation",""],["tuple_slice",""],["unify",""],["veccell",""]],"trait":[["ToHex","A trait for converting a value to hexadecimal encoding"]]});