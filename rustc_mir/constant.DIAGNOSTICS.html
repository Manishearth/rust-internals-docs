<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `DIAGNOSTICS` constant in crate `rustc_mir`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, DIAGNOSTICS">

    <title>rustc_mir::DIAGNOSTICS - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc constant">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>rustc_mir</a></p><script>window.sidebarCurrent = {name: 'DIAGNOSTICS', ty: 'constant', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Constant <a href='index.html'>rustc_mir</a>::<wbr><a class="constant" href=''>DIAGNOSTICS</a></span><span class='out-of-band'><span class='since' title='Stable since Rust version '></span><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/rustc_mir/lib.rs.html#64' title='goto source code'>[src]</a></span></h1>
<pre class='rust const'>pub const DIAGNOSTICS: <a class="primitive" href="../std/primitive.array.html">[</a><a class="primitive" href="../std/primitive.tuple.html">(</a>&amp;'static <a class="primitive" href="../std/primitive.str.html">str</a>, &amp;'static <a class="primitive" href="../std/primitive.str.html">str</a><a class="primitive" href="../std/primitive.tuple.html">)</a><a class="primitive" href="../std/primitive.array.html">; 25]</a><code> = </code><code>[(&quot;E0010&quot;,
  &quot;\nThe value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time. Erroneous\ncode example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box&lt;i32&gt; = box 0;\n```\n&quot;),
 (&quot;E0013&quot;,
  &quot;\nStatic and const variables can refer to other const variables. But a const\nvariable cannot refer to a static variable. For example, `Y` cannot refer to\n`X` here:\n\n```compile_fail,E0013\nstatic X: i32 = 42;\nconst Y: i32 = X;\n```\n\nTo fix this, the value can be extracted as a const and then used:\n\n```\nconst A: i32 = 42;\nstatic X: i32 = A;\nconst Y: i32 = A;\n```\n&quot;),
 (&quot;E0015&quot;,
  &quot;\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors. `const` functions are only\navailable on a nightly compiler. Rust currently does not support more general\ncompile-time function execution.\n\n```\nconst FOO: Option&lt;u8&gt; = Some(1); // enum constructor\nstruct Bar {x: u8}\nconst BAR: Bar = Bar {x: 1}; // struct constructor\n```\n\nSee [RFC 911] for more details on the design of `const fn`s.\n\n[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n&quot;),
 (&quot;E0016&quot;,
  &quot;\nBlocks in constants may only contain items (such as constant, function\ndefinition, etc...) and a tail expression. Erroneous code example:\n\n```compile_fail,E0016\nconst FOO: i32 = { let x = 0; x }; // \&#39;x\&#39; isn\&#39;t an item!\n```\n\nTo avoid it, you have to replace the non-item object:\n\n```\nconst FOO: i32 = { const X : i32 = 0; X };\n```\n&quot;),
 (&quot;E0017&quot;,
  &quot;\nReferences in statics and constants may only refer to immutable values.\nErroneous code example:\n\n```compile_fail,E0017\nstatic X: i32 = 1;\nconst C: i32 = 2;\n\n// these three are not allowed:\nconst CR: &amp;\&#39;static mut i32 = &amp;mut C;\nstatic STATIC_REF: &amp;\&#39;static mut i32 = &amp;mut X;\nstatic CONST_REF: &amp;\&#39;static mut i32 = &amp;mut C;\n```\n\nStatics are shared everywhere, and if they refer to mutable data one might\nviolate memory safety since holding multiple mutable references to shared data\nis not allowed.\n\nIf you really want global mutable state, try using `static mut` or a global\n`UnsafeCell`.\n&quot;),
 (&quot;E0018&quot;,
  &quot;\n\nThe value of static and constant integers must be known at compile time. You\ncan\&#39;t cast a pointer to an integer because the address of a pointer can\nvary.\n\nFor example, if you write:\n\n```compile_fail,E0018\nstatic MY_STATIC: u32 = 42;\nstatic MY_STATIC_ADDR: usize = &amp;MY_STATIC as *const _ as usize;\nstatic WHAT: usize = (MY_STATIC_ADDR^17) + MY_STATIC_ADDR;\n```\n\nThen `MY_STATIC_ADDR` would contain the address of `MY_STATIC`. However,\nthe address can change when the program is linked, as well as change\nbetween different executions due to ASLR, and many linkers would\nnot be able to calculate the value of `WHAT`.\n\nOn the other hand, static and constant pointers can point either to\na known numeric address or to the address of a symbol.\n\n```\nstatic MY_STATIC: u32 = 42;\nstatic MY_STATIC_ADDR: &amp;\&#39;static u32 = &amp;MY_STATIC;\nconst CONST_ADDR: *const u8 = 0x5f3759df as *const u8;\n```\n\nThis does not pose a problem by itself because they can\&#39;t be\naccessed directly.\n&quot;),
 (&quot;E0019&quot;,
  &quot;\nA function call isn\&#39;t allowed in the const\&#39;s initialization expression\nbecause the expression\&#39;s value must be known at compile-time. Erroneous code\nexample:\n\n```compile_fail\nenum Test {\n    V1\n}\n\nimpl Test {\n    fn test(&amp;self) -&gt; i32 {\n        12\n    }\n}\n\nfn main() {\n    const FOO: Test = Test::V1;\n\n    const A: i32 = FOO.test(); // You can\&#39;t call Test::func() here!\n}\n```\n\nRemember: you can\&#39;t use a function call inside a const\&#39;s initialization\nexpression! However, you can totally use it anywhere else:\n\n```\nenum Test {\n    V1\n}\n\nimpl Test {\n    fn func(&amp;self) -&gt; i32 {\n        12\n    }\n}\n\nfn main() {\n    const FOO: Test = Test::V1;\n\n    FOO.func(); // here is good\n    let x = FOO.func(); // or even here!\n}\n```\n&quot;),
 (&quot;E0022&quot;,
  &quot;\nConstant functions are not allowed to mutate anything. Thus, binding to an\nargument with a mutable pattern is not allowed. For example,\n\n```compile_fail\nconst fn foo(mut x: u8) {\n    // do stuff\n}\n```\n\nIs incorrect because the function body may not mutate `x`.\n\nRemove any mutable bindings from the argument list to fix this error. In case\nyou need to mutate the argument, try lazily initializing a global variable\ninstead of using a `const fn`, or refactoring the code to a functional style to\navoid mutation if possible.\n&quot;),
 (&quot;E0381&quot;,
  &quot;\nIt is not allowed to use or capture an uninitialized variable. For example:\n\n```compile_fail,E0381\nfn main() {\n    let x: i32;\n    let y = x; // error, use of possibly uninitialized variable\n}\n```\n\nTo fix this, ensure that any declared variables are initialized before being\nused. Example:\n\n```\nfn main() {\n    let x: i32 = 0;\n    let y = x; // ok!\n}\n```\n&quot;),
 (&quot;E0384&quot;,
  &quot;\nThis error occurs when an attempt is made to reassign an immutable variable.\nFor example:\n\n```compile_fail,E0384\nfn main() {\n    let x = 3;\n    x = 5; // error, reassignment of immutable variable\n}\n```\n\nBy default, variables in Rust are immutable. To fix this error, add the keyword\n`mut` after the keyword `let` when declaring the variable. For example:\n\n```\nfn main() {\n    let mut x = 3;\n    x = 5;\n}\n```\n&quot;),
 (&quot;E0394&quot;,
  &quot;\nA static was referred to by value by another static.\n\nErroneous code examples:\n\n```compile_fail,E0394\nstatic A: u32 = 0;\nstatic B: u32 = A; // error: cannot refer to other statics by value, use the\n                   //        address-of operator or a constant instead\n```\n\nA static cannot be referred by value. To fix this issue, either use a\nconstant:\n\n```\nconst A: u32 = 0; // `A` is now a constant\nstatic B: u32 = A; // ok!\n```\n\nOr refer to `A` by reference:\n\n```\nstatic A: u32 = 0;\nstatic B: &amp;\&#39;static u32 = &amp;A; // ok!\n```\n&quot;),
 (&quot;E0395&quot;,
  &quot;\nThe value assigned to a constant scalar must be known at compile time,\nwhich is not the case when comparing raw pointers.\n\nErroneous code example:\n\n```compile_fail,E0395\nstatic FOO: i32 = 42;\nstatic BAR: i32 = 42;\n\nstatic BAZ: bool = { (&amp;FOO as *const i32) == (&amp;BAR as *const i32) };\n// error: raw pointers cannot be compared in statics!\n```\n\nThe address assigned by the linker to `FOO` and `BAR` may or may not\nbe identical, so the value of `BAZ` can\&#39;t be determined.\n\nIf you want to do the comparison, please do it at run-time.\n\nFor example:\n\n```\nstatic FOO: i32 = 42;\nstatic BAR: i32 = 42;\n\nlet baz: bool = { (&amp;FOO as *const i32) == (&amp;BAR as *const i32) };\n// baz isn\&#39;t a constant expression so it\&#39;s ok\n```\n&quot;),
 (&quot;E0161&quot;,
  &quot;\nA value was moved. However, its size was not known at compile time, and only\nvalues of a known size can be moved.\n\nErroneous code example:\n\n```compile_fail\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &amp;[isize] = &amp;[1, 2, 3];\n    let _x: Box&lt;[isize]&gt; = box *array;\n    // error: cannot move a value of type [isize]: the size of [isize] cannot\n    //        be statically determined\n}\n```\n\nIn Rust, you can only move a value when its size is known at compile time.\n\nTo work around this restriction, consider \&quot;hiding\&quot; the value behind a reference:\neither `&amp;x` or `&amp;mut x`. Since a reference has a fixed size, this lets you move\nit around as usual. Example:\n\n```\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &amp;[isize] = &amp;[1, 2, 3];\n    let _x: Box&lt;&amp;[isize]&gt; = box array; // ok!\n}\n```\n&quot;),
 (&quot;E0396&quot;,
  &quot;\nThe value behind a raw pointer can\&#39;t be determined at compile-time\n(or even link-time), which means it can\&#39;t be used in a constant\nexpression. Erroneous code example:\n\n```compile_fail,E0396\nconst REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n\nconst VALUE: u8 = unsafe { *REG_ADDR };\n// error: raw pointers cannot be dereferenced in constants\n```\n\nA possible fix is to dereference your pointer at some point in run-time.\n\nFor example:\n\n```\nconst REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n\nlet reg_value = unsafe { *REG_ADDR };\n```\n&quot;),
 (&quot;E0492&quot;,
  &quot;\nA borrow of a constant containing interior mutability was attempted. Erroneous\ncode example:\n\n```compile_fail,E0492\nuse std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n\nconst A: AtomicUsize = ATOMIC_USIZE_INIT;\nstatic B: &amp;\&#39;static AtomicUsize = &amp;A;\n// error: cannot borrow a constant which may contain interior mutability,\n//        create a static instead\n```\n\nA `const` represents a constant value that should never change. If one takes\na `&amp;` reference to the constant, then one is taking a pointer to some memory\nlocation containing the value. Normally this is perfectly fine: most values\ncan\&#39;t be changed via a shared `&amp;` pointer, but interior mutability would allow\nit. That is, a constant value could be mutated. On the other hand, a `static` is\nexplicitly a single memory location, which can be mutated at will.\n\nSo, in order to solve this error, either use statics which are `Sync`:\n\n```\nuse std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n\nstatic A: AtomicUsize = ATOMIC_USIZE_INIT;\nstatic B: &amp;\&#39;static AtomicUsize = &amp;A; // ok!\n```\n\nYou can also have this error while using a cell type:\n\n```compile_fail,E0492\n#![feature(const_fn)]\n\nuse std::cell::Cell;\n\nconst A: Cell&lt;usize&gt; = Cell::new(1);\nconst B: &amp;\&#39;static Cell&lt;usize&gt; = &amp;A;\n// error: cannot borrow a constant which may contain interior mutability,\n//        create a static instead\n\n// or:\nstruct C { a: Cell&lt;usize&gt; }\n\nconst D: C = C { a: Cell::new(1) };\nconst E: &amp;\&#39;static Cell&lt;usize&gt; = &amp;D.a; // error\n\n// or:\nconst F: &amp;\&#39;static C = &amp;D; // error\n```\n\nThis is because cell types do operations that are not thread-safe. Due to this,\nthey don\&#39;t implement Sync and thus can\&#39;t be placed in statics. In this\ncase, `StaticMutex` would work just fine, but it isn\&#39;t stable yet:\nhttps://doc.rust-lang.org/nightly/std/sync/struct.StaticMutex.html\n\nHowever, if you still wish to use these types, you can achieve this by an unsafe\nwrapper:\n\n```\n#![feature(const_fn)]\n\nuse std::cell::Cell;\nuse std::marker::Sync;\n\nstruct NotThreadSafe&lt;T&gt; {\n    value: Cell&lt;T&gt;,\n}\n\nunsafe impl&lt;T&gt; Sync for NotThreadSafe&lt;T&gt; {}\n\nstatic A: NotThreadSafe&lt;usize&gt; = NotThreadSafe { value : Cell::new(1) };\nstatic B: &amp;\&#39;static NotThreadSafe&lt;usize&gt; = &amp;A; // ok!\n```\n\nRemember this solution is unsafe! You will have to ensure that accesses to the\ncell are synchronized.\n&quot;),
 (&quot;E0493&quot;,
  &quot;\nA type with a destructor was assigned to an invalid type of variable. Erroneous\ncode example:\n\n```compile_fail,E0493\nstruct Foo {\n    a: u32\n}\n\nimpl Drop for Foo {\n    fn drop(&amp;mut self) {}\n}\n\nconst F : Foo = Foo { a : 0 };\n// error: constants are not allowed to have destructors\nstatic S : Foo = Foo { a : 0 };\n// error: destructors in statics are an unstable feature\n```\n\nTo solve this issue, please use a type which does allow the usage of type with\ndestructors.\n&quot;),
 (&quot;E0494&quot;,
  &quot;\nA reference of an interior static was assigned to another const/static.\nErroneous code example:\n\n```compile_fail,E0494\nstruct Foo {\n    a: u32\n}\n\nstatic S : Foo = Foo { a : 0 };\nstatic A : &amp;\&#39;static u32 = &amp;S.a;\n// error: cannot refer to the interior of another static, use a\n//        constant instead\n```\n\nThe \&quot;base\&quot; variable has to be a const if you want another static/const variable\nto refer to one of its fields. Example:\n\n```\nstruct Foo {\n    a: u32\n}\n\nconst S : Foo = Foo { a : 0 };\nstatic A : &amp;\&#39;static u32 = &amp;S.a; // ok!\n```\n&quot;),
 (&quot;E0499&quot;,
  &quot;\nA variable was borrowed as mutable more than once. Erroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &amp;mut i;\nlet mut a = &amp;mut i;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in rust, you can either have many immutable references, or one\nmutable reference. Take a look at\nhttps://doc.rust-lang.org/stable/book/references-and-borrowing.html for more\ninformation. Example:\n\n\n```\nlet mut i = 0;\nlet mut x = &amp;mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &amp;i; // ok!\nlet b = &amp;i; // still ok!\nlet c = &amp;i; // still ok!\n```\n&quot;),
 (&quot;E0500&quot;,
  &quot;\nA borrowed variable was used in another closure. Example of erroneous code:\n\n```compile_fail\nfn you_know_nothing(jon_snow: &amp;mut i32) {\n    let nights_watch = || {\n        *jon_snow = 2;\n    };\n    let starks = || {\n        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n                       //        but it is already borrowed\n    };\n}\n```\n\nIn here, `jon_snow` is already borrowed by the `nights_watch` closure, so it\ncannot be borrowed by the `starks` closure at the same time. To fix this issue,\nyou can put the closure in its own scope:\n\n```\nfn you_know_nothing(jon_snow: &amp;mut i32) {\n    {\n        let nights_watch = || {\n            *jon_snow = 2;\n        };\n    } // At this point, `jon_snow` is free.\n    let starks = || {\n        *jon_snow = 3;\n    };\n}\n```\n\nOr, if the type implements the `Clone` trait, you can clone it between\nclosures:\n\n```\nfn you_know_nothing(jon_snow: &amp;mut i32) {\n    let mut jon_copy = jon_snow.clone();\n    let nights_watch = || {\n        jon_copy = 2;\n    };\n    let starks = || {\n        *jon_snow = 3;\n    };\n}\n```\n&quot;),
 (&quot;E0501&quot;,
  &quot;\nThis error indicates that a mutable variable is being used while it is still\ncaptured by a closure. Because the closure has borrowed the variable, it is not\navailable for use until the closure goes out of scope.\n\nNote that a capture will either move or borrow a variable, but in this\nsituation, the closure is borrowing the variable. Take a look at\nhttp://rustbyexample.com/fn/closures/capture.html for more information about\ncapturing.\n\nExample of erroneous code:\n\n```compile_fail,E0501\nfn inside_closure(x: &amp;mut i32) {\n    // Actions which require unique access\n}\n\nfn outside_closure(x: &amp;mut i32) {\n    // Actions which require unique access\n}\n\nfn foo(a: &amp;mut i32) {\n    let bar = || {\n        inside_closure(a)\n    };\n    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n                        //        closure requires unique access.\n}\n```\n\nTo fix this error, you can place the closure in its own scope:\n\n```\nfn inside_closure(x: &amp;mut i32) {}\nfn outside_closure(x: &amp;mut i32) {}\n\nfn foo(a: &amp;mut i32) {\n    {\n        let bar = || {\n            inside_closure(a)\n        };\n    } // borrow on `a` ends.\n    outside_closure(a); // ok!\n}\n```\n\nOr you can pass the variable as a parameter to the closure:\n\n```\nfn inside_closure(x: &amp;mut i32) {}\nfn outside_closure(x: &amp;mut i32) {}\n\nfn foo(a: &amp;mut i32) {\n    let bar = |s: &amp;mut i32| {\n        inside_closure(s)\n    };\n    outside_closure(a);\n    bar(a);\n}\n```\n\nIt may be possible to define the closure later:\n\n```\nfn inside_closure(x: &amp;mut i32) {}\nfn outside_closure(x: &amp;mut i32) {}\n\nfn foo(a: &amp;mut i32) {\n    outside_closure(a);\n    let bar = || {\n        inside_closure(a)\n    };\n}\n```\n&quot;),
 (&quot;E0502&quot;,
  &quot;\nThis error indicates that you are trying to borrow a variable as mutable when it\nhas already been borrowed as immutable.\n\nExample of erroneous code:\n\n```compile_fail,E0502\nfn bar(x: &amp;mut i32) {}\nfn foo(a: &amp;mut i32) {\n    let ref y = a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n}\n```\n\nTo fix this error, ensure that you don\&#39;t have any other references to the\nvariable before trying to access it mutably:\n\n```\nfn bar(x: &amp;mut i32) {}\nfn foo(a: &amp;mut i32) {\n    bar(a);\n    let ref y = a; // ok!\n}\n```\n\nFor more information on the rust ownership system, take a look at\nhttps://doc.rust-lang.org/stable/book/references-and-borrowing.html.\n&quot;),
 (&quot;E0503&quot;,
  &quot;\nA value was used after it was mutably borrowed.\n\nExample of erroneous code:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`. This borrow\n    // lives until the end of this function.\n    let _borrow = &amp;mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust\&#39;s mutability rules.\n\nYou can fix this error by limiting the scope of the borrow:\n\n```\nfn main() {\n    let mut value = 3;\n    // By creating a new block, you can limit the scope\n    // of the reference.\n    {\n        let _borrow = &amp;mut value; // Use `_borrow` inside this block.\n    }\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let _borrow = &amp;mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n}\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/stable/book/references-and-borrowing.html\n&quot;),
 (&quot;E0504&quot;,
  &quot;\nThis error occurs when an attempt is made to move a borrowed variable into a\nclosure.\n\nExample of erroneous code:\n\n```compile_fail,E0504\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &amp;fancy_num;\n\n    let x = move || {\n        println!(\&quot;child function: {}\&quot;, fancy_num.num);\n        // error: cannot move `fancy_num` into closure because it is borrowed\n    };\n\n    x();\n    println!(\&quot;main function: {}\&quot;, fancy_ref.num);\n}\n```\n\nHere, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\nthe closure `x`. There is no way to move a value into a closure while it is\nborrowed, as that would invalidate the borrow.\n\nIf the closure can\&#39;t outlive the value being moved, try using a reference\nrather than moving:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &amp;fancy_num;\n\n    let x = move || {\n        // fancy_ref is usable here because it doesn\&#39;t move `fancy_num`\n        println!(\&quot;child function: {}\&quot;, fancy_ref.num);\n    };\n\n    x();\n\n    println!(\&quot;main function: {}\&quot;, fancy_num.num);\n}\n```\n\nIf the value has to be borrowed and then moved, try limiting the lifetime of\nthe borrow using a scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n\n    {\n        let fancy_ref = &amp;fancy_num;\n        println!(\&quot;main function: {}\&quot;, fancy_ref.num);\n        // `fancy_ref` goes out of scope here\n    }\n\n    let x = move || {\n        // `fancy_num` can be moved now (no more references exist)\n        println!(\&quot;child function: {}\&quot;, fancy_num.num);\n    };\n\n    x();\n}\n```\n\nIf the lifetime of a reference isn\&#39;t enough, such as in the case of threading,\nconsider using an `Arc` to create a reference-counted value:\n\n```\nuse std::sync::Arc;\nuse std::thread;\n\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n    let fancy_ref2 = fancy_ref1.clone();\n\n    let x = thread::spawn(move || {\n        // `fancy_ref1` can be moved and has a `\&#39;static` lifetime\n        println!(\&quot;child thread: {}\&quot;, fancy_ref1.num);\n    });\n\n    x.join().expect(\&quot;child thread should finish\&quot;);\n    println!(\&quot;main thread: {}\&quot;, fancy_ref2.num);\n}\n```\n&quot;),
 (&quot;E0505&quot;,
  &quot;\nA value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &amp;Value = &amp;x;\n        eat(x);\n    }\n}\n```\n\nHere, the function `eat` takes the ownership of `x`. However,\n`x` cannot be moved because it was borrowed to `_ref_to_val`.\nTo fix that you can do few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn eat(val: &amp;Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &amp;Value = &amp;x;\n        eat(&amp;x); // pass by reference, if it\&#39;s possible\n    }\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &amp;Value = &amp;x;\n    }\n    eat(x); // release borrow and then move it.\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &amp;Value = &amp;x;\n        eat(x); // it will be copied here.\n    }\n}\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/stable/book/references-and-borrowing.html\n&quot;),
 (&quot;E0506&quot;,
  &quot;\nThis error occurs when an attempt is made to assign to a borrowed value.\n\nExample of erroneous code:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &amp;fancy_num;\n    fancy_num = FancyNum { num: 6 };\n    // error: cannot assign to `fancy_num` because it is borrowed\n\n    println!(\&quot;Num: {}, Ref: {}\&quot;, fancy_num.num, fancy_ref.num);\n}\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can\&#39;t\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n    let moved_num = fancy_num;\n    fancy_num = FancyNum { num: 6 };\n\n    println!(\&quot;Num: {}, Moved num: {}\&quot;, fancy_num.num, moved_num.num);\n}\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n\n    {\n        let fancy_ref = &amp;fancy_num;\n        println!(\&quot;Ref: {}\&quot;, fancy_ref.num);\n    }\n\n    // Works because `fancy_ref` is no longer in scope\n    fancy_num = FancyNum { num: 6 };\n    println!(\&quot;Num: {}\&quot;, fancy_num.num);\n}\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n\n    print_fancy_ref(&amp;fancy_num);\n\n    // Works because function borrow has ended\n    fancy_num = FancyNum { num: 6 };\n    println!(\&quot;Num: {}\&quot;, fancy_num.num);\n}\n\nfn print_fancy_ref(fancy_ref: &amp;FancyNum){\n    println!(\&quot;Ref: {}\&quot;, fancy_ref.num);\n}\n```\n&quot;)]</code></pre><div class='stability'><div class='stab unstable'><details><summary><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>rustc_private</code>)</summary><p>this crate is being loaded from the sysroot, and unstable location; did you mean to load this crate from crates.io via <code>Cargo.toml</code> instead?</p>
</details></div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "rustc_mir";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>