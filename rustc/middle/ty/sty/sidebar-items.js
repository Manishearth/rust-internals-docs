initSidebarItems({"enum":[["BoundRegion",""],["BuiltinBound",""],["FnOutput",""],["InferTy",""],["Region","Representation of regions.Unlike types, most region variants are \"fictitious\", not concrete, regions. Among these, `ReStatic`, `ReEmpty` and `ReScope` are the only ones representing concrete regions.Bound RegionsThese are regions that are stored behind a binder and must be substituted with some concrete region before being used. There are 2 kind of bound regions: early-bound, which are bound in a TypeScheme/TraitDef, and are substituted by a Substs,  and late-bound, which are part of higher-ranked types (e.g. `for<'a> fn(&'a ())`) and are substituted by the likes of `liberate_late_bound_regions`. The distinction exists because higher-ranked lifetimes aren't supported in all places. See [1][2].Unlike TyParam-s, bound regions are not supposed to exist \"in the wild\" outside their binder, e.g. in types passed to type inference, and should first be substituted (by skolemized regions, free regions, or region variables).Skolemized and Free RegionsOne often wants to work with bound regions without knowing their precise identity. For example, when checking a function, the lifetime of a borrow can end up being assigned to some region parameter. In these cases, it must be ensured that bounds on the region can't be accidentally assumed without being checked.The process of doing that is called \"skolemization\". The bound regions are replaced by skolemized markers, which don't satisfy any relation not explicity provided.There are 2 kinds of skolemized regions in rustc: `ReFree` and `ReSkolemized`. When checking an item's body, `ReFree` is supposed to be used. These also support explicit bounds: both the internally-stored *scope*, which the region is assumed to outlive, as well as other relations stored in the `FreeRegionMap`. Note that these relations aren't checked when you `make_subregion` (or `mk_eqty`), only by `resolve_regions_and_report_errors`.When working with higher-ranked types, some region relations aren't yet known, so you can't just call `resolve_regions_and_report_errors`. `ReSkolemized` is designed for this purpose. In these contexts, there's also the risk that some inference variable laying around will get unified with your skolemized region: if you want to check whether `for<'a> Foo<'_>: 'a`, and you substitute your bound region `'a` with a skolemized region `'%a`, the variable `'_` would just be instantiated to the skolemized region `'%a`, which is wrong because the inference variable is supposed to satisfy the relation *for every value of the skolemized region*. To ensure that doesn't happen, you can use `leak_check`. This is more clearly explained by infer/higher_ranked/README.md.[1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/ [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/"],["TypeVariants",""]],"struct":[["BareFnTy",""],["Binder","Binder is a binder for higher-ranked lifetimes. It is part of the compiler's representation for things like `for<'a> Fn(&'a isize)` (which would be represented by the type `PolyTraitRef == Binder<TraitRef>`). Note that when we skolemize, instantiate, erase, or otherwise \"discharge\" these bound regions, we change the type from `Binder<T>` to just `T` (see e.g. `liberate_late_bound_regions`)."],["BuiltinBounds",""],["ClosureSubsts","A closure can be modeled as a struct that looks like:where 'l0...'li and T0...Tj are the lifetime and type parameters in scope on the function that defined the closure, and U0...Uk are type parameters representing the types of its upvars (borrowed, if appropriate).So, for example, given this function:the type of the closure would be something like:Note that the type of the upvar is not specified in the struct. You may wonder how the impl would then be able to use the upvar, if it doesn't know it's type? The answer is that the impl is (conceptually) not fully generic over Closure but rather tied to instances with the expected upvar types:You can see that the *impl* fully specified the type of the upvar and thus knows full well that `data` has type `&'b mut &'a mut T`. (Here, I am assuming that `data` is mut-borrowed.)Now, the last question you may ask is: Why include the upvar types as extra type parameters? The reason for this design is that the upvar types can reference lifetimes that are internal to the creating function. In my example above, for example, the lifetime `'b` represents the extent of the closure itself; this is some subset of `foo`, probably just the extent of the call to the to `do()`. If we just had the lifetime/type parameters from the enclosing function, we couldn't name this lifetime `'b`. Note that there can also be lifetimes in the types of the upvars themselves, if one of them happens to be a reference to something that the creating fn owns.OK, you say, so why not create a more minimal set of parameters that just includes the extra lifetime parameters? The answer is primarily that it would be hard --- we don't know at the time when we create the closure type what the full types of the upvars are, nor do we know which are borrowed and which are not. In this design, we can just supply a fresh type parameter and figure that out later.All right, you say, but why include the type parameters from the original function then? The answer is that trans may need them when monomorphizing, and they may not appear in the upvars.  A closure could capture no variables but still make use of some in-scope type parameter with a bound (e.g., if our example above had an extra `U: Default`, and the closure called `U::default()`).There is another reason. This design (implicitly) prohibits closures from capturing themselves (except via a trait object). This simplifies closure inference considerably, since it means that when we infer the kind of a closure or its upvars, we don't have to handle cycles where the decisions we make for closure C wind up influencing the decisions we ought to make for closure C (which would then require fixed point iteration to handle). Plus it fixes an ICE. :P"],["ClosureTy",""],["DebruijnIndex","A De Bruijn index is a standard means of representing regions (and perhaps later types) in a higher-ranked setting. In particular, imagine a type like this:In this type, there are two binders (the outer fn and the inner fn). We need to be able to determine, for any given region, which fn type it is bound by, the inner or the outer one. There are various ways you can do this, but a De Bruijn index is one of the more convenient and has some nice properties. The basic idea is to count the number of binders, inside out. Some examples should help clarify what I mean.Let's start with the reference type `&'b isize` that is the first argument to the inner function. This region `'b` is assigned a De Bruijn index of 1, meaning \"the innermost binder\" (in this case, a fn). The region `'a` that appears in the second argument type (`&'a isize`) would then be assigned a De Bruijn index of 2, meaning \"the second-innermost binder\". (These indices are written on the arrays in the diagram).What is interesting is that De Bruijn index attached to a particular variable will vary depending on where it appears. For example, the final type `&'a char` also refers to the region `'a` declared on the outermost fn. But this time, this reference is not nested within any other binders (i.e., it is not an argument to the inner fn, but rather the outer one). Therefore, in this case, it is assigned a De Bruijn index of 1, because the innermost binder in that location is the outer fn."],["EarlyBoundRegion",""],["ExistentialBounds","Bounds suitable for an existentially quantified type parameter such as those that appear in object types or closure types."],["FloatVid",""],["FnSig","Signature of a function type, which I have arbitrarily decided to use to refer to the input/output types.`inputs` is the list of arguments and their modes. `output` is the return type. `variadic` indicates whether this is a variadic function. (only true for foreign fns)"],["FreeRegion","A \"free\" region `fr` can be interpreted as \"some region at least as big as the scope `fr.scope`\"."],["IntVid",""],["ParamTy",""],["ProjectionTy","Represents the projection of an associated type. In explicit UFCS form this would be written `<T as Trait<..>>::N`."],["RegionVid",""],["SkolemizedRegionVid",""],["TraitRef","A complete reference to a trait. These take numerous guises in syntax, but perhaps the most recognizable form is in a where clause:This would be represented by a trait-reference where the def-id is the def-id for the trait `Foo` and the substs defines `T` as parameter 0 in the `SelfSpace` and `U` as parameter 0 in the `TypeSpace`.Trait references also appear in object types like `Foo<U>`, but in that case the `Self` parameter is absent from the substitutions.Note that a `TraitRef` introduces a level of region binding, to account for higher-ranked trait bounds like `T : for<'a> Foo<&'a U>` or higher-ranked object types."],["TraitTy",""],["TyVid",""],["TypeAndMut",""]],"type":[["PolyFnOutput",""],["PolyFnSig",""],["PolyTraitRef",""]]});