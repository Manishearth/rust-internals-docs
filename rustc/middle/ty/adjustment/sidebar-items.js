initSidebarItems({"enum":[["AutoAdjustment",""],["AutoRef",""],["CustomCoerceUnsized",""]],"struct":[["AutoDerefRef","Represents coercing a pointer to a different kind of pointer - where 'kind' here means either or both of raw vs borrowed vs unique and fat vs thin.We transform pointers by following the following steps in order: 1. Deref the pointer `self.autoderefs` times (may be 0). 2. If `autoref` is `Some(_)`, then take the address and produce either a    `&` or `*` pointer. 3. If `unsize` is `Some(_)`, then apply the unsize transformation,    which will do things like convert thin pointers to fat    pointers, or convert structs containing thin pointers to    structs containing fat pointers, or convert between fat    pointers.  We don't store the details of how the transform is    done (in fact, we don't know that, because it might depend on    the precise type parameters). We just store the target    type. Trans figures out what has to be done at monomorphization    time based on the precise source/target type at hand.To make that more concrete, here are some common scenarios:The simplest cases are where the pointer is not adjusted fat vs thin. Here the pointer will be dereferenced N times (where a dereference can happen to raw or borrowed pointers or any smart pointer which implements Deref, including Box<_>). The number of dereferences is given by `autoderefs`.  It can then be auto-referenced zero or one times, indicated by `autoref`, to either a raw or borrowed pointer. In these cases unsize is None.A thin-to-fat coercon involves unsizing the underlying data. We start with a thin pointer, deref a number of times, unsize the underlying data, then autoref. The 'unsize' phase may change a fixed length array to a dynamically sized one, a concrete object to a trait object, or statically sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is represented by:Note that for a struct, the 'deep' unsizing of the struct is not recorded. E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]> The autoderef and -ref are the same as in the above example, but the type stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about the underlying conversions from `[i32; 4]` to `[i32]`.Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In that case, we have the pointer we need coming in, so there are no autoderefs, and no autoref. Instead we just do the `Unsize` transformation. At some point, of course, `Box` should move out of the compiler, in which case this is analogous to transformating a struct. E.g., Box<[i32; 4]> -> Box<[i32]> is represented by:"]]});