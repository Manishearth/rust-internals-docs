initSidebarItems({"constant":[["FAT_PTR_ADDR","The first half of a fat pointer. - For a trait object, this is the address of the box. - For a slice, this is the base address."],["FAT_PTR_EXTRA","The second half of a fat pointer. - For a trait object, this is the address of the vtable. - For a slice, this is the length."]],"enum":[["Endian","Endianness of the target, which must match cfg(target-endian)."],["Integer","Integers, also used for enum discriminants."],["Layout","Type layout, from which size and alignment can be cheaply computed. For ADTs, it also includes field placement and enum optimizations. NOTE: Because Layout is interned, redundant information should be kept to a minimum, e.g. it includes no sub-component Ty or Layout."],["LayoutError",""],["Primitive","Fundamental unit of memory access and layout."],["SizeSkeleton","Type size \"skeleton\", i.e. the only information determining a type's size. While this is conservative, (aside from constant sizes, only pointers, newtypes thereof and null pointer optimized enums are allowed), it is enough to statically check common usecases of transmute."]],"struct":[["Align","Alignment of a type in bytes, both ABI-mandated and preferred. Each field is a power of two, giving the alignment a maximum value of 2^(2^8 - 1), which is limited by LLVM to a i32, with a maximum capacity of 2^31 - 1 or 2147483647."],["LayoutCx","Combines a tcx with the parameter environment so that you can compute layout operations."],["Size","Size of a type in bytes."],["Struct","A structure, a product type in ADT terms."],["TargetDataLayout","Parsed Data layout for a target, which contains everything needed to compute layouts."],["TyLayout","A pair of a type and its layout. Implements various type traversal APIs (e.g. recursing into fields)."],["Union","An untagged union."]],"trait":[["HasDataLayout",""],["LayoutTyper",""]],"type":[["FieldPath","Path through fields of nested structures."]]});