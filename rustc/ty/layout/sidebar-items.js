initSidebarItems({"constant":[["FAT_PTR_ADDR","The first half of a fat pointer. - For a trait object, this is the address of the box. - For a slice, this is the base address."],["FAT_PTR_EXTRA","The second half of a fat pointer. - For a trait object, this is the address of the vtable. - For a slice, this is the length."]],"enum":[["Endian","Endianness of the target, which must match cfg(target-endian)."],["Integer","Integers, also used for enum discriminants."],["Layout","Type layout, from which size and alignment can be cheaply computed. For ADTs, it also includes field placement and enum optimizations. NOTE: Because Layout is interned, redundant information should be kept to a minimum, e.g. it includes no sub-component Ty or Layout."],["LayoutError",""],["Primitive","Fundamental unit of memory access and layout."],["SizeSkeleton","Type size \"skeleton\", i.e. the only information determining a type's size. While this is conservative, (aside from constant sizes, only pointers, newtypes thereof and null pointer optimized enums are allowed), it is enough to statically check common usecases of transmute."]],"struct":[["Align","Alignment of a type in bytes, both ABI-mandated and preferred. Since alignments are always powers of 2, we can pack both in one byte, giving each a nibble (4 bits) for a maximum alignment of 2^15 = 32768."],["Size","Size of a type in bytes."],["Struct","A structure, a product type in ADT terms."],["TargetDataLayout","Parsed Data layout for a target, which contains everything needed to compute layouts."]],"type":[["FieldPath","Path through fields of nested structures."]]});