<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `DIAGNOSTICS` constant in crate `rustc`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, DIAGNOSTICS">

    <title>rustc::DIAGNOSTICS - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../rustc/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='logo' width='100'></a>
        <p class='location'><a href='index.html'>rustc</a></p><script>window.sidebarCurrent = {name: 'DIAGNOSTICS', ty: 'constant', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content constant">
<h1 class='fqn'><span class='in-band'><a href='index.html'>rustc</a>::<wbr><a class='constant' href=''>DIAGNOSTICS</a></span><span class='out-of-band'><span class='since' title='Stable since Rust version '></span><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-58841' class='srclink' href='../src/rustc/src/librustc/lib.rs.html#149' title='goto source code'>[src]</a></span></h1>
<pre class='rust const'>pub const DIAGNOSTICS: <a class='primitive' href='../std/primitive.array.html'>[</a><a class='primitive' href='../std/primitive.tuple.html'>(</a>&amp;'static <a class='primitive' href='../std/primitive.str.html'>str</a>, &amp;'static <a class='primitive' href='../std/primitive.str.html'>str</a><a class='primitive' href='../std/primitive.tuple.html'>)</a><a class='primitive' href='../std/primitive.array.html'>; 40usize]</a><code> = </code><code>[(&quot;E0020&quot;,
  &quot;\nThis error indicates that an attempt was made to divide by zero (or take the\nremainder of a zero divisor) in a static or constant expression. Erroneous\ncode example:\n\n```compile_fail\nconst X: i32 = 42 / 0;\n// error: attempted to divide by zero in a constant expression\n```\n&quot;),
 (&quot;E0038&quot;,
  &quot;\nTrait objects like `Box&lt;Trait&gt;` can only be constructed when certain\nrequirements are satisfied by the trait in question.\n\nTrait objects are a form of dynamic dispatch and use a dynamically sized type\nfor the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\ntype, as in `Box&lt;Trait&gt;`, the inner type is \&#39;unsized\&#39;. In such cases the boxed\npointer is a \&#39;fat pointer\&#39; that contains an extra pointer to a table of methods\n(among other things) for dynamic dispatch. This design mandates some\nrestrictions on the types of traits that are allowed to be used in trait\nobjects, which are collectively termed as \&#39;object safety\&#39; rules.\n\nAttempting to create a trait object for a non object-safe trait will trigger\nthis error.\n\nThere are various rules:\n\n### The trait cannot require `Self: Sized`\n\nWhen `Trait` is treated as a type, the type does not implement the special\n`Sized` trait, because the type does not have a known size at compile time and\ncan only be accessed behind a pointer. Thus, if we have a trait like the\nfollowing:\n\n```\ntrait Foo where Self: Sized {\n\n}\n```\n\nWe cannot create an object of type `Box&lt;Foo&gt;` or `&amp;Foo` since in this case\n`Self` would not be `Sized`.\n\nGenerally, `Self : Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its arguments or return type\n\nThis happens when a trait has a method like the following:\n\n```compile_fail\ntrait Trait {\n    fn foo(&amp;self) -&gt; Self;\n}\n\nimpl Trait for String {\n    fn foo(&amp;self) -&gt; Self {\n        \&quot;hi\&quot;.to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&amp;self) -&gt; Self {\n        1\n    }\n}\n```\n\n(Note that `&amp;self` and `&amp;mut self` are okay, it\&#39;s additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail\ntrait Trait {\n    fn foo(&amp;self) -&gt; Self;\n}\n\nfn call_foo(x: Box&lt;Trait&gt;) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren\&#39;t object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box&lt;Trait&gt;` which is itself sized (assuming you `impl Trait for Box&lt;Trait&gt;`).\n\n```\ntrait Trait {\n    fn foo(&amp;self) -&gt; Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren\&#39;t behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&amp;self);\n}\n\nimpl Trait for String {\n    fn foo(&amp;self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&amp;self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo&lt;T&gt;(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::&lt;u8&gt;()`, `foo::&lt;bool&gt;()`, `foo::&lt;String&gt;()`, or any\nother type substitution is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::&lt;bool&gt;()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with unparametrized substitutions\n(i.e., substitutions where none of the substituted types are themselves\nparametrized).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo&lt;T&gt;(&amp;self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo&lt;T&gt;(&amp;self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo&lt;T&gt;(&amp;self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```ignore\nfn call_foo(thing: Box&lt;Trait&gt;) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\&quot;hello\&quot;);\n}\n```\n\nWe don\&#39;t just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo&lt;T&gt;(&amp;self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g. if `T: OtherTrait`, use `on: Box&lt;OtherTrait&gt;`). If the number\nof types you intend to feed to this method is limited, consider manually listing\nout the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can\&#39;t be called since there won\&#39;t be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -&gt; u8;\n}\n```\n\nThis could be called as `&lt;Foo as Foo&gt;::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -&gt; u8 where Self: Sized;\n}\n```\n\n### The trait cannot use `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail\ntrait Super&lt;A&gt; {}\n\ntrait Trait: Super&lt;Self&gt; {\n}\n\nstruct Foo;\n\nimpl Super&lt;Foo&gt; for Foo{}\n\nimpl Trait for Foo {}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super&lt;A&gt; {\n    fn get_a(&amp;self) -&gt; A; // note that this is object safe!\n}\n```\n\nIf the trait `Foo` was deriving from something like `Super&lt;String&gt;` or\n`Super&lt;T&gt;` (where `Foo` itself is `Foo&lt;T&gt;`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super&lt;Self&gt;`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere\&#39;s no easy fix for this, generally code will need to be refactored so that\nyou no longer need to derive from `Super&lt;Self&gt;`.\n&quot;),
 (&quot;E0072&quot;,
  &quot;\nWhen defining a recursive struct or enum, any use of the type being defined\nfrom inside the definition must occur behind a pointer (like `Box` or `&amp;`).\nThis is because structs and enums must have a well-defined size, and without\nthe pointer, the size of the type would need to be unbounded.\n\nConsider the following erroneous definition of a type for a list of bytes:\n\n```compile_fail\n// error, invalid recursive struct type\nstruct ListNode {\n    head: u8,\n    tail: Option&lt;ListNode&gt;,\n}\n```\n\nThis type cannot have a well-defined size, because it needs to be arbitrarily\nlarge (since we would be able to nest `ListNode`s to any depth). Specifically,\n\n```plain\nsize of `ListNode` = 1 byte for `head`\n                   + 1 byte for the discriminant of the `Option`\n                   + size of `ListNode`\n```\n\nOne way to fix this is by wrapping `ListNode` in a `Box`, like so:\n\n```\nstruct ListNode {\n    head: u8,\n    tail: Option&lt;Box&lt;ListNode&gt;&gt;,\n}\n```\n\nThis works because `Box` is a pointer, so its size is well-known.\n&quot;),
 (&quot;E0109&quot;,
  &quot;\nYou tried to give a type parameter to a type which doesn\&#39;t need it. Erroneous\ncode example:\n\n```compile_fail\ntype X = u32&lt;i32&gt;; // error: type parameters are not allowed on this type\n```\n\nPlease check that you used the correct type and recheck its definition. Perhaps\nit doesn\&#39;t need the type parameter.\n\nExample:\n\n```\ntype X = u32; // this compiles\n```\n\nNote that type parameters for enum-variant constructors go after the variant,\nnot after the enum (Option::None::&lt;u32&gt;, not Option::&lt;u32&gt;::None).\n&quot;),
 (&quot;E0110&quot;,
  &quot;\nYou tried to give a lifetime parameter to a type which doesn\&#39;t need it.\nErroneous code example:\n\n```compile_fail\ntype X = u32&lt;\&#39;static&gt;; // error: lifetime parameters are not allowed on\n                       //        this type\n```\n\nPlease check that the correct type was used and recheck its definition; perhaps\nit doesn\&#39;t need the lifetime parameter. Example:\n\n```\ntype X = u32; // ok!\n```\n&quot;),
 (&quot;E0133&quot;,
  &quot;\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); }\n}\n```\n\nSee also https://doc.rust-lang.org/book/unsafe.html\n&quot;),
 (&quot;E0136&quot;,
  &quot;\nA binary can only have one entry point, and by default that entry point is the\nfunction `main()`. If there are multiple such functions, please rename one.\n&quot;),
 (&quot;E0137&quot;,
  &quot;\nThis error indicates that the compiler found multiple functions with the\n`#[main]` attribute. This is an error because there must be a unique entry\npoint into a Rust program.\n&quot;),
 (&quot;E0138&quot;,
  &quot;\nThis error indicates that the compiler found multiple functions with the\n`#[start]` attribute. This is an error because there must be a unique entry\npoint into a Rust program.\n&quot;),
 (&quot;E0139&quot;,
  &quot;\nThere are various restrictions on transmuting between types in Rust; for example\ntypes being transmuted must have the same size. To apply all these restrictions,\nthe compiler must know the exact types that may be transmuted. When type\nparameters are involved, this cannot always be done.\n\nSo, for example, the following is not allowed:\n\n```compile_fail\nstruct Foo&lt;T&gt;(Vec&lt;T&gt;);\n\nfn foo&lt;T&gt;(x: Vec&lt;T&gt;) {\n    // we are transmuting between Vec&lt;T&gt; and Foo&lt;T&gt; here\n    let y: Foo&lt;T&gt; = unsafe { transmute(x) };\n    // do something with y\n}\n```\n\nIn this specific case there\&#39;s a good chance that the transmute is harmless (but\nthis is not guaranteed by Rust). However, when alignment and enum optimizations\ncome into the picture, it\&#39;s quite likely that the sizes may or may not match\nwith different type parameter substitutions. It\&#39;s not possible to check this for\n_all_ possible types, so `transmute()` simply only accepts types without any\nunsubstituted type parameters.\n\nIf you need this, there\&#39;s a good chance you\&#39;re doing something wrong. Keep in\nmind that Rust doesn\&#39;t guarantee much about the layout of different structs\n(even two structs with identical declarations may have different layouts). If\nthere is a solution that avoids the transmute entirely, try it instead.\n\nIf it\&#39;s possible, hand-monomorphize the code by writing the function for each\npossible type substitution. It\&#39;s possible to use traits to do this cleanly,\nfor example:\n\n```ignore\nstruct Foo&lt;T&gt;(Vec&lt;T&gt;);\n\ntrait MyTransmutableType {\n    fn transmute(Vec&lt;Self&gt;) -&gt; Foo&lt;Self&gt;;\n}\n\nimpl MyTransmutableType for u8 {\n    fn transmute(x: Foo&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {\n        transmute(x)\n    }\n}\n\nimpl MyTransmutableType for String {\n    fn transmute(x: Foo&lt;String&gt;) -&gt; Vec&lt;String&gt; {\n        transmute(x)\n    }\n}\n\n// ... more impls for the types you intend to transmute\n\nfn foo&lt;T: MyTransmutableType&gt;(x: Vec&lt;T&gt;) {\n    let y: Foo&lt;T&gt; = &lt;T as MyTransmutableType&gt;::transmute(x);\n    // do something with y\n}\n```\n\nEach impl will be checked for a size match in the transmute as usual, and since\nthere are no unbound type parameters involved, this should compile unless there\nis a size mismatch in one of the impls.\n\nIt is also possible to manually transmute:\n\n```ignore\nptr::read(&amp;v as *const _ as *const SomeType) // `v` transmuted to `SomeType`\n```\n\nNote that this does not move `v` (unlike `transmute`), and may need a\ncall to `mem::forget(v)` in case you want to avoid destructors being called.\n&quot;),
 (&quot;E0152&quot;,
  &quot;\nLang items are already implemented in the standard library. Unless you are\nwriting a free-standing application (e.g. a kernel), you do not need to provide\nthem yourself.\n\nYou can build a free-standing crate by adding `#![no_std]` to the crate\nattributes:\n\n```\n#![no_std]\n```\n\nSee also https://doc.rust-lang.org/book/no-stdlib.html\n&quot;),
 (&quot;E0229&quot;,
  &quot;\nAn associated type binding was done outside of the type parameter declaration\nand `where` clause. Erroneous code example:\n\n```compile_fail\npub trait Foo {\n    type A;\n    fn boo(&amp;self) -&gt; &lt;Self as Foo&gt;::A;\n}\n\nstruct Bar;\n\nimpl Foo for isize {\n    type A = usize;\n    fn boo(&amp;self) -&gt; usize { 42 }\n}\n\nfn baz&lt;I&gt;(x: &amp;&lt;I as Foo&lt;A=Bar&gt;&gt;::A) {}\n// error: associated type bindings are not allowed here\n```\n\nTo solve this error, please move the type bindings in the type parameter\ndeclaration:\n\n```ignore\nfn baz&lt;I: Foo&lt;A=Bar&gt;&gt;(x: &amp;&lt;I as Foo&gt;::A) {} // ok!\n```\n\nOr in the `where` clause:\n\n```ignore\nfn baz&lt;I&gt;(x: &amp;&lt;I as Foo&gt;::A) where I: Foo&lt;A=Bar&gt; {}\n```\n&quot;),
 (&quot;E0261&quot;,
  &quot;\nWhen using a lifetime like `\&#39;a` in a type, it must be declared before being\nused.\n\nThese two examples illustrate the problem:\n\n```compile_fail\n// error, use of undeclared lifetime name `\&#39;a`\nfn foo(x: &amp;\&#39;a str) { }\n\nstruct Foo {\n    // error, use of undeclared lifetime name `\&#39;a`\n    x: &amp;\&#39;a str,\n}\n```\n\nThese can be fixed by declaring lifetime parameters:\n\n```\nfn foo&lt;\&#39;a&gt;(x: &amp;\&#39;a str) {}\n\nstruct Foo&lt;\&#39;a&gt; {\n    x: &amp;\&#39;a str,\n}\n```\n&quot;),
 (&quot;E0262&quot;,
  &quot;\nDeclaring certain lifetime names in parameters is disallowed. For example,\nbecause the `\&#39;static` lifetime is a special built-in lifetime name denoting\nthe lifetime of the entire program, this is an error:\n\n```compile_fail\n// error, invalid lifetime parameter name `\&#39;static`\nfn foo&lt;\&#39;static&gt;(x: &amp;\&#39;static str) { }\n```\n&quot;),
 (&quot;E0263&quot;,
  &quot;\nA lifetime name cannot be declared more than once in the same scope. For\nexample:\n\n```compile_fail\n// error, lifetime name `\&#39;a` declared twice in the same scope\nfn foo&lt;\&#39;a, \&#39;b, \&#39;a&gt;(x: &amp;\&#39;a str, y: &amp;\&#39;b str) { }\n```\n&quot;),
 (&quot;E0264&quot;,
  &quot;\nAn unknown external lang item was used. Erroneous code example:\n\n```compile_fail\n#![feature(lang_items)]\n\nextern \&quot;C\&quot; {\n    #[lang = \&quot;cake\&quot;] // error: unknown external lang item: `cake`\n    fn cake();\n}\n```\n\nA list of available external lang items is available in\n`src/librustc/middle/weak_lang_items.rs`. Example:\n\n```\n#![feature(lang_items)]\n\nextern \&quot;C\&quot; {\n    #[lang = \&quot;panic_fmt\&quot;] // ok!\n    fn cake();\n}\n```\n&quot;),
 (&quot;E0269&quot;,
  &quot;\nFunctions must eventually return a value of their return type. For example, in\nthe following function:\n\n```compile_fail\nfn foo(x: u8) -&gt; u8 {\n    if x &gt; 0 {\n        x // alternatively, `return x`\n    }\n    // nothing here\n}\n```\n\nIf the condition is true, the value `x` is returned, but if the condition is\nfalse, control exits the `if` block and reaches a place where nothing is being\nreturned. All possible control paths must eventually return a `u8`, which is not\nhappening here.\n\nAn easy fix for this in a complicated function is to specify a default return\nvalue, if possible:\n\n```ignore\nfn foo(x: u8) -&gt; u8 {\n    if x &gt; 0 {\n        x // alternatively, `return x`\n    }\n    // lots of other if branches\n    0 // return 0 if all else fails\n}\n```\n\nIt is advisable to find out what the unhandled cases are and check for them,\nreturning an appropriate value or panicking if necessary. Check if you need\nto remove a semicolon from the last expression, like in this case:\n\n```ignore\nfn foo(x: u8) -&gt; u8 {\n    inner(2*x + 1);\n}\n```\n\nThe semicolon discards the return value of `inner`, instead of returning\nit from `foo`.\n&quot;),
 (&quot;E0270&quot;,
  &quot;\nRust lets you define functions which are known to never return, i.e. are\n\&#39;diverging\&#39;, by marking its return type as `!`.\n\nFor example, the following functions never return:\n\n```no_run\nfn foo() -&gt; ! {\n    loop {}\n}\n\nfn bar() -&gt; ! {\n    foo() // foo() is diverging, so this will diverge too\n}\n\nfn baz() -&gt; ! {\n    panic!(); // this macro internally expands to a call to a diverging function\n}\n```\n\nSuch functions can be used in a place where a value is expected without\nreturning a value of that type, for instance:\n\n```no_run\nfn foo() -&gt; ! {\n    loop {}\n}\n\nlet x = 3;\n\nlet y = match x {\n    1 =&gt; 1,\n    2 =&gt; 4,\n    _ =&gt; foo() // diverging function called here\n};\n\nprintln!(\&quot;{}\&quot;, y)\n```\n\nIf the third arm of the match block is reached, since `foo()` doesn\&#39;t ever\nreturn control to the match block, it is fine to use it in a place where an\ninteger was expected. The `match` block will never finish executing, and any\npoint where `y` (like the print statement) is needed will not be reached.\n\nHowever, if we had a diverging function that actually does finish execution:\n\n```ignore\nfn foo() -&gt; ! {\n    loop {break;}\n}\n```\n\nThen we would have an unknown value for `y` in the following code:\n\n```no_run\nfn foo() -&gt; ! {\n    loop {}\n}\n\nlet x = 3;\n\nlet y = match x {\n    1 =&gt; 1,\n    2 =&gt; 4,\n    _ =&gt; foo()\n};\n\nprintln!(\&quot;{}\&quot;, y);\n```\n\nIn the previous example, the print statement was never reached when the\nwildcard match arm was hit, so we were okay with `foo()` not returning an\ninteger that we could set to `y`. But in this example, `foo()` actually does\nreturn control, so the print statement will be executed with an uninitialized\nvalue.\n\nObviously we cannot have functions which are allowed to be used in such\npositions and yet can return control. So, if you are defining a function that\nreturns `!`, make sure that there is no way for it to actually finish\nexecuting.\n&quot;),
 (&quot;E0271&quot;,
  &quot;\nThis is because of a type mismatch between the associated type of some\ntrait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\nand another type `U` that is required to be equal to `T::Bar`, but is not.\nExamples follow.\n\nHere is a basic example:\n\n```compile_fail\ntrait Trait { type AssociatedType; }\n\nfn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType=u32&gt; {\n    println!(\&quot;in foo\&quot;);\n}\n\nimpl Trait for i8 { type AssociatedType = &amp;\&#39;static str; }\n\nfoo(3_i8);\n```\n\nHere is that same example again, with some explanatory comments:\n\n```ignore\ntrait Trait { type AssociatedType; }\n\nfn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType=u32&gt; {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\&quot;in foo\&quot;);\n}\n\nimpl Trait for i8 { type AssociatedType = &amp;\&#39;static str; }\n~~~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&amp;\&#39;static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `&lt;i8 as Trait&gt;::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nHere is a more subtle instance of the same problem, that can\narise with for-loops in Rust:\n\n```compile_fail\nlet vs: Vec&lt;i32&gt; = vec![1, 2, 3, 4];\nfor v in &amp;vs {\n    match v {\n        1 =&gt; {},\n        _ =&gt; {},\n    }\n}\n```\n\nThe above fails because of an analogous type mismatch,\nthough may be harder to see. Again, here are some\nexplanatory comments for the same example:\n\n```ignore\n{\n    let vs = vec![1, 2, 3, 4];\n\n    // `for`-loops use a protocol based on the `Iterator`\n    // trait. Each item yielded in a `for` loop has the\n    // type `Iterator::Item` -- that is, `Item` is the\n    // associated type of the concrete iterator impl.\n    for v in &amp;vs {\n//      ~    ~~~\n//      |     |\n//      |    We borrow `vs`, iterating over a sequence of\n//      |    *references* of type `&amp;Elem` (where `Elem` is\n//      |    vector\&#39;s element type). Thus, the associated\n//      |    type `Item` must be a reference `&amp;`-type ...\n//      |\n//  ... and `v` has the type `Iterator::Item`, as dictated by\n//  the `for`-loop protocol ...\n\n        match v {\n            1 =&gt; {}\n//          ~\n//          |\n// ... but *here*, `v` is forced to have some integral type;\n// only types like `u8`,`i8`,`u16`,`i16`, et cetera can\n// match the pattern `1` ...\n\n            _ =&gt; {}\n        }\n\n// ... therefore, the compiler complains, because it sees\n// an attempt to solve the equations\n// `some integral-type` = type-of-`v`\n//                      = `Iterator::Item`\n//                      = `&amp;Elem` (i.e. `some reference type`)\n//\n// which cannot possibly all be true.\n\n    }\n}\n```\n\nTo avoid those issues, you have to make the types match correctly.\nSo we can fix the previous examples like this:\n\n```\n// Basic Example:\ntrait Trait { type AssociatedType; }\n\nfn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType = &amp;\&#39;static str&gt; {\n    println!(\&quot;in foo\&quot;);\n}\n\nimpl Trait for i8 { type AssociatedType = &amp;\&#39;static str; }\n\nfoo(3_i8);\n\n// For-Loop Example:\nlet vs = vec![1, 2, 3, 4];\nfor v in &amp;vs {\n    match v {\n        &amp;1 =&gt; {}\n        _ =&gt; {}\n    }\n}\n```\n&quot;),
 (&quot;E0272&quot;,
  &quot;\nThe `#[rustc_on_unimplemented]` attribute lets you specify a custom error\nmessage for when a particular trait isn\&#39;t implemented on a type placed in a\nposition that needs that trait. For example, when the following code is\ncompiled:\n\n```compile_fail\nfn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}\n\n#[rustc_on_unimplemented = \&quot;the type `{Self}` cannot be indexed by `{Idx}`\&quot;]\ntrait Index&lt;Idx&gt; { /* ... */ }\n\nfoo(true); // `bool` does not implement `Index&lt;u8&gt;`\n```\n\nThere will be an error about `bool` not implementing `Index&lt;u8&gt;`, followed by a\nnote saying \&quot;the type `bool` cannot be indexed by `u8`\&quot;.\n\nAs you can see, you can specify type parameters in curly braces for\nsubstitution with the actual types (using the regular format string syntax) in\na given situation. Furthermore, `{Self}` will substitute to the type (in this\ncase, `bool`) that we tried to use.\n\nThis error appears when the curly braces contain an identifier which doesn\&#39;t\nmatch with any of the type parameters or the string `Self`. This might happen\nif you misspelled a type parameter, or if you intended to use literal curly\nbraces. If it is the latter, escape the curly braces with a second curly brace\nof the same type; e.g. a literal `{` is `{{`.\n&quot;),
 (&quot;E0273&quot;,
  &quot;\nThe `#[rustc_on_unimplemented]` attribute lets you specify a custom error\nmessage for when a particular trait isn\&#39;t implemented on a type placed in a\nposition that needs that trait. For example, when the following code is\ncompiled:\n\n```compile_fail\nfn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}\n\n#[rustc_on_unimplemented = \&quot;the type `{Self}` cannot be indexed by `{Idx}`\&quot;]\ntrait Index&lt;Idx&gt; { /* ... */ }\n\nfoo(true); // `bool` does not implement `Index&lt;u8&gt;`\n```\n\nthere will be an error about `bool` not implementing `Index&lt;u8&gt;`, followed by a\nnote saying \&quot;the type `bool` cannot be indexed by `u8`\&quot;.\n\nAs you can see, you can specify type parameters in curly braces for\nsubstitution with the actual types (using the regular format string syntax) in\na given situation. Furthermore, `{Self}` will substitute to the type (in this\ncase, `bool`) that we tried to use.\n\nThis error appears when the curly braces do not contain an identifier. Please\nadd one of the same name as a type parameter. If you intended to use literal\nbraces, use `{{` and `}}` to escape them.\n&quot;),
 (&quot;E0274&quot;,
  &quot;\nThe `#[rustc_on_unimplemented]` attribute lets you specify a custom error\nmessage for when a particular trait isn\&#39;t implemented on a type placed in a\nposition that needs that trait. For example, when the following code is\ncompiled:\n\n```compile_fail\nfn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}\n\n#[rustc_on_unimplemented = \&quot;the type `{Self}` cannot be indexed by `{Idx}`\&quot;]\ntrait Index&lt;Idx&gt; { /* ... */ }\n\nfoo(true); // `bool` does not implement `Index&lt;u8&gt;`\n```\n\nthere will be an error about `bool` not implementing `Index&lt;u8&gt;`, followed by a\nnote saying \&quot;the type `bool` cannot be indexed by `u8`\&quot;.\n\nFor this to work, some note must be specified. An empty attribute will not do\nanything, please remove the attribute or add some helpful note for users of the\ntrait.\n&quot;),
 (&quot;E0275&quot;,
  &quot;\nThis error occurs when there was a recursive trait requirement that overflowed\nbefore it could be evaluated. Often this means that there is unbounded\nrecursion in resolving some type bounds.\n\nFor example, in the following code:\n\n```compile_fail\ntrait Foo {}\n\nstruct Bar&lt;T&gt;(T);\n\nimpl&lt;T&gt; Foo for T where Bar&lt;T&gt;: Foo {}\n```\n\nTo determine if a `T` is `Foo`, we need to check if `Bar&lt;T&gt;` is `Foo`. However,\nto do this check, we need to determine that `Bar&lt;Bar&lt;T&gt;&gt;` is `Foo`. To\ndetermine this, we check if `Bar&lt;Bar&lt;Bar&lt;T&gt;&gt;&gt;` is `Foo`, and so on. This is\nclearly a recursive requirement that can\&#39;t be resolved directly.\n\nConsider changing your trait bounds so that they\&#39;re less self-referential.\n&quot;),
 (&quot;E0276&quot;,
  &quot;\nThis error occurs when a bound in an implementation of a trait does not match\nthe bounds specified in the original trait. For example:\n\n```compile_fail\ntrait Foo {\n    fn foo&lt;T&gt;(x: T);\n}\n\nimpl Foo for bool {\n    fn foo&lt;T&gt;(x: T) where T: Copy {}\n}\n```\n\nHere, all types implementing `Foo` must have a method `foo&lt;T&gt;(x: T)` which can\ntake any type `T`. However, in the `impl` for `bool`, we have added an extra\nbound that `T` is `Copy`, which isn\&#39;t compatible with the original trait.\n\nConsider removing the bound from the method or adding the bound to the original\nmethod definition in the trait.\n&quot;),
 (&quot;E0277&quot;,
  &quot;\nYou tried to use a type which doesn\&#39;t implement some trait in a place which\nexpected that trait. Erroneous code example:\n\n```compile_fail\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&amp;self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func&lt;T: Foo&gt;(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn\&#39;t implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you\&#39;re using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&amp;self);\n}\n\nfn some_func&lt;T: Foo&gt;(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&amp;self) {}\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n```compile_fail\nfn some_func&lt;T&gt;(foo: T) {\n    println!(\&quot;{:?}\&quot;, foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function: Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function: It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we\&#39;re\naccepting:\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func&lt;T: fmt::Debug&gt;(foo: T) {\n    println!(\&quot;{:?}\&quot;, foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n```\n\n&quot;),
 (&quot;E0281&quot;,
  &quot;\nYou tried to supply a type which doesn\&#39;t implement some trait in a location\nwhich expected that trait. This error typically occurs when working with\n`Fn`-based types. Erroneous code example:\n\n```compile_fail\nfn foo&lt;F: Fn()&gt;(x: F) { }\n\nfn main() {\n    // type mismatch: the type ... implements the trait `core::ops::Fn&lt;(_,)&gt;`,\n    // but the trait `core::ops::Fn&lt;()&gt;` is required (expected (), found tuple\n    // [E0281]\n    foo(|y| { });\n}\n```\n\nThe issue in this case is that `foo` is defined as accepting a `Fn` with no\narguments, but the closure we attempted to pass to it requires one argument.\n&quot;),
 (&quot;E0282&quot;,
  &quot;\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\n```compile_fail\nlet x = \&quot;hello\&quot;.chars().rev().collect();\n```\n\nIn this case, the compiler cannot infer what the type of `x` should be:\n`Vec&lt;char&gt;` and `String` are both suitable candidates. To specify which type to\nuse, you can use a type annotation on `x`:\n\n```\nlet x: Vec&lt;char&gt; = \&quot;hello\&quot;.chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec&lt;_&gt; = \&quot;hello\&quot;.chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \&quot;hello\&quot;.chars().rev().collect::&lt;Vec&lt;char&gt;&gt;();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \&quot;hello\&quot;.chars().rev().collect::&lt;Vec&lt;_&gt;&gt;();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail\nstruct Foo&lt;T&gt; {\n    num: T,\n}\n\nimpl&lt;T&gt; Foo&lt;T&gt; {\n    fn bar() -&gt; i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::&lt;T&gt;::bar()` to resolve the error.\n&quot;),
 (&quot;E0283&quot;,
  &quot;\nThis error occurs when the compiler doesn\&#39;t have enough information\nto unambiguously choose an implementation.\n\nFor example:\n\n```compile_fail\ntrait Generator {\n    fn create() -&gt; u32;\n}\n\nstruct Impl;\n\nimpl Generator for Impl {\n    fn create() -&gt; u32 { 1 }\n}\n\nstruct AnotherImpl;\n\nimpl Generator for AnotherImpl {\n    fn create() -&gt; u32 { 2 }\n}\n\nfn main() {\n    let cont: u32 = Generator::create();\n    // error, impossible to choose one of Generator trait implementation\n    // Impl or AnotherImpl? Maybe anything else?\n}\n```\n\nTo resolve this error use the concrete type:\n\n```\ntrait Generator {\n    fn create() -&gt; u32;\n}\n\nstruct AnotherImpl;\n\nimpl Generator for AnotherImpl {\n    fn create() -&gt; u32 { 2 }\n}\n\nfn main() {\n    let gen1 = AnotherImpl::create();\n\n    // if there are multiple methods with same name (different traits)\n    let gen2 = &lt;AnotherImpl as Generator&gt;::create();\n}\n```\n&quot;),
 (&quot;E0296&quot;,
  &quot;\nThis error indicates that the given recursion limit could not be parsed. Ensure\nthat the value provided is a positive integer between quotes, like so:\n\n```\n#![recursion_limit=\&quot;1000\&quot;]\n```\n&quot;),
 (&quot;E0308&quot;,
  &quot;\nThis error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable\&#39;s\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail\nlet x: i32 = \&quot;I am not a number!\&quot;;\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&amp;str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n\nAnother situation in which this occurs is when you attempt to use the `try!`\nmacro inside a function that does not return a `Result&lt;T, E&gt;`:\n\n```compile_fail\nuse std::fs::File;\n\nfn main() {\n    let mut f = try!(File::create(\&quot;foo.txt\&quot;));\n}\n```\n\nThis code gives an error like this:\n\n```text\n&lt;std macros&gt;:5:8: 6:42 error: mismatched types:\n expected `()`,\n     found `core::result::Result&lt;_, _&gt;`\n (expected (),\n     found enum `core::result::Result`) [E0308]\n```\n\n`try!` returns a `Result&lt;T, E&gt;`, and so the function must. But `main()` has\n`()` as its return type, hence the error.\n&quot;),
 (&quot;E0309&quot;,
  &quot;\nTypes in type definitions have lifetimes associated with them that represent\nhow long the data stored within them is guaranteed to be live. This lifetime\nmust be as long as the data needs to be alive, and missing the constraint that\ndenotes this will cause this error.\n\n```compile_fail\n// This won\&#39;t compile because T is not constrained, meaning the data\n// stored in it is not guaranteed to last as long as the reference\nstruct Foo&lt;\&#39;a, T&gt; {\n    foo: &amp;\&#39;a T\n}\n```\n\nThis will compile, because it has the constraint on the type parameter:\n\n```\nstruct Foo&lt;\&#39;a, T: \&#39;a&gt; {\n    foo: &amp;\&#39;a T\n}\n```\n&quot;),
 (&quot;E0310&quot;,
  &quot;\nTypes in type definitions have lifetimes associated with them that represent\nhow long the data stored within them is guaranteed to be live. This lifetime\nmust be as long as the data needs to be alive, and missing the constraint that\ndenotes this will cause this error.\n\n```compile_fail\n// This won\&#39;t compile because T is not constrained to the static lifetime\n// the reference needs\nstruct Foo&lt;T&gt; {\n    foo: &amp;\&#39;static T\n}\n\nThis will compile, because it has the constraint on the type parameter:\n\n```\nstruct Foo&lt;T: \&#39;static&gt; {\n    foo: &amp;\&#39;static T\n}\n```\n&quot;),
 (&quot;E0398&quot;,
  &quot;\nIn Rust 1.3, the default object lifetime bounds are expected to change, as\ndescribed in RFC #1156 [1]. You are getting a warning because the compiler\nthinks it is possible that this change will cause a compilation error in your\ncode. It is possible, though unlikely, that this is a false alarm.\n\nThe heart of the change is that where `&amp;\&#39;a Box&lt;SomeTrait&gt;` used to default to\n`&amp;\&#39;a Box&lt;SomeTrait+\&#39;a&gt;`, it now defaults to `&amp;\&#39;a Box&lt;SomeTrait+\&#39;static&gt;` (here,\n`SomeTrait` is the name of some trait type). Note that the only types which are\naffected are references to boxes, like `&amp;Box&lt;SomeTrait&gt;` or\n`&amp;[Box&lt;SomeTrait&gt;]`. More common types like `&amp;SomeTrait` or `Box&lt;SomeTrait&gt;`\nare unaffected.\n\nTo silence this warning, edit your code to use an explicit bound. Most of the\ntime, this means that you will want to change the signature of a function that\nyou are calling. For example, if the error is reported on a call like `foo(x)`,\nand `foo` is defined as follows:\n\n```ignore\nfn foo(arg: &amp;Box&lt;SomeTrait&gt;) { ... }\n```\n\nYou might change it to:\n\n```ignore\nfn foo&lt;\&#39;a&gt;(arg: &amp;Box&lt;SomeTrait+\&#39;a&gt;) { ... }\n```\n\nThis explicitly states that you expect the trait object `SomeTrait` to contain\nreferences (with a maximum lifetime of `\&#39;a`).\n\n[1]: https://github.com/rust-lang/rfcs/pull/1156\n&quot;),
 (&quot;E0452&quot;,
  &quot;\nAn invalid lint attribute has been given. Erroneous code example:\n\n```compile_fail\n#![allow(foo = \&quot;\&quot;)] // error: malformed lint attribute\n```\n\nLint attributes only accept a list of identifiers (where each identifier is a\nlint name). Ensure the attribute is of this form:\n\n```\n#![allow(foo)] // ok!\n// or:\n#![allow(foo, foo2)] // ok!\n```\n&quot;),
 (&quot;E0496&quot;,
  &quot;\nA lifetime name is shadowing another lifetime name. Erroneous code example:\n\n```compile_fail\nstruct Foo&lt;\&#39;a&gt; {\n    a: &amp;\&#39;a i32,\n}\n\nimpl&lt;\&#39;a&gt; Foo&lt;\&#39;a&gt; {\n    fn f&lt;\&#39;a&gt;(x: &amp;\&#39;a i32) { // error: lifetime name `\&#39;a` shadows a lifetime\n                           //        name that is already in scope\n    }\n}\n```\n\nPlease change the name of one of the lifetimes to remove this error. Example:\n\n```\nstruct Foo&lt;\&#39;a&gt; {\n    a: &amp;\&#39;a i32,\n}\n\nimpl&lt;\&#39;a&gt; Foo&lt;\&#39;a&gt; {\n    fn f&lt;\&#39;b&gt;(x: &amp;\&#39;b i32) { // ok!\n    }\n}\n\nfn main() {\n}\n```\n&quot;),
 (&quot;E0497&quot;,
  &quot;\nA stability attribute was used outside of the standard library. Erroneous code\nexample:\n\n```compile_fail\n#[stable] // error: stability attributes may not be used outside of the\n          //        standard library\nfn foo() {}\n```\n\nIt is not possible to use stability attributes outside of the standard library.\nAlso, for now, it is not possible to write deprecation messages either.\n&quot;),
 (&quot;E0512&quot;,
  &quot;\nTransmute with two differently sized types was attempted. Erroneous code\nexample:\n\n```compile_fail\nfn takes_u8(_: u8) {}\n\nfn main() {\n    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n    // error: transmute called with differently sized types\n}\n```\n\nPlease use types with same size or use the expected type directly. Example:\n\n```\nfn takes_u8(_: u8) {}\n\nfn main() {\n    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n    // or:\n    unsafe { takes_u8(0u8); } // ok!\n}\n```\n&quot;),
 (&quot;E0517&quot;,
  &quot;\nThis error indicates that a `#[repr(..)]` attribute was placed on an\nunsupported item.\n\nExamples of erroneous code:\n\n```compile_fail\n#[repr(C)]\ntype Foo = u8;\n\n#[repr(packed)]\nenum Foo {Bar, Baz}\n\n#[repr(u8)]\nstruct Foo {bar: bool, baz: bool}\n\n#[repr(C)]\nimpl Foo {\n    // ...\n}\n```\n\n* The `#[repr(C)]` attribute can only be placed on structs and enums.\n* The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs.\n* The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums.\n\nThese attributes do not work on typedefs, since typedefs are just aliases.\n\nRepresentations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the\ndiscriminant size for C-like enums (when there is no associated data, e.g.\n`enum Color {Red, Blue, Green}`), effectively setting the size of the enum to\nthe size of the provided type. Such an enum can be cast to a value of the same\ntype as well. In short, `#[repr(u8)]` makes the enum behave like an integer\nwith a constrained set of allowed values.\n\nOnly C-like enums can be cast to numerical primitives, so this attribute will\nnot apply to structs.\n\n`#[repr(packed)]` reduces padding to make the struct size smaller. The\nrepresentation of enums isn\&#39;t strictly defined in Rust, and this attribute\nwon\&#39;t work on enums.\n\n`#[repr(simd)]` will give a struct consisting of a homogenous series of machine\ntypes (i.e. `u8`, `i32`, etc) a representation that permits vectorization via\nSIMD. This doesn\&#39;t make much sense for enums since they don\&#39;t consist of a\nsingle list of data.\n&quot;),
 (&quot;E0518&quot;,
  &quot;\nThis error indicates that an `#[inline(..)]` attribute was incorrectly placed\non something other than a function or method.\n\nExamples of erroneous code:\n\n```compile_fail\n#[inline(always)]\nstruct Foo;\n\n#[inline(never)]\nimpl Foo {\n    // ...\n}\n```\n\n`#[inline]` hints the compiler whether or not to attempt to inline a method or\nfunction. By default, the compiler does a pretty good job of figuring this out\nitself, but if you feel the need for annotations, `#[inline(always)]` and\n`#[inline(never)]` can override or force the compiler\&#39;s decision.\n\nIf you wish to apply this attribute to all methods in an impl, manually annotate\neach method; it is not possible to annotate the entire impl with an `#[inline]`\nattribute.\n&quot;),
 (&quot;E0522&quot;,
  &quot;\nThe lang attribute is intended for marking special items that are built-in to\nRust itself. This includes special traits (like `Copy` and `Sized`) that affect\nhow the compiler behaves, as well as special functions that may be automatically\ninvoked (such as the handler for out-of-bounds accesses when indexing a slice).\nErroneous code example:\n\n```compile_fail\n#![feature(lang_items)]\n\n#[lang = \&quot;cookie\&quot;]\nfn cookie() -&gt; ! { // error: definition of an unknown language item: `cookie`\n    loop {}\n}\n```\n&quot;)]</code></pre><div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "rustc";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>