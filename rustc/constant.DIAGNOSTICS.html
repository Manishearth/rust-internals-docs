<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `DIAGNOSTICS` constant in crate `rustc`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, DIAGNOSTICS">

    <title>rustc::DIAGNOSTICS - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc constant">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../rustc/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='logo' width='100'></a>
        <p class='location'><a href='index.html'>rustc</a></p><script>window.sidebarCurrent = {name: 'DIAGNOSTICS', ty: 'constant', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Constant <a href='index.html'>rustc</a>::<wbr><a class="constant" href=''>DIAGNOSTICS</a></span><span class='out-of-band'><span class='since' title='Stable since Rust version '></span><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/rustc/lib.rs.html#144' title='goto source code'>[src]</a></span></h1>
<pre class='rust const'>pub const DIAGNOSTICS: <a class="primitive" href="../std/primitive.array.html">[</a><a class="primitive" href="../std/primitive.tuple.html">(</a>&amp;'static <a class="primitive" href="../std/primitive.str.html">str</a>, &amp;'static <a class="primitive" href="../std/primitive.str.html">str</a><a class="primitive" href="../std/primitive.tuple.html">)</a><a class="primitive" href="../std/primitive.array.html">; 52]</a><code> = </code><code>[(&quot;E0020&quot;,
  &quot;\nThis error indicates that an attempt was made to divide by zero (or take the\nremainder of a zero divisor) in a static or constant expression. Erroneous\ncode example:\n\n```compile_fail\n#[deny(const_err)]\n\nconst X: i32 = 42 / 0;\n// error: attempt to divide by zero in a constant expression\n```\n&quot;),
 (&quot;E0038&quot;,
  &quot;\nTrait objects like `Box&lt;Trait&gt;` can only be constructed when certain\nrequirements are satisfied by the trait in question.\n\nTrait objects are a form of dynamic dispatch and use a dynamically sized type\nfor the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\ntype, as in `Box&lt;Trait&gt;`, the inner type is \&#39;unsized\&#39;. In such cases the boxed\npointer is a \&#39;fat pointer\&#39; that contains an extra pointer to a table of methods\n(among other things) for dynamic dispatch. This design mandates some\nrestrictions on the types of traits that are allowed to be used in trait\nobjects, which are collectively termed as \&#39;object safety\&#39; rules.\n\nAttempting to create a trait object for a non object-safe trait will trigger\nthis error.\n\nThere are various rules:\n\n### The trait cannot require `Self: Sized`\n\nWhen `Trait` is treated as a type, the type does not implement the special\n`Sized` trait, because the type does not have a known size at compile time and\ncan only be accessed behind a pointer. Thus, if we have a trait like the\nfollowing:\n\n```\ntrait Foo where Self: Sized {\n\n}\n```\n\nWe cannot create an object of type `Box&lt;Foo&gt;` or `&amp;Foo` since in this case\n`Self` would not be `Sized`.\n\nGenerally, `Self : Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its arguments or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&amp;self) -&gt; Self;\n}\n\nimpl Trait for String {\n    fn foo(&amp;self) -&gt; Self {\n        \&quot;hi\&quot;.to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&amp;self) -&gt; Self {\n        1\n    }\n}\n```\n\n(Note that `&amp;self` and `&amp;mut self` are okay, it\&#39;s additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail\ntrait Trait {\n    fn foo(&amp;self) -&gt; Self;\n}\n\nfn call_foo(x: Box&lt;Trait&gt;) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren\&#39;t object-safe, you can add a `where Self: Sized` bound\non them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box&lt;Trait&gt;` which is itself sized (assuming you `impl Trait for Box&lt;Trait&gt;`).\n\n```\ntrait Trait {\n    fn foo(&amp;self) -&gt; Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any object-safe\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren\&#39;t behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&amp;self);\n}\n\nimpl Trait for String {\n    fn foo(&amp;self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&amp;self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo&lt;T&gt;(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::&lt;u8&gt;()`, `foo::&lt;bool&gt;()`, `foo::&lt;String&gt;()`, or any\nother type substitution is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::&lt;bool&gt;()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with unparametrized substitutions\n(i.e., substitutions where none of the substituted types are themselves\nparametrized).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo&lt;T&gt;(&amp;self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo&lt;T&gt;(&amp;self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo&lt;T&gt;(&amp;self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo&lt;T&gt;(&amp;self, on: T); }\n# impl Trait for String { fn foo&lt;T&gt;(&amp;self, on: T) {} }\n# impl Trait for u8 { fn foo&lt;T&gt;(&amp;self, on: T) {} }\n# impl Trait for bool { fn foo&lt;T&gt;(&amp;self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box&lt;Trait&gt;) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\&quot;hello\&quot;);\n}\n```\n\nWe don\&#39;t just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo&lt;T&gt;(&amp;self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g. if `T: OtherTrait`, use `on: Box&lt;OtherTrait&gt;`). If the number\nof types you intend to feed to this method is limited, consider manually listing\nout the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can\&#39;t be called since there won\&#39;t be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -&gt; u8;\n}\n```\n\nThis could be called as `&lt;Foo as Foo&gt;::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -&gt; u8 where Self: Sized;\n}\n```\n\n### The trait cannot use `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail\ntrait Super&lt;A&gt; {}\n\ntrait Trait: Super&lt;Self&gt; {\n}\n\nstruct Foo;\n\nimpl Super&lt;Foo&gt; for Foo{}\n\nimpl Trait for Foo {}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super&lt;A&gt; {\n    fn get_a(&amp;self) -&gt; A; // note that this is object safe!\n}\n```\n\nIf the trait `Foo` was deriving from something like `Super&lt;String&gt;` or\n`Super&lt;T&gt;` (where `Foo` itself is `Foo&lt;T&gt;`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super&lt;Self&gt;`, even though `Super` is object safe,\nthe method `get_a()` would return an object of unknown type when called on the\nfunction. `Self` type parameters let us make object safe traits no longer safe,\nso they are forbidden when specifying supertraits.\n\nThere\&#39;s no easy fix for this, generally code will need to be refactored so that\nyou no longer need to derive from `Super&lt;Self&gt;`.\n&quot;),
 (&quot;E0072&quot;,
  &quot;\nWhen defining a recursive struct or enum, any use of the type being defined\nfrom inside the definition must occur behind a pointer (like `Box` or `&amp;`).\nThis is because structs and enums must have a well-defined size, and without\nthe pointer, the size of the type would need to be unbounded.\n\nConsider the following erroneous definition of a type for a list of bytes:\n\n```compile_fail,E0072\n// error, invalid recursive struct type\nstruct ListNode {\n    head: u8,\n    tail: Option&lt;ListNode&gt;,\n}\n```\n\nThis type cannot have a well-defined size, because it needs to be arbitrarily\nlarge (since we would be able to nest `ListNode`s to any depth). Specifically,\n\n```plain\nsize of `ListNode` = 1 byte for `head`\n                   + 1 byte for the discriminant of the `Option`\n                   + size of `ListNode`\n```\n\nOne way to fix this is by wrapping `ListNode` in a `Box`, like so:\n\n```\nstruct ListNode {\n    head: u8,\n    tail: Option&lt;Box&lt;ListNode&gt;&gt;,\n}\n```\n\nThis works because `Box` is a pointer, so its size is well-known.\n&quot;),
 (&quot;E0080&quot;,
  &quot;\nThis error indicates that the compiler was unable to sensibly evaluate an\nconstant expression that had to be evaluated. Attempting to divide by 0\nor causing integer overflow are two ways to induce this error. For example:\n\n```compile_fail,E0080\nenum Enum {\n    X = (1 &lt;&lt; 500),\n    Y = (1 / 0)\n}\n```\n\nEnsure that the expressions given can be evaluated as the desired integer type.\nSee the FFI section of the Reference for more information about using a custom\ninteger type:\n\nhttps://doc.rust-lang.org/reference.html#ffi-attributes\n&quot;),
 (&quot;E0106&quot;,
  &quot;\nThis error indicates that a lifetime is missing from a type. If it is an error\ninside a function signature, the problem may be with failing to adhere to the\nlifetime elision rules (see below).\n\nHere are some simple examples of where you\&#39;ll run into this error:\n\n```compile_fail,E0106\nstruct Foo { x: &amp;bool }        // error\nstruct Foo&lt;\&#39;a&gt; { x: &amp;\&#39;a bool } // correct\n\nstruct Bar { x: Foo }\n               ^^^ expected lifetime parameter\nstruct Bar&lt;\&#39;a&gt; { x: Foo&lt;\&#39;a&gt; } // correct\n\nenum Bar { A(u8), B(&amp;bool), }        // error\nenum Bar&lt;\&#39;a&gt; { A(u8), B(&amp;\&#39;a bool), } // correct\n\ntype MyStr = &amp;str;        // error\ntype MyStr&lt;\&#39;a&gt; = &amp;\&#39;a str; // correct\n```\n\nLifetime elision is a special, limited kind of inference for lifetimes in\nfunction signatures which allows you to leave out lifetimes in certain cases.\nFor more background on lifetime elision see [the book][book-le].\n\nThe lifetime elision rules require that any function signature with an elided\noutput lifetime must either have\n\n - exactly one input lifetime\n - or, multiple input lifetimes, but the function must also be a method with a\n   `&amp;self` or `&amp;mut self` receiver\n\nIn the first case, the output lifetime is inferred to be the same as the unique\ninput lifetime. In the second case, the lifetime is instead inferred to be the\nsame as the lifetime on `&amp;self` or `&amp;mut self`.\n\nHere are some examples of elision errors:\n\n```compile_fail,E0106\n// error, no input lifetimes\nfn foo() -&gt; &amp;str { }\n\n// error, `x` and `y` have distinct lifetimes inferred\nfn bar(x: &amp;str, y: &amp;str) -&gt; &amp;str { }\n\n// error, `y`\&#39;s lifetime is inferred to be distinct from `x`\&#39;s\nfn baz&lt;\&#39;a&gt;(x: &amp;\&#39;a str, y: &amp;str) -&gt; &amp;str { }\n```\n\nHere\&#39;s an example that is currently an error, but may work in a future version\nof Rust:\n\n```compile_fail,E0106\nstruct Foo&lt;\&#39;a&gt;(&amp;\&#39;a str);\n\ntrait Quux { }\nimpl Quux for Foo { }\n```\n\nLifetime elision in implementation headers was part of the lifetime elision\nRFC. It is, however, [currently unimplemented][iss15872].\n\n[book-le]: https://doc.rust-lang.org/nightly/book/first-edition/lifetimes.html#lifetime-elision\n[iss15872]: https://github.com/rust-lang/rust/issues/15872\n&quot;),
 (&quot;E0119&quot;,
  &quot;\nThere are conflicting trait implementations for the same type.\nExample of erroneous code:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&amp;self) -&gt; usize;\n}\n\nimpl&lt;T&gt; MyTrait for T {\n    fn get(&amp;self) -&gt; usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&amp;self) -&gt; usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl&lt;T&gt; MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&amp;self) -&gt; usize;\n}\n\nimpl&lt;T&gt; MyTrait for T {\n    fn get(&amp;self) -&gt; usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&amp;self) -&gt; usize;\n}\n\nimpl&lt;T&gt; MyTrait for T {\n    fn get(&amp;self) -&gt; usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n&quot;),
 (&quot;E0133&quot;,
  &quot;\nUnsafe code was used outside of an unsafe function or block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee also https://doc.rust-lang.org/book/first-edition/unsafe.html\n&quot;),
 (&quot;E0136&quot;,
  &quot;\nA binary can only have one entry point, and by default that entry point is the\nfunction `main()`. If there are multiple such functions, please rename one.\n&quot;),
 (&quot;E0137&quot;,
  &quot;\nMore than one function was declared with the `#[main]` attribute.\n\nErroneous code example:\n\n```compile_fail,E0137\n#![feature(main)]\n\n#[main]\nfn foo() {}\n\n#[main]\nfn f() {} // error: multiple functions with a #[main] attribute\n```\n\nThis error indicates that the compiler found multiple functions with the\n`#[main]` attribute. This is an error because there must be a unique entry\npoint into a Rust program. Example:\n\n```\n#![feature(main)]\n\n#[main]\nfn f() {} // ok!\n```\n&quot;),
 (&quot;E0138&quot;,
  &quot;\nMore than one function was declared with the `#[start]` attribute.\n\nErroneous code example:\n\n```compile_fail,E0138\n#![feature(start)]\n\n#[start]\nfn foo(argc: isize, argv: *const *const u8) -&gt; isize {}\n\n#[start]\nfn f(argc: isize, argv: *const *const u8) -&gt; isize {}\n// error: multiple \&#39;start\&#39; functions\n```\n\nThis error indicates that the compiler found multiple functions with the\n`#[start]` attribute. This is an error because there must be a unique entry\npoint into a Rust program. Example:\n\n```\n#![feature(start)]\n\n#[start]\nfn foo(argc: isize, argv: *const *const u8) -&gt; isize { 0 } // ok!\n```\n&quot;),
 (&quot;E0139&quot;,
  &quot;\n#### Note: this error code is no longer emitted by the compiler.\n\nThere are various restrictions on transmuting between types in Rust; for example\ntypes being transmuted must have the same size. To apply all these restrictions,\nthe compiler must know the exact types that may be transmuted. When type\nparameters are involved, this cannot always be done.\n\nSo, for example, the following is not allowed:\n\n```\nuse std::mem::transmute;\n\nstruct Foo&lt;T&gt;(Vec&lt;T&gt;);\n\nfn foo&lt;T&gt;(x: Vec&lt;T&gt;) {\n    // we are transmuting between Vec&lt;T&gt; and Foo&lt;F&gt; here\n    let y: Foo&lt;T&gt; = unsafe { transmute(x) };\n    // do something with y\n}\n```\n\nIn this specific case there\&#39;s a good chance that the transmute is harmless (but\nthis is not guaranteed by Rust). However, when alignment and enum optimizations\ncome into the picture, it\&#39;s quite likely that the sizes may or may not match\nwith different type parameter substitutions. It\&#39;s not possible to check this for\n_all_ possible types, so `transmute()` simply only accepts types without any\nunsubstituted type parameters.\n\nIf you need this, there\&#39;s a good chance you\&#39;re doing something wrong. Keep in\nmind that Rust doesn\&#39;t guarantee much about the layout of different structs\n(even two structs with identical declarations may have different layouts). If\nthere is a solution that avoids the transmute entirely, try it instead.\n\nIf it\&#39;s possible, hand-monomorphize the code by writing the function for each\npossible type substitution. It\&#39;s possible to use traits to do this cleanly,\nfor example:\n\n```\nuse std::mem::transmute;\n\nstruct Foo&lt;T&gt;(Vec&lt;T&gt;);\n\ntrait MyTransmutableType: Sized {\n    fn transmute(_: Vec&lt;Self&gt;) -&gt; Foo&lt;Self&gt;;\n}\n\nimpl MyTransmutableType for u8 {\n    fn transmute(x: Vec&lt;u8&gt;) -&gt; Foo&lt;u8&gt; {\n        unsafe { transmute(x) }\n    }\n}\n\nimpl MyTransmutableType for String {\n    fn transmute(x: Vec&lt;String&gt;) -&gt; Foo&lt;String&gt; {\n        unsafe { transmute(x) }\n    }\n}\n\n// ... more impls for the types you intend to transmute\n\nfn foo&lt;T: MyTransmutableType&gt;(x: Vec&lt;T&gt;) {\n    let y: Foo&lt;T&gt; = &lt;T as MyTransmutableType&gt;::transmute(x);\n    // do something with y\n}\n```\n\nEach impl will be checked for a size match in the transmute as usual, and since\nthere are no unbound type parameters involved, this should compile unless there\nis a size mismatch in one of the impls.\n\nIt is also possible to manually transmute:\n\n```\n# use std::ptr;\n# let v = Some(\&quot;value\&quot;);\n# type SomeType = &amp;\&#39;static [u8];\nunsafe {\n    ptr::read(&amp;v as *const _ as *const SomeType) // `v` transmuted to `SomeType`\n}\n# ;\n```\n\nNote that this does not move `v` (unlike `transmute`), and may need a\ncall to `mem::forget(v)` in case you want to avoid destructors being called.\n&quot;),
 (&quot;E0152&quot;,
  &quot;\nA lang item was redefined.\n\nErroneous code example:\n\n```compile_fail,E0152\n#![feature(lang_items)]\n\n#[lang = \&quot;panic_fmt\&quot;]\nstruct Foo; // error: duplicate lang item found: `panic_fmt`\n```\n\nLang items are already implemented in the standard library. Unless you are\nwriting a free-standing application (e.g. a kernel), you do not need to provide\nthem yourself.\n\nYou can build a free-standing crate by adding `#![no_std]` to the crate\nattributes:\n\n```ignore (only-for-syntax-highlight)\n#![no_std]\n```\n\nSee also https://doc.rust-lang.org/book/first-edition/no-stdlib.html\n&quot;),
 (&quot;E0214&quot;,
  &quot;\nA generic type was described using parentheses rather than angle brackets. For\nexample:\n\n```compile_fail,E0214\nfn main() {\n    let v: Vec(&amp;str) = vec![\&quot;foo\&quot;];\n}\n```\n\nThis is not currently supported: `v` should be defined as `Vec&lt;&amp;str&gt;`.\nParentheses are currently only used with generic types when defining parameters\nfor `Fn`-family traits.\n&quot;),
 (&quot;E0261&quot;,
  &quot;\nWhen using a lifetime like `\&#39;a` in a type, it must be declared before being\nused.\n\nThese two examples illustrate the problem:\n\n```compile_fail,E0261\n// error, use of undeclared lifetime name `\&#39;a`\nfn foo(x: &amp;\&#39;a str) { }\n\nstruct Foo {\n    // error, use of undeclared lifetime name `\&#39;a`\n    x: &amp;\&#39;a str,\n}\n```\n\nThese can be fixed by declaring lifetime parameters:\n\n```\nfn foo&lt;\&#39;a&gt;(x: &amp;\&#39;a str) {}\n\nstruct Foo&lt;\&#39;a&gt; {\n    x: &amp;\&#39;a str,\n}\n```\n&quot;),
 (&quot;E0262&quot;,
  &quot;\nDeclaring certain lifetime names in parameters is disallowed. For example,\nbecause the `\&#39;static` lifetime is a special built-in lifetime name denoting\nthe lifetime of the entire program, this is an error:\n\n```compile_fail,E0262\n// error, invalid lifetime parameter name `\&#39;static`\nfn foo&lt;\&#39;static&gt;(x: &amp;\&#39;static str) { }\n```\n&quot;),
 (&quot;E0263&quot;,
  &quot;\nA lifetime name cannot be declared more than once in the same scope. For\nexample:\n\n```compile_fail,E0263\n// error, lifetime name `\&#39;a` declared twice in the same scope\nfn foo&lt;\&#39;a, \&#39;b, \&#39;a&gt;(x: &amp;\&#39;a str, y: &amp;\&#39;b str) { }\n```\n&quot;),
 (&quot;E0264&quot;,
  &quot;\nAn unknown external lang item was used. Erroneous code example:\n\n```compile_fail,E0264\n#![feature(lang_items)]\n\nextern \&quot;C\&quot; {\n    #[lang = \&quot;cake\&quot;] // error: unknown external lang item: `cake`\n    fn cake();\n}\n```\n\nA list of available external lang items is available in\n`src/librustc/middle/weak_lang_items.rs`. Example:\n\n```\n#![feature(lang_items)]\n\nextern \&quot;C\&quot; {\n    #[lang = \&quot;panic_fmt\&quot;] // ok!\n    fn cake();\n}\n```\n&quot;),
 (&quot;E0271&quot;,
  &quot;\nThis is because of a type mismatch between the associated type of some\ntrait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\nand another type `U` that is required to be equal to `T::Bar`, but is not.\nExamples follow.\n\nHere is a basic example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType=u32&gt; {\n    println!(\&quot;in foo\&quot;);\n}\n\nimpl Trait for i8 { type AssociatedType = &amp;\&#39;static str; }\n\nfoo(3_i8);\n```\n\nHere is that same example again, with some explanatory comments:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType=u32&gt; {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\&quot;in foo\&quot;);\n}\n\nimpl Trait for i8 { type AssociatedType = &amp;\&#39;static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&amp;\&#39;static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `&lt;i8 as Trait&gt;::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nHere is a more subtle instance of the same problem, that can\narise with for-loops in Rust:\n\n```compile_fail\nlet vs: Vec&lt;i32&gt; = vec![1, 2, 3, 4];\nfor v in &amp;vs {\n    match v {\n        1 =&gt; {},\n        _ =&gt; {},\n    }\n}\n```\n\nThe above fails because of an analogous type mismatch,\nthough may be harder to see. Again, here are some\nexplanatory comments for the same example:\n\n```compile_fail\n{\n    let vs = vec![1, 2, 3, 4];\n\n    // `for`-loops use a protocol based on the `Iterator`\n    // trait. Each item yielded in a `for` loop has the\n    // type `Iterator::Item` -- that is, `Item` is the\n    // associated type of the concrete iterator impl.\n    for v in &amp;vs {\n//      ~    ~~~\n//      |     |\n//      |    We borrow `vs`, iterating over a sequence of\n//      |    *references* of type `&amp;Elem` (where `Elem` is\n//      |    vector\&#39;s element type). Thus, the associated\n//      |    type `Item` must be a reference `&amp;`-type ...\n//      |\n//  ... and `v` has the type `Iterator::Item`, as dictated by\n//  the `for`-loop protocol ...\n\n        match v {\n            1 =&gt; {}\n//          ~\n//          |\n// ... but *here*, `v` is forced to have some integral type;\n// only types like `u8`,`i8`,`u16`,`i16`, et cetera can\n// match the pattern `1` ...\n\n            _ =&gt; {}\n        }\n\n// ... therefore, the compiler complains, because it sees\n// an attempt to solve the equations\n// `some integral-type` = type-of-`v`\n//                      = `Iterator::Item`\n//                      = `&amp;Elem` (i.e. `some reference type`)\n//\n// which cannot possibly all be true.\n\n    }\n}\n```\n\nTo avoid those issues, you have to make the types match correctly.\nSo we can fix the previous examples like this:\n\n```\n// Basic Example:\ntrait Trait { type AssociatedType; }\n\nfn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType = &amp;\&#39;static str&gt; {\n    println!(\&quot;in foo\&quot;);\n}\n\nimpl Trait for i8 { type AssociatedType = &amp;\&#39;static str; }\n\nfoo(3_i8);\n\n// For-Loop Example:\nlet vs = vec![1, 2, 3, 4];\nfor v in &amp;vs {\n    match v {\n        &amp;1 =&gt; {}\n        _ =&gt; {}\n    }\n}\n```\n&quot;),
 (&quot;E0272&quot;,
  &quot;\nThe `#[rustc_on_unimplemented]` attribute lets you specify a custom error\nmessage for when a particular trait isn\&#39;t implemented on a type placed in a\nposition that needs that trait. For example, when the following code is\ncompiled:\n\n```compile_fail\n#![feature(on_unimplemented)]\n\nfn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}\n\n#[rustc_on_unimplemented = \&quot;the type `{Self}` cannot be indexed by `{Idx}`\&quot;]\ntrait Index&lt;Idx&gt; { /* ... */ }\n\nfoo(true); // `bool` does not implement `Index&lt;u8&gt;`\n```\n\nThere will be an error about `bool` not implementing `Index&lt;u8&gt;`, followed by a\nnote saying \&quot;the type `bool` cannot be indexed by `u8`\&quot;.\n\nAs you can see, you can specify type parameters in curly braces for\nsubstitution with the actual types (using the regular format string syntax) in\na given situation. Furthermore, `{Self}` will substitute to the type (in this\ncase, `bool`) that we tried to use.\n\nThis error appears when the curly braces contain an identifier which doesn\&#39;t\nmatch with any of the type parameters or the string `Self`. This might happen\nif you misspelled a type parameter, or if you intended to use literal curly\nbraces. If it is the latter, escape the curly braces with a second curly brace\nof the same type; e.g. a literal `{` is `{{`.\n&quot;),
 (&quot;E0273&quot;,
  &quot;\nThe `#[rustc_on_unimplemented]` attribute lets you specify a custom error\nmessage for when a particular trait isn\&#39;t implemented on a type placed in a\nposition that needs that trait. For example, when the following code is\ncompiled:\n\n```compile_fail\n#![feature(on_unimplemented)]\n\nfn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}\n\n#[rustc_on_unimplemented = \&quot;the type `{Self}` cannot be indexed by `{Idx}`\&quot;]\ntrait Index&lt;Idx&gt; { /* ... */ }\n\nfoo(true); // `bool` does not implement `Index&lt;u8&gt;`\n```\n\nthere will be an error about `bool` not implementing `Index&lt;u8&gt;`, followed by a\nnote saying \&quot;the type `bool` cannot be indexed by `u8`\&quot;.\n\nAs you can see, you can specify type parameters in curly braces for\nsubstitution with the actual types (using the regular format string syntax) in\na given situation. Furthermore, `{Self}` will substitute to the type (in this\ncase, `bool`) that we tried to use.\n\nThis error appears when the curly braces do not contain an identifier. Please\nadd one of the same name as a type parameter. If you intended to use literal\nbraces, use `{{` and `}}` to escape them.\n&quot;),
 (&quot;E0274&quot;,
  &quot;\nThe `#[rustc_on_unimplemented]` attribute lets you specify a custom error\nmessage for when a particular trait isn\&#39;t implemented on a type placed in a\nposition that needs that trait. For example, when the following code is\ncompiled:\n\n```compile_fail\n#![feature(on_unimplemented)]\n\nfn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}\n\n#[rustc_on_unimplemented = \&quot;the type `{Self}` cannot be indexed by `{Idx}`\&quot;]\ntrait Index&lt;Idx&gt; { /* ... */ }\n\nfoo(true); // `bool` does not implement `Index&lt;u8&gt;`\n```\n\nthere will be an error about `bool` not implementing `Index&lt;u8&gt;`, followed by a\nnote saying \&quot;the type `bool` cannot be indexed by `u8`\&quot;.\n\nFor this to work, some note must be specified. An empty attribute will not do\nanything, please remove the attribute or add some helpful note for users of the\ntrait.\n&quot;),
 (&quot;E0275&quot;,
  &quot;\nThis error occurs when there was a recursive trait requirement that overflowed\nbefore it could be evaluated. Often this means that there is unbounded\nrecursion in resolving some type bounds.\n\nFor example, in the following code:\n\n```compile_fail,E0275\ntrait Foo {}\n\nstruct Bar&lt;T&gt;(T);\n\nimpl&lt;T&gt; Foo for T where Bar&lt;T&gt;: Foo {}\n```\n\nTo determine if a `T` is `Foo`, we need to check if `Bar&lt;T&gt;` is `Foo`. However,\nto do this check, we need to determine that `Bar&lt;Bar&lt;T&gt;&gt;` is `Foo`. To\ndetermine this, we check if `Bar&lt;Bar&lt;Bar&lt;T&gt;&gt;&gt;` is `Foo`, and so on. This is\nclearly a recursive requirement that can\&#39;t be resolved directly.\n\nConsider changing your trait bounds so that they\&#39;re less self-referential.\n&quot;),
 (&quot;E0276&quot;,
  &quot;\nThis error occurs when a bound in an implementation of a trait does not match\nthe bounds specified in the original trait. For example:\n\n```compile_fail,E0276\ntrait Foo {\n    fn foo&lt;T&gt;(x: T);\n}\n\nimpl Foo for bool {\n    fn foo&lt;T&gt;(x: T) where T: Copy {}\n}\n```\n\nHere, all types implementing `Foo` must have a method `foo&lt;T&gt;(x: T)` which can\ntake any type `T`. However, in the `impl` for `bool`, we have added an extra\nbound that `T` is `Copy`, which isn\&#39;t compatible with the original trait.\n\nConsider removing the bound from the method or adding the bound to the original\nmethod definition in the trait.\n&quot;),
 (&quot;E0277&quot;,
  &quot;\nYou tried to use a type which doesn\&#39;t implement some trait in a place which\nexpected that trait. Erroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&amp;self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func&lt;T: Foo&gt;(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn\&#39;t implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you\&#39;re using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&amp;self);\n}\n\nfn some_func&lt;T: Foo&gt;(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&amp;self) {}\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func&lt;T&gt;(foo: T) {\n    println!(\&quot;{:?}\&quot;, foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function: Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function: It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we\&#39;re\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func&lt;T: fmt::Debug&gt;(foo: T) {\n    println!(\&quot;{:?}\&quot;, foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n&quot;),
 (&quot;E0281&quot;,
  &quot;\nYou tried to supply a type which doesn\&#39;t implement some trait in a location\nwhich expected that trait. This error typically occurs when working with\n`Fn`-based types. Erroneous code example:\n\n```compile_fail,E0281\nfn foo&lt;F: Fn(usize)&gt;(x: F) { }\n\nfn main() {\n    // type mismatch: ... implements the trait `core::ops::Fn&lt;(String,)&gt;`,\n    // but the trait `core::ops::Fn&lt;(usize,)&gt;` is required\n    // [E0281]\n    foo(|y: String| { });\n}\n```\n\nThe issue in this case is that `foo` is defined as accepting a `Fn` with one\nargument of type `String`, but the closure we attempted to pass to it requires\none arguments of type `usize`.\n&quot;),
 (&quot;E0282&quot;,
  &quot;\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\n```compile_fail,E0282\nlet x = \&quot;hello\&quot;.chars().rev().collect();\n```\n\nIn this case, the compiler cannot infer what the type of `x` should be:\n`Vec&lt;char&gt;` and `String` are both suitable candidates. To specify which type to\nuse, you can use a type annotation on `x`:\n\n```\nlet x: Vec&lt;char&gt; = \&quot;hello\&quot;.chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec&lt;_&gt; = \&quot;hello\&quot;.chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \&quot;hello\&quot;.chars().rev().collect::&lt;Vec&lt;char&gt;&gt;();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \&quot;hello\&quot;.chars().rev().collect::&lt;Vec&lt;_&gt;&gt;();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo&lt;T&gt; {\n    num: T,\n}\n\nimpl&lt;T&gt; Foo&lt;T&gt; {\n    fn bar() -&gt; i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::&lt;T&gt;::bar()` to resolve the error.\n&quot;),
 (&quot;E0283&quot;,
  &quot;\nThis error occurs when the compiler doesn\&#39;t have enough information\nto unambiguously choose an implementation.\n\nFor example:\n\n```compile_fail,E0283\ntrait Generator {\n    fn create() -&gt; u32;\n}\n\nstruct Impl;\n\nimpl Generator for Impl {\n    fn create() -&gt; u32 { 1 }\n}\n\nstruct AnotherImpl;\n\nimpl Generator for AnotherImpl {\n    fn create() -&gt; u32 { 2 }\n}\n\nfn main() {\n    let cont: u32 = Generator::create();\n    // error, impossible to choose one of Generator trait implementation\n    // Impl or AnotherImpl? Maybe anything else?\n}\n```\n\nTo resolve this error use the concrete type:\n\n```\ntrait Generator {\n    fn create() -&gt; u32;\n}\n\nstruct AnotherImpl;\n\nimpl Generator for AnotherImpl {\n    fn create() -&gt; u32 { 2 }\n}\n\nfn main() {\n    let gen1 = AnotherImpl::create();\n\n    // if there are multiple methods with same name (different traits)\n    let gen2 = &lt;AnotherImpl as Generator&gt;::create();\n}\n```\n&quot;),
 (&quot;E0296&quot;,
  &quot;\nThis error indicates that the given recursion limit could not be parsed. Ensure\nthat the value provided is a positive integer between quotes.\n\nErroneous code example:\n\n```compile_fail,E0296\n#![recursion_limit]\n\nfn main() {}\n```\n\nAnd a working example:\n\n```\n#![recursion_limit=\&quot;1000\&quot;]\n\nfn main() {}\n```\n&quot;),
 (&quot;E0308&quot;,
  &quot;\nThis error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable\&#39;s\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \&quot;I am not a number!\&quot;;\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&amp;str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n&quot;),
 (&quot;E0309&quot;,
  &quot;\nTypes in type definitions have lifetimes associated with them that represent\nhow long the data stored within them is guaranteed to be live. This lifetime\nmust be as long as the data needs to be alive, and missing the constraint that\ndenotes this will cause this error.\n\n```compile_fail,E0309\n// This won\&#39;t compile because T is not constrained, meaning the data\n// stored in it is not guaranteed to last as long as the reference\nstruct Foo&lt;\&#39;a, T&gt; {\n    foo: &amp;\&#39;a T\n}\n```\n\nThis will compile, because it has the constraint on the type parameter:\n\n```\nstruct Foo&lt;\&#39;a, T: \&#39;a&gt; {\n    foo: &amp;\&#39;a T\n}\n```\n\nTo see why this is important, consider the case where `T` is itself a reference\n(e.g., `T = &amp;str`). If we don\&#39;t include the restriction that `T: \&#39;a`, the\nfollowing code would be perfectly legal:\n\n```compile_fail,E0309\nstruct Foo&lt;\&#39;a, T&gt; {\n    foo: &amp;\&#39;a T\n}\n\nfn main() {\n    let v = \&quot;42\&quot;.to_string();\n    let f = Foo{foo: &amp;v};\n    drop(v);\n    println!(\&quot;{}\&quot;, f.foo); // but we\&#39;ve already dropped v!\n}\n```\n&quot;),
 (&quot;E0310&quot;,
  &quot;\nTypes in type definitions have lifetimes associated with them that represent\nhow long the data stored within them is guaranteed to be live. This lifetime\nmust be as long as the data needs to be alive, and missing the constraint that\ndenotes this will cause this error.\n\n```compile_fail,E0310\n// This won\&#39;t compile because T is not constrained to the static lifetime\n// the reference needs\nstruct Foo&lt;T&gt; {\n    foo: &amp;\&#39;static T\n}\n```\n\nThis will compile, because it has the constraint on the type parameter:\n\n```\nstruct Foo&lt;T: \&#39;static&gt; {\n    foo: &amp;\&#39;static T\n}\n```\n&quot;),
 (&quot;E0312&quot;,
  &quot;\nA lifetime of reference outlives lifetime of borrowed content.\n\nErroneous code example:\n\n```compile_fail,E0312\nfn make_child&lt;\&#39;human, \&#39;elve&gt;(x: &amp;mut &amp;\&#39;human isize, y: &amp;mut &amp;\&#39;elve isize) {\n    *x = *y;\n    // error: lifetime of reference outlives lifetime of borrowed content\n}\n```\n\nThe compiler cannot determine if the `human` lifetime will live long enough\nto keep up on the elve one. To solve this error, you have to give an\nexplicit lifetime hierarchy:\n\n```\nfn make_child&lt;\&#39;human, \&#39;elve: \&#39;human&gt;(x: &amp;mut &amp;\&#39;human isize,\n                                     y: &amp;mut &amp;\&#39;elve isize) {\n    *x = *y; // ok!\n}\n```\n\nOr use the same lifetime for every variable:\n\n```\nfn make_child&lt;\&#39;elve&gt;(x: &amp;mut &amp;\&#39;elve isize, y: &amp;mut &amp;\&#39;elve isize) {\n    *x = *y; // ok!\n}\n```\n&quot;),
 (&quot;E0317&quot;,
  &quot;\nThis error occurs when an `if` expression without an `else` block is used in a\ncontext where a type other than `()` is expected, for example a `let`\nexpression:\n\n```compile_fail,E0317\nfn main() {\n    let x = 5;\n    let a = if x == 5 { 1 };\n}\n```\n\nAn `if` expression without an `else` block has the type `()`, so this is a type\nerror. To resolve it, add an `else` block having the same type as the `if`\nblock.\n&quot;),
 (&quot;E0391&quot;,
  &quot;\nThis error indicates that some types or traits depend on each other\nand therefore cannot be constructed.\n\nThe following example contains a circular dependency between two traits:\n\n```compile_fail,E0391\ntrait FirstTrait : SecondTrait {\n\n}\n\ntrait SecondTrait : FirstTrait {\n\n}\n```\n&quot;),
 (&quot;E0398&quot;,
  &quot;\n#### Note: this error code is no longer emitted by the compiler.\n\nIn Rust 1.3, the default object lifetime bounds are expected to change, as\ndescribed in [RFC 1156]. You are getting a warning because the compiler\nthinks it is possible that this change will cause a compilation error in your\ncode. It is possible, though unlikely, that this is a false alarm.\n\nThe heart of the change is that where `&amp;\&#39;a Box&lt;SomeTrait&gt;` used to default to\n`&amp;\&#39;a Box&lt;SomeTrait+\&#39;a&gt;`, it now defaults to `&amp;\&#39;a Box&lt;SomeTrait+\&#39;static&gt;` (here,\n`SomeTrait` is the name of some trait type). Note that the only types which are\naffected are references to boxes, like `&amp;Box&lt;SomeTrait&gt;` or\n`&amp;[Box&lt;SomeTrait&gt;]`. More common types like `&amp;SomeTrait` or `Box&lt;SomeTrait&gt;`\nare unaffected.\n\nTo silence this warning, edit your code to use an explicit bound. Most of the\ntime, this means that you will want to change the signature of a function that\nyou are calling. For example, if the error is reported on a call like `foo(x)`,\nand `foo` is defined as follows:\n\n```\n# trait SomeTrait {}\nfn foo(arg: &amp;Box&lt;SomeTrait&gt;) { /* ... */ }\n```\n\nYou might change it to:\n\n```\n# trait SomeTrait {}\nfn foo&lt;\&#39;a&gt;(arg: &amp;\&#39;a Box&lt;SomeTrait+\&#39;a&gt;) { /* ... */ }\n```\n\nThis explicitly states that you expect the trait object `SomeTrait` to contain\nreferences (with a maximum lifetime of `\&#39;a`).\n\n[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md\n&quot;),
 (&quot;E0452&quot;,
  &quot;\nAn invalid lint attribute has been given. Erroneous code example:\n\n```compile_fail,E0452\n#![allow(foo = \&quot;\&quot;)] // error: malformed lint attribute\n```\n\nLint attributes only accept a list of identifiers (where each identifier is a\nlint name). Ensure the attribute is of this form:\n\n```\n#![allow(foo)] // ok!\n// or:\n#![allow(foo, foo2)] // ok!\n```\n&quot;),
 (&quot;E0453&quot;,
  &quot;\nA lint check attribute was overruled by a `forbid` directive set as an\nattribute on an enclosing scope, or on the command line with the `-F` option.\n\nExample of erroneous code:\n\n```compile_fail,E0453\n#![forbid(non_snake_case)]\n\n#[allow(non_snake_case)]\nfn main() {\n    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer\n                      //        forbid(non_snake_case)\n}\n```\n\nThe `forbid` lint setting, like `deny`, turns the corresponding compiler\nwarning into a hard error. Unlike `deny`, `forbid` prevents itself from being\noverridden by inner attributes.\n\nIf you\&#39;re sure you want to override the lint check, you can change `forbid` to\n`deny` (or use `-D` instead of `-F` if the `forbid` setting was given as a\ncommand-line option) to allow the inner lint check attribute:\n\n```\n#![deny(non_snake_case)]\n\n#[allow(non_snake_case)]\nfn main() {\n    let MyNumber = 2; // ok!\n}\n```\n\nOtherwise, edit the code to pass the lint check, and remove the overruled\nattribute:\n\n```\n#![forbid(non_snake_case)]\n\nfn main() {\n    let my_number = 2;\n}\n```\n&quot;),
 (&quot;E0478&quot;,
  &quot;\nA lifetime bound was not satisfied.\n\nErroneous code example:\n\n```compile_fail,E0478\n// Check that the explicit lifetime bound (`\&#39;SnowWhite`, in this example) must\n// outlive all the superbounds from the trait (`\&#39;kiss`, in this example).\n\ntrait Wedding&lt;\&#39;t&gt;: \&#39;t { }\n\nstruct Prince&lt;\&#39;kiss, \&#39;SnowWhite&gt; {\n    child: Box&lt;Wedding&lt;\&#39;kiss&gt; + \&#39;SnowWhite&gt;,\n    // error: lifetime bound not satisfied\n}\n```\n\nIn this example, the `\&#39;SnowWhite` lifetime is supposed to outlive the `\&#39;kiss`\nlifetime but the declaration of the `Prince` struct doesn\&#39;t enforce it. To fix\nthis issue, you need to specify it:\n\n```\ntrait Wedding&lt;\&#39;t&gt;: \&#39;t { }\n\nstruct Prince&lt;\&#39;kiss, \&#39;SnowWhite: \&#39;kiss&gt; { // You say here that \&#39;kiss must live\n                                          // longer than \&#39;SnowWhite.\n    child: Box&lt;Wedding&lt;\&#39;kiss&gt; + \&#39;SnowWhite&gt;, // And now it\&#39;s all good!\n}\n```\n&quot;),
 (&quot;E0491&quot;,
  &quot;\nA reference has a longer lifetime than the data it references.\n\nErroneous code example:\n\n```compile_fail,E0491\n// struct containing a reference requires a lifetime parameter,\n// because the data the reference points to must outlive the struct (see E0106)\nstruct Struct&lt;\&#39;a&gt; {\n    ref_i32: &amp;\&#39;a i32,\n}\n\n// However, a nested struct like this, the signature itself does not tell\n// whether \&#39;a outlives \&#39;b or the other way around.\n// So it could be possible that \&#39;b of reference outlives \&#39;a of the data.\nstruct Nested&lt;\&#39;a, \&#39;b&gt; {\n    ref_struct: &amp;\&#39;b Struct&lt;\&#39;a&gt;, // compile error E0491\n}\n```\n\nTo fix this issue, you can specify a bound to the lifetime like below:\n\n```\nstruct Struct&lt;\&#39;a&gt; {\n    ref_i32: &amp;\&#39;a i32,\n}\n\n// \&#39;a: \&#39;b means \&#39;a outlives \&#39;b\nstruct Nested&lt;\&#39;a: \&#39;b, \&#39;b&gt; {\n    ref_struct: &amp;\&#39;b Struct&lt;\&#39;a&gt;,\n}\n```\n&quot;),
 (&quot;E0496&quot;,
  &quot;\nA lifetime name is shadowing another lifetime name. Erroneous code example:\n\n```compile_fail,E0496\nstruct Foo&lt;\&#39;a&gt; {\n    a: &amp;\&#39;a i32,\n}\n\nimpl&lt;\&#39;a&gt; Foo&lt;\&#39;a&gt; {\n    fn f&lt;\&#39;a&gt;(x: &amp;\&#39;a i32) { // error: lifetime name `\&#39;a` shadows a lifetime\n                           //        name that is already in scope\n    }\n}\n```\n\nPlease change the name of one of the lifetimes to remove this error. Example:\n\n```\nstruct Foo&lt;\&#39;a&gt; {\n    a: &amp;\&#39;a i32,\n}\n\nimpl&lt;\&#39;a&gt; Foo&lt;\&#39;a&gt; {\n    fn f&lt;\&#39;b&gt;(x: &amp;\&#39;b i32) { // ok!\n    }\n}\n\nfn main() {\n}\n```\n&quot;),
 (&quot;E0497&quot;,
  &quot;\nA stability attribute was used outside of the standard library. Erroneous code\nexample:\n\n```compile_fail\n#[stable] // error: stability attributes may not be used outside of the\n          //        standard library\nfn foo() {}\n```\n\nIt is not possible to use stability attributes outside of the standard library.\nAlso, for now, it is not possible to write deprecation messages either.\n&quot;),
 (&quot;E0512&quot;,
  &quot;\nTransmute with two differently sized types was attempted. Erroneous code\nexample:\n\n```compile_fail,E0512\nfn takes_u8(_: u8) {}\n\nfn main() {\n    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n    // error: transmute called with types of different sizes\n}\n```\n\nPlease use types with same size or use the expected type directly. Example:\n\n```\nfn takes_u8(_: u8) {}\n\nfn main() {\n    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n    // or:\n    unsafe { takes_u8(0u8); } // ok!\n}\n```\n&quot;),
 (&quot;E0517&quot;,
  &quot;\nThis error indicates that a `#[repr(..)]` attribute was placed on an\nunsupported item.\n\nExamples of erroneous code:\n\n```compile_fail,E0517\n#[repr(C)]\ntype Foo = u8;\n\n#[repr(packed)]\nenum Foo {Bar, Baz}\n\n#[repr(u8)]\nstruct Foo {bar: bool, baz: bool}\n\n#[repr(C)]\nimpl Foo {\n    // ...\n}\n```\n\n* The `#[repr(C)]` attribute can only be placed on structs and enums.\n* The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs.\n* The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums.\n\nThese attributes do not work on typedefs, since typedefs are just aliases.\n\nRepresentations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the\ndiscriminant size for C-like enums (when there is no associated data, e.g.\n`enum Color {Red, Blue, Green}`), effectively setting the size of the enum to\nthe size of the provided type. Such an enum can be cast to a value of the same\ntype as well. In short, `#[repr(u8)]` makes the enum behave like an integer\nwith a constrained set of allowed values.\n\nOnly C-like enums can be cast to numerical primitives, so this attribute will\nnot apply to structs.\n\n`#[repr(packed)]` reduces padding to make the struct size smaller. The\nrepresentation of enums isn\&#39;t strictly defined in Rust, and this attribute\nwon\&#39;t work on enums.\n\n`#[repr(simd)]` will give a struct consisting of a homogeneous series of machine\ntypes (i.e. `u8`, `i32`, etc) a representation that permits vectorization via\nSIMD. This doesn\&#39;t make much sense for enums since they don\&#39;t consist of a\nsingle list of data.\n&quot;),
 (&quot;E0518&quot;,
  &quot;\nThis error indicates that an `#[inline(..)]` attribute was incorrectly placed\non something other than a function or method.\n\nExamples of erroneous code:\n\n```compile_fail,E0518\n#[inline(always)]\nstruct Foo;\n\n#[inline(never)]\nimpl Foo {\n    // ...\n}\n```\n\n`#[inline]` hints the compiler whether or not to attempt to inline a method or\nfunction. By default, the compiler does a pretty good job of figuring this out\nitself, but if you feel the need for annotations, `#[inline(always)]` and\n`#[inline(never)]` can override or force the compiler\&#39;s decision.\n\nIf you wish to apply this attribute to all methods in an impl, manually annotate\neach method; it is not possible to annotate the entire impl with an `#[inline]`\nattribute.\n&quot;),
 (&quot;E0522&quot;,
  &quot;\nThe lang attribute is intended for marking special items that are built-in to\nRust itself. This includes special traits (like `Copy` and `Sized`) that affect\nhow the compiler behaves, as well as special functions that may be automatically\ninvoked (such as the handler for out-of-bounds accesses when indexing a slice).\nErroneous code example:\n\n```compile_fail,E0522\n#![feature(lang_items)]\n\n#[lang = \&quot;cookie\&quot;]\nfn cookie() -&gt; ! { // error: definition of an unknown language item: `cookie`\n    loop {}\n}\n```\n&quot;),
 (&quot;E0525&quot;,
  &quot;\nA closure was used but didn\&#39;t implement the expected trait.\n\nErroneous code example:\n\n```compile_fail,E0525\nstruct X;\n\nfn foo&lt;T&gt;(_: T) {}\nfn bar&lt;T: Fn(u32)&gt;(_: T) {}\n\nfn main() {\n    let x = X;\n    let closure = |_| foo(x); // error: expected a closure that implements\n                              //        the `Fn` trait, but this closure only\n                              //        implements `FnOnce`\n    bar(closure);\n}\n```\n\nIn the example above, `closure` is an `FnOnce` closure whereas the `bar`\nfunction expected an `Fn` closure. In this case, it\&#39;s simple to fix the issue,\nyou just have to implement `Copy` and `Clone` traits on `struct X` and it\&#39;ll\nbe ok:\n\n```\n#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.\nstruct X;\n\nfn foo&lt;T&gt;(_: T) {}\nfn bar&lt;T: Fn(u32)&gt;(_: T) {}\n\nfn main() {\n    let x = X;\n    let closure = |_| foo(x);\n    bar(closure); // ok!\n}\n```\n\nTo understand better how closures work in Rust, read:\nhttps://doc.rust-lang.org/book/first-edition/closures.html\n&quot;),
 (&quot;E0580&quot;,
  &quot;\nThe `main` function was incorrectly declared.\n\nErroneous code example:\n\n```compile_fail,E0580\nfn main() -&gt; i32 { // error: main function has wrong type\n    0\n}\n```\n\nThe `main` function prototype should never take arguments or return type.\nExample:\n\n```\nfn main() {\n    // your code\n}\n```\n\nIf you want to get command-line arguments, use `std::env::args`. To exit with a\nspecified exit code, use `std::process::exit`.\n&quot;),
 (&quot;E0591&quot;,
  &quot;\nPer [RFC 401][rfc401], if you have a function declaration `foo`:\n\n```\n// For the purposes of this explanation, all of these\n// different kinds of `fn` declarations are equivalent:\nstruct S;\nfn foo(x: S) { /* ... */ }\n# #[cfg(for_demonstration_only)]\nextern \&quot;C\&quot; { fn foo(x: S); }\n# #[cfg(for_demonstration_only)]\nimpl S { fn foo(self) { /* ... */ } }\n```\n\nthe type of `foo` is **not** `fn(S)`, as one might expect.\nRather, it is a unique, zero-sized marker type written here as `typeof(foo)`.\nHowever, `typeof(foo)` can be _coerced_ to a function pointer `fn(S)`,\nso you rarely notice this:\n\n```\n# struct S;\n# fn foo(_: S) {}\nlet x: fn(S) = foo; // OK, coerces\n```\n\nThe reason that this matter is that the type `fn(S)` is not specific to\nany particular function: it\&#39;s a function _pointer_. So calling `x()` results\nin a virtual call, whereas `foo()` is statically dispatched, because the type\nof `foo` tells us precisely what function is being called.\n\nAs noted above, coercions mean that most code doesn\&#39;t have to be\nconcerned with this distinction. However, you can tell the difference\nwhen using **transmute** to convert a fn item into a fn pointer.\n\nThis is sometimes done as part of an FFI:\n\n```compile_fail,E0591\nextern \&quot;C\&quot; fn foo(userdata: Box&lt;i32&gt;) {\n    /* ... */\n}\n\n# fn callback(_: extern \&quot;C\&quot; fn(*mut i32)) {}\n# use std::mem::transmute;\n# unsafe {\nlet f: extern \&quot;C\&quot; fn(*mut i32) = transmute(foo);\ncallback(f);\n# }\n```\n\nHere, transmute is being used to convert the types of the fn arguments.\nThis pattern is incorrect because, because the type of `foo` is a function\n**item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\nis a function pointer, which is not zero-sized.\nThis pattern should be rewritten. There are a few possible ways to do this:\n\n- change the original fn declaration to match the expected signature,\n  and do the cast in the fn body (the prefered option)\n- cast the fn item fo a fn pointer before calling transmute, as shown here:\n\n    ```\n    # extern \&quot;C\&quot; fn foo(_: Box&lt;i32&gt;) {}\n    # use std::mem::transmute;\n    # unsafe {\n    let f: extern \&quot;C\&quot; fn(*mut i32) = transmute(foo as extern \&quot;C\&quot; fn(_));\n    let f: extern \&quot;C\&quot; fn(*mut i32) = transmute(foo as usize); // works too\n    # }\n    ```\n\nThe same applies to transmutes to `*mut fn()`, which were observedin practice.\nNote though that use of this type is generally incorrect.\nThe intention is typically to describe a function pointer, but just `fn()`\nalone suffices for that. `*mut fn()` is a pointer to a fn pointer.\n(Since these values are typically just passed to C code, however, this rarely\nmakes a difference in practice.)\n\n[rfc401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n&quot;),
 (&quot;E0593&quot;,
  &quot;\nYou tried to supply an `Fn`-based type with an incorrect number of arguments\nthan what was expected.\n\nErroneous code example:\n\n```compile_fail,E0593\nfn foo&lt;F: Fn()&gt;(x: F) { }\n\nfn main() {\n    // [E0593] closure takes 1 argument but 0 arguments are required\n    foo(|y| { });\n}\n```\n&quot;),
 (&quot;E0601&quot;,
  &quot;\nNo `main` function was found in a binary crate. To fix this error, just add a\n`main` function. For example:\n\n```\nfn main() {\n    // Your program will start here.\n    println!(\&quot;Hello world!\&quot;);\n}\n```\n\nIf you don\&#39;t know the basics of Rust, you can go look to the Rust Book to get\nstarted: https://doc.rust-lang.org/book/\n&quot;),
 (&quot;E0602&quot;,
  &quot;\nAn unknown lint was used on the command line.\n\nErroneous example:\n\n```sh\nrustc -D bogus omse_file.rs\n```\n\nMaybe you just misspelled the lint name or the lint doesn\&#39;t exist anymore.\nEither way, try to update/remove it in order to fix the error.\n&quot;),
 (&quot;E0621&quot;,
  &quot;\nThis error code indicates a mismatch between the lifetimes appearing in the\nfunction signature (i.e., the parameter types and the return type) and the\ndata-flow found in the function body.\n\nErroneous code example:\n\n```compile_fail,E0621\nfn foo&lt;\&#39;a&gt;(x: &amp;\&#39;a i32, y: &amp;i32) -&gt; &amp;\&#39;a i32 { // error: explicit lifetime\n                                             //        required in the type of\n                                             //        `y`\n    if x &gt; y { x } else { y }\n}\n```\n\nIn the code above, the function is returning data borrowed from either `x` or\n`y`, but the `\&#39;a` annotation indicates that it is returning data only from `x`.\nTo fix the error, the signature and the body must be made to match. Typically,\nthis is done by updating the function signature. So, in this case, we change\nthe type of `y` to `&amp;\&#39;a i32`, like so:\n\n```\nfn foo&lt;\&#39;a&gt;(x: &amp;\&#39;a i32, y: &amp;\&#39;a i32) -&gt; &amp;\&#39;a i32 {\n    if x &gt; y { x } else { y }\n}\n```\n\nNow the signature indicates that the function data borrowed from either `x` or\n`y`. Alternatively, you could change the body to not return data from `y`:\n\n```\nfn foo&lt;\&#39;a&gt;(x: &amp;\&#39;a i32, y: &amp;i32) -&gt; &amp;\&#39;a i32 {\n    x\n}\n```\n&quot;)]</code></pre><div class='stability'><div class='stab unstable'><details><summary><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>rustc_private</code>)</summary><p>this crate is being loaded from the sysroot, and unstable location; did you mean to load this crate from crates.io via <code>Cargo.toml</code> instead?</p>
</details></div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "rustc";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>