initSidebarItems({"enum":[["FixupError",""],["InferTables","A version of &ty::Tables which can be global or local. Only the local version supports borrow_mut."],["LateBoundRegionConversionTime","Times when we replace late-bound regions with variables:"],["ParameterOrigin","Places that type/region parameters can appear."],["RegionVariableOrigin","Reasons to create a region inference variable"],["SubregionOrigin","The origin of a `r1 <= r2` constraint."],["TypeOrigin","Why did we require that the two types be related?"],["ValuePairs","See `error_reporting.rs` for more details"]],"mod":[["bivariate","Applies the \"bivariance relationship\" to two types and/or regions. If (A,B) are bivariant then either A <: B or B <: A. It occurs when type/lifetime parameters are unconstrained. Usually this is an error, but we permit it in the specific case where a type parameter is constrained in a where-clause via an associated type."],["combine",""],["equate",""],["error_reporting","Error Reporting Code for the inference engine"],["glb",""],["lattice","Lattice Variables"],["lub",""],["region_inference","See README.md"],["resolve",""],["sub",""],["type_variable",""],["unify_key",""]],"struct":[["CombinedSnapshot",""],["InferCtxt",""],["InferCtxtBuilder","Helper type of a temporary returned by tcx.infer_ctxt(...). Necessary because we can't write the following bound: F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>)."],["InferOk",""],["TypeFreshener",""],["TypeTrace","The trace designates the path through inference that we took to encounter an error or subtyping constraint."]],"trait":[["TransNormalize","Helper trait for shortening the lifetimes inside a value for post-type-checking normalization."]],"type":[["Bound",""],["FixupResult",""],["InferResult",""],["SkolemizationMap","A map returned by `skolemize_late_bound_regions()` indicating the skolemized region that each late-bound region was replaced with."],["UnitResult",""]]});