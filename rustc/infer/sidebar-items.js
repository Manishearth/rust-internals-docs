initSidebarItems({"enum":[["FixupError",""],["LateBoundRegionConversionTime","Times when we replace late-bound regions with variables:"],["ParameterOrigin","Places that type/region parameters can appear."],["RegionVariableOrigin","Reasons to create a region inference variable"],["SubregionOrigin","The origin of a `r1 <= r2` constraint."],["ValuePairs","See `error_reporting` module for more details"]],"mod":[["at","A nice interface for working with the infcx.  The basic idea is to do `infcx.at(cause, param_env)`, which sets the \"cause\" of the operation as well as the surrounding parameter environment.  Then you can do something like `.sub(a, b)` or `.eq(a, b)` to create a subtype or equality relationship respectively. The first argument is always the \"expected\" output from the POV of diagnostics."],["error_reporting","Error Reporting Code for the inference engine"],["lattice","Lattice Variables"],["region_inference","See README.md"],["resolve",""],["type_variable",""],["unify_key",""]],"struct":[["CombinedSnapshot",""],["InferCtxt",""],["InferCtxtBuilder","Helper type of a temporary returned by tcx.infer_ctxt(). Necessary because we can't write the following bound: F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>)."],["InferOk",""],["TypeFreshener",""],["TypeTrace","The trace designates the path through inference that we took to encounter an error or subtyping constraint."]],"trait":[["TransNormalize","Helper trait for shortening the lifetimes inside a value for post-type-checking normalization."]],"type":[["Bound",""],["FixupResult",""],["InferResult",""],["SkolemizationMap","A map returned by `skolemize_late_bound_regions()` indicating the skolemized region that each late-bound region was replaced with."],["UnitResult",""]]});