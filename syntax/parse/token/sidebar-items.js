initSidebarItems({"constant":[["SELF_KEYWORD_NAME",""],["SELF_KEYWORD_NAME_NUM",""]],"enum":[["BinOpToken",""],["DelimToken","A delimiter token"],["IdentStyle",""],["Lit",""],["Nonterminal","For interpolation during macro expansion."],["SpecialMacroVar",""],["Token",""]],"fn":[["fresh_mark",""],["fresh_name",""],["gensym","gensym's a new usize, using the current interner."],["gensym_ident","Maps a string to a gensym'ed identifier."],["get_ident_interner",""],["intern","Maps a string to its interned representation."],["intern_and_get_ident","Interns and returns the string contents of an identifier, using the thread-local interner."],["reset_ident_interner","Reset the ident interner to its initial state."],["str_to_ident","Maps a string to an identifier with an empty syntax context."]],"mod":[["keywords","All the valid words that have meaning in the Rust language.Rust keywords are either 'strict' or 'reserved'.  Strict keywords may not appear as identifiers at all. Reserved keywords are not used anywhere in the language and may not appear as identifiers."],["special_idents",""],["special_names",""]],"struct":[["InternedString","Represents a string stored in the thread-local interner. Because the interner lives for the life of the thread, this can be safely treated as an immortal string, as long as it never crosses between threads.FIXME(pcwalton): You must be careful about what you do in the destructors of objects stored in TLS, because they may run after the interner is destroyed. In particular, they must not access string contents. This can be fixed in the future by just leaking all strings until thread death somehow."]],"type":[["IdentInterner",""]]});