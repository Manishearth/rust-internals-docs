initSidebarItems({"macro":[["fileline_help!",""],["panictry!",""],["register_diagnostic!",""],["register_diagnostics!",""],["register_long_diagnostics!",""],["span_err!",""],["span_err_or_warn!",""],["span_fatal!",""],["span_help!",""],["span_note!",""],["span_warn!",""],["struct_span_err!",""],["struct_span_err_or_warn!",""],["struct_span_fatal!",""],["struct_span_warn!",""],["walk_list!",""]],"mod":[["abi",""],["ast",""],["ast_util",""],["attr",""],["codemap","The CodeMap tracks all the source code used within a single crate, mapping from integer byte positions to the original source code location. Each bit of source parsed during crate parsing (typically files, in-memory strings, or various bits of macro expansion) cover a continuous range of bytes in the CodeMap and are represented by FileMaps. Byte positions are stored in `spans` and used pervasively in the compiler. They are absolute positions within the CodeMap, which upon request can be converted to line and column information, source code snippets, etc."],["config",""],["diagnostics",""],["entry",""],["errors",""],["ext",""],["feature_gate","Feature gatingThis module implements the gating necessary for preventing certain compiler features from being used by default. This module will crawl a pre-expanded AST to ensure that there are no features which are used that are not enabled.Features are enabled in programs via the crate-level attributes of `#![feature(...)]` with a comma-separated list of features.For the purpose of future feature-tracking, once code for detection of feature gate usage is added, *do not remove it again* even once the feature becomes stable."],["fold","A Folder represents an AST->AST fold; it accepts an AST piece, and returns a piece of the same type. So, for instance, macro expansion is a Folder that walks over an AST and produces another AST.Note: using a Folder (other than the MacroExpander Folder) on an AST before macro expansion is probably a bad idea. For instance, a folder renaming item names in a module will miss all of those that are created by the expansion of a macro."],["owned_slice",""],["parse","The main parser interface"],["print",""],["ptr","The AST pointerProvides `P<T>`, a frozen owned smart pointer, as a replacement for `@T` in the AST.Motivations and benefits**Identity**: sharing AST nodes is problematic for the various analysis passes (e.g. one may be able to bypass the borrow checker with a shared `ExprKind::AddrOf` node taking a mutable borrow). The only reason `@T` in the AST hasn't caused issues is because of inefficient folding passes which would always deduplicate any such shared nodes. Even if the AST were to switch to an arena, this would still hold, i.e. it couldn't use `&'a T`, but rather a wrapper like `P<'a, T>`.**Immutability**: `P<T>` disallows mutating its inner `T`, unlike `Box<T>` (unless it contains an `Unsafe` interior, but that may be denied later). This mainly prevents mistakes, but can also enforces a kind of \"purity\".**Efficiency**: folding can reuse allocation space for `P<T>` and `Vec<T>`, the latter even when the input and output types differ (as it would be the case with arenas or a GADT AST using type parameters to toggle features).**Maintainability**: `P<T>` provides a fixed interface - `Deref`, `and_then` and `map` - which can remain fully functional even if the implementation changes (using a special thread-local heap, for example). Moreover, a switch to, e.g. `P<'a, T>` would be easy and mostly automated."],["show_span","Span debuggerThis module shows spans for all expressions in the crate to help with compiler debugging."],["std_inject",""],["str",""],["syntax",""],["test",""],["util",""],["visit","AST walker. Each overridden visit method has full control over what happens with its node, it can do its own traversal of the node's children, call `visit::walk_*` to apply the default traversal algorithm, or prevent deeper traversal by doing nothing.Note: it is an important invariant that the default visitor walks the body of a function in \"execution order\" (more concretely, reverse post-order with respect to the CFG implied by the AST), meaning that if AST node A may execute before AST node B, then A is visited first.  The borrow checker in particular relies on this property.Note: walking an AST before macro expansion is probably a bad idea. For instance, a walker looking for item names in a module will miss all of those that are created by the expansion of a macro."]]});