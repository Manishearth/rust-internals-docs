initSidebarItems({"mod":[["abi",""],["rpath",""],["sha2","This module implements only the Sha256 function since that is all that is needed for internal use. This implementation is not intended for external use or for any use where security is important."],["slice",""],["svh","Calculation and management of a Strict Version Hash for cratesToday's ABI problemIn today's implementation of rustc, it is incredibly difficult to achieve forward binary compatibility without resorting to C-like interfaces. Within rust code itself, abi details such as symbol names suffer from a variety of unrelated factors to code changing such as the \"def id drift\" problem. This ends up yielding confusing error messages about metadata mismatches and such.The core of this problem is when an upstream dependency changes and downstream dependents are not recompiled. This causes compile errors because the upstream crate's metadata has changed but the downstream crates are still referencing the older crate's metadata.This problem exists for many reasons, the primary of which is that rust does not currently support forwards ABI compatibility (in place upgrades of a crate).SVH and how it alleviates the problemWith all of this knowledge on hand, this module contains the implementation of a notion of a \"Strict Version Hash\" for a crate. This is essentially a hash of all contents of a crate which can somehow be exposed to downstream crates.This hash is currently calculated by just hashing the AST, but this is obviously wrong (doc changes should not result in an incompatible ABI). Implementation-wise, this is required at this moment in time.By encoding this strict version hash into all crate's metadata, stale crates can be detected immediately and error'd about by rustc itself.Relevant linksOriginal issue: https://github.com/rust-lang/rust/issues/10207"],["target","Flexible target specification.Rust targets a wide variety of usecases, and in the interest of flexibility, allows new target triples to be defined in configuration files. Most users will not need to care about these, but this is invaluable when porting Rust to a new platform, and allows for an unprecedented level of control over how the compiler works.Using custom targetsA target triple, as passed via `rustc --target=TRIPLE`, will first be compared against the list of built-in targets. This is to ease distributing rustc (no need for configuration files) and also to hold these built-in targets as immutable and sacred. If `TRIPLE` is not one of the built-in targets, rustc will check if a file named `TRIPLE` exists. If it does, it will be loaded as the target configuration. If the file does not exist, rustc will search each directory in the environment variable `RUST_TARGET_PATH` for a file named `TRIPLE.json`. The first one found will be loaded. If no file is found in any of those directories, a fatal error will be given.  `RUST_TARGET_PATH` includes `/etc/rustc` as its last entry, to be searched by default.Projects defining their own targets should use `--target=path/to/my-awesome-platform.json` instead of adding to `RUST_TARGET_PATH`.Defining a new targetTargets are defined using JSON. The `Target` struct in this module defines the format the JSON file should take, though each underscore in the field names should be replaced with a hyphen (`-`) in the JSON file. Some fields are required in every target specification, such as `data-layout`, `llvm-target`, `target-endian`, `target-pointer-width`, and `arch`. In general, options passed to rustc with `-C` override the target's settings, though `target-feature` and `link-args` will *add* to the list specified by the target, rather than replace."],["tempdir",""]]});