initSidebarItems({"mod":[["astconv_util","This module contains a simple utility routine used by both `typeck` and `const_eval`. Almost certainly this could (and should) be refactored out of existence."],["astencode",""],["cast",""],["cfg","Module that constructs a control-flow graph representing an item. Uses `Graph` as the underlying representation."],["check_const",""],["check_loop",""],["check_match",""],["check_rvalues",""],["check_static_recursion",""],["const_eval",""],["dataflow","A module for propagating forward dataflow information. The analysis assumes that the items to be propagated can be represented as bits and thus uses bitvectors. Your job is simply to specify the so-called GEN and KILL bits for each expression."],["dead",""],["def",""],["dependency_format","Resolution of mixing rlibs and dylibs"],["effect","Enforces the Rust effect system. Currently there is just one effect, `unsafe`."],["entry",""],["expr_use_visitor","A different sort of visitor for walking fn bodies.  Unlike the normal visitor, which just walks the entire body in one shot, the `ExprUseVisitor` determines how expressions are being used."],["fast_reject",""],["free_region","This file defines"],["implicator",""],["infer","See the Book for more information."],["intrinsicck",""],["lang_items",""],["liveness","A classic liveness analysis based on dataflow over the AST.  Computes, for each local variable in a function, whether that variable is live at a given point.  Program execution points are identified by their id."],["mem_categorization","Categorization"],["outlives",""],["pat_util",""],["privacy","A pass that checks to make sure private fields and methods aren't used outside their scopes. This pass will also generate a set of exported items which are available for use externally when compiled as a library."],["reachable",""],["recursion_limit",""],["region","This file actually contains two passes related to regions.  The first pass builds up the `scope_map`, which describes the parent links in the region hierarchy.  The second pass infers which types must be region parameterized."],["resolve_lifetime","Name resolution for lifetimes."],["stability","A pass that annotates every item and method with its stability level, propagating default levels lexically from parent to children ast nodes."],["subst",""],["traits","Trait Resolution. See the Book for more."],["ty",""],["ty_fold","Generalized type folding mechanism. The setup is a bit convoluted but allows for convenient usage. Let T be an instance of some \"foldable type\" (one which implements `TypeFoldable`) and F be an instance of a \"folder\" (a type which implements `TypeFolder`). Then the setup is intended to be:"],["ty_match",""],["ty_relate","Generalized type relating mechanism. A type relation R relates a pair of values (A, B). A and B are usually types or regions but can be other things. Examples of type relations are subtyping, type equality, etc."],["ty_walk","An iterator over the type substructure. WARNING: this does not keep track of the region depth."],["weak_lang_items","Validity checking for weak lang items"],["wf",""]]});