initSidebarItems({"mod":[["args","Global storage for command line argumentsThe current incarnation of the Rust runtime expects for the processes `argc` and `argv` arguments to be stored in a globally-accessible location for use by the `os` module.Only valid to call on Linux. Mac and Windows use syscalls to discover the command line arguments.FIXME #7756: Would be nice for this to not exist."],["at_exit_imp","Implementation of running at_exit routinesDocumentation can be found on the `rt::at_exit` function."],["dwarf","Utilities for parsing DWARF-encoded data streams. See http://www.dwarfstd.org, DWARF-4 standard, Section 7 - \"Data Representation\""],["libunwind","Unwind library interface"],["poison",""],["thread_local","OS-based thread local storageThis module provides an implementation of OS-based thread local storage, using the native OS-provided facilities (think `TlsAlloc` or `pthread_setspecific`). The interface of this differs from the other types of thread-local-storage provided in this crate in that OS-based TLS can only get/set pointers,This module also provides two flavors of TLS. One is intended for static initialization, and does not contain a `Drop` implementation to deallocate the OS-TLS key. The other is a type which does implement `Drop` and hence has a safe interface.UsageThis module should likely not be used directly unless other primitives are being built on. types such as `thread_local::spawn::Key` are likely much more useful in practice than this OS-based version which likely requires unsafe code to interoperate with.ExamplesUsing a dynamically allocated TLS key. Note that this key can be shared among many threads via an `Arc`.Sometimes a statically allocated key is either required or easier to work with, however."],["unwind","Implementation of Rust stack unwindingFor background on exception handling and stack unwinding please see \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and documents linked from it. These are also good reads:     http://mentorembedded.github.io/cxx-abi/abi-eh.html     http://monoinfinito.wordpress.com/series/exception-handling-in-c/     http://www.airs.com/blog/index.php?s=exception+framesA brief summaryException handling happens in two phases: a search phase and a cleanup phase.In both phases the unwinder walks stack frames from top to bottom using information from the stack frame unwind sections of the current process's modules (\"module\" here refers to an OS module, i.e. an executable or a dynamic library).For each stack frame, it invokes the associated \"personality routine\", whose address is also stored in the unwind info section.In the search phase, the job of a personality routine is to examine exception object being thrown, and to decide whether it should be caught at that stack frame.  Once the handler frame has been identified, cleanup phase begins.In the cleanup phase, the unwinder invokes each personality routine again. This time it decides which (if any) cleanup code needs to be run for the current stack frame.  If so, the control is transferred to a special branch in the function body, the \"landing pad\", which invokes destructors, frees memory, etc.  At the end of the landing pad, control is transferred back to the unwinder and unwinding resumes.Once stack has been unwound down to the handler frame level, unwinding stops and the last personality routine transfers control to the catch block.`eh_personality` and `eh_unwind_resume`These language items are used by the compiler when generating unwind info. The first one is the personality routine described above.  The second one allows compilation target to customize the process of resuming unwind at the end of the landing pads.  `eh_unwind_resume` is used only if `custom_unwind_resume` flag in the target options is set.Frame unwind info registrationEach module's image contains a frame unwind info section (usually \".eh_frame\"). When a module is loaded/unloaded into the process, the unwinder must be informed about the location of this section in memory. The methods of achieving that vary by the platform. On some (e.g. Linux), the unwinder can discover unwind info sections on its own (by dynamically enumerating currently loaded modules via the dl_iterate_phdr() API and finding their \".eh_frame\" sections); Others, like Windows, require modules to actively register their unwind info sections via unwinder API (see `rust_eh_register_frames`/`rust_eh_unregister_frames`)."],["wtf8","Implementation of the WTF-8 encoding.This library uses Rustâ€™s type system to maintain well-formedness, like the `String` and `&str` types do for UTF-8.Since WTF-8 must not be used for interchange, this library deliberately does not provide access to the underlying bytes of WTF-8 strings, nor can it decode WTF-8 from arbitrary bytes. WTF-8 strings can be obtained from UTF-8, UTF-16, or code points."]]});