<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `fmt` mod in crate `std`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, fmt">

    <title>std::fmt - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../normalize.css">
    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../../std/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='logo' width='100'></a>
        <p class='location'><a href='../index.html'>std</a></p><script>window.sidebarCurrent = {name: 'fmt', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Module <a href='../index.html'>std</a>::<wbr><a class='mod' href=''>fmt</a></span><span class='out-of-band'><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../../src/collections/fmt.rs.html#11-545' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Utilities for formatting and printing <code>String</code>s</p>

<p>This module contains the runtime support for the <code>format!</code> syntax extension.
This macro is implemented in the compiler to emit calls to this module in
order to format arguments at runtime into strings.</p>

<h1 id='usage' class='section-header'><a href='#usage'>Usage</a></h1>
<p>The <code>format!</code> macro is intended to be familiar to those coming from C&#39;s
printf/fprintf functions or Python&#39;s <code>str.format</code> function.</p>

<p>Some examples of the <code>format!</code> extension are:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Hello&quot;</span>);                 <span class='comment'>// =&gt; &quot;Hello&quot;</span>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, {}!&quot;</span>, <span class='string'>&quot;world&quot;</span>);   <span class='comment'>// =&gt; &quot;Hello, world!&quot;</span>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;The number is {}&quot;</span>, <span class='number'>1</span>);   <span class='comment'>// =&gt; &quot;The number is 1&quot;</span>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, (<span class='number'>3</span>, <span class='number'>4</span>));          <span class='comment'>// =&gt; &quot;(3, 4)&quot;</span>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{value}&quot;</span>, <span class='ident'>value</span><span class='op'>=</span><span class='number'>4</span>);      <span class='comment'>// =&gt; &quot;4&quot;</span>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{} {}&quot;</span>, <span class='number'>1</span>, <span class='number'>2</span>);           <span class='comment'>// =&gt; &quot;1 2&quot;</span>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:04}&quot;</span>, <span class='number'>42</span>);             <span class='comment'>// =&gt; &quot;0042&quot; with leading zeros</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aformat!(%22Hello%22)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%22Hello%22%0Aformat!(%22Hello%2C%20%7B%7D!%22%2C%20%22world%22)%3B%20%20%20%2F%2F%20%3D%3E%20%22Hello%2C%20world!%22%0Aformat!(%22The%20number%20is%20%7B%7D%22%2C%201)%3B%20%20%20%2F%2F%20%3D%3E%20%22The%20number%20is%201%22%0Aformat!(%22%7B%3A%3F%7D%22%2C%20(3%2C%204))%3B%20%20%20%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%22(3%2C%204)%22%0Aformat!(%22%7Bvalue%7D%22%2C%20value%3D4)%3B%20%20%20%20%20%20%2F%2F%20%3D%3E%20%224%22%0Aformat!(%22%7B%7D%20%7B%7D%22%2C%201%2C%202)%3B%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%221%202%22%0Aformat!(%22%7B%3A04%7D%22%2C%2042)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%220042%22%20with%20leading%20zeros%0A%7D">Run</a></pre>

<p>From these, you can see that the first argument is a format string. It is
required by the compiler for this to be a string literal; it cannot be a
variable passed in (in order to perform validity checking). The compiler
will then parse the format string and determine if the list of arguments
provided is suitable to pass to this format string.</p>

<h2 id='positional-parameters' class='section-header'><a href='#positional-parameters'>Positional parameters</a></h2>
<p>Each formatting argument is allowed to specify which value argument it&#39;s
referencing, and if omitted it is assumed to be &quot;the next argument&quot;. For
example, the format string <code>{} {} {}</code> would take three parameters, and they
would be formatted in the same order as they&#39;re given. The format string
<code>{2} {1} {0}</code>, however, would format arguments in reverse order.</p>

<p>Things can get a little tricky once you start intermingling the two types of
positional specifiers. The &quot;next argument&quot; specifier can be thought of as an
iterator over the argument. Each time a &quot;next argument&quot; specifier is seen,
the iterator advances. This leads to behavior like this:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{1} {} {0} {}&quot;</span>, <span class='number'>1</span>, <span class='number'>2</span>); <span class='comment'>// =&gt; &quot;2 1 1 2&quot;</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aformat!(%22%7B1%7D%20%7B%7D%20%7B0%7D%20%7B%7D%22%2C%201%2C%202)%3B%20%2F%2F%20%3D%3E%20%222%201%201%202%22%0A%7D">Run</a></pre>

<p>The internal iterator over the argument has not been advanced by the time
the first <code>{}</code> is seen, so it prints the first argument. Then upon reaching
the second <code>{}</code>, the iterator has advanced forward to the second argument.
Essentially, parameters which explicitly name their argument do not affect
parameters which do not name an argument in terms of positional specifiers.</p>

<p>A format string is required to use all of its arguments, otherwise it is a
compile-time error. You may refer to the same argument more than once in the
format string, although it must always be referred to with the same type.</p>

<h2 id='named-parameters' class='section-header'><a href='#named-parameters'>Named parameters</a></h2>
<p>Rust itself does not have a Python-like equivalent of named parameters to a
function, but the <code>format!</code> macro is a syntax extension which allows it to
leverage named parameters. Named parameters are listed at the end of the
argument list and have the syntax:</p>

<pre><code class="language-text">identifier &#39;=&#39; expression
</code></pre>

<p>For example, the following <code>format!</code> expressions all use named argument:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{argument}&quot;</span>, <span class='ident'>argument</span> <span class='op'>=</span> <span class='string'>&quot;test&quot;</span>);   <span class='comment'>// =&gt; &quot;test&quot;</span>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{name} {}&quot;</span>, <span class='number'>1</span>, <span class='ident'>name</span> <span class='op'>=</span> <span class='number'>2</span>);          <span class='comment'>// =&gt; &quot;2 1&quot;</span>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{a} {c} {b}&quot;</span>, <span class='ident'>a</span><span class='op'>=</span><span class='string'>&quot;a&quot;</span>, <span class='ident'>b</span><span class='op'>=</span><span class='string'>&#39;b&#39;</span>, <span class='ident'>c</span><span class='op'>=</span><span class='number'>3</span>);  <span class='comment'>// =&gt; &quot;a 3 b&quot;</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aformat!(%22%7Bargument%7D%22%2C%20argument%20%3D%20%22test%22)%3B%20%20%20%2F%2F%20%3D%3E%20%22test%22%0Aformat!(%22%7Bname%7D%20%7B%7D%22%2C%201%2C%20name%20%3D%202)%3B%20%20%20%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%222%201%22%0Aformat!(%22%7Ba%7D%20%7Bc%7D%20%7Bb%7D%22%2C%20a%3D%22a%22%2C%20b%3D'b'%2C%20c%3D3)%3B%20%20%2F%2F%20%3D%3E%20%22a%203%20b%22%0A%7D">Run</a></pre>

<p>It is not valid to put positional parameters (those without names) after
arguments which have names. Like with positional parameters, it is not
valid to provide named parameters that are unused by the format string.</p>

<h2 id='argument-types' class='section-header'><a href='#argument-types'>Argument types</a></h2>
<p>Each argument&#39;s type is dictated by the format string. It is a requirement
that every argument is only ever referred to by one type. For example, this
is an invalid format string:</p>

<pre><code class="language-text">{0:x} {0:o}
</code></pre>

<p>This is invalid because the first argument is both referred to as a
hexadecimal as well as an
octal.</p>

<p>There are various parameters which do require a particular type, however.
An example is the <code>{:.*}</code> syntax, which sets the number of decimal places
in floating-point types:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>formatted_number</span> <span class='op'>=</span> <span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.*}&quot;</span>, <span class='number'>2</span>, <span class='number'>1.234567</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;1.23&quot;</span>, <span class='ident'>formatted_number</span>)<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20formatted_number%20%3D%20format!(%22%7B%3A.*%7D%22%2C%202%2C%201.234567)%3B%0A%0Aassert_eq!(%221.23%22%2C%20formatted_number)%0A%7D">Run</a></pre>

<p>If this syntax is used, then the number of characters to print precedes the
actual object being formatted, and the number of characters must have the
type <code>usize</code>. Although a <code>usize</code> can be printed with <code>{}</code>, it is invalid to
reference an argument as such. For example this is another invalid format
string:</p>

<pre><code class="language-text">{:.*} {0}
</code></pre>

<h2 id='formatting-traits' class='section-header'><a href='#formatting-traits'>Formatting traits</a></h2>
<p>When requesting that an argument be formatted with a particular type, you
are actually requesting that an argument ascribes to a particular trait.
This allows multiple actual types to be formatted via <code>{:x}</code> (like <code>i8</code> as
well as <code>isize</code>).  The current mapping of types to traits is:</p>

<ul>
<li><em>nothing</em> ⇒ <a href="trait.Display.html"><code>Display</code></a></li>
<li><code>?</code> ⇒ <a href="trait.Debug.html"><code>Debug</code></a></li>
<li><code>o</code> ⇒ <a href="trait.Octal.html"><code>Octal</code></a></li>
<li><code>x</code> ⇒ <a href="trait.LowerHex.html"><code>LowerHex</code></a></li>
<li><code>X</code> ⇒ <a href="trait.UpperHex.html"><code>UpperHex</code></a></li>
<li><code>p</code> ⇒ <a href="trait.Pointer.html"><code>Pointer</code></a></li>
<li><code>b</code> ⇒ <a href="trait.Binary.html"><code>Binary</code></a></li>
<li><code>e</code> ⇒ <a href="trait.LowerExp.html"><code>LowerExp</code></a></li>
<li><code>E</code> ⇒ <a href="trait.UpperExp.html"><code>UpperExp</code></a></li>
</ul>

<p>What this means is that any type of argument which implements the
<code>fmt::Binary</code> trait can then be formatted with <code>{:b}</code>. Implementations
are provided for these traits for a number of primitive types by the
standard library as well. If no format is specified (as in <code>{}</code> or <code>{:6}</code>),
then the format trait used is the <code>Display</code> trait.</p>

<p>When implementing a format trait for your own type, you will have to
implement a method of the signature:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23!%5Ballow(dead_code)%5D%0Ause%20std%3A%3Afmt%3B%0Astruct%20Foo%3B%20%2F%2F%20our%20custom%20type%0Aimpl%20fmt%3A%3ADisplay%20for%20Foo%20%7B%0Afn%20fmt(%26self%2C%20f%3A%20%26mut%20fmt%3A%3AFormatter)%20-%3E%20fmt%3A%3AResult%20%7B%0Awrite!(f%2C%20%22testing%2C%20testing%22)%0A%7D%20%7D%0A%7D">Run</a></pre>

<p>Your type will be passed as <code>self</code> by-reference, and then the function
should emit output into the <code>f.buf</code> stream. It is up to each format trait
implementation to correctly adhere to the requested formatting parameters.
The values of these parameters will be listed in the fields of the
<code>Formatter</code> struct. In order to help with this, the <code>Formatter</code> struct also
provides some helper methods.</p>

<p>Additionally, the return value of this function is <code>fmt::Result</code> which is a
type alias of <code>Result&lt;(), std::fmt::Error&gt;</code>. Formatting implementations
should ensure that they propagate errors from the <code>Formatter</code> (e.g., when
calling <code>write!</code>) however, they should never return errors spuriously. That
is, a formatting implementation must and may only return an error if the
passed-in <code>Formatter</code> returns an error. This is because, contrary to what
the function signature might suggest, string formatting is an infallible
operation. This function only returns a result because writing to the
underlying stream might fail and it must provide a way to propagate the fact
that an error has occurred back up the stack.</p>

<p>An example of implementing the formatting traits would look
like:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>;

<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Vector2D</span> {
    <span class='ident'>x</span>: <span class='ident'>isize</span>,
    <span class='ident'>y</span>: <span class='ident'>isize</span>,
}

<span class='kw'>impl</span> <span class='ident'>fmt</span>::<span class='ident'>Display</span> <span class='kw'>for</span> <span class='ident'>Vector2D</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='comment'>// The `f` value implements the `Write` trait, which is what the</span>
        <span class='comment'>// write! macro is expecting. Note that this formatting ignores the</span>
        <span class='comment'>// various flags provided to format strings.</span>
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>, <span class='string'>&quot;({}, {})&quot;</span>, <span class='self'>self</span>.<span class='ident'>x</span>, <span class='self'>self</span>.<span class='ident'>y</span>)
    }
}

<span class='comment'>// Different traits allow different forms of output of a type. The meaning</span>
<span class='comment'>// of this format is to print the magnitude of a vector.</span>
<span class='kw'>impl</span> <span class='ident'>fmt</span>::<span class='ident'>Binary</span> <span class='kw'>for</span> <span class='ident'>Vector2D</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='kw'>let</span> <span class='ident'>magnitude</span> <span class='op'>=</span> (<span class='self'>self</span>.<span class='ident'>x</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>x</span> <span class='op'>+</span> <span class='self'>self</span>.<span class='ident'>y</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>y</span>) <span class='kw'>as</span> <span class='ident'>f64</span>;
        <span class='kw'>let</span> <span class='ident'>magnitude</span> <span class='op'>=</span> <span class='ident'>magnitude</span>.<span class='ident'>sqrt</span>();

        <span class='comment'>// Respect the formatting flags by using the helper method</span>
        <span class='comment'>// `pad_integral` on the Formatter object. See the method</span>
        <span class='comment'>// documentation for details, and the function `pad` can be used</span>
        <span class='comment'>// to pad strings.</span>
        <span class='kw'>let</span> <span class='ident'>decimals</span> <span class='op'>=</span> <span class='ident'>f</span>.<span class='ident'>precision</span>().<span class='ident'>unwrap_or</span>(<span class='number'>3</span>);
        <span class='kw'>let</span> <span class='ident'>string</span> <span class='op'>=</span> <span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.*}&quot;</span>, <span class='ident'>decimals</span>, <span class='ident'>magnitude</span>);
        <span class='ident'>f</span>.<span class='ident'>pad_integral</span>(<span class='bool-val'>true</span>, <span class='string'>&quot;&quot;</span>, <span class='kw-2'>&amp;</span><span class='ident'>string</span>)
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>myvector</span> <span class='op'>=</span> <span class='ident'>Vector2D</span> { <span class='ident'>x</span>: <span class='number'>3</span>, <span class='ident'>y</span>: <span class='number'>4</span> };

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>myvector</span>);       <span class='comment'>// =&gt; &quot;(3, 4)&quot;</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>myvector</span>);     <span class='comment'>// =&gt; &quot;Vector2D {x: 3, y:4}&quot;</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:10.3b}&quot;</span>, <span class='ident'>myvector</span>); <span class='comment'>// =&gt; &quot;     5.000&quot;</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=use%20std%3A%3Afmt%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20Vector2D%20%7B%0A%20%20%20%20x%3A%20isize%2C%0A%20%20%20%20y%3A%20isize%2C%0A%7D%0A%0Aimpl%20fmt%3A%3ADisplay%20for%20Vector2D%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20fmt%3A%3AFormatter)%20-%3E%20fmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20The%20%60f%60%20value%20implements%20the%20%60Write%60%20trait%2C%20which%20is%20what%20the%0A%20%20%20%20%20%20%20%20%2F%2F%20write!%20macro%20is%20expecting.%20Note%20that%20this%20formatting%20ignores%20the%0A%20%20%20%20%20%20%20%20%2F%2F%20various%20flags%20provided%20to%20format%20strings.%0A%20%20%20%20%20%20%20%20write!(f%2C%20%22(%7B%7D%2C%20%7B%7D)%22%2C%20self.x%2C%20self.y)%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20Different%20traits%20allow%20different%20forms%20of%20output%20of%20a%20type.%20The%20meaning%0A%2F%2F%20of%20this%20format%20is%20to%20print%20the%20magnitude%20of%20a%20vector.%0Aimpl%20fmt%3A%3ABinary%20for%20Vector2D%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20fmt%3A%3AFormatter)%20-%3E%20fmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20let%20magnitude%20%3D%20(self.x%20*%20self.x%20%2B%20self.y%20*%20self.y)%20as%20f64%3B%0A%20%20%20%20%20%20%20%20let%20magnitude%20%3D%20magnitude.sqrt()%3B%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20Respect%20the%20formatting%20flags%20by%20using%20the%20helper%20method%0A%20%20%20%20%20%20%20%20%2F%2F%20%60pad_integral%60%20on%20the%20Formatter%20object.%20See%20the%20method%0A%20%20%20%20%20%20%20%20%2F%2F%20documentation%20for%20details%2C%20and%20the%20function%20%60pad%60%20can%20be%20used%0A%20%20%20%20%20%20%20%20%2F%2F%20to%20pad%20strings.%0A%20%20%20%20%20%20%20%20let%20decimals%20%3D%20f.precision().unwrap_or(3)%3B%0A%20%20%20%20%20%20%20%20let%20string%20%3D%20format!(%22%7B%3A.*%7D%22%2C%20decimals%2C%20magnitude)%3B%0A%20%20%20%20%20%20%20%20f.pad_integral(true%2C%20%22%22%2C%20%26string)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20myvector%20%3D%20Vector2D%20%7B%20x%3A%203%2C%20y%3A%204%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20myvector)%3B%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%22(3%2C%204)%22%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20myvector)%3B%20%20%20%20%20%2F%2F%20%3D%3E%20%22Vector2D%20%7Bx%3A%203%2C%20y%3A4%7D%22%0A%20%20%20%20println!(%22%7B%3A10.3b%7D%22%2C%20myvector)%3B%20%2F%2F%20%3D%3E%20%22%20%20%20%20%205.000%22%0A%7D%0A">Run</a></pre>

<h3 id='fmtdisplay-vs-fmtdebug' class='section-header'><a href='#fmtdisplay-vs-fmtdebug'><code>fmt::Display</code> vs <code>fmt::Debug</code></a></h3>
<p>These two formatting traits have distinct purposes:</p>

<ul>
<li><code>fmt::Display</code> implementations assert that the type can be faithfully
represented as a UTF-8 string at all times. It is <strong>not</strong> expected that
all types implement the <code>Display</code> trait.</li>
<li><code>fmt::Debug</code> implementations should be implemented for <strong>all</strong> public types.
Output will typically represent the internal state as faithfully as possible.
The purpose of the <code>Debug</code> trait is to facilitate debugging Rust code. In
most cases, using <code>#[derive(Debug)]</code> is sufficient and recommended.</li>
</ul>

<p>Some examples of the output from both traits:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{} {:?}&quot;</span>, <span class='number'>3</span>, <span class='number'>4</span>), <span class='string'>&quot;3 4&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{} {:?}&quot;</span>, <span class='string'>&#39;a&#39;</span>, <span class='string'>&#39;b&#39;</span>), <span class='string'>&quot;a &#39;b&#39;&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{} {:?}&quot;</span>, <span class='string'>&quot;foo\n&quot;</span>, <span class='string'>&quot;bar\n&quot;</span>), <span class='string'>&quot;foo\n \&quot;bar\\n\&quot;&quot;</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aassert_eq!(format!(%22%7B%7D%20%7B%3A%3F%7D%22%2C%203%2C%204)%2C%20%223%204%22)%3B%0Aassert_eq!(format!(%22%7B%7D%20%7B%3A%3F%7D%22%2C%20'a'%2C%20'b')%2C%20%22a%20'b'%22)%3B%0Aassert_eq!(format!(%22%7B%7D%20%7B%3A%3F%7D%22%2C%20%22foo%5Cn%22%2C%20%22bar%5Cn%22)%2C%20%22foo%5Cn%20%5C%22bar%5C%5Cn%5C%22%22)%3B%0A%7D">Run</a></pre>

<h2 id='related-macros' class='section-header'><a href='#related-macros'>Related macros</a></h2>
<p>There are a number of related macros in the <code>format!</code> family. The ones that
are currently implemented are:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>format</span><span class='macro'>!</span>      <span class='comment'>// described above</span>
<span class='macro'>write</span><span class='macro'>!</span>       <span class='comment'>// first argument is a &amp;mut io::Write, the destination</span>
<span class='macro'>writeln</span><span class='macro'>!</span>     <span class='comment'>// same as write but appends a newline</span>
<span class='macro'>print</span><span class='macro'>!</span>       <span class='comment'>// the format string is printed to the standard output</span>
<span class='macro'>println</span><span class='macro'>!</span>     <span class='comment'>// same as print but appends a newline</span>
<span class='macro'>format_args</span><span class='macro'>!</span> <span class='comment'>// described below.</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aformat!%20%20%20%20%20%20%2F%2F%20described%20above%0Awrite!%20%20%20%20%20%20%20%2F%2F%20first%20argument%20is%20a%20%26mut%20io%3A%3AWrite%2C%20the%20destination%0Awriteln!%20%20%20%20%20%2F%2F%20same%20as%20write%20but%20appends%20a%20newline%0Aprint!%20%20%20%20%20%20%20%2F%2F%20the%20format%20string%20is%20printed%20to%20the%20standard%20output%0Aprintln!%20%20%20%20%20%2F%2F%20same%20as%20print%20but%20appends%20a%20newline%0Aformat_args!%20%2F%2F%20described%20below.%0A%7D">Run</a></pre>

<h3 id='write' class='section-header'><a href='#write'><code>write!</code></a></h3>
<p>This and <code>writeln</code> are two macros which are used to emit the format string
to a specified stream. This is used to prevent intermediate allocations of
format strings and instead directly write the output. Under the hood, this
function is actually invoking the <code>write_fmt</code> function defined on the
<code>std::io::Write</code> trait. Example usage is:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Write</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>w</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
<span class='macro'>write</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>w</span>, <span class='string'>&quot;Hello {}!&quot;</span>, <span class='string'>&quot;world&quot;</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23!%5Ballow(unused_must_use)%5D%0Ause%20std%3A%3Aio%3A%3AWrite%3B%0Alet%20mut%20w%20%3D%20Vec%3A%3Anew()%3B%0Awrite!(%26mut%20w%2C%20%22Hello%20%7B%7D!%22%2C%20%22world%22)%3B%0A%7D">Run</a></pre>

<h3 id='print' class='section-header'><a href='#print'><code>print!</code></a></h3>
<p>This and <code>println</code> emit their output to stdout. Similarly to the <code>write!</code>
macro, the goal of these macros is to avoid intermediate allocations when
printing output. Example usage is:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {}!&quot;</span>, <span class='string'>&quot;world&quot;</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;I have a newline {}&quot;</span>, <span class='string'>&quot;character at the end&quot;</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aprint!(%22Hello%20%7B%7D!%22%2C%20%22world%22)%3B%0Aprintln!(%22I%20have%20a%20newline%20%7B%7D%22%2C%20%22character%20at%20the%20end%22)%3B%0A%7D">Run</a></pre>

<h3 id='format_args' class='section-header'><a href='#format_args'><code>format_args!</code></a></h3>
<p>This is a curious macro which is used to safely pass around
an opaque object describing the format string. This object
does not require any heap allocations to create, and it only
references information on the stack. Under the hood, all of
the related macros are implemented in terms of this. First
off, some example usage is:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='self'>self</span>, <span class='ident'>Write</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>some_writer</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdout</span>();
<span class='macro'>write</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>some_writer</span>, <span class='string'>&quot;{}&quot;</span>, <span class='macro'>format_args</span><span class='macro'>!</span>(<span class='string'>&quot;print with a {}&quot;</span>, <span class='string'>&quot;macro&quot;</span>));

<span class='kw'>fn</span> <span class='ident'>my_fmt_fn</span>(<span class='ident'>args</span>: <span class='ident'>fmt</span>::<span class='ident'>Arguments</span>) {
    <span class='macro'>write</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>io</span>::<span class='ident'>stdout</span>(), <span class='string'>&quot;{}&quot;</span>, <span class='ident'>args</span>);
}
<span class='ident'>my_fmt_fn</span>(<span class='macro'>format_args</span><span class='macro'>!</span>(<span class='string'>&quot;, or a {} too&quot;</span>, <span class='string'>&quot;function&quot;</span>));<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23!%5Ballow(unused_must_use)%5D%0Ause%20std%3A%3Afmt%3B%0Ause%20std%3A%3Aio%3A%3A%7Bself%2C%20Write%7D%3B%0A%0Alet%20mut%20some_writer%20%3D%20io%3A%3Astdout()%3B%0Awrite!(%26mut%20some_writer%2C%20%22%7B%7D%22%2C%20format_args!(%22print%20with%20a%20%7B%7D%22%2C%20%22macro%22))%3B%0A%0Afn%20my_fmt_fn(args%3A%20fmt%3A%3AArguments)%20%7B%0A%20%20%20%20write!(%26mut%20io%3A%3Astdout()%2C%20%22%7B%7D%22%2C%20args)%3B%0A%7D%0Amy_fmt_fn(format_args!(%22%2C%20or%20a%20%7B%7D%20too%22%2C%20%22function%22))%3B%0A%7D">Run</a></pre>

<p>The result of the <code>format_args!</code> macro is a value of type <code>fmt::Arguments</code>.
This structure can then be passed to the <code>write</code> and <code>format</code> functions
inside this module in order to process the format string.
The goal of this macro is to even further prevent intermediate allocations
when dealing formatting strings.</p>

<p>For example, a logging library could use the standard formatting syntax, but
it would internally pass around this structure until it has been determined
where output should go to.</p>

<h1 id='syntax' class='section-header'><a href='#syntax'>Syntax</a></h1>
<p>The syntax for the formatting language used is drawn from other languages,
so it should not be too alien. Arguments are formatted with Python-like
syntax, meaning that arguments are surrounded by <code>{}</code> instead of the C-like
<code>%</code>. The actual grammar for the formatting syntax is:</p>

<pre><code class="language-text">format_string := &lt;text&gt; [ format &lt;text&gt; ] *
format := &#39;{&#39; [ argument ] [ &#39;:&#39; format_spec ] &#39;}&#39;
argument := integer | identifier

format_spec := [[fill]align][sign][&#39;#&#39;][&#39;0&#39;][width][&#39;.&#39; precision][type]
fill := character
align := &#39;&lt;&#39; | &#39;^&#39; | &#39;&gt;&#39;
sign := &#39;+&#39; | &#39;-&#39;
width := count
precision := count | &#39;*&#39;
type := identifier | &#39;&#39;
count := parameter | integer
parameter := argument &#39;$&#39;
</code></pre>

<h1 id='formatting-parameters' class='section-header'><a href='#formatting-parameters'>Formatting Parameters</a></h1>
<p>Each argument being formatted can be transformed by a number of formatting
parameters (corresponding to <code>format_spec</code> in the syntax above). These
parameters affect the string representation of what&#39;s being formatted. This
syntax draws heavily from Python&#39;s, so it may seem a bit familiar.</p>

<h2 id='fillalignment' class='section-header'><a href='#fillalignment'>Fill/Alignment</a></h2>
<p>The fill character is provided normally in conjunction with the <code>width</code>
parameter. This indicates that if the value being formatted is smaller than
<code>width</code> some extra characters will be printed around it. The extra
characters are specified by <code>fill</code>, and the alignment can be one of the
following options:</p>

<ul>
<li><code>&lt;</code> - the argument is left-aligned in <code>width</code> columns</li>
<li><code>^</code> - the argument is center-aligned in <code>width</code> columns</li>
<li><code>&gt;</code> - the argument is right-aligned in <code>width</code> columns</li>
</ul>

<p>Note that alignment may not be implemented by some types. A good way
to ensure padding is applied is to format your input, then use this
resulting string to pad your output.</p>

<h2 id='sign0' class='section-header'><a href='#sign0'>Sign/<code>#</code>/<code>0</code></a></h2>
<p>These can all be interpreted as flags for a particular formatter.</p>

<ul>
<li><code>+</code> - This is intended for numeric types and indicates that the sign
    should always be printed. Positive signs are never printed by
    default, and the negative sign is only printed by default for the
    <code>Signed</code> trait. This flag indicates that the correct sign (<code>+</code> or <code>-</code>)
    should always be printed.</li>
<li><code>-</code> - Currently not used</li>
<li><code>#</code> - This flag is indicates that the &quot;alternate&quot; form of printing should
    be used. The alternate forms are:

<ul>
<li><code>#?</code> - pretty-print the <code>Debug</code> formatting</li>
<li><code>#x</code> - precedes the argument with a <code>0x</code></li>
<li><code>#X</code> - precedes the argument with a <code>0x</code></li>
<li><code>#b</code> - precedes the argument with a <code>0b</code></li>
<li><code>#o</code> - precedes the argument with a <code>0o</code></li>
</ul></li>
<li><code>0</code> - This is used to indicate for integer formats that the padding should
    both be done with a <code>0</code> character as well as be sign-aware. A format
    like <code>{:08}</code> would yield <code>00000001</code> for the integer <code>1</code>, while the
    same format would yield <code>-0000001</code> for the integer <code>-1</code>. Notice that
    the negative version has one fewer zero than the positive version.</li>
</ul>

<h2 id='width' class='section-header'><a href='#width'>Width</a></h2>
<p>This is a parameter for the &quot;minimum width&quot; that the format should take up.
If the value&#39;s string does not fill up this many characters, then the
padding specified by fill/alignment will be used to take up the required
space.</p>

<p>The default fill/alignment for non-numerics is a space and left-aligned. The
defaults for numeric formatters is also a space but with right-alignment. If
the <code>0</code> flag is specified for numerics, then the implicit fill character is
<code>0</code>.</p>

<p>The value for the width can also be provided as a <code>usize</code> in the list of
parameters by using the dollar syntax indicating that the second argument is
a <code>usize</code> specifying the width, for example:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// All of these print &quot;Hello x    !&quot;</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {:5}!&quot;</span>, <span class='string'>&quot;x&quot;</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {:1$}!&quot;</span>, <span class='string'>&quot;x&quot;</span>, <span class='number'>5</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {1:0$}!&quot;</span>, <span class='number'>5</span>, <span class='string'>&quot;x&quot;</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {:width$}!&quot;</span>, <span class='string'>&quot;x&quot;</span>, <span class='ident'>width</span> <span class='op'>=</span> <span class='number'>5</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20All%20of%20these%20print%20%22Hello%20x%20%20%20%20!%22%0Aprintln!(%22Hello%20%7B%3A5%7D!%22%2C%20%22x%22)%3B%0Aprintln!(%22Hello%20%7B%3A1%24%7D!%22%2C%20%22x%22%2C%205)%3B%0Aprintln!(%22Hello%20%7B1%3A0%24%7D!%22%2C%205%2C%20%22x%22)%3B%0Aprintln!(%22Hello%20%7B%3Awidth%24%7D!%22%2C%20%22x%22%2C%20width%20%3D%205)%3B%0A%7D">Run</a></pre>

<p>Referring to an argument with the dollar syntax does not affect the &quot;next
argument&quot; counter, so it&#39;s usually a good idea to refer to arguments by
position, or use named arguments.</p>

<h2 id='precision' class='section-header'><a href='#precision'>Precision</a></h2>
<p>For non-numeric types, this can be considered a &quot;maximum width&quot;. If the resulting string is
longer than this width, then it is truncated down to this many characters and that truncated
value is emitted with proper <code>fill</code>, <code>alignment</code> and <code>width</code> if those parameters are set.</p>

<p>For integral types, this is ignored.</p>

<p>For floating-point types, this indicates how many digits after the decimal point should be
printed.</p>

<p>There are three possible ways to specify the desired <code>precision</code>:</p>

<ol>
<li><p>An integer <code>.N</code>:</p>

<p>the integer <code>N</code> itself is the precision.</p></li>
<li><p>An integer or name followed by dollar sign <code>.N$</code>:</p>

<p>use format <em>argument</em> <code>N</code> (which must be a <code>usize</code>) as the precision.</p></li>
<li><p>An asterisk <code>.*</code>:</p>

<p><code>.*</code> means that this <code>{...}</code> is associated with <em>two</em> format inputs rather than one: the
first input holds the <code>usize</code> precision, and the second holds the value to print.  Note that
in this case, if one uses the format string <code>{&lt;arg&gt;:&lt;spec&gt;.*}</code>, then the <code>&lt;arg&gt;</code> part refers
to the <em>value</em> to print, and the <code>precision</code> must come in the input preceding <code>&lt;arg&gt;</code>.</p></li>
</ol>

<p>For example, the following calls all print the same thing <code>Hello x is 0.01000</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// Hello {arg 0 (&quot;x&quot;)} is {arg 1 (0.01) with precision specified inline (5)}</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {0} is {1:.5}&quot;</span>, <span class='string'>&quot;x&quot;</span>, <span class='number'>0.01</span>);

<span class='comment'>// Hello {arg 1 (&quot;x&quot;)} is {arg 2 (0.01) with precision specified in arg 0 (5)}</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {1} is {2:.0$}&quot;</span>, <span class='number'>5</span>, <span class='string'>&quot;x&quot;</span>, <span class='number'>0.01</span>);

<span class='comment'>// Hello {arg 0 (&quot;x&quot;)} is {arg 2 (0.01) with precision specified in arg 1 (5)}</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {0} is {2:.1$}&quot;</span>, <span class='string'>&quot;x&quot;</span>, <span class='number'>5</span>, <span class='number'>0.01</span>);

<span class='comment'>// Hello {next arg (&quot;x&quot;)} is {second of next two args (0.01) with precision</span>
<span class='comment'>//                          specified in first of next two args (5)}</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {} is {:.*}&quot;</span>,    <span class='string'>&quot;x&quot;</span>, <span class='number'>5</span>, <span class='number'>0.01</span>);

<span class='comment'>// Hello {next arg (&quot;x&quot;)} is {arg 2 (0.01) with precision</span>
<span class='comment'>//                          specified in its predecessor (5)}</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {} is {2:.*}&quot;</span>,   <span class='string'>&quot;x&quot;</span>, <span class='number'>5</span>, <span class='number'>0.01</span>);

<span class='comment'>// Hello {next arg (&quot;x&quot;)} is {arg &quot;number&quot; (0.01) with precision specified</span>
<span class='comment'>//                          in arg &quot;prec&quot; (5)}</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {} is {number:.prec$}&quot;</span>, <span class='string'>&quot;x&quot;</span>, <span class='ident'>prec</span> <span class='op'>=</span> <span class='number'>5</span>, <span class='ident'>number</span> <span class='op'>=</span> <span class='number'>0.01</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20Hello%20%7Barg%200%20(%22x%22)%7D%20is%20%7Barg%201%20(0.01)%20with%20precision%20specified%20inline%20(5)%7D%0Aprintln!(%22Hello%20%7B0%7D%20is%20%7B1%3A.5%7D%22%2C%20%22x%22%2C%200.01)%3B%0A%0A%2F%2F%20Hello%20%7Barg%201%20(%22x%22)%7D%20is%20%7Barg%202%20(0.01)%20with%20precision%20specified%20in%20arg%200%20(5)%7D%0Aprintln!(%22Hello%20%7B1%7D%20is%20%7B2%3A.0%24%7D%22%2C%205%2C%20%22x%22%2C%200.01)%3B%0A%0A%2F%2F%20Hello%20%7Barg%200%20(%22x%22)%7D%20is%20%7Barg%202%20(0.01)%20with%20precision%20specified%20in%20arg%201%20(5)%7D%0Aprintln!(%22Hello%20%7B0%7D%20is%20%7B2%3A.1%24%7D%22%2C%20%22x%22%2C%205%2C%200.01)%3B%0A%0A%2F%2F%20Hello%20%7Bnext%20arg%20(%22x%22)%7D%20is%20%7Bsecond%20of%20next%20two%20args%20(0.01)%20with%20precision%0A%2F%2F%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20specified%20in%20first%20of%20next%20two%20args%20(5)%7D%0Aprintln!(%22Hello%20%7B%7D%20is%20%7B%3A.*%7D%22%2C%20%20%20%20%22x%22%2C%205%2C%200.01)%3B%0A%0A%2F%2F%20Hello%20%7Bnext%20arg%20(%22x%22)%7D%20is%20%7Barg%202%20(0.01)%20with%20precision%0A%2F%2F%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20specified%20in%20its%20predecessor%20(5)%7D%0Aprintln!(%22Hello%20%7B%7D%20is%20%7B2%3A.*%7D%22%2C%20%20%20%22x%22%2C%205%2C%200.01)%3B%0A%0A%2F%2F%20Hello%20%7Bnext%20arg%20(%22x%22)%7D%20is%20%7Barg%20%22number%22%20(0.01)%20with%20precision%20specified%0A%2F%2F%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20in%20arg%20%22prec%22%20(5)%7D%0Aprintln!(%22Hello%20%7B%7D%20is%20%7Bnumber%3A.prec%24%7D%22%2C%20%22x%22%2C%20prec%20%3D%205%2C%20number%20%3D%200.01)%3B%0A%7D">Run</a></pre>

<p>While these:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, `{name:.*}` has 3 fractional digits&quot;</span>, <span class='string'>&quot;Hello&quot;</span>, <span class='number'>3</span>, <span class='ident'>name</span><span class='op'>=</span><span class='number'>1234.56</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, `{name:.*}` has 3 characters&quot;</span>, <span class='string'>&quot;Hello&quot;</span>, <span class='number'>3</span>, <span class='ident'>name</span><span class='op'>=</span><span class='string'>&quot;1234.56&quot;</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, `{name:&gt;8.*}` has 3 right-aligned characters&quot;</span>, <span class='string'>&quot;Hello&quot;</span>, <span class='number'>3</span>, <span class='ident'>name</span><span class='op'>=</span><span class='string'>&quot;1234.56&quot;</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aprintln!(%22%7B%7D%2C%20%60%7Bname%3A.*%7D%60%20has%203%20fractional%20digits%22%2C%20%22Hello%22%2C%203%2C%20name%3D1234.56)%3B%0Aprintln!(%22%7B%7D%2C%20%60%7Bname%3A.*%7D%60%20has%203%20characters%22%2C%20%22Hello%22%2C%203%2C%20name%3D%221234.56%22)%3B%0Aprintln!(%22%7B%7D%2C%20%60%7Bname%3A%3E8.*%7D%60%20has%203%20right-aligned%20characters%22%2C%20%22Hello%22%2C%203%2C%20name%3D%221234.56%22)%3B%0A%7D">Run</a></pre>

<p>print two significantly different things:</p>

<pre><code class="language-text">Hello, `1234.560` has 3 fractional digits
Hello, `123` has 3 characters
Hello, `     123` has 3 right-aligned characters
</code></pre>

<h1 id='escaping' class='section-header'><a href='#escaping'>Escaping</a></h1>
<p>The literal characters <code>{</code> and <code>}</code> may be included in a string by preceding
them with the same character. For example, the <code>{</code> character is escaped with
<code>{{</code> and the <code>}</code> character is escaped with <code>}}</code>.</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Arguments.html'
                                  title='std::fmt::Arguments'>Arguments</a></td>
                           <td class='docblock-short'>
                                <p>This structure represents a safely precompiled version of a format string
and its arguments. This cannot be generated at runtime because it cannot
safely be done so, so no constructors are given and the fields are private
to prevent modification.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.DebugList.html'
                                  title='std::fmt::DebugList'>DebugList</a></td>
                           <td class='docblock-short'>
                                <p>A struct to help with <code>fmt::Debug</code> implementations.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.DebugMap.html'
                                  title='std::fmt::DebugMap'>DebugMap</a></td>
                           <td class='docblock-short'>
                                <p>A struct to help with <code>fmt::Debug</code> implementations.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.DebugSet.html'
                                  title='std::fmt::DebugSet'>DebugSet</a></td>
                           <td class='docblock-short'>
                                <p>A struct to help with <code>fmt::Debug</code> implementations.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.DebugStruct.html'
                                  title='std::fmt::DebugStruct'>DebugStruct</a></td>
                           <td class='docblock-short'>
                                <p>A struct to help with <code>fmt::Debug</code> implementations.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.DebugTuple.html'
                                  title='std::fmt::DebugTuple'>DebugTuple</a></td>
                           <td class='docblock-short'>
                                <p>A struct to help with <code>fmt::Debug</code> implementations.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Error.html'
                                  title='std::fmt::Error'>Error</a></td>
                           <td class='docblock-short'>
                                <p>The error type which is returned from formatting a message into a stream.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Formatter.html'
                                  title='std::fmt::Formatter'>Formatter</a></td>
                           <td class='docblock-short'>
                                <p>A struct to represent both where to emit formatting strings to and how they
should be formatted. A mutable version of this is passed to all formatting
traits.</p>
                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.Binary.html'
                                  title='std::fmt::Binary'>Binary</a></td>
                           <td class='docblock-short'>
                                <p>Format trait for the <code>b</code> character.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.Debug.html'
                                  title='std::fmt::Debug'>Debug</a></td>
                           <td class='docblock-short'>
                                <p>Format trait for the <code>?</code> character.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.Display.html'
                                  title='std::fmt::Display'>Display</a></td>
                           <td class='docblock-short'>
                                <p>Format trait for an empty format, <code>{}</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.LowerExp.html'
                                  title='std::fmt::LowerExp'>LowerExp</a></td>
                           <td class='docblock-short'>
                                <p>Format trait for the <code>e</code> character.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.LowerHex.html'
                                  title='std::fmt::LowerHex'>LowerHex</a></td>
                           <td class='docblock-short'>
                                <p>Format trait for the <code>x</code> character.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.Octal.html'
                                  title='std::fmt::Octal'>Octal</a></td>
                           <td class='docblock-short'>
                                <p>Format trait for the <code>o</code> character.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.Pointer.html'
                                  title='std::fmt::Pointer'>Pointer</a></td>
                           <td class='docblock-short'>
                                <p>Format trait for the <code>p</code> character.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.UpperExp.html'
                                  title='std::fmt::UpperExp'>UpperExp</a></td>
                           <td class='docblock-short'>
                                <p>Format trait for the <code>E</code> character.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.UpperHex.html'
                                  title='std::fmt::UpperHex'>UpperHex</a></td>
                           <td class='docblock-short'>
                                <p>Format trait for the <code>X</code> character.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.Write.html'
                                  title='std::fmt::Write'>Write</a></td>
                           <td class='docblock-short'>
                                <p>A collection of methods that are required to format a message into a stream.</p>
                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='fn' href='fn.format.html'
                                  title='std::fmt::format'>format</a></td>
                           <td class='docblock-short'>
                                <p>The format function takes a precompiled format string and a list of
arguments, to return the resulting formatted string.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='fn' href='fn.write.html'
                                  title='std::fmt::write'>write</a></td>
                           <td class='docblock-short'>
                                <p>The <code>write</code> function takes an output stream, a precompiled format string,
and a list of arguments. The arguments will be formatted according to the
specified format string into the output stream provided.</p>
                           </td>
                       </tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='type' href='type.Result.html'
                                  title='std::fmt::Result'>Result</a></td>
                           <td class='docblock-short'>
                                <p>The type returned by formatter methods.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "std";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script defer src="../../search-index.js"></script>
</body>
</html>