<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `BinaryHeap` struct in crate `std`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, BinaryHeap">

    <title>std::collections::binary_heap::BinaryHeap - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../../main.css">

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        <a href='../../../std/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../../index.html'>std</a>::<wbr><a href='../index.html'>collections</a>::<wbr><a href='index.html'>binary_heap</a></p><script>window.sidebarCurrent = {name: 'BinaryHeap', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../../index.html'>std</a>::<wbr><a href='../index.html'>collections</a>::<wbr><a href='index.html'>binary_heap</a>::<wbr><a class='struct' href=''>BinaryHeap</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-27' class='srclink' href='../../../core_collections/binary_heap/struct.BinaryHeap.html?gotosrc=27' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct BinaryHeap&lt;T&gt; {
    // some fields omitted
}</pre><div class='docblock'><p>A priority queue implemented with a binary heap.</p>

<p>This will be a max-heap.</p>

<p>It is a logic error for an item to be modified in such a way that the
item&#39;s ordering relative to any other item, as determined by the <code>Ord</code>
trait, changes while it is in the heap. This is normally only possible
through <code>Cell</code>, <code>RefCell</code>, global state, I/O, or unsafe code.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl&lt;T&gt; <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Creates an empty <code>BinaryHeap</code> as a max-heap.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    use std::collections::BinaryHeap;
    let mut heap = BinaryHeap::new();
    heap.push(4);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>4</span>);</pre>
</div><h4 id='method.with_capacity' class='method'><code>fn <a href='#method.with_capacity' class='fnname'>with_capacity</a>(capacity: <a href='../../primitive.usize.html'>usize</a>) -&gt; <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Creates an empty <code>BinaryHeap</code> with a specific capacity.
This preallocates enough memory for <code>capacity</code> elements,
so that the <code>BinaryHeap</code> does not have to be reallocated
until it contains at least that many values.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    use std::collections::BinaryHeap;
    let mut heap = BinaryHeap::with_capacity(10);
    heap.push(4);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>with_capacity</span>(<span class='number'>10</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>4</span>);</pre>
</div><h4 id='method.from_vec' class='method'><code>fn <a href='#method.from_vec' class='fnname'>from_vec</a>(vec: <a class='struct' href='../../../std/vec/struct.Vec.html' title='std::vec::Vec'>Vec</a>&lt;T&gt;) -&gt; <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt;</code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>collections</code> <a href="https://github.com/rust-lang/rust/issues/27783">#27783</a>)<p>: library is unlikely to be stabilized with the current layout and name, use std::collections instead</p>
</em></div><div class='docblock'><p>Creates a <code>BinaryHeap</code> from a vector. This is sometimes called
<code>heapifying</code> the vector.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>#![feature(collections)]

fn main() {
    use std::collections::BinaryHeap;
    let heap = BinaryHeap::from_vec(vec![9, 1, 2, 7, 3, 2]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>collections</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from_vec</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>9</span>, <span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>7</span>, <span class='number'>3</span>, <span class='number'>2</span>]);</pre>
</div><h4 id='method.iter' class='method'><code>fn <a href='#method.iter' class='fnname'>iter</a>(&amp;self) -&gt; <a class='struct' href='../../../std/collections/binary_heap/struct.Iter.html' title='std::collections::binary_heap::Iter'>Iter</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Returns an iterator visiting all values in the underlying vector, in
arbitrary order.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>#![feature(collections)]

fn main() {
    use std::collections::BinaryHeap;
    let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4]);
    
    // Print 1, 2, 3, 4 in arbitrary order
    for x in heap.iter() {
        println!(&quot;{}&quot;, x);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>collections</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from_vec</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>]);

<span class='comment'>// Print 1, 2, 3, 4 in arbitrary order</span>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>heap</span>.<span class='ident'>iter</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>
</div><h4 id='method.peek' class='method'><code>fn <a href='#method.peek' class='fnname'>peek</a>(&amp;self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;T&gt;</code></h4>
<div class='docblock'><p>Returns the greatest item in the binary heap, or <code>None</code> if it is empty.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    use std::collections::BinaryHeap;
    let mut heap = BinaryHeap::new();
    assert_eq!(heap.peek(), None);
    
    heap.push(1);
    heap.push(5);
    heap.push(2);
    assert_eq!(heap.peek(), Some(&amp;5));
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>None</span>);

<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>1</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>5</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>5</span>));
</pre>
</div><h4 id='method.capacity' class='method'><code>fn <a href='#method.capacity' class='fnname'>capacity</a>(&amp;self) -&gt; <a href='../../primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Returns the number of elements the binary heap can hold without reallocating.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    use std::collections::BinaryHeap;
    let mut heap = BinaryHeap::with_capacity(100);
    assert!(heap.capacity() &gt;= 100);
    heap.push(4);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>with_capacity</span>(<span class='number'>100</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>100</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>4</span>);</pre>
</div><h4 id='method.reserve_exact' class='method'><code>fn <a href='#method.reserve_exact' class='fnname'>reserve_exact</a>(&amp;mut self, additional: <a href='../../primitive.usize.html'>usize</a>)</code></h4>
<div class='docblock'><p>Reserves the minimum capacity for exactly <code>additional</code> more elements to be inserted in the
given <code>BinaryHeap</code>. Does nothing if the capacity is already sufficient.</p>

<p>Note that the allocator may give the collection more space than it requests. Therefore
capacity can not be relied upon to be precisely minimal. Prefer <code>reserve</code> if future
insertions are expected.</p>

<h1 id="panics" class='section-header'><a
                           href="#panics">Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    use std::collections::BinaryHeap;
    let mut heap = BinaryHeap::new();
    heap.reserve_exact(100);
    assert!(heap.capacity() &gt;= 100);
    heap.push(4);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='ident'>heap</span>.<span class='ident'>reserve_exact</span>(<span class='number'>100</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>100</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>4</span>);</pre>
</div><h4 id='method.reserve' class='method'><code>fn <a href='#method.reserve' class='fnname'>reserve</a>(&amp;mut self, additional: <a href='../../primitive.usize.html'>usize</a>)</code></h4>
<div class='docblock'><p>Reserves capacity for at least <code>additional</code> more elements to be inserted in the
<code>BinaryHeap</code>. The collection may reserve more space to avoid frequent reallocations.</p>

<h1 id="panics" class='section-header'><a
                           href="#panics">Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    use std::collections::BinaryHeap;
    let mut heap = BinaryHeap::new();
    heap.reserve(100);
    assert!(heap.capacity() &gt;= 100);
    heap.push(4);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='ident'>heap</span>.<span class='ident'>reserve</span>(<span class='number'>100</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>100</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>4</span>);</pre>
</div><h4 id='method.shrink_to_fit' class='method'><code>fn <a href='#method.shrink_to_fit' class='fnname'>shrink_to_fit</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Discards as much additional capacity as possible.</p>
</div><h4 id='method.pop' class='method'><code>fn <a href='#method.pop' class='fnname'>pop</a>(&amp;mut self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Removes the greatest item from the binary heap and returns it, or <code>None</code> if it
is empty.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>#![feature(collections)]

fn main() {
    use std::collections::BinaryHeap;
    let mut heap = BinaryHeap::from_vec(vec![1, 3]);
    
    assert_eq!(heap.pop(), Some(3));
    assert_eq!(heap.pop(), Some(1));
    assert_eq!(heap.pop(), None);
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>collections</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from_vec</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>3</span>]);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='number'>3</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='number'>1</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h4 id='method.push' class='method'><code>fn <a href='#method.push' class='fnname'>push</a>(&amp;mut self, item: T)</code></h4>
<div class='docblock'><p>Pushes an item onto the binary heap.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    use std::collections::BinaryHeap;
    let mut heap = BinaryHeap::new();
    heap.push(3);
    heap.push(5);
    heap.push(1);
    
    assert_eq!(heap.len(), 3);
    assert_eq!(heap.peek(), Some(&amp;5));
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>3</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>5</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>1</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>len</span>(), <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>5</span>));</pre>
</div><h4 id='method.push_pop' class='method'><code>fn <a href='#method.push_pop' class='fnname'>push_pop</a>(&amp;mut self, item: T) -&gt; T</code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>collections</code> <a href="https://github.com/rust-lang/rust/issues/27783">#27783</a>)<p>: library is unlikely to be stabilized with the current layout and name, use std::collections instead</p>
</em></div><div class='docblock'><p>Pushes an item onto the binary heap, then pops the greatest item off the queue in
an optimized fashion.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>#![feature(collections)]

fn main() {
    use std::collections::BinaryHeap;
    let mut heap = BinaryHeap::new();
    heap.push(1);
    heap.push(5);
    
    assert_eq!(heap.push_pop(3), 5);
    assert_eq!(heap.push_pop(9), 9);
    assert_eq!(heap.len(), 2);
    assert_eq!(heap.peek(), Some(&amp;3));
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>collections</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>1</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>5</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>push_pop</span>(<span class='number'>3</span>), <span class='number'>5</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>push_pop</span>(<span class='number'>9</span>), <span class='number'>9</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>len</span>(), <span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>3</span>));</pre>
</div><h4 id='method.replace' class='method'><code>fn <a href='#method.replace' class='fnname'>replace</a>(&amp;mut self, item: T) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;T&gt;</code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>collections</code> <a href="https://github.com/rust-lang/rust/issues/27783">#27783</a>)<p>: library is unlikely to be stabilized with the current layout and name, use std::collections instead</p>
</em></div><div class='docblock'><p>Pops the greatest item off the binary heap, then pushes an item onto the queue in
an optimized fashion. The push is done regardless of whether the binary heap
was empty.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>#![feature(collections)]

fn main() {
    use std::collections::BinaryHeap;
    let mut heap = BinaryHeap::new();
    
    assert_eq!(heap.replace(1), None);
    assert_eq!(heap.replace(3), Some(1));
    assert_eq!(heap.len(), 1);
    assert_eq!(heap.peek(), Some(&amp;3));
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>collections</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>replace</span>(<span class='number'>1</span>), <span class='prelude-val'>None</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>replace</span>(<span class='number'>3</span>), <span class='prelude-val'>Some</span>(<span class='number'>1</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>len</span>(), <span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>3</span>));</pre>
</div><h4 id='method.into_vec' class='method'><code>fn <a href='#method.into_vec' class='fnname'>into_vec</a>(self) -&gt; <a class='struct' href='../../../std/vec/struct.Vec.html' title='std::vec::Vec'>Vec</a>&lt;T&gt;</code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>collections</code> <a href="https://github.com/rust-lang/rust/issues/27783">#27783</a>)<p>: library is unlikely to be stabilized with the current layout and name, use std::collections instead</p>
</em></div><div class='docblock'><p>Consumes the <code>BinaryHeap</code> and returns the underlying vector
in arbitrary order.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>#![feature(collections)]

fn main() {
    use std::collections::BinaryHeap;
    let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4, 5, 6, 7]);
    let vec = heap.into_vec();
    
    // Will print in some order
    for x in vec {
        println!(&quot;{}&quot;, x);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>collections</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from_vec</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>, <span class='number'>7</span>]);
<span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='ident'>heap</span>.<span class='ident'>into_vec</span>();

<span class='comment'>// Will print in some order</span>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>vec</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>
</div><h4 id='method.into_sorted_vec' class='method'><code>fn <a href='#method.into_sorted_vec' class='fnname'>into_sorted_vec</a>(self) -&gt; <a class='struct' href='../../../std/vec/struct.Vec.html' title='std::vec::Vec'>Vec</a>&lt;T&gt;</code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>collections</code> <a href="https://github.com/rust-lang/rust/issues/27783">#27783</a>)<p>: library is unlikely to be stabilized with the current layout and name, use std::collections instead</p>
</em></div><div class='docblock'><p>Consumes the <code>BinaryHeap</code> and returns a vector in sorted
(ascending) order.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>#![feature(collections)]

fn main() {
    use std::collections::BinaryHeap;
    
    let mut heap = BinaryHeap::from_vec(vec![1, 2, 4, 5, 7]);
    heap.push(6);
    heap.push(3);
    
    let vec = heap.into_sorted_vec();
    assert_eq!(vec, [1, 2, 3, 4, 5, 6, 7]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>collections</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from_vec</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>7</span>]);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>6</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>3</span>);

<span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='ident'>heap</span>.<span class='ident'>into_sorted_vec</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>vec</span>, [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>, <span class='number'>7</span>]);</pre>
</div><h4 id='method.len' class='method'><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a href='../../primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Returns the length of the binary heap.</p>
</div><h4 id='method.is_empty' class='method'><code>fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a href='../../primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Checks if the binary heap is empty.</p>
</div><h4 id='method.drain' class='method'><code>fn <a href='#method.drain' class='fnname'>drain</a>(&amp;mut self) -&gt; <a class='struct' href='../../../std/collections/binary_heap/struct.Drain.html' title='std::collections::binary_heap::Drain'>Drain</a>&lt;T&gt;</code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>drain</code> <a href="https://github.com/rust-lang/rust/issues/27711">#27711</a>)<p>: matches collection reform specification, waiting for dust to settle</p>
</em></div><div class='docblock'><p>Clears the binary heap, returning an iterator over the removed elements.</p>

<p>The elements are removed in arbitrary order.</p>
</div><h4 id='method.clear' class='method'><code>fn <a href='#method.clear' class='fnname'>clear</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Drops all items from the binary heap.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../std/default/trait.Default.html' title='std::default::Default'>Default</a> for <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='method.default' class='method'><code>fn <a href='../../../std/default/trait.Default.html#method.default' class='fnname'>default</a>() -&gt; <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt;</code></h4>
</div><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../std/iter/trait.FromIterator.html' title='std::iter::FromIterator'>FromIterator</a>&lt;T&gt; for <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='method.from_iter' class='method'><code>fn <a href='../../../std/iter/trait.FromIterator.html#method.from_iter' class='fnname'>from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where I: <a class='trait' href='../../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a>&lt;Item=T&gt;</span></code></h4>
</div><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a> for <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='assoc_type.Item' class='type'><code>type Item = T</code></h4>
<h4 id='assoc_type.IntoIter' class='type'><code>type IntoIter = <a class='struct' href='../../../std/collections/binary_heap/struct.IntoIter.html' title='std::collections::binary_heap::IntoIter'>IntoIter</a>&lt;T&gt;</code></h4>
<h4 id='method.into_iter' class='method'><code>fn <a href='../../../std/iter/trait.IntoIterator.html#method.into_iter' class='fnname'>into_iter</a>(self) -&gt; <a class='struct' href='../../../std/collections/binary_heap/struct.IntoIter.html' title='std::collections::binary_heap::IntoIter'>IntoIter</a>&lt;T&gt;</code></h4>
</div><h3 class='impl'><code>impl&lt;'a, T&gt; <a class='trait' href='../../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a> for &amp;'a <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='assoc_type.Item' class='type'><code>type Item = &amp;'a T</code></h4>
<h4 id='assoc_type.IntoIter' class='type'><code>type IntoIter = <a class='struct' href='../../../std/collections/binary_heap/struct.Iter.html' title='std::collections::binary_heap::Iter'>Iter</a>&lt;'a, T&gt;</code></h4>
<h4 id='method.into_iter' class='method'><code>fn <a href='../../../std/iter/trait.IntoIterator.html#method.into_iter' class='fnname'>into_iter</a>(self) -&gt; <a class='struct' href='../../../std/collections/binary_heap/struct.Iter.html' title='std::collections::binary_heap::Iter'>Iter</a>&lt;'a, T&gt;</code></h4>
</div><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../std/iter/trait.Extend.html' title='std::iter::Extend'>Extend</a>&lt;T&gt; for <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='method.extend' class='method'><code>fn <a href='../../../std/iter/trait.Extend.html#method.extend' class='fnname'>extend</a>&lt;I&gt;(&amp;mut self, iterable: I) <span class='where'>where I: <a class='trait' href='../../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a>&lt;Item=T&gt;</span></code></h4>
</div><h3 class='impl'><code>impl&lt;'a, T&gt; <a class='trait' href='../../../std/iter/trait.Extend.html' title='std::iter::Extend'>Extend</a>&lt;&amp;'a T&gt; for <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../std/marker/trait.Copy.html' title='std::marker::Copy'>Copy</a> + 'a + <a class='trait' href='../../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='method.extend' class='method'><code>fn <a href='../../../std/iter/trait.Extend.html#method.extend' class='fnname'>extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class='where'>where I: <a class='trait' href='../../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a>&lt;Item=&amp;'a T&gt;</span></code></h4>
</div><h3 id='derived_implementations'>Derived Implementations </h3><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a> for <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a></span></code></h3><div class='impl-items'><h4 id='method.clone' class='method'><code>fn <a href='../../../std/clone/trait.Clone.html#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../../../std/collections/binary_heap/struct.BinaryHeap.html' title='std::collections::binary_heap::BinaryHeap'>BinaryHeap</a>&lt;T&gt;</code></h4>
<h4 id='method.clone_from' class='method'><code>fn <a href='../../../std/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div>
            <div class="shortcuts">
                <h1>Keyboard Shortcuts</h1>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h1>Search Tricks</h1>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../../";
        window.currentCrate = "std";
        window.playgroundUrl = "https://play.rust-lang.org/";
    </script>
    <script src="../../../jquery.js"></script>
    <script src="../../../main.js"></script>
    <script src="../../../playpen.js"></script>
    <script async src="../../../search-index.js"></script>
</body>
</html>