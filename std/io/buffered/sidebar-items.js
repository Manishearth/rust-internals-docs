initSidebarItems({"struct":[["BufReader","The `BufReader` struct adds buffering to any reader.It can be excessively inefficient to work directly with a `Read` instance. For example, every call to `read` on `TcpStream` results in a system call. A `BufReader` performs large, infrequent reads on the underlying `Read` and maintains an in-memory buffer of the results.Examples"],["BufWriter","Wraps a writer and buffers its output.It can be excessively inefficient to work directly with something that implements `Write`. For example, every call to `write` on `TcpStream` results in a system call. A `BufWriter` keeps an in-memory buffer of data and writes it to an underlying writer in large, infrequent batches.The buffer will be written out when the writer is dropped.ExamplesLet's write the numbers one through ten to a `TcpStream`:Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written. We can fix this with a `BufWriter`:By wrapping the stream with a `BufWriter`, these ten writes are all grouped together by the buffer, and will all be written out in one system call when the `stream` is dropped."],["IntoInnerError","An error returned by `into_inner` which combines an error that happened while writing out the buffer, and the buffered writer object which may be used to recover from the condition.Examples"],["LineWriter","Wraps a writer and buffers output to it, flushing whenever a newline (`0x0a`, `'\\n'`) is detected.The `BufWriter` struct wraps a writer and buffers its output. But it only does this batched write when it goes out of scope, or when the internal buffer is full. Sometimes, you'd prefer to write each line as it's completed, rather than the entire buffer at once. Enter `LineWriter`. It does exactly that.If there's still a partial line in the buffer when the `LineWriter` is dropped, it will flush those contents.ExamplesWe can use `LineWriter` to write one line at a time, significantly reducing the number of actual writes to the file."]]});