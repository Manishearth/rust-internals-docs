initSidebarItems({"constant":[["MUTEX_INIT","Static initialization of a mutex. This constant can be used to initialize other mutex constants."]],"struct":[["Mutex","A mutual exclusion primitive useful for protecting shared dataThis mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a `new` constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from `lock` and `try_lock`, which guarantees that the data is only ever accessed when the mutex is locked.PoisoningThe mutexes in this module implement a strategy called \"poisoning\" where a mutex is considered poisoned whenever a thread panics while holding the lock. Once a mutex is poisoned, all other threads are unable to access the data by default as it is likely tainted (some invariant is not being upheld).For a mutex, this means that the `lock` and `try_lock` methods return a `Result` which indicates whether a mutex has been poisoned or not. Most usage of a mutex will simply `unwrap()` these results, propagating panics among threads to ensure that a possibly invalid invariant is not witnessed.A poisoned mutex, however, does not prevent all access to the underlying data. The `PoisonError` type has an `into_inner` method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.ExamplesTo recover from a poisoned mutex:"],["MutexGuard","An RAII implementation of a \"scoped lock\" of a mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.The data protected by the mutex can be access through this guard via its `Deref` and `DerefMut` implementations"],["StaticMutex","The static mutex type is provided to allow for static allocation of mutexes.Note that this is a separate type because using a Mutex correctly means that it needs to have a destructor run. In Rust, statics are not allowed to have destructors. As a result, a `StaticMutex` has one extra method when compared to a `Mutex`, a `destroy` method. This method is unsafe to call, and documentation can be found directly on the method.Examples"]]});