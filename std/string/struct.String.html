<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `String` struct in crate `std`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, String">

    <title>std::string::String - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../../std/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../index.html'>std</a>::<wbr><a href='index.html'>string</a></p><script>window.sidebarCurrent = {name: 'String', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>std</a>::<wbr><a href='index.html'>string</a>::<wbr><a class='struct' href=''>String</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-3580' class='srclink' href='../../core_collections/string/struct.String.html?gotosrc=3580' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct String {
    // some fields omitted
}</pre><div class='docblock'><p>A growable string stored as a UTF-8 encoded buffer.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<div class='docblock'><p>Creates a new string buffer initialized with the empty string.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::new();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();</pre>
</div><h4 id='method.with_capacity' class='method'><code>fn <a href='#method.with_capacity' class='fnname'>with_capacity</a>(capacity: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<div class='docblock'><p>Creates a new string buffer with the given capacity.
The string will be able to hold exactly <code>capacity</code> bytes without
reallocating. If <code>capacity</code> is 0, the string will not allocate.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::with_capacity(10);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>with_capacity</span>(<span class='number'>10</span>);</pre>
</div><h4 id='method.from_utf8' class='method'><code>fn <a href='#method.from_utf8' class='fnname'>from_utf8</a>(vec: <a class='struct' href='../../std/vec/struct.Vec.html' title='std::vec::Vec'>Vec</a>&lt;<a class='primitive' href='../primitive.u8.html'>u8</a>&gt;) -&gt; <a class='enum' href='../../std/result/enum.Result.html' title='std::result::Result'>Result</a>&lt;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>, <a class='struct' href='../../std/string/struct.FromUtf8Error.html' title='std::string::FromUtf8Error'>FromUtf8Error</a>&gt;</code></h4>
<div class='docblock'><p>Converts a vector of bytes to a <code>String</code>.</p>

<p>A string slice (<code>&amp;str</code>) is made of bytes (<code>u8</code>), and a vector of bytes
(<code>Vec&lt;u8&gt;</code>) is made of bytes, so this function converts between the
two. Not all byte slices are valid <code>String</code>s, however: <code>String</code>
requires that it is valid UTF-8. <code>from_utf8()</code> checks to ensure that
the bytes are valid UTF-8, and then does the conversion.</p>

<p>If you are sure that the byte slice is valid UTF-8, and you don&#39;t want
to incur the overhead of the validity check, there is an unsafe version
of this function, <a href="struct.String.html#method.from_utf8_unchecked"><code>from_utf8_unchecked()</code></a>, which has the
same behavior but skips the check.</p>

<p>This method will take care to not copy the vector, for efficiency&#39;s
sake.</p>

<p>If you need a <code>&amp;str</code> instead of a <code>String</code>, consider
<a href="../str/fn.from_utf8.html"><code>str::from_utf8()</code></a>.</p>

<h1 id='failure' class='section-header'><a href='#failure'>Failure</a></h1>
<p>Returns <code>Err</code> if the slice is not UTF-8 with a description as to why the
provided bytes are not UTF-8. The vector you moved in is also included.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Basic usage:</p>
<span class='rusttest'>fn main() {
    // some bytes, in a vector
    let sparkle_heart = vec![240, 159, 146, 150];
    
    // We know these bytes are valid, so just use `unwrap()`.
    let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();
    
    assert_eq!(&quot;💖&quot;, sparkle_heart);
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// some bytes, in a vector</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>240</span>, <span class='number'>159</span>, <span class='number'>146</span>, <span class='number'>150</span>];

<span class='comment'>// We know these bytes are valid, so just use `unwrap()`.</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from_utf8</span>(<span class='ident'>sparkle_heart</span>).<span class='ident'>unwrap</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;💖&quot;</span>, <span class='ident'>sparkle_heart</span>);</pre>

<p>Incorrect bytes:</p>
<span class='rusttest'>fn main() {
    // some invalid bytes, in a vector
    let sparkle_heart = vec![0, 159, 146, 150];
    
    assert!(String::from_utf8(sparkle_heart).is_err());
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// some invalid bytes, in a vector</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0</span>, <span class='number'>159</span>, <span class='number'>146</span>, <span class='number'>150</span>];

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>String</span>::<span class='ident'>from_utf8</span>(<span class='ident'>sparkle_heart</span>).<span class='ident'>is_err</span>());</pre>

<p>See the docs for <a href="struct.FromUtf8Error.html"><code>FromUtf8Error</code></a> for more details on what you
can do with this error.</p>
</div><h4 id='method.from_utf8_lossy' class='method'><code>fn <a href='#method.from_utf8_lossy' class='fnname'>from_utf8_lossy</a>(v: <a class='primitive' href='../primitive.slice.html'>&amp;'a [</a><a class='primitive' href='../primitive.u8.html'>u8</a><a class='primitive' href='../primitive.slice.html'>]</a>) -&gt; <a class='enum' href='../../std/borrow/enum.Cow.html' title='std::borrow::Cow'>Cow</a>&lt;'a, <a class='primitive' href='../primitive.str.html'>str</a>&gt;</code></h4>
<div class='docblock'><p>Converts a slice of bytes to a <code>String</code>, including invalid characters.</p>

<p>A string slice (<code>&amp;str</code>) is made of bytes (<code>u8</code>), and a slice of bytes
(<code>&amp;[u8]</code>) is made of bytes, so this function converts between the two.
Not all byte slices are valid string slices, however: <code>&amp;str</code> requires
that it is valid UTF-8. During this conversion, <code>from_utf8_lossy()</code>
will replace any invalid UTF-8 sequences with
<code>U+FFFD REPLACEMENT CHARACTER</code>, which looks like this: �</p>

<p>If you are sure that the byte slice is valid UTF-8, and you don&#39;t want
to incur the overhead of the conversion, there is an unsafe version
of this function, <a href="struct.String.html#method.from_utf8_unchecked"><code>from_utf8_unchecked()</code></a>, which has the
same behavior but skips the checks.</p>

<p>If you need a <code>&amp;str</code> instead of a <code>String</code>, consider
<a href="../str/fn.from_utf8.html"><code>str::from_utf8()</code></a>.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Basic usage:</p>
<span class='rusttest'>fn main() {
    // some bytes, in a vector
    let sparkle_heart = vec![240, 159, 146, 150];
    
    // We know these bytes are valid, so just use `unwrap()`.
    let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();
    
    assert_eq!(&quot;💖&quot;, sparkle_heart);
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// some bytes, in a vector</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>240</span>, <span class='number'>159</span>, <span class='number'>146</span>, <span class='number'>150</span>];

<span class='comment'>// We know these bytes are valid, so just use `unwrap()`.</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from_utf8</span>(<span class='ident'>sparkle_heart</span>).<span class='ident'>unwrap</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;💖&quot;</span>, <span class='ident'>sparkle_heart</span>);</pre>

<p>Incorrect bytes:</p>
<span class='rusttest'>fn main() {
    // some invalid bytes
    let input = b&quot;Hello \xF0\x90\x80World&quot;;
    let output = String::from_utf8_lossy(input);
    
    assert_eq!(&quot;Hello �World&quot;, output);
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// some invalid bytes</span>
<span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='string'>b&quot;Hello \xF0\x90\x80World&quot;</span>;
<span class='kw'>let</span> <span class='ident'>output</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from_utf8_lossy</span>(<span class='ident'>input</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;Hello �World&quot;</span>, <span class='ident'>output</span>);</pre>
</div><h4 id='method.from_utf16' class='method'><code>fn <a href='#method.from_utf16' class='fnname'>from_utf16</a>(v: <a class='primitive' href='../primitive.slice.html'>&amp;[</a><a class='primitive' href='../primitive.u16.html'>u16</a><a class='primitive' href='../primitive.slice.html'>]</a>) -&gt; <a class='enum' href='../../std/result/enum.Result.html' title='std::result::Result'>Result</a>&lt;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>, <a class='struct' href='../../std/string/struct.FromUtf16Error.html' title='std::string::FromUtf16Error'>FromUtf16Error</a>&gt;</code></h4>
<div class='docblock'><p>Decode a UTF-16 encoded vector <code>v</code> into a <code>String</code>, returning <code>None</code>
if <code>v</code> contains any invalid data.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    // 𝄞music
    let mut v = &amp;mut [0xD834, 0xDD1E, 0x006d, 0x0075,
                      0x0073, 0x0069, 0x0063];
    assert_eq!(String::from_utf16(v).unwrap(),
               &quot;𝄞music&quot;.to_string());
    
    // 𝄞mu&lt;invalid&gt;ic
    v[4] = 0xD800;
    assert!(String::from_utf16(v).is_err());
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// 𝄞music</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>0xD834</span>, <span class='number'>0xDD1E</span>, <span class='number'>0x006d</span>, <span class='number'>0x0075</span>,
                  <span class='number'>0x0073</span>, <span class='number'>0x0069</span>, <span class='number'>0x0063</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>String</span>::<span class='ident'>from_utf16</span>(<span class='ident'>v</span>).<span class='ident'>unwrap</span>(),
           <span class='string'>&quot;𝄞music&quot;</span>.<span class='ident'>to_string</span>());

<span class='comment'>// 𝄞mu&lt;invalid&gt;ic</span>
<span class='ident'>v</span>[<span class='number'>4</span>] <span class='op'>=</span> <span class='number'>0xD800</span>;
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>String</span>::<span class='ident'>from_utf16</span>(<span class='ident'>v</span>).<span class='ident'>is_err</span>());</pre>
</div><h4 id='method.from_utf16_lossy' class='method'><code>fn <a href='#method.from_utf16_lossy' class='fnname'>from_utf16_lossy</a>(v: <a class='primitive' href='../primitive.slice.html'>&amp;[</a><a class='primitive' href='../primitive.u16.html'>u16</a><a class='primitive' href='../primitive.slice.html'>]</a>) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<div class='docblock'><p>Decode a UTF-16 encoded vector <code>v</code> into a string, replacing
invalid data with the replacement character (U+FFFD).</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    // 𝄞mus&lt;invalid&gt;ic&lt;invalid&gt;
    let v = &amp;[0xD834, 0xDD1E, 0x006d, 0x0075,
              0x0073, 0xDD1E, 0x0069, 0x0063,
              0xD834];
    
    assert_eq!(String::from_utf16_lossy(v),
               &quot;𝄞mus\u{FFFD}ic\u{FFFD}&quot;.to_string());
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// 𝄞mus&lt;invalid&gt;ic&lt;invalid&gt;</span>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0xD834</span>, <span class='number'>0xDD1E</span>, <span class='number'>0x006d</span>, <span class='number'>0x0075</span>,
          <span class='number'>0x0073</span>, <span class='number'>0xDD1E</span>, <span class='number'>0x0069</span>, <span class='number'>0x0063</span>,
          <span class='number'>0xD834</span>];

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>String</span>::<span class='ident'>from_utf16_lossy</span>(<span class='ident'>v</span>),
           <span class='string'>&quot;𝄞mus\u{FFFD}ic\u{FFFD}&quot;</span>.<span class='ident'>to_string</span>());</pre>
</div><h4 id='method.from_raw_parts' class='method'><code>unsafe fn <a href='#method.from_raw_parts' class='fnname'>from_raw_parts</a>(buf: <a class='primitive' href='../primitive.pointer.html'>*mut <a class='primitive' href='../primitive.u8.html'>u8</a></a>, length: <a class='primitive' href='../primitive.usize.html'>usize</a>, capacity: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<div class='docblock'><p>Creates a new <code>String</code> from a length, capacity, and pointer.</p>

<h1 id='safety' class='section-header'><a href='#safety'>Safety</a></h1>
<p>This is <em>very</em> unsafe because:</p>

<ul>
<li>We call <code>Vec::from_raw_parts</code> to get a <code>Vec&lt;u8&gt;</code>. Therefore, this
function inherits all of its unsafety, see <a href="../vec/struct.Vec.html#method.from_raw_parts">its
documentation</a>
for the invariants it expects, they also apply to this function.</li>
<li>We assume that the <code>Vec</code> contains valid UTF-8.</li>
</ul>
</div><h4 id='method.from_utf8_unchecked' class='method'><code>unsafe fn <a href='#method.from_utf8_unchecked' class='fnname'>from_utf8_unchecked</a>(bytes: <a class='struct' href='../../std/vec/struct.Vec.html' title='std::vec::Vec'>Vec</a>&lt;<a class='primitive' href='../primitive.u8.html'>u8</a>&gt;) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<div class='docblock'><p>Converts a vector of bytes to a <code>String</code> without checking that the
string contains valid UTF-8.</p>

<p>See the safe version, <a href="struct.String.html#method.from_utf8"><code>from_utf8()</code></a>, for more.</p>

<h1 id='safety' class='section-header'><a href='#safety'>Safety</a></h1>
<p>This function is unsafe because it does not check that the bytes passed to
it are valid UTF-8. If this constraint is violated, undefined behavior
results, as the rest of Rust assumes that <code>String</code>s are valid UTF-8.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Basic usage:</p>
<span class='rusttest'>fn main() {
    // some bytes, in a vector
    let sparkle_heart = vec![240, 159, 146, 150];
    
    let sparkle_heart = unsafe {
        String::from_utf8_unchecked(sparkle_heart)
    };
    
    assert_eq!(&quot;💖&quot;, sparkle_heart);
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// some bytes, in a vector</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>240</span>, <span class='number'>159</span>, <span class='number'>146</span>, <span class='number'>150</span>];

<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='kw'>unsafe</span> {
    <span class='ident'>String</span>::<span class='ident'>from_utf8_unchecked</span>(<span class='ident'>sparkle_heart</span>)
};

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;💖&quot;</span>, <span class='ident'>sparkle_heart</span>);</pre>
</div><h4 id='method.into_bytes' class='method'><code>fn <a href='#method.into_bytes' class='fnname'>into_bytes</a>(self) -&gt; <a class='struct' href='../../std/vec/struct.Vec.html' title='std::vec::Vec'>Vec</a>&lt;<a class='primitive' href='../primitive.u8.html'>u8</a>&gt;</code></h4>
<div class='docblock'><p>Returns the underlying byte buffer, encoded as UTF-8.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = String::from(&quot;hello&quot;);
    let bytes = s.into_bytes();
    assert_eq!(bytes, [104, 101, 108, 108, 111]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='kw'>let</span> <span class='ident'>bytes</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>into_bytes</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>bytes</span>, [<span class='number'>104</span>, <span class='number'>101</span>, <span class='number'>108</span>, <span class='number'>108</span>, <span class='number'>111</span>]);</pre>
</div><h4 id='method.as_str' class='method'><code>fn <a href='#method.as_str' class='fnname'>as_str</a>(&amp;self) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>convert</code> <a href="https://github.com/rust-lang/rust/issues/27729">#27729</a>)<p>: waiting on RFC revision</p>
</em></div><div class='docblock'><p>Extracts a string slice containing the entire string.</p>
</div><h4 id='method.push_str' class='method'><code>fn <a href='#method.push_str' class='fnname'>push_str</a>(&amp;mut self, string: &amp;<a class='primitive' href='../primitive.str.html'>str</a>)</code></h4>
<div class='docblock'><p>Pushes the given string onto this string buffer.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
    assert_eq!(s, &quot;foobar&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;bar&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;foobar&quot;</span>);</pre>
</div><h4 id='method.capacity' class='method'><code>fn <a href='#method.capacity' class='fnname'>capacity</a>(&amp;self) -&gt; <a class='primitive' href='../primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Returns the number of bytes that this string buffer can hold without
reallocating.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = String::with_capacity(10);
    assert!(s.capacity() &gt;= 10);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>with_capacity</span>(<span class='number'>10</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>10</span>);</pre>
</div><h4 id='method.reserve' class='method'><code>fn <a href='#method.reserve' class='fnname'>reserve</a>(&amp;mut self, additional: <a class='primitive' href='../primitive.usize.html'>usize</a>)</code></h4>
<div class='docblock'><p>Reserves capacity for at least <code>additional</code> more bytes to be inserted
in the given <code>String</code>. The collection may reserve more space to avoid
frequent reallocations.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::new();
    s.reserve(10);
    assert!(s.capacity() &gt;= 10);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='ident'>s</span>.<span class='ident'>reserve</span>(<span class='number'>10</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>10</span>);</pre>
</div><h4 id='method.reserve_exact' class='method'><code>fn <a href='#method.reserve_exact' class='fnname'>reserve_exact</a>(&amp;mut self, additional: <a class='primitive' href='../primitive.usize.html'>usize</a>)</code></h4>
<div class='docblock'><p>Reserves the minimum capacity for exactly <code>additional</code> more bytes to be
inserted in the given <code>String</code>. Does nothing if the capacity is already
sufficient.</p>

<p>Note that the allocator may give the collection more space than it
requests. Therefore capacity can not be relied upon to be precisely
minimal. Prefer <code>reserve</code> if future insertions are expected.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::new();
    s.reserve_exact(10);
    assert!(s.capacity() &gt;= 10);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='ident'>s</span>.<span class='ident'>reserve_exact</span>(<span class='number'>10</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>10</span>);</pre>
</div><h4 id='method.shrink_to_fit' class='method'><code>fn <a href='#method.shrink_to_fit' class='fnname'>shrink_to_fit</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Shrinks the capacity of this string buffer to match its length.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    s.reserve(100);
    assert!(s.capacity() &gt;= 100);
    s.shrink_to_fit();
    assert_eq!(s.capacity(), 3);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>reserve</span>(<span class='number'>100</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>100</span>);
<span class='ident'>s</span>.<span class='ident'>shrink_to_fit</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>(), <span class='number'>3</span>);</pre>
</div><h4 id='method.push' class='method'><code>fn <a href='#method.push' class='fnname'>push</a>(&amp;mut self, ch: <a class='primitive' href='../primitive.char.html'>char</a>)</code></h4>
<div class='docblock'><p>Adds the given character to the end of the string.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;abc&quot;);
    s.push(&#39;1&#39;);
    s.push(&#39;2&#39;);
    s.push(&#39;3&#39;);
    assert_eq!(s, &quot;abc123&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;abc&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>push</span>(<span class='string'>&#39;1&#39;</span>);
<span class='ident'>s</span>.<span class='ident'>push</span>(<span class='string'>&#39;2&#39;</span>);
<span class='ident'>s</span>.<span class='ident'>push</span>(<span class='string'>&#39;3&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;abc123&quot;</span>);</pre>
</div><h4 id='method.as_bytes' class='method'><code>fn <a href='#method.as_bytes' class='fnname'>as_bytes</a>(&amp;self) -&gt; <a class='primitive' href='../primitive.slice.html'>&amp;[</a><a class='primitive' href='../primitive.u8.html'>u8</a><a class='primitive' href='../primitive.slice.html'>]</a></code></h4>
<div class='docblock'><p>Works with the underlying buffer as a byte slice.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = String::from(&quot;hello&quot;);
    assert_eq!(s.as_bytes(), [104, 101, 108, 108, 111]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>as_bytes</span>(), [<span class='number'>104</span>, <span class='number'>101</span>, <span class='number'>108</span>, <span class='number'>108</span>, <span class='number'>111</span>]);</pre>
</div><h4 id='method.truncate' class='method'><code>fn <a href='#method.truncate' class='fnname'>truncate</a>(&amp;mut self, new_len: <a class='primitive' href='../primitive.usize.html'>usize</a>)</code></h4>
<div class='docblock'><p>Shortens a string to the specified length.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>Panics if <code>new_len</code> &gt; current length,
or if <code>new_len</code> is not a character boundary.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;hello&quot;);
    s.truncate(2);
    assert_eq!(s, &quot;he&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>truncate</span>(<span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;he&quot;</span>);</pre>
</div><h4 id='method.pop' class='method'><code>fn <a href='#method.pop' class='fnname'>pop</a>(&amp;mut self) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='primitive' href='../primitive.char.html'>char</a>&gt;</code></h4>
<div class='docblock'><p>Removes the last character from the string buffer and returns it.
Returns <code>None</code> if this string buffer is empty.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    assert_eq!(s.pop(), Some(&#39;o&#39;));
    assert_eq!(s.pop(), Some(&#39;o&#39;));
    assert_eq!(s.pop(), Some(&#39;f&#39;));
    assert_eq!(s.pop(), None);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='string'>&#39;o&#39;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='string'>&#39;o&#39;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='string'>&#39;f&#39;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h4 id='method.remove' class='method'><code>fn <a href='#method.remove' class='fnname'>remove</a>(&amp;mut self, idx: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; <a class='primitive' href='../primitive.char.html'>char</a></code></h4>
<div class='docblock'><p>Removes the character from the string buffer at byte position <code>idx</code> and
returns it.</p>

<h1 id='warning' class='section-header'><a href='#warning'>Warning</a></h1>
<p>This is an O(n) operation as it requires copying every element in the
buffer.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>If <code>idx</code> does not lie on a character boundary, or if it is out of
bounds, then this function will panic.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    assert_eq!(s.remove(0), &#39;f&#39;);
    assert_eq!(s.remove(1), &#39;o&#39;);
    assert_eq!(s.remove(0), &#39;o&#39;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>remove</span>(<span class='number'>0</span>), <span class='string'>&#39;f&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>remove</span>(<span class='number'>1</span>), <span class='string'>&#39;o&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>remove</span>(<span class='number'>0</span>), <span class='string'>&#39;o&#39;</span>);</pre>
</div><h4 id='method.insert' class='method'><code>fn <a href='#method.insert' class='fnname'>insert</a>(&amp;mut self, idx: <a class='primitive' href='../primitive.usize.html'>usize</a>, ch: <a class='primitive' href='../primitive.char.html'>char</a>)</code></h4>
<div class='docblock'><p>Inserts a character into the string buffer at byte position <code>idx</code>.</p>

<h1 id='warning' class='section-header'><a href='#warning'>Warning</a></h1>
<p>This is an O(n) operation as it requires copying every element in the
buffer.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>If <code>idx</code> does not lie on a character boundary or is out of bounds, then
this function will panic.</p>
</div><h4 id='method.as_mut_vec' class='method'><code>unsafe fn <a href='#method.as_mut_vec' class='fnname'>as_mut_vec</a>(&amp;mut self) -&gt; &amp;mut <a class='struct' href='../../std/vec/struct.Vec.html' title='std::vec::Vec'>Vec</a>&lt;<a class='primitive' href='../primitive.u8.html'>u8</a>&gt;</code></h4>
<div class='docblock'><p>Views the string buffer as a mutable sequence of bytes.</p>

<p>This is unsafe because it does not check
to ensure that the resulting string will be valid UTF-8.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;hello&quot;);
    unsafe {
        let vec = s.as_mut_vec();
        assert!(vec == &amp;[104, 101, 108, 108, 111]);
        vec.reverse();
    }
    assert_eq!(s, &quot;olleh&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='kw'>unsafe</span> {
    <span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>as_mut_vec</span>();
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>vec</span> <span class='op'>==</span> <span class='kw-2'>&amp;</span>[<span class='number'>104</span>, <span class='number'>101</span>, <span class='number'>108</span>, <span class='number'>108</span>, <span class='number'>111</span>]);
    <span class='ident'>vec</span>.<span class='ident'>reverse</span>();
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;olleh&quot;</span>);</pre>
</div><h4 id='method.len' class='method'><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a class='primitive' href='../primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Returns the number of bytes in this string.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let a = &quot;foo&quot;.to_string();
    assert_eq!(a.len(), 3);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>.<span class='ident'>to_string</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>len</span>(), <span class='number'>3</span>);</pre>
</div><h4 id='method.is_empty' class='method'><code>fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if the string contains no bytes</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut v = String::new();
    assert!(v.is_empty());
    v.push(&#39;a&#39;);
    assert!(!v.is_empty());
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span>.<span class='ident'>is_empty</span>());
<span class='ident'>v</span>.<span class='ident'>push</span>(<span class='string'>&#39;a&#39;</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>v</span>.<span class='ident'>is_empty</span>());</pre>
</div><h4 id='method.clear' class='method'><code>fn <a href='#method.clear' class='fnname'>clear</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Truncates the string, returning it to 0 length.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = &quot;foo&quot;.to_string();
    s.clear();
    assert!(s.is_empty());
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>.<span class='ident'>to_string</span>();
<span class='ident'>s</span>.<span class='ident'>clear</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>is_empty</span>());</pre>
</div><h4 id='method.drain' class='method'><code>fn <a href='#method.drain' class='fnname'>drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class='struct' href='../../std/string/struct.Drain.html' title='std::string::Drain'>Drain</a> <span class='where'>where R: <a class='trait' href='../../core_collections/range/trait.RangeArgument.html' title='core_collections::range::RangeArgument'>RangeArgument</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;</span></code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>drain</code> <a href="https://github.com/rust-lang/rust/issues/27711">#27711</a>)<p>: recently added, matches RFC</p>
</em></div><div class='docblock'><p>Create a draining iterator that removes the specified range in the string
and yields the removed chars from start to end. The element range is
removed even if the iterator is not consumed until the end.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>Panics if the starting point or end point are not on character boundaries,
or if they are out of bounds.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>#![feature(drain)]

fn main() {
    let mut s = String::from(&quot;α is alpha, β is beta&quot;);
    let beta_offset = s.find(&#39;β&#39;).unwrap_or(s.len());
    
    // Remove the range up until the β from the string
    let t: String = s.drain(..beta_offset).collect();
    assert_eq!(t, &quot;α is alpha, &quot;);
    assert_eq!(s, &quot;β is beta&quot;);
    
    // A full range clears the string
    s.drain(..);
    assert_eq!(s, &quot;&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>drain</span>)]</span>

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;α is alpha, β is beta&quot;</span>);
<span class='kw'>let</span> <span class='ident'>beta_offset</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>find</span>(<span class='string'>&#39;β&#39;</span>).<span class='ident'>unwrap_or</span>(<span class='ident'>s</span>.<span class='ident'>len</span>());

<span class='comment'>// Remove the range up until the β from the string</span>
<span class='kw'>let</span> <span class='ident'>t</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>drain</span>(..<span class='ident'>beta_offset</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>t</span>, <span class='string'>&quot;α is alpha, &quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;β is beta&quot;</span>);

<span class='comment'>// A full range clears the string</span>
<span class='ident'>s</span>.<span class='ident'>drain</span>(..);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;&quot;</span>);</pre>
</div><h4 id='method.into_boxed_str' class='method'><code>fn <a href='#method.into_boxed_str' class='fnname'>into_boxed_str</a>(self) -&gt; <a class='struct' href='../../std/boxed/struct.Box.html' title='std::boxed::Box'>Box</a>&lt;<a class='primitive' href='../primitive.str.html'>str</a>&gt;</code></h4>
<div class='docblock'><p>Converts the string into <code>Box&lt;str&gt;</code>.</p>

<p>Note that this will drop any excess capacity.</p>
</div><h4 id='method.into_boxed_slice' class='method'><code>fn <a href='#method.into_boxed_slice' class='fnname'>into_boxed_slice</a>(self) -&gt; <a class='struct' href='../../std/boxed/struct.Box.html' title='std::boxed::Box'>Box</a>&lt;<a class='primitive' href='../primitive.str.html'>str</a>&gt;</code></h4>
<div class='stability'><em class='stab unstable deprecated'>Deprecated since 1.4.0<p>: renamed to <code>into_boxed_str</code></p>
</em></div><div class='docblock'><p>Converts the string into <code>Box&lt;str&gt;</code>.</p>

<p>Note that this will drop any excess capacity.</p>
</div></div><h2 id='deref-methods'>Methods from <a class='trait' href='../../std/ops/trait.Deref.html' title='std::ops::Deref'>Deref</a>&lt;Target=<a class='primitive' href='../primitive.str.html'>str</a>&gt;</h2><div class='impl-items'><h4 id='method.len' class='method'><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a class='primitive' href='../primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Returns the length of <code>self</code> in bytes.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    assert_eq!(&quot;foo&quot;.len(), 3);
    assert_eq!(&quot;ƒoo&quot;.len(), 4); // fancy f!
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;foo&quot;</span>.<span class='ident'>len</span>(), <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;ƒoo&quot;</span>.<span class='ident'>len</span>(), <span class='number'>4</span>); <span class='comment'>// fancy f!</span></pre>
</div><h4 id='method.is_empty' class='method'><code>fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if this slice has a length of zero bytes.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    assert!(&quot;&quot;.is_empty());
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='string'>&quot;&quot;</span>.<span class='ident'>is_empty</span>());</pre>
</div><h4 id='method.is_char_boundary' class='method'><code>fn <a href='#method.is_char_boundary' class='fnname'>is_char_boundary</a>(&amp;self, index: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>str_char</code> <a href="https://github.com/rust-lang/rust/issues/27754">#27754</a>)<p>: it is unclear whether this method pulls its weight with the existence of the char_indices iterator or this method may want to be replaced with checked slicing</p>
</em></div><div class='docblock'><p>Checks that <code>index</code>-th byte lies at the start and/or end of a
UTF-8 code point sequence.</p>

<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be
boundaries.</p>

<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>#![feature(str_char)]

fn main() {
    let s = &quot;Löwe 老虎 Léopard&quot;;
    assert!(s.is_char_boundary(0));
    // start of `老`
    assert!(s.is_char_boundary(6));
    assert!(s.is_char_boundary(s.len()));
    
    // second byte of `ö`
    assert!(!s.is_char_boundary(2));
    
    // third byte of `老`
    assert!(!s.is_char_boundary(8));
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>str_char</span>)]</span>

<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>;
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>is_char_boundary</span>(<span class='number'>0</span>));
<span class='comment'>// start of `老`</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>is_char_boundary</span>(<span class='number'>6</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>is_char_boundary</span>(<span class='ident'>s</span>.<span class='ident'>len</span>()));

<span class='comment'>// second byte of `ö`</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>s</span>.<span class='ident'>is_char_boundary</span>(<span class='number'>2</span>));

<span class='comment'>// third byte of `老`</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>s</span>.<span class='ident'>is_char_boundary</span>(<span class='number'>8</span>));</pre>
</div><h4 id='method.as_bytes' class='method'><code>fn <a href='#method.as_bytes' class='fnname'>as_bytes</a>(&amp;self) -&gt; <a class='primitive' href='../primitive.slice.html'>&amp;[</a><a class='primitive' href='../primitive.u8.html'>u8</a><a class='primitive' href='../primitive.slice.html'>]</a></code></h4>
<div class='docblock'><p>Converts <code>self</code> to a byte slice.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    assert_eq!(&quot;bors&quot;.as_bytes(), b&quot;bors&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;bors&quot;</span>.<span class='ident'>as_bytes</span>(), <span class='string'>b&quot;bors&quot;</span>);</pre>
</div><h4 id='method.as_ptr' class='method'><code>fn <a href='#method.as_ptr' class='fnname'>as_ptr</a>(&amp;self) -&gt; <a class='primitive' href='../primitive.pointer.html'>*const <a class='primitive' href='../primitive.u8.html'>u8</a></a></code></h4>
<div class='docblock'><p>Returns a raw pointer to the <code>&amp;str</code>&#39;s buffer.</p>

<p>The caller must ensure that the string outlives this pointer, and
that it is not
reallocated (e.g. by pushing to the string).</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = &quot;Hello&quot;;
    let p = s.as_ptr();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>;
<span class='kw'>let</span> <span class='ident'>p</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>as_ptr</span>();</pre>
</div><h4 id='method.slice_unchecked' class='method'><code>unsafe fn <a href='#method.slice_unchecked' class='fnname'>slice_unchecked</a>(&amp;self, begin: <a class='primitive' href='../primitive.usize.html'>usize</a>, end: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
<div class='docblock'><p>Takes a bytewise slice from a string.</p>

<p>Returns the substring from [<code>begin</code>..<code>end</code>).</p>

<h1 id='safety' class='section-header'><a href='#safety'>Safety</a></h1>
<p>Caller must check both UTF-8 sequence boundaries and the boundaries
of the entire slice as well.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = &quot;Löwe 老虎 Léopard&quot;;
    
    unsafe {
        assert_eq!(s.slice_unchecked(0, 21), &quot;Löwe 老虎 Léopard&quot;);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>;

<span class='kw'>unsafe</span> {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>slice_unchecked</span>(<span class='number'>0</span>, <span class='number'>21</span>), <span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>);
}</pre>
</div><h4 id='method.slice_mut_unchecked' class='method'><code>unsafe fn <a href='#method.slice_mut_unchecked' class='fnname'>slice_mut_unchecked</a>(&amp;mut self, begin: <a class='primitive' href='../primitive.usize.html'>usize</a>, end: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; &amp;mut <a class='primitive' href='../primitive.str.html'>str</a></code></h4>
<div class='docblock'><p>Takes a bytewise mutable slice from a string.</p>

<p>Same as <code>slice_unchecked</code>, but works with <code>&amp;mut str</code> instead of <code>&amp;str</code>.</p>
</div><h4 id='method.char_range_at' class='method'><code>fn <a href='#method.char_range_at' class='fnname'>char_range_at</a>(&amp;self, start: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; <a class='struct' href='../../std/str/struct.CharRange.html' title='std::str::CharRange'>CharRange</a></code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>str_char</code> <a href="https://github.com/rust-lang/rust/issues/27754">#27754</a>)<p>: often replaced by char_indices, this method may be removed in favor of just char_at() or eventually removed altogether</p>
</em></div><div class='docblock'><p>Given a byte position, return the next code point and its index.</p>

<p>This can be used to iterate over the Unicode code points of a string.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>If <code>i</code> is greater than or equal to the length of the string.
If <code>i</code> is not the index of the beginning of a valid UTF-8 sequence.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>This example manually iterates through the code points of a string;
this should normally be
done by <code>.chars()</code> or <code>.char_indices()</code>.</p>
<span class='rusttest'>#![feature(str_char, core)]

fn main() {
    use std::str::CharRange;
    
    let s = &quot;中华Việt Nam&quot;;
    let mut i = 0;
    while i &lt; s.len() {
        let CharRange {ch, next} = s.char_range_at(i);
        println!(&quot;{}: {}&quot;, i, ch);
        i = next;
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>str_char</span>, <span class='ident'>core</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>str</span>::<span class='ident'>CharRange</span>;

<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;中华Việt Nam&quot;</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='number'>0</span>;
<span class='kw'>while</span> <span class='ident'>i</span> <span class='op'>&lt;</span> <span class='ident'>s</span>.<span class='ident'>len</span>() {
    <span class='kw'>let</span> <span class='ident'>CharRange</span> {<span class='ident'>ch</span>, <span class='ident'>next</span>} <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>char_range_at</span>(<span class='ident'>i</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}: {}&quot;</span>, <span class='ident'>i</span>, <span class='ident'>ch</span>);
    <span class='ident'>i</span> <span class='op'>=</span> <span class='ident'>next</span>;
}</pre>

<p>This outputs:</p>

<pre><code class="language-text">0: 中
3: 华
6: V
7: i
8: e
9:
11:
13: t
14:
15: N
16: a
17: m
</code></pre>
</div><h4 id='method.char_range_at_reverse' class='method'><code>fn <a href='#method.char_range_at_reverse' class='fnname'>char_range_at_reverse</a>(&amp;self, start: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; <a class='struct' href='../../std/str/struct.CharRange.html' title='std::str::CharRange'>CharRange</a></code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>str_char</code> <a href="https://github.com/rust-lang/rust/issues/27754">#27754</a>)<p>: often replaced by char_indices, this method may be removed in favor of just char_at_reverse() or eventually removed altogether</p>
</em></div><div class='docblock'><p>Given a byte position, return the previous <code>char</code> and its position.</p>

<p>This function can be used to iterate over a Unicode code points in reverse.</p>

<p>Note that Unicode has many features, such as combining marks, ligatures,
and direction marks, that need to be taken into account to correctly reverse a string.</p>

<p>Returns 0 for next index if called on start index 0.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>If <code>i</code> is greater than the length of the string.
If <code>i</code> is not an index following a valid UTF-8 sequence.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>This example manually iterates through the code points of a string;
this should normally be
done by <code>.chars().rev()</code> or <code>.char_indices()</code>.</p>
<span class='rusttest'>#![feature(str_char, core)]

fn main() {
    use std::str::CharRange;
    
    let s = &quot;中华Việt Nam&quot;;
    let mut i = s.len();
    while i &gt; 0 {
        let CharRange {ch, next} = s.char_range_at_reverse(i);
        println!(&quot;{}: {}&quot;, i, ch);
        i = next;
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>str_char</span>, <span class='ident'>core</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>str</span>::<span class='ident'>CharRange</span>;

<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;中华Việt Nam&quot;</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>len</span>();
<span class='kw'>while</span> <span class='ident'>i</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
    <span class='kw'>let</span> <span class='ident'>CharRange</span> {<span class='ident'>ch</span>, <span class='ident'>next</span>} <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>char_range_at_reverse</span>(<span class='ident'>i</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}: {}&quot;</span>, <span class='ident'>i</span>, <span class='ident'>ch</span>);
    <span class='ident'>i</span> <span class='op'>=</span> <span class='ident'>next</span>;
}</pre>

<p>This outputs:</p>

<pre><code class="language-text">18: m
17: a
16: N
15:
14: t
13:
11:
9: e
8: i
7: V
6: 华
3: 中
</code></pre>
</div><h4 id='method.char_at' class='method'><code>fn <a href='#method.char_at' class='fnname'>char_at</a>(&amp;self, i: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; <a class='primitive' href='../primitive.char.html'>char</a></code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>str_char</code> <a href="https://github.com/rust-lang/rust/issues/27754">#27754</a>)<p>: frequently replaced by the chars() iterator, this method may be removed or possibly renamed in the future; it is normally replaced by chars/char_indices iterators or by getting the first char from a subslice</p>
</em></div><div class='docblock'><p>Given a byte position, return the <code>char</code> at that position.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>If <code>i</code> is greater than or equal to the length of the string.
If <code>i</code> is not the index of the beginning of a valid UTF-8 sequence.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>#![feature(str_char)]

fn main() {
    let s = &quot;abπc&quot;;
    assert_eq!(s.char_at(1), &#39;b&#39;);
    assert_eq!(s.char_at(2), &#39;π&#39;);
    assert_eq!(s.char_at(4), &#39;c&#39;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>str_char</span>)]</span>

<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;abπc&quot;</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>char_at</span>(<span class='number'>1</span>), <span class='string'>&#39;b&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>char_at</span>(<span class='number'>2</span>), <span class='string'>&#39;π&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>char_at</span>(<span class='number'>4</span>), <span class='string'>&#39;c&#39;</span>);</pre>
</div><h4 id='method.char_at_reverse' class='method'><code>fn <a href='#method.char_at_reverse' class='fnname'>char_at_reverse</a>(&amp;self, i: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; <a class='primitive' href='../primitive.char.html'>char</a></code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>str_char</code> <a href="https://github.com/rust-lang/rust/issues/27754">#27754</a>)<p>: see char_at for more details, but reverse semantics are also somewhat unclear, especially with which cases generate panics</p>
</em></div><div class='docblock'><p>Given a byte position, return the <code>char</code> at that position, counting
from the end.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>If <code>i</code> is greater than the length of the string.
If <code>i</code> is not an index following a valid UTF-8 sequence.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>#![feature(str_char)]

fn main() {
    let s = &quot;abπc&quot;;
    assert_eq!(s.char_at_reverse(1), &#39;a&#39;);
    assert_eq!(s.char_at_reverse(2), &#39;b&#39;);
    assert_eq!(s.char_at_reverse(3), &#39;π&#39;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>str_char</span>)]</span>

<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;abπc&quot;</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>char_at_reverse</span>(<span class='number'>1</span>), <span class='string'>&#39;a&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>char_at_reverse</span>(<span class='number'>2</span>), <span class='string'>&#39;b&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>char_at_reverse</span>(<span class='number'>3</span>), <span class='string'>&#39;π&#39;</span>);</pre>
</div><h4 id='method.slice_shift_char' class='method'><code>fn <a href='#method.slice_shift_char' class='fnname'>slice_shift_char</a>(&amp;self) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='primitive' href='../primitive.tuple.html'>(<a class='primitive' href='../primitive.char.html'>char</a>, &amp;<a class='primitive' href='../primitive.str.html'>str</a>)</a>&gt;</code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>str_char</code> <a href="https://github.com/rust-lang/rust/issues/27754">#27754</a>)<p>: awaiting conventions about shifting and slices and may not be warranted with the existence of the chars and/or char_indices iterators</p>
</em></div><div class='docblock'><p>Retrieves the first code point from a <code>&amp;str</code> and returns it.</p>

<p>Note that a single Unicode character (grapheme cluster)
can be composed of multiple <code>char</code>s.</p>

<p>This does not allocate a new string; instead, it returns a slice that
points one code point beyond the code point that was shifted.</p>

<p><code>None</code> is returned if the slice is empty.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>#![feature(str_char)]

fn main() {
    let s = &quot;Łódź&quot;; // \u{141}o\u{301}dz\u{301}
    let (c, s1) = s.slice_shift_char().unwrap();
    
    assert_eq!(c, &#39;Ł&#39;);
    assert_eq!(s1, &quot;ódź&quot;);
    
    let (c, s2) = s1.slice_shift_char().unwrap();
    
    assert_eq!(c, &#39;o&#39;);
    assert_eq!(s2, &quot;\u{301}dz\u{301}&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>str_char</span>)]</span>

<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Łódź&quot;</span>; <span class='comment'>// \u{141}o\u{301}dz\u{301}</span>
<span class='kw'>let</span> (<span class='ident'>c</span>, <span class='ident'>s1</span>) <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>slice_shift_char</span>().<span class='ident'>unwrap</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>c</span>, <span class='string'>&#39;Ł&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s1</span>, <span class='string'>&quot;ódź&quot;</span>);

<span class='kw'>let</span> (<span class='ident'>c</span>, <span class='ident'>s2</span>) <span class='op'>=</span> <span class='ident'>s1</span>.<span class='ident'>slice_shift_char</span>().<span class='ident'>unwrap</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>c</span>, <span class='string'>&#39;o&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s2</span>, <span class='string'>&quot;\u{301}dz\u{301}&quot;</span>);</pre>
</div><h4 id='method.split_at' class='method'><code>fn <a href='#method.split_at' class='fnname'>split_at</a>(&amp;self, mid: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; <a class='primitive' href='../primitive.tuple.html'>(&amp;<a class='primitive' href='../primitive.str.html'>str</a>, &amp;<a class='primitive' href='../primitive.str.html'>str</a>)</a></code></h4>
<div class='docblock'><p>Divide one string slice into two at an index.</p>

<p>The index <code>mid</code> is a byte offset from the start of the string
that must be on a <code>char</code> boundary.</p>

<p>Return slices <code>&amp;self[..mid]</code> and <code>&amp;self[mid..]</code>.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>Panics if <code>mid</code> is beyond the last code point of the string,
or if it is not on a <code>char</code> boundary.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = &quot;Löwe 老虎 Léopard&quot;;
    let first_space = s.find(&#39; &#39;).unwrap_or(s.len());
    let (a, b) = s.split_at(first_space);
    
    assert_eq!(a, &quot;Löwe&quot;);
    assert_eq!(b, &quot; 老虎 Léopard&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>;
<span class='kw'>let</span> <span class='ident'>first_space</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>find</span>(<span class='string'>&#39; &#39;</span>).<span class='ident'>unwrap_or</span>(<span class='ident'>s</span>.<span class='ident'>len</span>());
<span class='kw'>let</span> (<span class='ident'>a</span>, <span class='ident'>b</span>) <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>split_at</span>(<span class='ident'>first_space</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>, <span class='string'>&quot;Löwe&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>b</span>, <span class='string'>&quot; 老虎 Léopard&quot;</span>);</pre>
</div><h4 id='method.split_at_mut' class='method'><code>fn <a href='#method.split_at_mut' class='fnname'>split_at_mut</a>(&amp;mut self, mid: <a class='primitive' href='../primitive.usize.html'>usize</a>) -&gt; <a class='primitive' href='../primitive.tuple.html'>(&amp;mut <a class='primitive' href='../primitive.str.html'>str</a>, &amp;mut <a class='primitive' href='../primitive.str.html'>str</a>)</a></code></h4>
<div class='docblock'><p>Divide one mutable string slice into two at an index.</p>
</div><h4 id='method.chars' class='method'><code>fn <a href='#method.chars' class='fnname'>chars</a>(&amp;self) -&gt; <a class='struct' href='../../std/str/struct.Chars.html' title='std::str::Chars'>Chars</a></code></h4>
<div class='docblock'><p>An iterator over the code points of <code>self</code>.</p>

<p>In Unicode relationship between code points and characters is complex.
A single character may be composed of multiple code points
(e.g. diacritical marks added to a letter), and a single code point
(e.g. Hangul syllable) may contain multiple characters.</p>

<p>For iteration over human-readable characters a grapheme cluster iterator
may be more appropriate. See the <a href="https://crates.io/crates/unicode-segmentation">unicode-segmentation crate</a>.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let v: Vec&lt;char&gt; = &quot;ASCII żółć 🇨🇭 한&quot;.chars().collect();
    
    assert_eq!(v, [&#39;A&#39;, &#39;S&#39;, &#39;C&#39;, &#39;I&#39;, &#39;I&#39;, &#39; &#39;,
        &#39;z&#39;, &#39;\u{307}&#39;, &#39;o&#39;, &#39;\u{301}&#39;, &#39;ł&#39;, &#39;c&#39;, &#39;\u{301}&#39;, &#39; &#39;,
        &#39;\u{1f1e8}&#39;, &#39;\u{1f1ed}&#39;, &#39; &#39;, &#39;한&#39;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>char</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;ASCII żółć 🇨🇭 한&quot;</span>.<span class='ident'>chars</span>().<span class='ident'>collect</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&#39;A&#39;</span>, <span class='string'>&#39;S&#39;</span>, <span class='string'>&#39;C&#39;</span>, <span class='string'>&#39;I&#39;</span>, <span class='string'>&#39;I&#39;</span>, <span class='string'>&#39; &#39;</span>,
    <span class='string'>&#39;z&#39;</span>, <span class='string'>&#39;\u{307}&#39;</span>, <span class='string'>&#39;o&#39;</span>, <span class='string'>&#39;\u{301}&#39;</span>, <span class='string'>&#39;ł&#39;</span>, <span class='string'>&#39;c&#39;</span>, <span class='string'>&#39;\u{301}&#39;</span>, <span class='string'>&#39; &#39;</span>,
    <span class='string'>&#39;\u{1f1e8}&#39;</span>, <span class='string'>&#39;\u{1f1ed}&#39;</span>, <span class='string'>&#39; &#39;</span>, <span class='string'>&#39;한&#39;</span>]);</pre>
</div><h4 id='method.char_indices' class='method'><code>fn <a href='#method.char_indices' class='fnname'>char_indices</a>(&amp;self) -&gt; <a class='struct' href='../../std/str/struct.CharIndices.html' title='std::str::CharIndices'>CharIndices</a></code></h4>
<div class='docblock'><p>An iterator over the <code>char</code>s of <code>self</code> and their byte offsets.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let v: Vec&lt;(usize, char)&gt; = &quot;A🇨🇭&quot;.char_indices().collect();
    let b = vec![(0, &#39;A&#39;), (1, &#39;\u{1f1e8}&#39;), (5, &#39;\u{1f1ed}&#39;)];
    
    assert_eq!(v, b);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>(<span class='ident'>usize</span>, <span class='ident'>char</span>)<span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;A🇨🇭&quot;</span>.<span class='ident'>char_indices</span>().<span class='ident'>collect</span>();
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='number'>0</span>, <span class='string'>&#39;A&#39;</span>), (<span class='number'>1</span>, <span class='string'>&#39;\u{1f1e8}&#39;</span>), (<span class='number'>5</span>, <span class='string'>&#39;\u{1f1ed}&#39;</span>)];

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='ident'>b</span>);</pre>
</div><h4 id='method.bytes' class='method'><code>fn <a href='#method.bytes' class='fnname'>bytes</a>(&amp;self) -&gt; <a class='struct' href='../../std/str/struct.Bytes.html' title='std::str::Bytes'>Bytes</a></code></h4>
<div class='docblock'><p>An iterator over the bytes of <code>self</code>.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let v: Vec&lt;u8&gt; = &quot;bors&quot;.bytes().collect();
    
    assert_eq!(v, b&quot;bors&quot;.to_vec());
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;bors&quot;</span>.<span class='ident'>bytes</span>().<span class='ident'>collect</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='string'>b&quot;bors&quot;</span>.<span class='ident'>to_vec</span>());</pre>
</div><h4 id='method.split_whitespace' class='method'><code>fn <a href='#method.split_whitespace' class='fnname'>split_whitespace</a>(&amp;self) -&gt; <a class='struct' href='../../std/str/struct.SplitWhitespace.html' title='std::str::SplitWhitespace'>SplitWhitespace</a></code></h4>
<div class='docblock'><p>An iterator over the non-empty substrings of <code>self</code> which contain no whitespace,
and which are separated by any amount of whitespace.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let some_words = &quot; Mary   had\ta\u{2009}little  \n\t lamb&quot;;
    let v: Vec&lt;&amp;str&gt; = some_words.split_whitespace().collect();
    
    assert_eq!(v, [&quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>some_words</span> <span class='op'>=</span> <span class='string'>&quot; Mary   had\ta\u{2009}little  \n\t lamb&quot;</span>;
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>some_words</span>.<span class='ident'>split_whitespace</span>().<span class='ident'>collect</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;Mary&quot;</span>, <span class='string'>&quot;had&quot;</span>, <span class='string'>&quot;a&quot;</span>, <span class='string'>&quot;little&quot;</span>, <span class='string'>&quot;lamb&quot;</span>]);</pre>
</div><h4 id='method.lines' class='method'><code>fn <a href='#method.lines' class='fnname'>lines</a>(&amp;self) -&gt; <a class='struct' href='../../std/str/struct.Lines.html' title='std::str::Lines'>Lines</a></code></h4>
<div class='docblock'><p>An iterator over the lines of a string, separated by <code>\n</code> or <code>\r\n</code>.</p>

<p>This does not include the empty string after a trailing newline or CRLF.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let four_lines = &quot;foo\nbar\n\r\nbaz&quot;;
    let v: Vec&lt;&amp;str&gt; = four_lines.lines().collect();
    
    assert_eq!(v, [&quot;foo&quot;, &quot;bar&quot;, &quot;&quot;, &quot;baz&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>four_lines</span> <span class='op'>=</span> <span class='string'>&quot;foo\nbar\n\r\nbaz&quot;</span>;
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>four_lines</span>.<span class='ident'>lines</span>().<span class='ident'>collect</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;foo&quot;</span>, <span class='string'>&quot;bar&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;baz&quot;</span>]);</pre>

<p>Leaving off the trailing character:</p>
<span class='rusttest'>fn main() {
    let four_lines = &quot;foo\r\nbar\n\nbaz\n&quot;;
    let v: Vec&lt;&amp;str&gt; = four_lines.lines().collect();
    
    assert_eq!(v, [&quot;foo&quot;, &quot;bar&quot;, &quot;&quot;, &quot;baz&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>four_lines</span> <span class='op'>=</span> <span class='string'>&quot;foo\r\nbar\n\nbaz\n&quot;</span>;
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>four_lines</span>.<span class='ident'>lines</span>().<span class='ident'>collect</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;foo&quot;</span>, <span class='string'>&quot;bar&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;baz&quot;</span>]);</pre>
</div><h4 id='method.lines_any' class='method'><code>fn <a href='#method.lines_any' class='fnname'>lines_any</a>(&amp;self) -&gt; <a class='struct' href='../../std/str/struct.LinesAny.html' title='std::str::LinesAny'>LinesAny</a></code></h4>
<div class='stability'><em class='stab  deprecated'>Deprecated since 1.4.0<p>: use lines() instead now</p>
</em></div><div class='docblock'><p>An iterator over the lines of a string, separated by either
<code>\n</code> or <code>\r\n</code>.</p>

<p>As with <code>.lines()</code>, this does not include an empty trailing line.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let four_lines = &quot;foo\r\nbar\n\r\nbaz&quot;;
    let v: Vec&lt;&amp;str&gt; = four_lines.lines_any().collect();
    
    assert_eq!(v, [&quot;foo&quot;, &quot;bar&quot;, &quot;&quot;, &quot;baz&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>four_lines</span> <span class='op'>=</span> <span class='string'>&quot;foo\r\nbar\n\r\nbaz&quot;</span>;
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>four_lines</span>.<span class='ident'>lines_any</span>().<span class='ident'>collect</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;foo&quot;</span>, <span class='string'>&quot;bar&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;baz&quot;</span>]);</pre>

<p>Leaving off the trailing character:</p>
<span class='rusttest'>fn main() {
    let four_lines = &quot;foo\r\nbar\n\r\nbaz\n&quot;;
    let v: Vec&lt;&amp;str&gt; = four_lines.lines_any().collect();
    
    assert_eq!(v, [&quot;foo&quot;, &quot;bar&quot;, &quot;&quot;, &quot;baz&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>four_lines</span> <span class='op'>=</span> <span class='string'>&quot;foo\r\nbar\n\r\nbaz\n&quot;</span>;
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>four_lines</span>.<span class='ident'>lines_any</span>().<span class='ident'>collect</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;foo&quot;</span>, <span class='string'>&quot;bar&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;baz&quot;</span>]);</pre>
</div><h4 id='method.utf16_units' class='method'><code>fn <a href='#method.utf16_units' class='fnname'>utf16_units</a>(&amp;self) -&gt; <a class='struct' href='../../std/str/struct.Utf16Units.html' title='std::str::Utf16Units'>Utf16Units</a></code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>str_utf16</code> <a href="https://github.com/rust-lang/rust/issues/27714">#27714</a>)<p>: this functionality may only be provided by libunicode</p>
</em></div><div class='docblock'><p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p>
</div><h4 id='method.contains' class='method'><code>fn <a href='#method.contains' class='fnname'>contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a> <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>Returns <code>true</code> if <code>self</code> contains another <code>&amp;str</code>.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    assert!(&quot;bananas&quot;.contains(&quot;nana&quot;));
    
    assert!(!&quot;bananas&quot;.contains(&quot;foobar&quot;));
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='string'>&quot;bananas&quot;</span>.<span class='ident'>contains</span>(<span class='string'>&quot;nana&quot;</span>));

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='string'>&quot;bananas&quot;</span>.<span class='ident'>contains</span>(<span class='string'>&quot;foobar&quot;</span>));</pre>
</div><h4 id='method.starts_with' class='method'><code>fn <a href='#method.starts_with' class='fnname'>starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a> <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>Returns <code>true</code> if the given <code>&amp;str</code> is a prefix of the string.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    assert!(&quot;banana&quot;.starts_with(&quot;ba&quot;));
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='string'>&quot;banana&quot;</span>.<span class='ident'>starts_with</span>(<span class='string'>&quot;ba&quot;</span>));</pre>
</div><h4 id='method.ends_with' class='method'><code>fn <a href='#method.ends_with' class='fnname'>ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a> <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;, P::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a>: <a class='trait' href='../../std/str/pattern/trait.ReverseSearcher.html' title='std::str::pattern::ReverseSearcher'>ReverseSearcher</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>Returns true if the given <code>&amp;str</code> is a suffix of the string.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    assert!(&quot;banana&quot;.ends_with(&quot;nana&quot;));
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='string'>&quot;banana&quot;</span>.<span class='ident'>ends_with</span>(<span class='string'>&quot;nana&quot;</span>));</pre>
</div><h4 id='method.find' class='method'><code>fn <a href='#method.find' class='fnname'>find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>Returns the byte index of the first character of <code>self</code> that matches
the pattern, if it
exists.</p>

<p>Returns <code>None</code> if it doesn&#39;t exist.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that
determines if a character matches.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Simple patterns:</p>
<span class='rusttest'>fn main() {
    let s = &quot;Löwe 老虎 Léopard&quot;;
    
    assert_eq!(s.find(&#39;L&#39;), Some(0));
    assert_eq!(s.find(&#39;é&#39;), Some(14));
    assert_eq!(s.find(&quot;Léopard&quot;), Some(13));
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='string'>&#39;L&#39;</span>), <span class='prelude-val'>Some</span>(<span class='number'>0</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='string'>&#39;é&#39;</span>), <span class='prelude-val'>Some</span>(<span class='number'>14</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='string'>&quot;Léopard&quot;</span>), <span class='prelude-val'>Some</span>(<span class='number'>13</span>));
</pre>

<p>More complex patterns with closures:</p>
<span class='rusttest'>fn main() {
    let s = &quot;Löwe 老虎 Léopard&quot;;
    
    assert_eq!(s.find(char::is_whitespace), Some(5));
    assert_eq!(s.find(char::is_lowercase), Some(1));
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='ident'>char</span>::<span class='ident'>is_whitespace</span>), <span class='prelude-val'>Some</span>(<span class='number'>5</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='ident'>char</span>::<span class='ident'>is_lowercase</span>), <span class='prelude-val'>Some</span>(<span class='number'>1</span>));</pre>

<p>Not finding the pattern:</p>
<span class='rusttest'>fn main() {
    let s = &quot;Löwe 老虎 Léopard&quot;;
    let x: &amp;[_] = &amp;[&#39;1&#39;, &#39;2&#39;];
    
    assert_eq!(s.find(x), None);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>;
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[_] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>&#39;1&#39;</span>, <span class='string'>&#39;2&#39;</span>];

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='ident'>x</span>), <span class='prelude-val'>None</span>);</pre>
</div><h4 id='method.rfind' class='method'><code>fn <a href='#method.rfind' class='fnname'>rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;, P::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a>: <a class='trait' href='../../std/str/pattern/trait.ReverseSearcher.html' title='std::str::pattern::ReverseSearcher'>ReverseSearcher</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>Returns the byte index of the last character of <code>self</code> that
matches the pattern, if it
exists.</p>

<p>Returns <code>None</code> if it doesn&#39;t exist.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>,
or a closure that determines if a character matches.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Simple patterns:</p>
<span class='rusttest'>fn main() {
    let s = &quot;Löwe 老虎 Léopard&quot;;
    
    assert_eq!(s.rfind(&#39;L&#39;), Some(13));
    assert_eq!(s.rfind(&#39;é&#39;), Some(14));
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>rfind</span>(<span class='string'>&#39;L&#39;</span>), <span class='prelude-val'>Some</span>(<span class='number'>13</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>rfind</span>(<span class='string'>&#39;é&#39;</span>), <span class='prelude-val'>Some</span>(<span class='number'>14</span>));</pre>

<p>More complex patterns with closures:</p>
<span class='rusttest'>fn main() {
    let s = &quot;Löwe 老虎 Léopard&quot;;
    
    assert_eq!(s.rfind(char::is_whitespace), Some(12));
    assert_eq!(s.rfind(char::is_lowercase), Some(20));
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>rfind</span>(<span class='ident'>char</span>::<span class='ident'>is_whitespace</span>), <span class='prelude-val'>Some</span>(<span class='number'>12</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>rfind</span>(<span class='ident'>char</span>::<span class='ident'>is_lowercase</span>), <span class='prelude-val'>Some</span>(<span class='number'>20</span>));</pre>

<p>Not finding the pattern:</p>
<span class='rusttest'>fn main() {
    let s = &quot;Löwe 老虎 Léopard&quot;;
    let x: &amp;[_] = &amp;[&#39;1&#39;, &#39;2&#39;];
    
    assert_eq!(s.rfind(x), None);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>;
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[_] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>&#39;1&#39;</span>, <span class='string'>&#39;2&#39;</span>];

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>rfind</span>(<span class='ident'>x</span>), <span class='prelude-val'>None</span>);</pre>
</div><h4 id='method.split' class='method'><code>fn <a href='#method.split' class='fnname'>split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='struct' href='../../std/str/struct.Split.html' title='std::str::Split'>Split</a>&lt;'a, P&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that
determines the split. Additional libraries might provide more complex
patterns like regular expressions.</p>

<h1 id='iterator-behavior' class='section-header'><a href='#iterator-behavior'>Iterator behavior</a></h1>
<p>The returned iterator will be double ended if the pattern allows a
reverse search and forward/reverse search yields the same elements.
This is true for, eg, <code>char</code> but not
for <code>&amp;str</code>.</p>

<p>If the pattern allows a reverse search but its results might differ
from a forward search, <code>rsplit()</code> can be used.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Simple patterns:</p>
<span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;Mary had a little lamb&quot;.split(&#39; &#39;).collect();
    assert_eq!(v, [&quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;&quot;.split(&#39;X&#39;).collect();
    assert_eq!(v, [&quot;&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;lionXXtigerXleopard&quot;.split(&#39;X&#39;).collect();
    assert_eq!(v, [&quot;lion&quot;, &quot;&quot;, &quot;tiger&quot;, &quot;leopard&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;lion::tiger::leopard&quot;.split(&quot;::&quot;).collect();
    assert_eq!(v, [&quot;lion&quot;, &quot;tiger&quot;, &quot;leopard&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;abc1def2ghi&quot;.split(char::is_numeric).collect();
    assert_eq!(v, [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;lionXtigerXleopard&quot;.split(char::is_uppercase).collect();
    assert_eq!(v, [&quot;lion&quot;, &quot;tiger&quot;, &quot;leopard&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;Mary had a little lamb&quot;</span>.<span class='ident'>split</span>(<span class='string'>&#39; &#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;Mary&quot;</span>, <span class='string'>&quot;had&quot;</span>, <span class='string'>&quot;a&quot;</span>, <span class='string'>&quot;little&quot;</span>, <span class='string'>&quot;lamb&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;&quot;</span>.<span class='ident'>split</span>(<span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;lionXXtigerXleopard&quot;</span>.<span class='ident'>split</span>(<span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;lion&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;tiger&quot;</span>, <span class='string'>&quot;leopard&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;lion::tiger::leopard&quot;</span>.<span class='ident'>split</span>(<span class='string'>&quot;::&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;lion&quot;</span>, <span class='string'>&quot;tiger&quot;</span>, <span class='string'>&quot;leopard&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;abc1def2ghi&quot;</span>.<span class='ident'>split</span>(<span class='ident'>char</span>::<span class='ident'>is_numeric</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;abc&quot;</span>, <span class='string'>&quot;def&quot;</span>, <span class='string'>&quot;ghi&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;lionXtigerXleopard&quot;</span>.<span class='ident'>split</span>(<span class='ident'>char</span>::<span class='ident'>is_uppercase</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;lion&quot;</span>, <span class='string'>&quot;tiger&quot;</span>, <span class='string'>&quot;leopard&quot;</span>]);</pre>

<p>A more complex pattern, using a closure:</p>
<span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;abc1defXghi&quot;.split(|c| c == &#39;1&#39; || c == &#39;X&#39;).collect();
    assert_eq!(v, [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;abc1defXghi&quot;</span>.<span class='ident'>split</span>(<span class='op'>|</span><span class='ident'>c</span><span class='op'>|</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;1&#39;</span> <span class='op'>||</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;abc&quot;</span>, <span class='string'>&quot;def&quot;</span>, <span class='string'>&quot;ghi&quot;</span>]);</pre>

<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>
<span class='rusttest'>fn main() {
    let x = &quot;||||a||b|c&quot;.to_string();
    let d: Vec&lt;_&gt; = x.split(&#39;|&#39;).collect();
    
    assert_eq!(d, &amp;[&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;||||a||b|c&quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>d</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>split</span>(<span class='string'>&#39;|&#39;</span>).<span class='ident'>collect</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>d</span>, <span class='kw-2'>&amp;</span>[<span class='string'>&quot;&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;a&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;b&quot;</span>, <span class='string'>&quot;c&quot;</span>]);</pre>

<p>This can lead to possibly surprising behavior when whitespace is used
as the separator. This code is correct:</p>
<span class='rusttest'>fn main() {
    let x = &quot;    a  b c&quot;.to_string();
    let d: Vec&lt;_&gt; = x.split(&#39; &#39;).collect();
    
    assert_eq!(d, &amp;[&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;    a  b c&quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>d</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>split</span>(<span class='string'>&#39; &#39;</span>).<span class='ident'>collect</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>d</span>, <span class='kw-2'>&amp;</span>[<span class='string'>&quot;&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;a&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;b&quot;</span>, <span class='string'>&quot;c&quot;</span>]);</pre>

<p>It does <em>not</em> give you:</p>
<span class='rusttest'>fn main() {
    assert_eq!(d, &amp;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>d</span>, <span class='kw-2'>&amp;</span>[<span class='string'>&quot;a&quot;</span>, <span class='string'>&quot;b&quot;</span>, <span class='string'>&quot;c&quot;</span>]);</pre>

<p>Use <a href="#method.split_whitespace"><code>.split_whitespace()</code></a> for this behavior.</p>
</div><h4 id='method.rsplit' class='method'><code>fn <a href='#method.rsplit' class='fnname'>rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='struct' href='../../std/str/struct.RSplit.html' title='std::str::RSplit'>RSplit</a>&lt;'a, P&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;, P::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a>: <a class='trait' href='../../std/str/pattern/trait.ReverseSearcher.html' title='std::str::pattern::ReverseSearcher'>ReverseSearcher</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that
determines the split.
Additional libraries might provide more complex patterns like
regular expressions.</p>

<h1 id='iterator-behavior' class='section-header'><a href='#iterator-behavior'>Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a
reverse search,
and it will be double ended if a forward/reverse search yields
the same elements.</p>

<p>For iterating from the front, <code>split()</code> can be used.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Simple patterns:</p>
<span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;Mary had a little lamb&quot;.rsplit(&#39; &#39;).collect();
    assert_eq!(v, [&quot;lamb&quot;, &quot;little&quot;, &quot;a&quot;, &quot;had&quot;, &quot;Mary&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;&quot;.rsplit(&#39;X&#39;).collect();
    assert_eq!(v, [&quot;&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;lionXXtigerXleopard&quot;.rsplit(&#39;X&#39;).collect();
    assert_eq!(v, [&quot;leopard&quot;, &quot;tiger&quot;, &quot;&quot;, &quot;lion&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;lion::tiger::leopard&quot;.rsplit(&quot;::&quot;).collect();
    assert_eq!(v, [&quot;leopard&quot;, &quot;tiger&quot;, &quot;lion&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;Mary had a little lamb&quot;</span>.<span class='ident'>rsplit</span>(<span class='string'>&#39; &#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;lamb&quot;</span>, <span class='string'>&quot;little&quot;</span>, <span class='string'>&quot;a&quot;</span>, <span class='string'>&quot;had&quot;</span>, <span class='string'>&quot;Mary&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;&quot;</span>.<span class='ident'>rsplit</span>(<span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;lionXXtigerXleopard&quot;</span>.<span class='ident'>rsplit</span>(<span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;leopard&quot;</span>, <span class='string'>&quot;tiger&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;lion&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;lion::tiger::leopard&quot;</span>.<span class='ident'>rsplit</span>(<span class='string'>&quot;::&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;leopard&quot;</span>, <span class='string'>&quot;tiger&quot;</span>, <span class='string'>&quot;lion&quot;</span>]);</pre>

<p>A more complex pattern, using a closure:</p>
<span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;abc1defXghi&quot;.rsplit(|c| c == &#39;1&#39; || c == &#39;X&#39;).collect();
    assert_eq!(v, [&quot;ghi&quot;, &quot;def&quot;, &quot;abc&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;abc1defXghi&quot;</span>.<span class='ident'>rsplit</span>(<span class='op'>|</span><span class='ident'>c</span><span class='op'>|</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;1&#39;</span> <span class='op'>||</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;ghi&quot;</span>, <span class='string'>&quot;def&quot;</span>, <span class='string'>&quot;abc&quot;</span>]);</pre>
</div><h4 id='method.split_terminator' class='method'><code>fn <a href='#method.split_terminator' class='fnname'>split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='struct' href='../../std/str/struct.SplitTerminator.html' title='std::str::SplitTerminator'>SplitTerminator</a>&lt;'a, P&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that
determines the split.
Additional libraries might provide more complex patterns
like regular expressions.</p>

<p>Equivalent to <code>split</code>, except that the trailing substring
is skipped if empty.</p>

<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>

<h1 id='iterator-behavior' class='section-header'><a href='#iterator-behavior'>Iterator behavior</a></h1>
<p>The returned iterator will be double ended if the pattern allows a
reverse search
and forward/reverse search yields the same elements. This is true
for, eg, <code>char</code> but not for <code>&amp;str</code>.</p>

<p>If the pattern allows a reverse search but its results might differ
from a forward search, <code>rsplit_terminator()</code> can be used.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;A.B.&quot;.split_terminator(&#39;.&#39;).collect();
    assert_eq!(v, [&quot;A&quot;, &quot;B&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;A..B..&quot;.split_terminator(&quot;.&quot;).collect();
    assert_eq!(v, [&quot;A&quot;, &quot;&quot;, &quot;B&quot;, &quot;&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;A.B.&quot;</span>.<span class='ident'>split_terminator</span>(<span class='string'>&#39;.&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;A&quot;</span>, <span class='string'>&quot;B&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;A..B..&quot;</span>.<span class='ident'>split_terminator</span>(<span class='string'>&quot;.&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;A&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;B&quot;</span>, <span class='string'>&quot;&quot;</span>]);</pre>
</div><h4 id='method.rsplit_terminator' class='method'><code>fn <a href='#method.rsplit_terminator' class='fnname'>rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='struct' href='../../std/str/struct.RSplitTerminator.html' title='std::str::RSplitTerminator'>RSplitTerminator</a>&lt;'a, P&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;, P::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a>: <a class='trait' href='../../std/str/pattern/trait.ReverseSearcher.html' title='std::str::pattern::ReverseSearcher'>ReverseSearcher</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that
determines the split.
Additional libraries might provide more complex patterns like
regular expressions.</p>

<p>Equivalent to <code>split</code>, except that the trailing substring is
skipped if empty.</p>

<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>

<h1 id='iterator-behavior' class='section-header'><a href='#iterator-behavior'>Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>

<p>For iterating from the front, <code>split_terminator()</code> can be used.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;A.B.&quot;.rsplit_terminator(&#39;.&#39;).collect();
    assert_eq!(v, [&quot;B&quot;, &quot;A&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;A..B..&quot;.rsplit_terminator(&quot;.&quot;).collect();
    assert_eq!(v, [&quot;&quot;, &quot;B&quot;, &quot;&quot;, &quot;A&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;A.B.&quot;</span>.<span class='ident'>rsplit_terminator</span>(<span class='string'>&#39;.&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;B&quot;</span>, <span class='string'>&quot;A&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;A..B..&quot;</span>.<span class='ident'>rsplit_terminator</span>(<span class='string'>&quot;.&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;&quot;</span>, <span class='string'>&quot;B&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;A&quot;</span>]);</pre>
</div><h4 id='method.splitn' class='method'><code>fn <a href='#method.splitn' class='fnname'>splitn</a>&lt;'a, P&gt;(&amp;'a self, count: <a class='primitive' href='../primitive.usize.html'>usize</a>, pat: P) -&gt; <a class='struct' href='../../std/str/struct.SplitN.html' title='std::str::SplitN'>SplitN</a>&lt;'a, P&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by a pattern,
restricted to returning
at most <code>count</code> items.</p>

<p>The last element returned, if any, will contain the remainder of the
string.
The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that
determines the split.
Additional libraries might provide more complex patterns like
regular expressions.</p>

<h1 id='iterator-behavior' class='section-header'><a href='#iterator-behavior'>Iterator behavior</a></h1>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>

<p>If the pattern allows a reverse search, <code>rsplitn()</code> can be used.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Simple patterns:</p>
<span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;Mary had a little lambda&quot;.splitn(3, &#39; &#39;).collect();
    assert_eq!(v, [&quot;Mary&quot;, &quot;had&quot;, &quot;a little lambda&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;lionXXtigerXleopard&quot;.splitn(3, &quot;X&quot;).collect();
    assert_eq!(v, [&quot;lion&quot;, &quot;&quot;, &quot;tigerXleopard&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;abcXdef&quot;.splitn(1, &#39;X&#39;).collect();
    assert_eq!(v, [&quot;abcXdef&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;&quot;.splitn(1, &#39;X&#39;).collect();
    assert_eq!(v, [&quot;&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;Mary had a little lambda&quot;</span>.<span class='ident'>splitn</span>(<span class='number'>3</span>, <span class='string'>&#39; &#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;Mary&quot;</span>, <span class='string'>&quot;had&quot;</span>, <span class='string'>&quot;a little lambda&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;lionXXtigerXleopard&quot;</span>.<span class='ident'>splitn</span>(<span class='number'>3</span>, <span class='string'>&quot;X&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;lion&quot;</span>, <span class='string'>&quot;&quot;</span>, <span class='string'>&quot;tigerXleopard&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;abcXdef&quot;</span>.<span class='ident'>splitn</span>(<span class='number'>1</span>, <span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;abcXdef&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;&quot;</span>.<span class='ident'>splitn</span>(<span class='number'>1</span>, <span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;&quot;</span>]);</pre>

<p>A more complex pattern, using a closure:</p>
<span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;abc1defXghi&quot;.splitn(2, |c| c == &#39;1&#39; || c == &#39;X&#39;).collect();
    assert_eq!(v, [&quot;abc&quot;, &quot;defXghi&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;abc1defXghi&quot;</span>.<span class='ident'>splitn</span>(<span class='number'>2</span>, <span class='op'>|</span><span class='ident'>c</span><span class='op'>|</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;1&#39;</span> <span class='op'>||</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;abc&quot;</span>, <span class='string'>&quot;defXghi&quot;</span>]);</pre>
</div><h4 id='method.rsplitn' class='method'><code>fn <a href='#method.rsplitn' class='fnname'>rsplitn</a>&lt;'a, P&gt;(&amp;'a self, count: <a class='primitive' href='../primitive.usize.html'>usize</a>, pat: P) -&gt; <a class='struct' href='../../std/str/struct.RSplitN.html' title='std::str::RSplitN'>RSplitN</a>&lt;'a, P&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;, P::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a>: <a class='trait' href='../../std/str/pattern/trait.ReverseSearcher.html' title='std::str::pattern::ReverseSearcher'>ReverseSearcher</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by a pattern,
starting from the end of the string, restricted to returning
at most <code>count</code> items.</p>

<p>The last element returned, if any, will contain the remainder of the
string.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that
determines the split.
Additional libraries might provide more complex patterns like
regular expressions.</p>

<h1 id='iterator-behavior' class='section-header'><a href='#iterator-behavior'>Iterator behavior</a></h1>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>

<p><code>splitn()</code> can be used for splitting from the front.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Simple patterns:</p>
<span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;Mary had a little lamb&quot;.rsplitn(3, &#39; &#39;).collect();
    assert_eq!(v, [&quot;lamb&quot;, &quot;little&quot;, &quot;Mary had a&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;lionXXtigerXleopard&quot;.rsplitn(3, &#39;X&#39;).collect();
    assert_eq!(v, [&quot;leopard&quot;, &quot;tiger&quot;, &quot;lionX&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;lion::tiger::leopard&quot;.rsplitn(2, &quot;::&quot;).collect();
    assert_eq!(v, [&quot;leopard&quot;, &quot;lion::tiger&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;Mary had a little lamb&quot;</span>.<span class='ident'>rsplitn</span>(<span class='number'>3</span>, <span class='string'>&#39; &#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;lamb&quot;</span>, <span class='string'>&quot;little&quot;</span>, <span class='string'>&quot;Mary had a&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;lionXXtigerXleopard&quot;</span>.<span class='ident'>rsplitn</span>(<span class='number'>3</span>, <span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;leopard&quot;</span>, <span class='string'>&quot;tiger&quot;</span>, <span class='string'>&quot;lionX&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;lion::tiger::leopard&quot;</span>.<span class='ident'>rsplitn</span>(<span class='number'>2</span>, <span class='string'>&quot;::&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;leopard&quot;</span>, <span class='string'>&quot;lion::tiger&quot;</span>]);</pre>

<p>A more complex pattern, using a closure:</p>
<span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;abc1defXghi&quot;.rsplitn(2, |c| c == &#39;1&#39; || c == &#39;X&#39;).collect();
    assert_eq!(v, [&quot;ghi&quot;, &quot;abc1def&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;abc1defXghi&quot;</span>.<span class='ident'>rsplitn</span>(<span class='number'>2</span>, <span class='op'>|</span><span class='ident'>c</span><span class='op'>|</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;1&#39;</span> <span class='op'>||</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;ghi&quot;</span>, <span class='string'>&quot;abc1def&quot;</span>]);</pre>
</div><h4 id='method.matches' class='method'><code>fn <a href='#method.matches' class='fnname'>matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='struct' href='../../std/str/struct.Matches.html' title='std::str::Matches'>Matches</a>&lt;'a, P&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>An iterator over the matches of a pattern within <code>self</code>.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that
determines if a character matches.
Additional libraries might provide more complex patterns like
regular expressions.</p>

<h1 id='iterator-behavior' class='section-header'><a href='#iterator-behavior'>Iterator behavior</a></h1>
<p>The returned iterator will be double ended if the pattern allows
a reverse search
and forward/reverse search yields the same elements. This is true
for, eg, <code>char</code> but not
for <code>&amp;str</code>.</p>

<p>If the pattern allows a reverse search but its results might differ
from a forward search, <code>rmatches()</code> can be used.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;abcXXXabcYYYabc&quot;.matches(&quot;abc&quot;).collect();
    assert_eq!(v, [&quot;abc&quot;, &quot;abc&quot;, &quot;abc&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;1abc2abc3&quot;.matches(char::is_numeric).collect();
    assert_eq!(v, [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;abcXXXabcYYYabc&quot;</span>.<span class='ident'>matches</span>(<span class='string'>&quot;abc&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;abc&quot;</span>, <span class='string'>&quot;abc&quot;</span>, <span class='string'>&quot;abc&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;1abc2abc3&quot;</span>.<span class='ident'>matches</span>(<span class='ident'>char</span>::<span class='ident'>is_numeric</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;2&quot;</span>, <span class='string'>&quot;3&quot;</span>]);</pre>
</div><h4 id='method.rmatches' class='method'><code>fn <a href='#method.rmatches' class='fnname'>rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='struct' href='../../std/str/struct.RMatches.html' title='std::str::RMatches'>RMatches</a>&lt;'a, P&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;, P::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a>: <a class='trait' href='../../std/str/pattern/trait.ReverseSearcher.html' title='std::str::pattern::ReverseSearcher'>ReverseSearcher</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>An iterator over the matches of a pattern within <code>self</code>, yielded in
reverse order.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that
determines if a character matches.
Additional libraries might provide more complex patterns like
regular expressions.</p>

<h1 id='iterator-behavior' class='section-header'><a href='#iterator-behavior'>Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a
reverse search,
and it will be double ended if a forward/reverse search yields
the same elements.</p>

<p>For iterating from the front, <code>matches()</code> can be used.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let v: Vec&lt;&amp;str&gt; = &quot;abcXXXabcYYYabc&quot;.rmatches(&quot;abc&quot;).collect();
    assert_eq!(v, [&quot;abc&quot;, &quot;abc&quot;, &quot;abc&quot;]);
    
    let v: Vec&lt;&amp;str&gt; = &quot;1abc2abc3&quot;.rmatches(char::is_numeric).collect();
    assert_eq!(v, [&quot;3&quot;, &quot;2&quot;, &quot;1&quot;]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;abcXXXabcYYYabc&quot;</span>.<span class='ident'>rmatches</span>(<span class='string'>&quot;abc&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;abc&quot;</span>, <span class='string'>&quot;abc&quot;</span>, <span class='string'>&quot;abc&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;1abc2abc3&quot;</span>.<span class='ident'>rmatches</span>(<span class='ident'>char</span>::<span class='ident'>is_numeric</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [<span class='string'>&quot;3&quot;</span>, <span class='string'>&quot;2&quot;</span>, <span class='string'>&quot;1&quot;</span>]);</pre>
</div><h4 id='method.match_indices' class='method'><code>fn <a href='#method.match_indices' class='fnname'>match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='struct' href='../../std/str/struct.MatchIndices.html' title='std::str::MatchIndices'>MatchIndices</a>&lt;'a, P&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>An iterator over the disjoint matches of a pattern within <code>self</code> as well
as the index that the match starts at.</p>

<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that determines
if a character matches. Additional libraries might provide more complex
patterns like regular expressions.</p>

<h1 id='iterator-behavior' class='section-header'><a href='#iterator-behavior'>Iterator behavior</a></h1>
<p>The returned iterator will be double ended if the pattern allows a
reverse search and forward/reverse search yields the same elements. This
is true for, eg, <code>char</code> but not for <code>&amp;str</code>.</p>

<p>If the pattern allows a reverse search but its results might differ
from a forward search, <code>rmatch_indices()</code> can be used.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>#![feature(str_match_indices)]

fn main() {
    let v: Vec&lt;_&gt; = &quot;abcXXXabcYYYabc&quot;.match_indices(&quot;abc&quot;).collect();
    assert_eq!(v, [(0, &quot;abc&quot;), (6, &quot;abc&quot;), (12, &quot;abc&quot;)]);
    
    let v: Vec&lt;_&gt; = &quot;1abcabc2&quot;.match_indices(&quot;abc&quot;).collect();
    assert_eq!(v, [(1, &quot;abc&quot;), (4, &quot;abc&quot;)]);
    
    let v: Vec&lt;_&gt; = &quot;ababa&quot;.match_indices(&quot;aba&quot;).collect();
    assert_eq!(v, [(0, &quot;aba&quot;)]); // only the first `aba`
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>str_match_indices</span>)]</span>

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;abcXXXabcYYYabc&quot;</span>.<span class='ident'>match_indices</span>(<span class='string'>&quot;abc&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [(<span class='number'>0</span>, <span class='string'>&quot;abc&quot;</span>), (<span class='number'>6</span>, <span class='string'>&quot;abc&quot;</span>), (<span class='number'>12</span>, <span class='string'>&quot;abc&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;1abcabc2&quot;</span>.<span class='ident'>match_indices</span>(<span class='string'>&quot;abc&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [(<span class='number'>1</span>, <span class='string'>&quot;abc&quot;</span>), (<span class='number'>4</span>, <span class='string'>&quot;abc&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;ababa&quot;</span>.<span class='ident'>match_indices</span>(<span class='string'>&quot;aba&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [(<span class='number'>0</span>, <span class='string'>&quot;aba&quot;</span>)]); <span class='comment'>// only the first `aba`</span></pre>
</div><h4 id='method.rmatch_indices' class='method'><code>fn <a href='#method.rmatch_indices' class='fnname'>rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class='struct' href='../../std/str/struct.RMatchIndices.html' title='std::str::RMatchIndices'>RMatchIndices</a>&lt;'a, P&gt; <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;, P::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a>: <a class='trait' href='../../std/str/pattern/trait.ReverseSearcher.html' title='std::str::pattern::ReverseSearcher'>ReverseSearcher</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>An iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>

<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that determines
if a character matches. Additional libraries might provide more complex
patterns like regular expressions.</p>

<h1 id='iterator-behavior' class='section-header'><a href='#iterator-behavior'>Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be double ended if a forward/reverse search yields
the same elements.</p>

<p>For iterating from the front, <code>match_indices()</code> can be used.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>#![feature(str_match_indices)]

fn main() {
    let v: Vec&lt;_&gt; = &quot;abcXXXabcYYYabc&quot;.rmatch_indices(&quot;abc&quot;).collect();
    assert_eq!(v, [(12, &quot;abc&quot;), (6, &quot;abc&quot;), (0, &quot;abc&quot;)]);
    
    let v: Vec&lt;_&gt; = &quot;1abcabc2&quot;.rmatch_indices(&quot;abc&quot;).collect();
    assert_eq!(v, [(4, &quot;abc&quot;), (1, &quot;abc&quot;)]);
    
    let v: Vec&lt;_&gt; = &quot;ababa&quot;.rmatch_indices(&quot;aba&quot;).collect();
    assert_eq!(v, [(2, &quot;aba&quot;)]); // only the last `aba`
    
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>str_match_indices</span>)]</span>

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;abcXXXabcYYYabc&quot;</span>.<span class='ident'>rmatch_indices</span>(<span class='string'>&quot;abc&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [(<span class='number'>12</span>, <span class='string'>&quot;abc&quot;</span>), (<span class='number'>6</span>, <span class='string'>&quot;abc&quot;</span>), (<span class='number'>0</span>, <span class='string'>&quot;abc&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;1abcabc2&quot;</span>.<span class='ident'>rmatch_indices</span>(<span class='string'>&quot;abc&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [(<span class='number'>4</span>, <span class='string'>&quot;abc&quot;</span>), (<span class='number'>1</span>, <span class='string'>&quot;abc&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;ababa&quot;</span>.<span class='ident'>rmatch_indices</span>(<span class='string'>&quot;aba&quot;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, [(<span class='number'>2</span>, <span class='string'>&quot;aba&quot;</span>)]); <span class='comment'>// only the last `aba`</span></pre>
</div><h4 id='method.trim' class='method'><code>fn <a href='#method.trim' class='fnname'>trim</a>(&amp;self) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
<div class='docblock'><p>Returns a <code>&amp;str</code> with leading and trailing whitespace removed.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = &quot; Hello\tworld\t&quot;;
    assert_eq!(s.trim(), &quot;Hello\tworld&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot; Hello\tworld\t&quot;</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>trim</span>(), <span class='string'>&quot;Hello\tworld&quot;</span>);</pre>
</div><h4 id='method.trim_left' class='method'><code>fn <a href='#method.trim_left' class='fnname'>trim_left</a>(&amp;self) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
<div class='docblock'><p>Returns a <code>&amp;str</code> with leading whitespace removed.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = &quot; Hello\tworld\t&quot;;
    assert_eq!(s.trim_left(), &quot;Hello\tworld\t&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot; Hello\tworld\t&quot;</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>trim_left</span>(), <span class='string'>&quot;Hello\tworld\t&quot;</span>);</pre>
</div><h4 id='method.trim_right' class='method'><code>fn <a href='#method.trim_right' class='fnname'>trim_right</a>(&amp;self) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
<div class='docblock'><p>Returns a <code>&amp;str</code> with trailing whitespace removed.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = &quot; Hello\tworld\t&quot;;
    assert_eq!(s.trim_right(), &quot; Hello\tworld&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot; Hello\tworld\t&quot;</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>trim_right</span>(), <span class='string'>&quot; Hello\tworld&quot;</span>);</pre>
</div><h4 id='method.trim_matches' class='method'><code>fn <a href='#method.trim_matches' class='fnname'>trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class='primitive' href='../primitive.str.html'>str</a> <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;, P::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a>: <a class='trait' href='../../std/str/pattern/trait.DoubleEndedSearcher.html' title='std::str::pattern::DoubleEndedSearcher'>DoubleEndedSearcher</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>Returns a string with all pre- and suffixes that match a pattern
repeatedly removed.</p>

<p>The pattern can be a simple <code>char</code>, or a closure that determines
if a character matches.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Simple patterns:</p>
<span class='rusttest'>fn main() {
    assert_eq!(&quot;11foo1bar11&quot;.trim_matches(&#39;1&#39;), &quot;foo1bar&quot;);
    assert_eq!(&quot;123foo1bar123&quot;.trim_matches(char::is_numeric), &quot;foo1bar&quot;);
    
    let x: &amp;[_] = &amp;[&#39;1&#39;, &#39;2&#39;];
    assert_eq!(&quot;12foo1bar12&quot;.trim_matches(x), &quot;foo1bar&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;11foo1bar11&quot;</span>.<span class='ident'>trim_matches</span>(<span class='string'>&#39;1&#39;</span>), <span class='string'>&quot;foo1bar&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;123foo1bar123&quot;</span>.<span class='ident'>trim_matches</span>(<span class='ident'>char</span>::<span class='ident'>is_numeric</span>), <span class='string'>&quot;foo1bar&quot;</span>);

<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[_] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>&#39;1&#39;</span>, <span class='string'>&#39;2&#39;</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;12foo1bar12&quot;</span>.<span class='ident'>trim_matches</span>(<span class='ident'>x</span>), <span class='string'>&quot;foo1bar&quot;</span>);</pre>

<p>A more complex pattern, using a closure:</p>
<span class='rusttest'>fn main() {
    assert_eq!(&quot;1foo1barXX&quot;.trim_matches(|c| c == &#39;1&#39; || c == &#39;X&#39;), &quot;foo1bar&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;1foo1barXX&quot;</span>.<span class='ident'>trim_matches</span>(<span class='op'>|</span><span class='ident'>c</span><span class='op'>|</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;1&#39;</span> <span class='op'>||</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;X&#39;</span>), <span class='string'>&quot;foo1bar&quot;</span>);</pre>
</div><h4 id='method.trim_left_matches' class='method'><code>fn <a href='#method.trim_left_matches' class='fnname'>trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class='primitive' href='../primitive.str.html'>str</a> <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>Returns a string with all prefixes that match a pattern
repeatedly removed.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that
determines if a character matches.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    assert_eq!(&quot;11foo1bar11&quot;.trim_left_matches(&#39;1&#39;), &quot;foo1bar11&quot;);
    assert_eq!(&quot;123foo1bar123&quot;.trim_left_matches(char::is_numeric), &quot;foo1bar123&quot;);
    
    let x: &amp;[_] = &amp;[&#39;1&#39;, &#39;2&#39;];
    assert_eq!(&quot;12foo1bar12&quot;.trim_left_matches(x), &quot;foo1bar12&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;11foo1bar11&quot;</span>.<span class='ident'>trim_left_matches</span>(<span class='string'>&#39;1&#39;</span>), <span class='string'>&quot;foo1bar11&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;123foo1bar123&quot;</span>.<span class='ident'>trim_left_matches</span>(<span class='ident'>char</span>::<span class='ident'>is_numeric</span>), <span class='string'>&quot;foo1bar123&quot;</span>);

<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[_] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>&#39;1&#39;</span>, <span class='string'>&#39;2&#39;</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;12foo1bar12&quot;</span>.<span class='ident'>trim_left_matches</span>(<span class='ident'>x</span>), <span class='string'>&quot;foo1bar12&quot;</span>);</pre>
</div><h4 id='method.trim_right_matches' class='method'><code>fn <a href='#method.trim_right_matches' class='fnname'>trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class='primitive' href='../primitive.str.html'>str</a> <span class='where'>where P: <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt;, P::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a>: <a class='trait' href='../../std/str/pattern/trait.ReverseSearcher.html' title='std::str::pattern::ReverseSearcher'>ReverseSearcher</a>&lt;'a&gt;</span></code></h4>
<div class='docblock'><p>Returns a string with all suffixes that match a pattern
repeatedly removed.</p>

<p>The pattern can be a simple <code>&amp;str</code>, <code>char</code>, or a closure that
determines if a character matches.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Simple patterns:</p>
<span class='rusttest'>fn main() {
    assert_eq!(&quot;11foo1bar11&quot;.trim_right_matches(&#39;1&#39;), &quot;11foo1bar&quot;);
    assert_eq!(&quot;123foo1bar123&quot;.trim_right_matches(char::is_numeric), &quot;123foo1bar&quot;);
    
    let x: &amp;[_] = &amp;[&#39;1&#39;, &#39;2&#39;];
    assert_eq!(&quot;12foo1bar12&quot;.trim_right_matches(x), &quot;12foo1bar&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;11foo1bar11&quot;</span>.<span class='ident'>trim_right_matches</span>(<span class='string'>&#39;1&#39;</span>), <span class='string'>&quot;11foo1bar&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;123foo1bar123&quot;</span>.<span class='ident'>trim_right_matches</span>(<span class='ident'>char</span>::<span class='ident'>is_numeric</span>), <span class='string'>&quot;123foo1bar&quot;</span>);

<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[_] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>&#39;1&#39;</span>, <span class='string'>&#39;2&#39;</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;12foo1bar12&quot;</span>.<span class='ident'>trim_right_matches</span>(<span class='ident'>x</span>), <span class='string'>&quot;12foo1bar&quot;</span>);</pre>

<p>A more complex pattern, using a closure:</p>
<span class='rusttest'>fn main() {
    assert_eq!(&quot;1fooX&quot;.trim_left_matches(|c| c == &#39;1&#39; || c == &#39;X&#39;), &quot;fooX&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;1fooX&quot;</span>.<span class='ident'>trim_left_matches</span>(<span class='op'>|</span><span class='ident'>c</span><span class='op'>|</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;1&#39;</span> <span class='op'>||</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='string'>&#39;X&#39;</span>), <span class='string'>&quot;fooX&quot;</span>);</pre>
</div><h4 id='method.parse' class='method'><code>fn <a href='#method.parse' class='fnname'>parse</a>&lt;F&gt;(&amp;self) -&gt; <a class='enum' href='../../std/result/enum.Result.html' title='std::result::Result'>Result</a>&lt;F, F::<a class='trait' href='../../std/str/trait.FromStr.html' title='std::str::FromStr'>Err</a>&gt; <span class='where'>where F: <a class='trait' href='../../std/str/trait.FromStr.html' title='std::str::FromStr'>FromStr</a></span></code></h4>
<div class='docblock'><p>Parses <code>self</code> into the specified type.</p>

<h1 id='failure' class='section-header'><a href='#failure'>Failure</a></h1>
<p>Will return <code>Err</code> if it&#39;s not possible to parse <code>self</code> into the type.</p>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1><span class='rusttest'>fn main() {
    assert_eq!(&quot;4&quot;.parse::&lt;u32&gt;(), Ok(4));
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;4&quot;</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span>(), <span class='prelude-val'>Ok</span>(<span class='number'>4</span>));</pre>

<p>Failing:</p>
<span class='rusttest'>fn main() {
    assert!(&quot;j&quot;.parse::&lt;u32&gt;().is_err());
    
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='string'>&quot;j&quot;</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span>().<span class='ident'>is_err</span>());</pre>
</div><h4 id='method.replace' class='method'><code>fn <a href='#method.replace' class='fnname'>replace</a>(&amp;self, from: &amp;<a class='primitive' href='../primitive.str.html'>str</a>, to: &amp;<a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<div class='docblock'><p>Replaces all occurrences of one string with another.</p>

<p><code>replace</code> takes two arguments, a sub-<code>&amp;str</code> to find in <code>self</code>, and a
second <code>&amp;str</code> to
replace it with. If the original <code>&amp;str</code> isn&#39;t found, no change occurs.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = &quot;this is old&quot;;
    
    assert_eq!(s.replace(&quot;old&quot;, &quot;new&quot;), &quot;this is new&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;this is old&quot;</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>replace</span>(<span class='string'>&quot;old&quot;</span>, <span class='string'>&quot;new&quot;</span>), <span class='string'>&quot;this is new&quot;</span>);</pre>

<p>When a <code>&amp;str</code> isn&#39;t found:</p>
<span class='rusttest'>fn main() {
    let s = &quot;this is old&quot;;
    assert_eq!(s.replace(&quot;cookie monster&quot;, &quot;little lamb&quot;), s);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;this is old&quot;</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>replace</span>(<span class='string'>&quot;cookie monster&quot;</span>, <span class='string'>&quot;little lamb&quot;</span>), <span class='ident'>s</span>);</pre>
</div><h4 id='method.to_lowercase' class='method'><code>fn <a href='#method.to_lowercase' class='fnname'>to_lowercase</a>(&amp;self) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<div class='docblock'><p>Returns the lowercase equivalent of this string.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = &quot;HELLO&quot;;
    assert_eq!(s.to_lowercase(), &quot;hello&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;HELLO&quot;</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>to_lowercase</span>(), <span class='string'>&quot;hello&quot;</span>);</pre>
</div><h4 id='method.to_uppercase' class='method'><code>fn <a href='#method.to_uppercase' class='fnname'>to_uppercase</a>(&amp;self) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<div class='docblock'><p>Returns the uppercase equivalent of this string.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = &quot;hello&quot;;
    assert_eq!(s.to_uppercase(), &quot;HELLO&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>;
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>to_uppercase</span>(), <span class='string'>&quot;HELLO&quot;</span>);</pre>
</div><h4 id='method.escape_default' class='method'><code>fn <a href='#method.escape_default' class='fnname'>escape_default</a>(&amp;self) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>str_escape</code> <a href="https://github.com/rust-lang/rust/issues/27791">#27791</a>)<p>: return type may change to be an iterator</p>
</em></div><div class='docblock'><p>Escapes each char in <code>s</code> with <code>char::escape_default</code>.</p>
</div><h4 id='method.escape_unicode' class='method'><code>fn <a href='#method.escape_unicode' class='fnname'>escape_unicode</a>(&amp;self) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>str_escape</code> <a href="https://github.com/rust-lang/rust/issues/27791">#27791</a>)<p>: return type may change to be an iterator</p>
</em></div><div class='docblock'><p>Escapes each char in <code>s</code> with <code>char::escape_unicode</code>.</p>
</div><h4 id='method.into_string' class='method'><code>fn <a href='#method.into_string' class='fnname'>into_string</a>(self: <a class='struct' href='../../std/boxed/struct.Box.html' title='std::boxed::Box'>Box</a>&lt;<a class='primitive' href='../primitive.str.html'>str</a>&gt;) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<div class='docblock'><p>Converts the <code>Box&lt;str&gt;</code> into a <code>String</code> without copying or allocating.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl <a class='trait' href='../../std/borrow/trait.Borrow.html' title='std::borrow::Borrow'>Borrow</a>&lt;<a class='primitive' href='../primitive.str.html'>str</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.borrow' class='method'><code>fn <a href='../../std/borrow/trait.Borrow.html#method.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a> for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.clone' class='method'><code>fn <a href='../../std/clone/trait.Clone.html#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<h4 id='method.clone_from' class='method'><code>fn <a href='../../std/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>)</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/iter/trait.FromIterator.html' title='std::iter::FromIterator'>FromIterator</a>&lt;<a class='primitive' href='../primitive.char.html'>char</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.from_iter' class='method'><code>fn <a href='../../std/iter/trait.FromIterator.html#method.from_iter' class='fnname'>from_iter</a>&lt;I&gt;(iterable: I) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a> <span class='where'>where I: <a class='trait' href='../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a class='primitive' href='../primitive.char.html'>char</a>&gt;</span></code></h4>
</div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../std/iter/trait.FromIterator.html' title='std::iter::FromIterator'>FromIterator</a>&lt;&amp;'a <a class='primitive' href='../primitive.str.html'>str</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.from_iter' class='method'><code>fn <a href='../../std/iter/trait.FromIterator.html#method.from_iter' class='fnname'>from_iter</a>&lt;I&gt;(iterable: I) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a> <span class='where'>where I: <a class='trait' href='../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a>&lt;Item=&amp;'a <a class='primitive' href='../primitive.str.html'>str</a>&gt;</span></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/iter/trait.FromIterator.html' title='std::iter::FromIterator'>FromIterator</a>&lt;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.from_iter' class='method'><code>fn <a href='../../std/iter/trait.FromIterator.html#method.from_iter' class='fnname'>from_iter</a>&lt;I&gt;(iterable: I) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a> <span class='where'>where I: <a class='trait' href='../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>&gt;</span></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/iter/trait.Extend.html' title='std::iter::Extend'>Extend</a>&lt;<a class='primitive' href='../primitive.char.html'>char</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.extend' class='method'><code>fn <a href='../../std/iter/trait.Extend.html#method.extend' class='fnname'>extend</a>&lt;I&gt;(&amp;mut self, iterable: I) <span class='where'>where I: <a class='trait' href='../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a class='primitive' href='../primitive.char.html'>char</a>&gt;</span></code></h4>
</div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../std/iter/trait.Extend.html' title='std::iter::Extend'>Extend</a>&lt;&amp;'a <a class='primitive' href='../primitive.char.html'>char</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.extend' class='method'><code>fn <a href='../../std/iter/trait.Extend.html#method.extend' class='fnname'>extend</a>&lt;I&gt;(&amp;mut self, iterable: I) <span class='where'>where I: <a class='trait' href='../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a>&lt;Item=&amp;'a <a class='primitive' href='../primitive.char.html'>char</a>&gt;</span></code></h4>
</div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../std/iter/trait.Extend.html' title='std::iter::Extend'>Extend</a>&lt;&amp;'a <a class='primitive' href='../primitive.str.html'>str</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.extend' class='method'><code>fn <a href='../../std/iter/trait.Extend.html#method.extend' class='fnname'>extend</a>&lt;I&gt;(&amp;mut self, iterable: I) <span class='where'>where I: <a class='trait' href='../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a>&lt;Item=&amp;'a <a class='primitive' href='../primitive.str.html'>str</a>&gt;</span></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/iter/trait.Extend.html' title='std::iter::Extend'>Extend</a>&lt;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.extend' class='method'><code>fn <a href='../../std/iter/trait.Extend.html#method.extend' class='fnname'>extend</a>&lt;I&gt;(&amp;mut self, iterable: I) <span class='where'>where I: <a class='trait' href='../../std/iter/trait.IntoIterator.html' title='std::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>&gt;</span></code></h4>
</div><h3 class='impl'><code>impl&lt;'a, 'b&gt; <a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Pattern</a>&lt;'a&gt; for &amp;'b <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='docblock'><p>A convenience impl that delegates to the impl for <code>&amp;str</code></p>
</div><div class='impl-items'><h4 id='assoc_type.Searcher' class='type'><code>type Searcher = &amp;'b <a class='primitive' href='../primitive.str.html'>str</a>::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a></code></h4>
<h4 id='method.into_searcher' class='method'><code>fn <a href='../../std/str/pattern/trait.Pattern.html#method.into_searcher' class='fnname'>into_searcher</a>(self, haystack: &amp;'a <a class='primitive' href='../primitive.str.html'>str</a>) -&gt; &amp;'b <a class='primitive' href='../primitive.str.html'>str</a>::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a></code></h4>
<h4 id='method.is_contained_in' class='method'><code>fn <a href='../../std/str/pattern/trait.Pattern.html#method.is_contained_in' class='fnname'>is_contained_in</a>(self, haystack: &amp;'a <a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.is_prefix_of' class='method'><code>fn <a href='../../std/str/pattern/trait.Pattern.html#method.is_prefix_of' class='fnname'>is_prefix_of</a>(self, haystack: &amp;'a <a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.is_suffix_of' class='method'><code>fn <a href='../../std/str/pattern/trait.Pattern.html#method.is_suffix_of' class='fnname'>is_suffix_of</a>(self, haystack: &amp;'a <a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a> <span class='where'>where Self::<a class='trait' href='../../std/str/pattern/trait.Pattern.html' title='std::str::pattern::Pattern'>Searcher</a>: <a class='trait' href='../../std/str/pattern/trait.ReverseSearcher.html' title='std::str::pattern::ReverseSearcher'>ReverseSearcher</a>&lt;'a&gt;</span></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/cmp/trait.PartialEq.html' title='std::cmp::PartialEq'>PartialEq</a>&lt;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.eq' class='method'><code>fn <a href='../../std/cmp/trait.PartialEq.html#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ne' class='method'><code>fn <a href='../../std/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><code>impl&lt;'a, 'b&gt; <a class='trait' href='../../std/cmp/trait.PartialEq.html' title='std::cmp::PartialEq'>PartialEq</a>&lt;<a class='primitive' href='../primitive.str.html'>str</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.eq' class='method'><code>fn <a href='../../std/cmp/trait.PartialEq.html#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ne' class='method'><code>fn <a href='../../std/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;<a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><code>impl&lt;'a, 'b&gt; <a class='trait' href='../../std/cmp/trait.PartialEq.html' title='std::cmp::PartialEq'>PartialEq</a>&lt;&amp;'a <a class='primitive' href='../primitive.str.html'>str</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.eq' class='method'><code>fn <a href='../../std/cmp/trait.PartialEq.html#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;&amp;'a <a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ne' class='method'><code>fn <a href='../../std/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;&amp;'a <a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><code>impl&lt;'a, 'b&gt; <a class='trait' href='../../std/cmp/trait.PartialEq.html' title='std::cmp::PartialEq'>PartialEq</a>&lt;<a class='enum' href='../../std/borrow/enum.Cow.html' title='std::borrow::Cow'>Cow</a>&lt;'a, <a class='primitive' href='../primitive.str.html'>str</a>&gt;&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.eq' class='method'><code>fn <a href='../../std/cmp/trait.PartialEq.html#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class='enum' href='../../std/borrow/enum.Cow.html' title='std::borrow::Cow'>Cow</a>&lt;'a, <a class='primitive' href='../primitive.str.html'>str</a>&gt;) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ne' class='method'><code>fn <a href='../../std/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;<a class='enum' href='../../std/borrow/enum.Cow.html' title='std::borrow::Cow'>Cow</a>&lt;'a, <a class='primitive' href='../primitive.str.html'>str</a>&gt;) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/default/trait.Default.html' title='std::default::Default'>Default</a> for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.default' class='method'><code>fn <a href='../../std/default/trait.Default.html#method.default' class='fnname'>default</a>() -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/fmt/trait.Display.html' title='std::fmt::Display'>Display</a> for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='../../std/fmt/trait.Display.html#method.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class='struct' href='../../std/fmt/struct.Formatter.html' title='std::fmt::Formatter'>Formatter</a>) -&gt; <a class='enum' href='../../std/result/enum.Result.html' title='std::result::Result'>Result</a>&lt;<a class='primitive' href='../primitive.tuple.html'>()</a>, <a class='struct' href='../../std/fmt/struct.Error.html' title='std::fmt::Error'>Error</a>&gt;</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/fmt/trait.Debug.html' title='std::fmt::Debug'>Debug</a> for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='../../std/fmt/trait.Debug.html#method.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class='struct' href='../../std/fmt/struct.Formatter.html' title='std::fmt::Formatter'>Formatter</a>) -&gt; <a class='enum' href='../../std/result/enum.Result.html' title='std::result::Result'>Result</a>&lt;<a class='primitive' href='../primitive.tuple.html'>()</a>, <a class='struct' href='../../std/fmt/struct.Error.html' title='std::fmt::Error'>Error</a>&gt;</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a> for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.hash' class='method'><code>fn <a href='../../std/hash/trait.Hash.html#method.hash' class='fnname'>hash</a>&lt;H&gt;(&amp;self, hasher: &amp;mut H) <span class='where'>where H: <a class='trait' href='../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a></span></code></h4>
<h4 id='method.hash_slice' class='method'><code>fn <a href='../../std/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: <a class='primitive' href='../primitive.slice.html'>&amp;[Self]</a>, state: &amp;mut H) <span class='where'>where H: <a class='trait' href='../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a></span></code></h4>
</div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../std/ops/trait.Add.html' title='std::ops::Add'>Add</a>&lt;&amp;'a <a class='primitive' href='../primitive.str.html'>str</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Output' class='type'><code>type Output = <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
<h4 id='method.add' class='method'><code>fn <a href='../../std/ops/trait.Add.html#method.add' class='fnname'>add</a>(self, other: &amp;<a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/ops/trait.Index.html' title='std::ops::Index'>Index</a>&lt;<a class='struct' href='../../std/ops/struct.Range.html' title='std::ops::Range'>Range</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Output' class='type'><code>type Output = <a class='primitive' href='../primitive.str.html'>str</a></code></h4>
<h4 id='method.index' class='method'><code>fn <a href='../../std/ops/trait.Index.html#method.index' class='fnname'>index</a>(&amp;self, index: <a class='struct' href='../../std/ops/struct.Range.html' title='std::ops::Range'>Range</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/ops/trait.Index.html' title='std::ops::Index'>Index</a>&lt;<a class='struct' href='../../std/ops/struct.RangeTo.html' title='std::ops::RangeTo'>RangeTo</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Output' class='type'><code>type Output = <a class='primitive' href='../primitive.str.html'>str</a></code></h4>
<h4 id='method.index' class='method'><code>fn <a href='../../std/ops/trait.Index.html#method.index' class='fnname'>index</a>(&amp;self, index: <a class='struct' href='../../std/ops/struct.RangeTo.html' title='std::ops::RangeTo'>RangeTo</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/ops/trait.Index.html' title='std::ops::Index'>Index</a>&lt;<a class='struct' href='../../std/ops/struct.RangeFrom.html' title='std::ops::RangeFrom'>RangeFrom</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Output' class='type'><code>type Output = <a class='primitive' href='../primitive.str.html'>str</a></code></h4>
<h4 id='method.index' class='method'><code>fn <a href='../../std/ops/trait.Index.html#method.index' class='fnname'>index</a>(&amp;self, index: <a class='struct' href='../../std/ops/struct.RangeFrom.html' title='std::ops::RangeFrom'>RangeFrom</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/ops/trait.Index.html' title='std::ops::Index'>Index</a>&lt;<a class='struct' href='../../std/ops/struct.RangeFull.html' title='std::ops::RangeFull'>RangeFull</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Output' class='type'><code>type Output = <a class='primitive' href='../primitive.str.html'>str</a></code></h4>
<h4 id='method.index' class='method'><code>fn <a href='../../std/ops/trait.Index.html#method.index' class='fnname'>index</a>(&amp;self, _index: <a class='struct' href='../../std/ops/struct.RangeFull.html' title='std::ops::RangeFull'>RangeFull</a>) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/ops/trait.IndexMut.html' title='std::ops::IndexMut'>IndexMut</a>&lt;<a class='struct' href='../../std/ops/struct.Range.html' title='std::ops::Range'>Range</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.index_mut' class='method'><code>fn <a href='../../std/ops/trait.IndexMut.html#method.index_mut' class='fnname'>index_mut</a>(&amp;mut self, index: <a class='struct' href='../../std/ops/struct.Range.html' title='std::ops::Range'>Range</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;) -&gt; &amp;mut <a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/ops/trait.IndexMut.html' title='std::ops::IndexMut'>IndexMut</a>&lt;<a class='struct' href='../../std/ops/struct.RangeTo.html' title='std::ops::RangeTo'>RangeTo</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.index_mut' class='method'><code>fn <a href='../../std/ops/trait.IndexMut.html#method.index_mut' class='fnname'>index_mut</a>(&amp;mut self, index: <a class='struct' href='../../std/ops/struct.RangeTo.html' title='std::ops::RangeTo'>RangeTo</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;) -&gt; &amp;mut <a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/ops/trait.IndexMut.html' title='std::ops::IndexMut'>IndexMut</a>&lt;<a class='struct' href='../../std/ops/struct.RangeFrom.html' title='std::ops::RangeFrom'>RangeFrom</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.index_mut' class='method'><code>fn <a href='../../std/ops/trait.IndexMut.html#method.index_mut' class='fnname'>index_mut</a>(&amp;mut self, index: <a class='struct' href='../../std/ops/struct.RangeFrom.html' title='std::ops::RangeFrom'>RangeFrom</a>&lt;<a class='primitive' href='../primitive.usize.html'>usize</a>&gt;) -&gt; &amp;mut <a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/ops/trait.IndexMut.html' title='std::ops::IndexMut'>IndexMut</a>&lt;<a class='struct' href='../../std/ops/struct.RangeFull.html' title='std::ops::RangeFull'>RangeFull</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.index_mut' class='method'><code>fn <a href='../../std/ops/trait.IndexMut.html#method.index_mut' class='fnname'>index_mut</a>(&amp;mut self, _index: <a class='struct' href='../../std/ops/struct.RangeFull.html' title='std::ops::RangeFull'>RangeFull</a>) -&gt; &amp;mut <a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/ops/trait.Deref.html' title='std::ops::Deref'>Deref</a> for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Target' class='type'><code>type Target = <a class='primitive' href='../primitive.str.html'>str</a></code></h4>
<h4 id='method.deref' class='method'><code>fn <a href='../../std/ops/trait.Deref.html#method.deref' class='fnname'>deref</a>(&amp;self) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/ops/trait.DerefMut.html' title='std::ops::DerefMut'>DerefMut</a> for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.deref_mut' class='method'><code>fn <a href='../../std/ops/trait.DerefMut.html#method.deref_mut' class='fnname'>deref_mut</a>(&amp;mut self) -&gt; &amp;mut <a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/str/trait.FromStr.html' title='std::str::FromStr'>FromStr</a> for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Err' class='type'><code>type Err = <a class='enum' href='../../std/string/enum.ParseError.html' title='std::string::ParseError'>ParseError</a></code></h4>
<h4 id='method.from_str' class='method'><code>fn <a href='../../std/str/trait.FromStr.html#method.from_str' class='fnname'>from_str</a>(s: &amp;<a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='enum' href='../../std/result/enum.Result.html' title='std::result::Result'>Result</a>&lt;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>, <a class='enum' href='../../std/string/enum.ParseError.html' title='std::string::ParseError'>ParseError</a>&gt;</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/convert/trait.AsRef.html' title='std::convert::AsRef'>AsRef</a>&lt;<a class='primitive' href='../primitive.str.html'>str</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.as_ref' class='method'><code>fn <a href='../../std/convert/trait.AsRef.html#method.as_ref' class='fnname'>as_ref</a>(&amp;self) -&gt; &amp;<a class='primitive' href='../primitive.str.html'>str</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/convert/trait.AsRef.html' title='std::convert::AsRef'>AsRef</a>&lt;<a class='primitive' href='../primitive.slice.html'>[<a class='primitive' href='../primitive.u8.html'>u8</a>]</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.as_ref' class='method'><code>fn <a href='../../std/convert/trait.AsRef.html#method.as_ref' class='fnname'>as_ref</a>(&amp;self) -&gt; <a class='primitive' href='../primitive.slice.html'>&amp;[</a><a class='primitive' href='../primitive.u8.html'>u8</a><a class='primitive' href='../primitive.slice.html'>]</a></code></h4>
</div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../std/convert/trait.From.html' title='std::convert::From'>From</a>&lt;&amp;'a <a class='primitive' href='../primitive.str.html'>str</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.from' class='method'><code>fn <a href='../../std/convert/trait.From.html#method.from' class='fnname'>from</a>(s: &amp;'a <a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/convert/trait.Into.html' title='std::convert::Into'>Into</a>&lt;<a class='struct' href='../../std/vec/struct.Vec.html' title='std::vec::Vec'>Vec</a>&lt;<a class='primitive' href='../primitive.u8.html'>u8</a>&gt;&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.into' class='method'><code>fn <a href='../../std/convert/trait.Into.html#method.into' class='fnname'>into</a>(self) -&gt; <a class='struct' href='../../std/vec/struct.Vec.html' title='std::vec::Vec'>Vec</a>&lt;<a class='primitive' href='../primitive.u8.html'>u8</a>&gt;</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/borrow/trait.IntoCow.html' title='std::borrow::IntoCow'>IntoCow</a>&lt;'static, <a class='primitive' href='../primitive.str.html'>str</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.into_cow' class='method'><code>fn <a href='../../std/borrow/trait.IntoCow.html#method.into_cow' class='fnname'>into_cow</a>(self) -&gt; <a class='enum' href='../../std/borrow/enum.Cow.html' title='std::borrow::Cow'>Cow</a>&lt;'static, <a class='primitive' href='../primitive.str.html'>str</a>&gt;</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/fmt/trait.Write.html' title='std::fmt::Write'>Write</a> for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.write_str' class='method'><code>fn <a href='../../std/fmt/trait.Write.html#method.write_str' class='fnname'>write_str</a>(&amp;mut self, s: &amp;<a class='primitive' href='../primitive.str.html'>str</a>) -&gt; <a class='enum' href='../../std/result/enum.Result.html' title='std::result::Result'>Result</a>&lt;<a class='primitive' href='../primitive.tuple.html'>()</a>, <a class='struct' href='../../std/fmt/struct.Error.html' title='std::fmt::Error'>Error</a>&gt;</code></h4>
<h4 id='method.write_char' class='method'><code>fn <a href='../../std/fmt/trait.Write.html#method.write_char' class='fnname'>write_char</a>(&amp;mut self, c: <a class='primitive' href='../primitive.char.html'>char</a>) -&gt; <a class='enum' href='../../std/result/enum.Result.html' title='std::result::Result'>Result</a>&lt;<a class='primitive' href='../primitive.tuple.html'>()</a>, <a class='struct' href='../../std/fmt/struct.Error.html' title='std::fmt::Error'>Error</a>&gt;</code></h4>
<h4 id='method.write_fmt' class='method'><code>fn <a href='../../std/fmt/trait.Write.html#method.write_fmt' class='fnname'>write_fmt</a>(&amp;mut self, args: <a class='struct' href='../../std/fmt/struct.Arguments.html' title='std::fmt::Arguments'>Arguments</a>) -&gt; <a class='enum' href='../../std/result/enum.Result.html' title='std::result::Result'>Result</a>&lt;<a class='primitive' href='../primitive.tuple.html'>()</a>, <a class='struct' href='../../std/fmt/struct.Error.html' title='std::fmt::Error'>Error</a>&gt;</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/convert/trait.AsRef.html' title='std::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='../../std/ffi/struct.OsStr.html' title='std::ffi::OsStr'>OsStr</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.as_ref' class='method'><code>fn <a href='../../std/convert/trait.AsRef.html#method.as_ref' class='fnname'>as_ref</a>(&amp;self) -&gt; &amp;<a class='struct' href='../../std/ffi/struct.OsStr.html' title='std::ffi::OsStr'>OsStr</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/convert/trait.AsRef.html' title='std::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='../../std/path/struct.Path.html' title='std::path::Path'>Path</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.as_ref' class='method'><code>fn <a href='../../std/convert/trait.AsRef.html#method.as_ref' class='fnname'>as_ref</a>(&amp;self) -&gt; &amp;<a class='struct' href='../../std/path/struct.Path.html' title='std::path::Path'>Path</a></code></h4>
</div><h3 id='derived_implementations'>Derived Implementations </h3><h3 class='impl'><code>impl <a class='trait' href='../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a> for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.cmp' class='method'><code>fn <a href='../../std/cmp/trait.Ord.html#method.cmp' class='fnname'>cmp</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>) -&gt; <a class='enum' href='../../std/cmp/enum.Ordering.html' title='std::cmp::Ordering'>Ordering</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'></div><h3 class='impl'><code>impl <a class='trait' href='../../std/cmp/trait.PartialOrd.html' title='std::cmp::PartialOrd'>PartialOrd</a>&lt;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>&gt; for <a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.partial_cmp' class='method'><code>fn <a href='../../std/cmp/trait.PartialOrd.html#method.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='enum' href='../../std/cmp/enum.Ordering.html' title='std::cmp::Ordering'>Ordering</a>&gt;</code></h4>
<h4 id='method.lt' class='method'><code>fn <a href='../../std/cmp/trait.PartialOrd.html#method.lt' class='fnname'>lt</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.le' class='method'><code>fn <a href='../../std/cmp/trait.PartialOrd.html#method.le' class='fnname'>le</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.gt' class='method'><code>fn <a href='../../std/cmp/trait.PartialOrd.html#method.gt' class='fnname'>gt</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ge' class='method'><code>fn <a href='../../std/cmp/trait.PartialOrd.html#method.ge' class='fnname'>ge</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../std/string/struct.String.html' title='std::string::String'>String</a>) -&gt; <a class='primitive' href='../primitive.bool.html'>bool</a></code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "std";
        window.playgroundUrl = "https://play.rust-lang.org/";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script src="../../playpen.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>