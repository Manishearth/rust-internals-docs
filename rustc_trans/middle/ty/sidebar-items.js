initSidebarItems({"constant":[["INITIAL_DISCRIMINANT_VALUE",""]],"enum":[["AdtKind",""],["BorrowKind",""],["ClosureKind",""],["DtorKind",""],["ExplicitSelfCategory","The category of explicit self."],["FragmentInfo","Describes the fragment-state associated with a NodeId."],["ImplOrTraitItem",""],["ImplOrTraitItemContainer",""],["ImplOrTraitItemId",""],["IntVarValue",""],["LvaluePreference",""],["ObjectLifetimeDefault","Default region to use for the bound of objects that are supplied as the value for this type parameter. This is derived from `T:'a` annotations appearing in the type definition.  If this is `None`, then the default is inherited from the surrounding context. See RFC #599 for details."],["Predicate",""],["UpvarCapture","Information describing the capture of an upvar. This is computed during `typeck`, specifically by `regionck`."],["Variance",""],["VariantKind",""]],"mod":[["_match",""],["adjustment",""],["cast",""],["error",""],["fast_reject",""],["fold","Generalized type folding mechanism. The setup is a bit convoluted but allows for convenient usage. Let T be an instance of some \"foldable type\" (one which implements `TypeFoldable`) and F be an instance of a \"folder\" (a type which implements `TypeFolder`). Then the setup is intended to be:"],["maps",""],["outlives",""],["relate","Generalized type relating mechanism. A type relation R relates a pair of values (A, B). A and B are usually types or regions but can be other things. Examples of type relations are subtyping, type equality, etc."],["trait_def",""],["util","misc. type-system utilities too small to deserve their own file"],["walk","An iterator over the type substructure. WARNING: this does not keep track of the region depth."],["wf",""]],"struct":[["AdtDefData","The definition of an abstract data type - a struct or enum."],["AdtFlags",""],["AssociatedConst",""],["AssociatedType",""],["CReaderCacheKey",""],["ClosureUpvar",""],["CrateAnalysis","The complete set of all analyses described in this module. This is produced by the driver and fed to trans and later passes."],["EquatePredicate",""],["FieldDefData",""],["Freevar","A free variable referred to in a function."],["GenericPredicates","Bounds on generics."],["Generics","Information about the formal type/lifetime parameters associated with an item or method. Analogous to hir::Generics."],["InstantiatedPredicates","Represents the bounds declared on a particular set of type parameters.  Should eventually be generalized into a flag list of where clauses.  You can obtain a `InstantiatedPredicates` list from a `GenericPredicates` by using the `instantiate` method. Note that this method reflects an important semantic invariant of `InstantiatedPredicates`: while the `GenericPredicates` are expressed in terms of the bound type parameters of the impl/trait/whatever, an `InstantiatedPredicates` instance represented a set of bounds for some particular instantiation, meaning that the generic parameters have been substituted with their values."],["ItemSubsts","Records the substitutions used to translate the polytype for an item into the monotype of an item reference."],["ItemVariances",""],["Method",""],["MethodCall","With method calls, we store some extra information in side tables (i.e method_map). We use MethodCall as a key to index into these tables instead of just directly using the expression's NodeId. The reason for this being that we may apply adjustments (coercions) with the resulting expression also needing to use the side tables. The problem with this is that we don't assign a separate NodeId to this new expression and so it would clash with the base expression if both needed to add to the side tables. Thus to disambiguate we also keep track of whether there's an adjustment in our key."],["MethodCallee",""],["OutlivesPredicate",""],["ParameterEnvironment","When type checking, we use the `ParameterEnvironment` to track details about the type/lifetime parameters that are in scope. It primarily stores the bounds information."],["ProjectionPredicate","This kind of predicate has no *direct* correspondent in the syntax, but it roughly corresponds to the syntactic forms:"],["RegionParameterDef",""],["TraitPredicate",""],["TransmuteRestriction","A restriction that certain types must be the same size. The use of `transmute` gives rise to these restrictions. These generally cannot be checked until trans; therefore, each call to `transmute` will push one or more such restriction into the `transmute_restrictions` vector during `intrinsicck`. They are then checked during `trans` by the fn `check_intrinsics`."],["TyS",""],["TypeFlags",""],["TypeParameterDef",""],["TypeScheme","A \"type scheme\", in ML terminology, is a type combined with some set of generic types that the type is, well, generic over. In Rust terms, it is the \"type\" of a fn item or struct -- this type will include various generic parameters that must be substituted when the item/struct is referenced. That is called converting the type scheme to a monotype."],["UpvarBorrow",""],["UpvarId","Upvars do not get their own node-id. Instead, we use the pair of the original var id (that is, the root variable that is referenced by the upvar) and the id of the closure expression."],["VariantDefData",""]],"trait":[["HasTypeFlags",""],["RegionEscape","An \"escaping region\" is a bound region whose binder is not part of `t`."],["ToPolyTraitRef",""],["ToPredicate",""]],"type":[["AdtDef",""],["AdtDefMaster",""],["CaptureModeMap",""],["Disr",""],["FieldDef",""],["FieldDefMaster",""],["FreevarMap",""],["GlobMap",""],["MethodMap",""],["PolyEquatePredicate",""],["PolyOutlivesPredicate",""],["PolyProjectionPredicate",""],["PolyRegionOutlivesPredicate",""],["PolyTraitPredicate",""],["PolyTypeOutlivesPredicate",""],["TraitMap",""],["Ty",""],["UpvarCaptureMap",""],["VariantDef",""],["VariantDefMaster",""]]});