initSidebarItems({"constant":[["INITIAL_DISCRIMINANT_VALUE",""]],"enum":[["AdtKind",""],["BorrowKind",""],["BoundRegion",""],["BuiltinBound",""],["ClosureKind",""],["DtorKind",""],["ExplicitSelfCategory","The category of explicit self."],["FnOutput",""],["FragmentInfo","Describes the fragment-state associated with a NodeId.Currently only unfragmented paths have entries in the table, but longer-term this enum is expected to expand to also include data for fragmented paths."],["ImplOrTraitItem",""],["ImplOrTraitItemContainer",""],["ImplOrTraitItemId",""],["InferTy",""],["IntVarValue",""],["LvaluePreference",""],["ObjectLifetimeDefault","Default region to use for the bound of objects that are supplied as the value for this type parameter. This is derived from `T:'a` annotations appearing in the type definition.  If this is `None`, then the default is inherited from the surrounding context. See RFC #599 for details."],["Predicate",""],["Region","Representation of regions.Unlike types, most region variants are \"fictitious\", not concrete, regions. Among these, `ReStatic`, `ReEmpty` and `ReScope` are the only ones representing concrete regions.Bound RegionsThese are regions that are stored behind a binder and must be substituted with some concrete region before being used. There are 2 kind of bound regions: early-bound, which are bound in a TypeScheme/TraitDef, and are substituted by a Substs,  and late-bound, which are part of higher-ranked types (e.g. `for<'a> fn(&'a ())`) and are substituted by the likes of `liberate_late_bound_regions`. The distinction exists because higher-ranked lifetimes aren't supported in all places. See [1][2].Unlike TyParam-s, bound regions are not supposed to exist \"in the wild\" outside their binder, e.g. in types passed to type inference, and should first be substituted (by skolemized regions, free regions, or region variables).Skolemized and Free RegionsOne often wants to work with bound regions without knowing their precise identity. For example, when checking a function, the lifetime of a borrow can end up being assigned to some region parameter. In these cases, it must be ensured that bounds on the region can't be accidentally assumed without being checked.The process of doing that is called \"skolemization\". The bound regions are replaced by skolemized markers, which don't satisfy any relation not explicity provided.There are 2 kinds of skolemized regions in rustc: `ReFree` and `ReSkolemized`. When checking an item's body, `ReFree` is supposed to be used. These also support explicit bounds: both the internally-stored *scope*, which the region is assumed to outlive, as well as other relations stored in the `FreeRegionMap`. Note that these relations aren't checked when you `make_subregion` (or `mk_eqty`), only by `resolve_regions_and_report_errors`.When working with higher-ranked types, some region relations aren't yet known, so you can't just call `resolve_regions_and_report_errors`. `ReSkolemized` is designed for this purpose. In these contexts, there's also the risk that some inference variable laying around will get unified with your skolemized region: if you want to check whether `for<'a> Foo<'_>: 'a`, and you substitute your bound region `'a` with a skolemized region `'%a`, the variable `'_` would just be instantiated to the skolemized region `'%a`, which is wrong because the inference variable is supposed to satisfy the relation *for every value of the skolemized region*. To ensure that doesn't happen, you can use `leak_check`. This is more clearly explained by infer/higher_ranked/README.md.[1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/ [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/"],["TypeVariants",""],["UpvarCapture","Information describing the capture of an upvar. This is computed during `typeck`, specifically by `regionck`."],["Variance",""],["VariantKind",""]],"mod":[["_match",""],["adjustment",""],["cast",""],["error",""],["fast_reject",""],["fold","Generalized type folding mechanism. The setup is a bit convoluted but allows for convenient usage. Let T be an instance of some \"foldable type\" (one which implements `TypeFoldable`) and F be an instance of a \"folder\" (a type which implements `TypeFolder`). Then the setup is intended to be:  T.fold_with(F) --calls--> F.fold_T(T) --calls--> T.super_fold_with(F)This way, when you define a new folder F, you can override `fold_T()` to customize the behavior, and invoke `T.super_fold_with()` to get the original behavior. Meanwhile, to actually fold something, you can just write `T.fold_with(F)`, which is convenient. (Note that `fold_with` will also transparently handle things like a `Vec<T>` where T is foldable and so on.)In this ideal setup, the only function that actually *does* anything is `T.super_fold_with()`, which traverses the type `T`. Moreover, `T.super_fold_with()` should only ever call `T.fold_with()`.In some cases, we follow a degenerate pattern where we do not have a `fold_T` method. Instead, `T.fold_with` traverses the structure directly. This is suboptimal because the behavior cannot be overridden, but it's much less work to implement. If you ever *do* need an override that doesn't exist, it's not hard to convert the degenerate pattern into the proper thing.A `TypeFoldable` T can also be visited by a `TypeVisitor` V using similar setup:   T.visit_with(V) --calls--> V.visit_T(T) --calls--> T.super_visit_with(V). These methods return true to indicate that the visitor has found what it is looking for and does not need to visit anything else."],["maps",""],["outlives",""],["relate","Generalized type relating mechanism. A type relation R relates a pair of values (A, B). A and B are usually types or regions but can be other things. Examples of type relations are subtyping, type equality, etc."],["tls",""],["trait_def",""],["util","misc. type-system utilities too small to deserve their own file"],["walk","An iterator over the type substructure. WARNING: this does not keep track of the region depth."],["wf",""]],"struct":[["AdtDefData","The definition of an abstract data type - a struct or enum.These are all interned (by intern_adt_def) into the adt_defs table.Because of the possibility of nested tcx-s, this type needs 2 lifetimes: the traditional variant lifetime ('tcx) bounding the lifetime of the inner types is of course necessary. However, it is not sufficient - types from a child tcx must not be leaked into the master tcx by being stored in an AdtDefData.The 'container lifetime ensures that by outliving the container tcx and preventing shorter-lived types from being inserted. When write access is not needed, the 'container lifetime can be erased to 'static, which can be done by the AdtDef wrapper."],["AdtFlags",""],["AssociatedConst",""],["AssociatedType",""],["BareFnTy",""],["Binder","Binder is a binder for higher-ranked lifetimes. It is part of the compiler's representation for things like `for<'a> Fn(&'a isize)` (which would be represented by the type `PolyTraitRef == Binder<TraitRef>`). Note that when we skolemize, instantiate, erase, or otherwise \"discharge\" these bound regions, we change the type from `Binder<T>` to just `T` (see e.g. `liberate_late_bound_regions`)."],["BuiltinBounds",""],["CReaderCacheKey",""],["ClosureSubsts","A closure can be modeled as a struct that looks like:where 'l0...'li and T0...Tj are the lifetime and type parameters in scope on the function that defined the closure, and U0...Uk are type parameters representing the types of its upvars (borrowed, if appropriate).So, for example, given this function:the type of the closure would be something like:Note that the type of the upvar is not specified in the struct. You may wonder how the impl would then be able to use the upvar, if it doesn't know it's type? The answer is that the impl is (conceptually) not fully generic over Closure but rather tied to instances with the expected upvar types:You can see that the *impl* fully specified the type of the upvar and thus knows full well that `data` has type `&'b mut &'a mut T`. (Here, I am assuming that `data` is mut-borrowed.)Now, the last question you may ask is: Why include the upvar types as extra type parameters? The reason for this design is that the upvar types can reference lifetimes that are internal to the creating function. In my example above, for example, the lifetime `'b` represents the extent of the closure itself; this is some subset of `foo`, probably just the extent of the call to the to `do()`. If we just had the lifetime/type parameters from the enclosing function, we couldn't name this lifetime `'b`. Note that there can also be lifetimes in the types of the upvars themselves, if one of them happens to be a reference to something that the creating fn owns.OK, you say, so why not create a more minimal set of parameters that just includes the extra lifetime parameters? The answer is primarily that it would be hard --- we don't know at the time when we create the closure type what the full types of the upvars are, nor do we know which are borrowed and which are not. In this design, we can just supply a fresh type parameter and figure that out later.All right, you say, but why include the type parameters from the original function then? The answer is that trans may need them when monomorphizing, and they may not appear in the upvars.  A closure could capture no variables but still make use of some in-scope type parameter with a bound (e.g., if our example above had an extra `U: Default`, and the closure called `U::default()`).There is another reason. This design (implicitly) prohibits closures from capturing themselves (except via a trait object). This simplifies closure inference considerably, since it means that when we infer the kind of a closure or its upvars, we don't have to handle cycles where the decisions we make for closure C wind up influencing the decisions we ought to make for closure C (which would then require fixed point iteration to handle). Plus it fixes an ICE. :P"],["ClosureTy",""],["ClosureUpvar",""],["CrateAnalysis","The complete set of all analyses described in this module. This is produced by the driver and fed to trans and later passes."],["CtxtArenas","Internal storage"],["DebruijnIndex","A De Bruijn index is a standard means of representing regions (and perhaps later types) in a higher-ranked setting. In particular, imagine a type like this:In this type, there are two binders (the outer fn and the inner fn). We need to be able to determine, for any given region, which fn type it is bound by, the inner or the outer one. There are various ways you can do this, but a De Bruijn index is one of the more convenient and has some nice properties. The basic idea is to count the number of binders, inside out. Some examples should help clarify what I mean.Let's start with the reference type `&'b isize` that is the first argument to the inner function. This region `'b` is assigned a De Bruijn index of 1, meaning \"the innermost binder\" (in this case, a fn). The region `'a` that appears in the second argument type (`&'a isize`) would then be assigned a De Bruijn index of 2, meaning \"the second-innermost binder\". (These indices are written on the arrays in the diagram).What is interesting is that De Bruijn index attached to a particular variable will vary depending on where it appears. For example, the final type `&'a char` also refers to the region `'a` declared on the outermost fn. But this time, this reference is not nested within any other binders (i.e., it is not an argument to the inner fn, but rather the outer one). Therefore, in this case, it is assigned a De Bruijn index of 1, because the innermost binder in that location is the outer fn."],["EarlyBoundRegion",""],["EquatePredicate",""],["ExistentialBounds","Bounds suitable for an existentially quantified type parameter such as those that appear in object types or closure types."],["FieldDefData",""],["FloatVid",""],["FnSig","Signature of a function type, which I have arbitrarily decided to use to refer to the input/output types.`inputs` is the list of arguments and their modes. `output` is the return type. `variadic` indicates whether this is a variadic function. (only true for foreign fns)"],["FreeRegion","A \"free\" region `fr` can be interpreted as \"some region at least as big as the scope `fr.scope`\"."],["Freevar","A free variable referred to in a function."],["GenericPredicates","Bounds on generics."],["Generics","Information about the formal type/lifetime parameters associated with an item or method. Analogous to hir::Generics."],["InstantiatedPredicates","Represents the bounds declared on a particular set of type parameters.  Should eventually be generalized into a flag list of where clauses.  You can obtain a `InstantiatedPredicates` list from a `GenericPredicates` by using the `instantiate` method. Note that this method reflects an important semantic invariant of `InstantiatedPredicates`: while the `GenericPredicates` are expressed in terms of the bound type parameters of the impl/trait/whatever, an `InstantiatedPredicates` instance represented a set of bounds for some particular instantiation, meaning that the generic parameters have been substituted with their values.Example:Here, the `GenericPredicates` for `Foo` would contain a list of bounds like `[[], [U:Bar<T>]]`.  Now if there were some particular reference like `Foo<isize,usize>`, then the `InstantiatedPredicates` would be `[[], [usize:Bar<isize>]]`."],["IntVid",""],["ItemSubsts","Records the substitutions used to translate the polytype for an item into the monotype of an item reference."],["ItemVariances",""],["Method",""],["MethodCall","With method calls, we store some extra information in side tables (i.e method_map). We use MethodCall as a key to index into these tables instead of just directly using the expression's NodeId. The reason for this being that we may apply adjustments (coercions) with the resulting expression also needing to use the side tables. The problem with this is that we don't assign a separate NodeId to this new expression and so it would clash with the base expression if both needed to add to the side tables. Thus to disambiguate we also keep track of whether there's an adjustment in our key."],["MethodCallee",""],["OutlivesPredicate",""],["ParamTy",""],["ParameterEnvironment","When type checking, we use the `ParameterEnvironment` to track details about the type/lifetime parameters that are in scope. It primarily stores the bounds information.Note: This information might seem to be redundant with the data in `tcx.ty_param_defs`, but it is not. That table contains the parameter definitions from an \"outside\" perspective, but this struct will contain the bounds for a parameter as seen from inside the function body. Currently the only real distinction is that bound lifetime parameters are replaced with free ones, but in the future I hope to refine the representation of types so as to make more distinctions clearer."],["ProjectionPredicate","This kind of predicate has no *direct* correspondent in the syntax, but it roughly corresponds to the syntactic forms:`T : TraitRef<..., Item=Type>` `<T as TraitRef<...>>::Item == Type` (NYI) In particular, form #1 is \"desugared\" to the combination of a normal trait predicate (`T : TraitRef<...>`) and one of these predicates. Form #2 is a broader form in that it also permits equality between arbitrary types. Processing an instance of Form2 eventually yields one of these `ProjectionPredicate`instances to normalize the LHS."],["ProjectionTy","Represents the projection of an associated type. In explicit UFCS form this would be written `<T as Trait<..>>::N`."],["RegionParameterDef",""],["RegionVid",""],["SkolemizedRegionVid",""],["Tables",""],["TraitDef","As `TypeScheme` but for a trait ref."],["TraitFlags",""],["TraitPredicate",""],["TraitRef","A complete reference to a trait. These take numerous guises in syntax, but perhaps the most recognizable form is in a where clause:This would be represented by a trait-reference where the def-id is the def-id for the trait `Foo` and the substs defines `T` as parameter 0 in the `SelfSpace` and `U` as parameter 0 in the `TypeSpace`.Trait references also appear in object types like `Foo<U>`, but in that case the `Self` parameter is absent from the substitutions.Note that a `TraitRef` introduces a level of region binding, to account for higher-ranked trait bounds like `T : for<'a> Foo<&'a U>` or higher-ranked object types."],["TraitTy",""],["TransmuteRestriction","A restriction that certain types must be the same size. The use of `transmute` gives rise to these restrictions. These generally cannot be checked until trans; therefore, each call to `transmute` will push one or more such restriction into the `transmute_restrictions` vector during `intrinsicck`. They are then checked during `trans` by the fn `check_intrinsics`."],["TyS",""],["TyVid",""],["TypeAndMut",""],["TypeContents","Type contents is how the type checker reasons about kinds. They track what kinds of things are found within a type.  You can think of them as kind of an \"anti-kind\".  They track the kinds of values and thinks that are contained in types.  Having a larger contents for a type tends to rule that type *out* from various kinds.  For example, a type that contains a reference is not sendable.The reason we compute type contents and not kinds is that it is easier for me (nmatsakis) to think about what is contained within a type than to think about what is *not* contained within a type."],["TypeFlags",""],["TypeParameterDef",""],["TypeScheme","A \"type scheme\", in ML terminology, is a type combined with some set of generic types that the type is, well, generic over. In Rust terms, it is the \"type\" of a fn item or struct -- this type will include various generic parameters that must be substituted when the item/struct is referenced. That is called converting the type scheme to a monotype.`generics`: the set of type parameters and their bounds `ty`: the base types, which may reference the parameters defined in `generics` Note that TypeSchemes are also sometimes called \"polytypes\" (and in fact this struct used to carry that name, so you may find some stray references in a comment or something). We try to reserve the \"poly\" prefix to refer to higher-ranked things, as in `PolyTraitRef`.Note that each item also comes with predicates, see `lookup_predicates`."],["UpvarBorrow",""],["UpvarId","Upvars do not get their own node-id. Instead, we use the pair of the original var id (that is, the root variable that is referenced by the upvar) and the id of the closure expression."],["VariantDefData",""],["ctxt","The data structure to keep track of all the information that typechecker generates so that so that it can be reused and doesn't have to be redone later on."]],"trait":[["Lift","A trait implemented for all X<'a> types which can be safely and efficiently converted to X<'tcx> as long as they are part of the provided ty::ctxt<'tcx>. This can be done, for example, for Ty<'tcx> or &'tcx Substs<'tcx> by looking them up in their respective interners. None is returned if the value or one of the components is not part of the provided context. For Ty, None can be returned if either the type interner doesn't contain the TypeVariants key or if the address of the interned pointer differs. The latter case is possible if a primitive type, e.g. `()` or `u8`, was interned in a different context."],["ToPolyTraitRef",""],["ToPredicate",""],["TypeFoldable","The TypeFoldable trait is implemented for every type that can be folded. Basically, every type that has a corresponding method in TypeFolder."]],"type":[["AdtDef",""],["AdtDefMaster",""],["CaptureModeMap",""],["Disr",""],["FieldDef",""],["FieldDefMaster",""],["FreevarMap",""],["GlobMap",""],["MethodMap",""],["PolyEquatePredicate",""],["PolyFnOutput",""],["PolyFnSig",""],["PolyOutlivesPredicate",""],["PolyProjectionPredicate",""],["PolyRegionOutlivesPredicate",""],["PolyTraitPredicate",""],["PolyTraitRef",""],["PolyTypeOutlivesPredicate",""],["TraitMap",""],["Ty",""],["UpvarCaptureMap",""],["VariantDef",""],["VariantDefMaster",""]]});