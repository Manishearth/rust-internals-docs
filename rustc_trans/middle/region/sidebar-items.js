initSidebarItems({"constant":[["DUMMY_CODE_EXTENT","A placeholder used in trans to stand for real code extents"],["ROOT_CODE_EXTENT","The root of everything. I should be using NonZero or profiling instead of this (probably)."]],"enum":[["CodeExtentData","CodeExtent represents a statically-describable extent that can be used to bound the lifetime/region for values.`Misc(node_id)`: Any AST node that has any extent at all has the `Misc(node_id)` extent. Other variants represent special cases not immediately derivable from the abstract syntax tree structure.`DestructionScope(node_id)` represents the extent of destructors implicitly-attached to `node_id` that run immediately after the expression for `node_id` itself. Not every AST node carries a `DestructionScope`, but those that are `terminating_scopes` do; see discussion with `RegionMaps`.`Remainder(BlockRemainder { block, statement_index })` represents the extent of user code running immediately after the initializer expression for the indexed statement, until the end of the block.So: the following code can be broken down into the extents beneath: ``` let a = f().g( 'b: { let x = d(); let y = d(); x.h(y)  }   ) ; ```+-----------------------------------------------------------+     (M1.) (M1.): Misc extent of the whole `let a = ...;` statement.  (M2.): Misc extent of the `f()` expression.  (M3.): Misc extent of the `f().g(..)` expression.  (M4.): Misc extent of the block labelled `'b:`.  (M5.): Misc extent of the `let x = d();` statement  (D6.): DestructionScope for temporaries created during M5.  (R7.): Remainder extent for block `'b:`, stmt 0 (let x = ...).  (M8.): Misc Extent of the `let y = d();` statement.  (D9.): DestructionScope for temporaries created during M8. (R10.): Remainder extent for block `'b:`, stmt 1 (let y = ...). (D11.): DestructionScope for temporaries and bindings from block `'b:`. (D12.): DestructionScope for temporaries created during M1 (e.g. f()).Note that while the above picture shows the destruction scopes as following their corresponding misc extents, in the internal data structures of the compiler the destruction scopes are represented as enclosing parents. This is sound because we use the enclosing parent relationship just to ensure that referenced values live long enough; phrased another way, the starting point of each range is not really the important thing in the above picture, but rather the ending point.FIXME (pnkfelix): This currently derives `PartialOrd` and `Ord` to placate the same deriving in `ty::FreeRegion`, but we may want to actually attach a more meaningful ordering to scopes than the one generated via deriving here."]],"fn":[["resolve_crate",""],["resolve_inlined_item",""]],"struct":[["BlockRemainder","Represents a subscope of `block` for a binding that is introduced by `block.stmts[first_statement_index]`. Such subscopes represent a suffix of the block. Note that each subscope does not include the initializer expression, if any, for the statement indexed by `first_statement_index`.For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:the subscope with `first_statement_index == 0` is scope of both `a` and `b`; it does not include EXPR_1, but does include everything after that first `let`. (If you want a scope that includes EXPR_1 as well, then do not use `CodeExtentData::Remainder`, but instead another `CodeExtent` that encompasses the whole block, e.g. `CodeExtentData::Misc`.the subscope with `first_statement_index == 1` is scope of `c`, and thus does not include EXPR_2, but covers the `...`."],["CallSiteScopeData","extent of call-site for a function/method."],["CodeExtent",""],["Context",""],["RegionMaps","The region maps encode information about region relationships."]]});