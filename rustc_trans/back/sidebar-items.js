initSidebarItems({"mod":[["abi",""],["archive","A helper class for dealing with static archives"],["link",""],["linker",""],["lto",""],["msvc","MSVC-specific logic for linkers and such.This module contains a cross-platform interface but has a blank unix implementation. The Windows implementation builds on top of Windows native libraries (reading registry keys), so it otherwise wouldn't link on unix.Note that we don't have much special logic for finding the system linker on any other platforms, so it may seem a little odd to single out MSVC to have a good deal of code just to find the linker. Unlike Unix systems, however, the MSVC linker is not in the system PATH by default. It also additionally needs a few environment variables or command line flags to be able to link against system libraries.In order to have a nice smooth experience on Windows, the logic in this file is here to find the MSVC linker and set it up in the default configuration one would need to set up anyway. This means that the Rust compiler can be run not only in the developer shells of MSVC but also the standard cmd.exe shell or MSYS shells.As a high-level note, all logic in this module for looking up various paths/files is based on Microsoft's logic in their vcvars bat files, but comments can also be found below leading through the various code paths."],["rpath",""],["svh","Calculation and management of a Strict Version Hash for cratesToday's ABI problemIn today's implementation of rustc, it is incredibly difficult to achieve forward binary compatibility without resorting to C-like interfaces. Within rust code itself, abi details such as symbol names suffer from a variety of unrelated factors to code changing such as the \"def id drift\" problem. This ends up yielding confusing error messages about metadata mismatches and such.The core of this problem is when an upstream dependency changes and downstream dependents are not recompiled. This causes compile errors because the upstream crate's metadata has changed but the downstream crates are still referencing the older crate's metadata.This problem exists for many reasons, the primary of which is that rust does not currently support forwards ABI compatibility (in place upgrades of a crate).SVH and how it alleviates the problemWith all of this knowledge on hand, this module contains the implementation of a notion of a \"Strict Version Hash\" for a crate. This is essentially a hash of all contents of a crate which can somehow be exposed to downstream crates.This hash is currently calculated by just hashing the AST, but this is obviously wrong (doc changes should not result in an incompatible ABI). Implementation-wise, this is required at this moment in time.By encoding this strict version hash into all crate's metadata, stale crates can be detected immediately and error'd about by rustc itself.Relevant linksOriginal issue: https://github.com/rust-lang/rust/issues/10207"],["write",""]]});