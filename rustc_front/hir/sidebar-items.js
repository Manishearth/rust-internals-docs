initSidebarItems({"enum":[["BinOp_",""],["BindingMode",""],["BlockCheckMode",""],["CaptureClause",""],["Constness",""],["Decl_",""],["ExplicitSelf_","Represents the kind of 'self' associated with a method"],["Expr_",""],["ForeignItem_","An item within an `extern` block"],["FunctionRetTy",""],["ImplItemKind",""],["ImplPolarity",""],["Item_",""],["MatchSource",""],["Mutability",""],["PatKind",""],["PathListItem_",""],["PathParameters",""],["PrimTy","Not represented directly in the AST, referred to by name through a ty_path."],["Stmt_",""],["StructFieldKind",""],["TraitBoundModifier","A modifier on a bound, currently this is only used for `?Sized`, where the modifier is `Maybe`. Negative bounds should also be handled here."],["TraitItem_",""],["TyParamBound","The AST represents all type param bounds as types. typeck::collect::compute_bounds matches these against the \"special\" built-in traits (see middle::lang_items) and detects Copy, Send and Sync."],["Ty_","The different kinds of types recognized by the compiler"],["UnOp",""],["UnsafeSource",""],["Unsafety",""],["VariantData","Fields and Ids of enum variants and structsFor enum variants: `NodeId` represents both an Id of the variant itself (relevant for all variant kinds) and an Id of the variant's constructor (not relevant for `Struct`-variants). One shared Id can be successfully used for these two purposes. Id of the whole enum lives in `Item`.For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of the variant itself\" from enum variants. Id of the whole struct lives in `Item`."],["ViewPath_",""],["Visibility",""],["WherePredicate","A single predicate in a `where` clause"]],"struct":[["AngleBracketedParameterData","A path like `Foo<'a, T>`"],["Arg","represents an argument in a function header"],["Arm","represents one arm of a 'match'"],["BareFnTy",""],["Block",""],["Crate",""],["EnumDef",""],["Expr","An expression"],["Field",""],["FieldPat","A single field in a struct patternPatterns like the fields of Foo `{ x, ref y, ref mut z }` are treated the same as` x: x, y: ref y, z: ref mut z`, except is_shorthand is true"],["FnDecl","Represents the header (not the body) of a function declaration"],["ForeignItem",""],["ForeignMod",""],["Generics","Represents lifetimes and type parameters attached to a declaration of a function, enum, trait, etc."],["Ident","Identifier in HIR"],["ImplItem",""],["InlineAsm",""],["InlineAsmOutput",""],["Item","An itemThe name might be a dummy name in case of anonymous items"],["ItemId",""],["Lifetime",""],["LifetimeDef","A lifetime definition, eg `'a: 'b+'c+'d`"],["Local","Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`"],["MacroDef","A macro definition, in this crate or imported from another.Not parsed directly, but created on macro import or `macro_rules!` expansion."],["MethodSig","Represents a method's signature in a trait declaration, or in an implementation."],["Mod",""],["MutTy",""],["ParenthesizedParameterData","A path like `Foo(A,B) -> C`"],["Pat",""],["Path","A \"Path\" is essentially Rust's notion of a name; for instance: std::cmp::PartialEq  .  It's represented as a sequence of identifiers, along with a bunch of supporting information."],["PathSegment","A segment of a path: an identifier, an optional lifetime, and a set of types."],["PolyTraitRef",""],["QSelf","The explicit Self type in a \"qualified path\". The actual path, including the trait and the associated item, is stored separately. `position` represents the index of the associated item qualified with this Self type."],["StructField_",""],["TraitItem","Represents a method declaration in a trait declaration, possibly including a default implementation A trait method is either required (meaning it doesn't have an implementation, just a signature) or provided (meaning it has a default implementation)."],["TraitRef","TraitRef's appear in impls.resolve maps each TraitRef's ref_id to its defining trait; that's all that the ref_id is for. The impl_id maps to the \"self type\" of this impl. If this impl is an ItemImpl, the impl_id is redundant (it could be the same as the impl's node id)."],["Ty",""],["TyParam",""],["TypeBinding",""],["Variant_",""],["WhereBoundPredicate","A type bound, eg `for<'c> Foo: Send+Clone+'c`"],["WhereClause","A `where` clause in a definition"],["WhereEqPredicate","An equality predicate (unsupported), e.g. `T=int`"],["WhereRegionPredicate","A lifetime predicate, e.g. `'a: 'b+'c`"]],"type":[["BinOp",""],["CrateConfig",""],["Decl",""],["ExplicitSelf",""],["HirVec","HIR doesn't commit to a concrete storage type and have its own alias for a vector. It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar behavior. Unlike AST, HIR is mostly a static structure, so we can use an owned slice instead of `Vec` to avoid keeping extra capacity."],["PathListItem",""],["Stmt","A statement"],["StructField",""],["TyParamBounds",""],["Variant",""],["ViewPath",""]]});