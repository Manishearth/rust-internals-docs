initSidebarItems({"constant":[["MAX_SIG_DIGITS","The minimum size of buffer necessary for the shortest mode."]],"enum":[["FullDecoded","Decoded unsigned value."],["Part","Formatted parts."],["Sign","Sign formatting options."]],"fn":[["decode","Returns a sign (true when negative) and `FullDecoded` value from given floating point number."],["determine_sign","Returns the static byte string corresponding to the sign to be formatted. It can be either `b\"\"`, `b\"+\"` or `b\"-\"`."],["digits_to_dec_str","Formats given decimal digits `0.<...buf...> * 10^exp` into the decimal form with at least given number of fractional digits. The result is stored to the supplied parts array and a slice of written parts is returned."],["digits_to_exp_str","Formats given decimal digits `0.<...buf...> * 10^exp` into the exponential form with at least given number of significant digits. When `upper` is true, the exponent will be prefixed by `E`; otherwise that's `e`. The result is stored to the supplied parts array and a slice of written parts is returned."],["estimate_max_buf_len","Returns rather crude approximation (upper bound) for the maximum buffer size calculated from the given decoded exponent."],["round_up","When `d[..n]` contains decimal digits, increase the last digit and propagate carry. Returns a next digit when it causes the length change."],["to_exact_exp_str","Formats given floating point number into the exponential form with exactly given number of significant digits. The result is stored to the supplied parts array while utilizing given byte buffer as a scratch. `upper` is used to determine the case of the exponent prefix (`e` or `E`). The first part to be rendered is always a `Part::Sign` (which can be an empty string if no sign is rendered)."],["to_exact_fixed_str","Formats given floating point number into the decimal form with exactly given number of fractional digits. The result is stored to the supplied parts array while utilizing given byte buffer as a scratch. `upper` is currently unused but left for the future decision to change the case of non-finite values, i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign` (which can be an empty string if no sign is rendered)."],["to_shortest_exp_str","Formats given floating point number into the decimal form or the exponential form, depending on the resulting exponent. The result is stored to the supplied parts array while utilizing given byte buffer as a scratch. `upper` is used to determine the case of non-finite values (`inf` and `nan`) or the case of the exponent prefix (`e` or `E`). The first part to be rendered is always a `Part::Sign` (which can be an empty string if no sign is rendered)."],["to_shortest_str","Formats given floating point number into the decimal form with at least given number of fractional digits. The result is stored to the supplied parts array while utilizing given byte buffer as a scratch. `upper` is currently unused but left for the future decision to change the case of non-finite values, i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign` (which can be an empty string if no sign is rendered)."]],"mod":[["decoder","Decodes a floating-point value into individual parts and error ranges."],["estimator","The exponent estimator."],["strategy","Digit-generation algorithms."]],"struct":[["Decoded","Decoded unsigned finite value, such that:"],["Formatted","Formatted result containing one or more parts. This can be written to the byte buffer or converted to the allocated string."]],"trait":[["DecodableFloat","A floating point type which can be `decode`d."]]});