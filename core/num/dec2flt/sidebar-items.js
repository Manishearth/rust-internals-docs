initSidebarItems({"enum":[["FloatErrorKind",""]],"fn":[["bound_intermediate_digits","Quick and dirty upper bound on the size (log10) of the largest value that Algorithm R and Algorithm M will compute while working on the given decimal."],["convert","The main workhorse for the decimal-to-float conversion: Orchestrate all the preprocessing and figure out which algorithm should do the actual conversion."],["dec2flt","Convert a decimal string into a floating point number."],["extract_sign","Split decimal string into sign and the rest, without inspecting or validating the rest."],["pfe_empty",""],["pfe_invalid",""],["simplify","Strip zeros where possible, even when this requires changing the exponent"],["trivial_cases","Detect obvious overflows and underflows without even looking at the decimal digits."]],"mod":[["algorithm","The various algorithms from the paper."],["num","Utility functions for bignums that don't make too much sense to turn into methods."],["parse","Validating and decomposing a decimal string of the form:"],["rawfp","Bit fiddling on positive IEEE 754 floats. Negative numbers aren't and needn't be handled. Normal floating point numbers have a canonical representation as (frac, exp) such that the value is 2^exp * (1 + sum(frac[N-i] / 2^i)) where N is the number of bits. Subnormals are slightly different and weird, but the same principle applies."],["table","Tables of approximations of powers of ten. DO NOT MODIFY: Generated by `src/etc/dec2flt_table.py`"]],"struct":[["ParseFloatError","An error which can be returned when parsing a float."]]});