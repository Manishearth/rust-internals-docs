initSidebarItems({"macro":[["assert!","Ensure that a boolean expression is `true` at runtime.This will invoke the `panic!` macro if the provided expression cannot be evaluated to `true` at runtime.This macro has a second version, where a custom panic message can be provided.Examples"],["assert_eq!","Asserts that two expressions are equal to each other.On panic, this macro will print the values of the expressions with their debug representations.Examples"],["debug_assert!","Ensure that a boolean expression is `true` at runtime.This will invoke the `panic!` macro if the provided expression cannot be evaluated to `true` at runtime.Like `assert!`, this macro also has a second version, where a custom panic message can be provided.Unlike `assert!`, `debug_assert!` statements are only enabled in non optimized builds by default. An optimized build will omit all `debug_assert!` statements unless `-C debug-assertions` is passed to the compiler. This makes `debug_assert!` useful for checks that are too expensive to be present in a release build but may be helpful during development.Examples"],["debug_assert_eq!","Asserts that two expressions are equal to each other.On panic, this macro will print the values of the expressions with their debug representations.Unlike `assert_eq!`, `debug_assert_eq!` statements are only enabled in non optimized builds by default. An optimized build will omit all `debug_assert_eq!` statements unless `-C debug-assertions` is passed to the compiler. This makes `debug_assert_eq!` useful for checks that are too expensive to be present in a release build but may be helpful during development.Examples"],["panic!","Entry point of thread panic, for details, see std::macros"],["try!","Helper macro for unwrapping `Result` values while returning early with an error if the value of the expression is `Err`. Can only be used in functions that return `Result` because of the early return of `Err` that it provides.Examples"],["unimplemented!","A standardized placeholder for marking unfinished code. It panics with the message `\"not yet implemented\"` when executed.This can be useful if you are prototyping and are just looking to have your code typecheck, or if you're implementing a trait that requires multiple methods, and you're only planning on using one of them.ExamplesHere's an example of some in-progress code. We have a trait `Foo`:We want to implement `Foo` on one of our types, but we also want to work on just `bar()` first. In order for our code to compile, we need to implement `baz()`, so we can use `unimplemented!`:"],["unreachable!","A utility macro for indicating unreachable code.This is useful any time that the compiler can't determine that some code is unreachable. For example:Match arms with guard conditions. Loops that dynamically terminate. Iterators that dynamically terminate. PanicsThis will always panic.ExamplesMatch arms:Iterators:"],["write!","Use the `format!` syntax to write data into a buffer.This macro is typically used with a buffer of `&mut ``Write`.See `std::fmt` for more information on format syntax.Examples"],["writeln!","Use the `format!` syntax to write data into a buffer, appending a newline.This macro is typically used with a buffer of `&mut ``Write`.See `std::fmt` for more information on format syntax.Examples"]],"mod":[["any","This module implements the `Any` trait, which enables dynamic typing of any `'static` type through runtime reflection.`Any` itself can be used to get a `TypeId`, and has more features when used as a trait object. As `&Any` (a borrowed trait object), it has the `is` and `downcast_ref` methods, to test if the contained value is of a given type, and to get a reference to the inner value as a type. As `&mut Any`, there is also the `downcast_mut` method, for getting a mutable reference to the inner value. `Box<Any>` adds the `downcast` method, which attempts to convert to a `Box<T>`. See the `Box` documentation for the full details.Note that &Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.ExamplesConsider a situation where we want to log out a value passed to a function. We know the value we're working on implements Debug, but we don't know its concrete type.  We want to give special treatment to certain types: in this case printing out the length of String values prior to their value. We don't know the concrete type of our value at compile time, so we need to use runtime reflection instead."],["array","Implementations of things like `Eq` for fixed-length arrays up to a certain length. Eventually we should able to generalize to all lengths.*See also the array primitive type.*"],["borrow","A module for working with borrowed data."],["cell","Shareable mutable containers.Values of the `Cell<T>` and `RefCell<T>` types may be mutated through shared references (i.e. the common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`) references. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast with typical Rust types that exhibit 'inherited mutability'.Cell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` provides `get` and `set` methods that change the interior value with a single method call. `Cell<T>` though is only compatible with types that implement `Copy`. For other types, one must use the `RefCell<T>` type, acquiring a write lock before mutating.`RefCell<T>` uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are tracked 'at runtime', unlike Rust's native reference types which are entirely tracked statically, at compile time. Because `RefCell<T>` borrows are dynamic it is possible to attempt to borrow a value that is already mutably borrowed; when this happens it results in thread panic.When to choose interior mutabilityThe more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even *must* be used, e.g.Introducing mutability 'inside' of something immutable Implementation details of logically-immutable methods. Mutating implementations of `Clone`. Introducing mutability 'inside' of something immutableMany shared smart pointer types, including `Rc<T>` and `Arc<T>`, provide containers that can be cloned and shared between multiple parties. Because the contained values may be multiply-aliased, they can only be borrowed with `&`, not `&mut`. Without cells it would be impossible to mutate data inside of these smart pointers at all.It's very common then to put a `RefCell<T>` inside shared pointer types to reintroduce mutability:Note that this example uses `Rc<T>` and not `Arc<T>`. `RefCell<T>`s are for single-threaded scenarios. Consider using `RwLock<T>` or `Mutex<T>` if you need shared mutability in a multi-threaded situation.Implementation details of logically-immutable methodsOccasionally it may be desirable not to expose in an API that there is mutation happening \"under the hood\". This may be because logically the operation is immutable, but e.g. caching forces the implementation to perform mutation; or because you must employ mutation to implement a trait method that was originally defined to take `&self`.Mutating implementations of `Clone`This is simply a special - but common - case of the previous: hiding mutability for operations that appear to be immutable. The `clone` method is expected to not change the source value, and is declared to take `&self`, not `&mut self`. Therefore any mutation that happens in the `clone` method must use cell types. For example, `Rc<T>` maintains its reference counts within a `Cell<T>`."],["char","Character manipulation.For more details, see ::rustc_unicode::char (a.k.a. std::char)"],["clone","The `Clone` trait for types that cannot be 'implicitly copied'In Rust, some simple types are \"implicitly copyable\" and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e. they do not contain owned boxes or implement `Drop`), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the `Clone` trait and calling the `clone` method."],["cmp","Functionality for ordering and comparison.This module defines both `PartialOrd` and `PartialEq` traits which are used by the compiler to implement comparison operators. Rust programs may implement `PartialOrd` to overload the `<`, `<=`, `>`, and `>=` operators, and may implement `PartialEq` to overload the `==` and `!=` operators."],["convert","Traits for conversions between types.The traits in this module provide a general way to talk about conversions from one type to another. They follow the standard Rust conventions of `as`/`into`/`from`.Like many traits, these are often used as bounds for generic functions, to support arguments of multiple types.Impl the `As*` traits for reference-to-reference conversions Impl the `Into` trait when you want to consume the value in the conversion The `From` trait is the most flexible, useful for values _and_ references conversions As a library writer, you should prefer implementing `From<T>` rather than `Into<U>`, as `From` provides greater flexibility and offer the equivalent `Into` implementation for free, thanks to a blanket implementation in the standard library.**Note: these traits must not fail**. If the conversion can fail, you must use a dedicated method which return an `Option<T>` or a `Result<T, E>`.Generic impl`AsRef` and `AsMut` auto-dereference if the inner type is a reference `From<U> for T` implies `Into<T> for U` `From` and `Into` are reflexive, which means that all types can `into()` themselves and `from()` themselves See each trait for usage examples."],["default","The `Default` trait for types which may have meaningful default values.Sometimes, you want to fall back to some kind of default value, and don't particularly care what it is. This comes up often with `struct`s that define a set of options:How can we define some default values? You can use `Default`:Now, you get all of the default values. Rust implements `Default` for various primitives types. If you have your own type, you need to implement `Default` yourself:If you want to override a particular option, but still retain the other defaults:"],["f32","Operations and constants for 32-bits floats (`f32` type)"],["f64","Operations and constants for 64-bits floats (`f64` type)"],["fmt","Utilities for formatting and printing strings"],["hash","Generic hashing support.This module provides a generic way to compute the hash of a value. The simplest way to make a type hashable is to use `#[derive(Hash)]`:ExamplesIf you need more control over how a value is hashed, you need to implement the trait `Hash`:"],["i16","The 16-bit signed integer type.*See also the `i16` primitive type.*"],["i32","The 32-bit signed integer type.*See also the `i32` primitive type.*"],["i64","The 64-bit signed integer type.*See also the `i64` primitive type.*"],["i8","The 8-bit signed integer type.*See also the `i8` primitive type.*"],["intrinsics","rustc compiler intrinsics.The corresponding definitions are in librustc_trans/trans/intrinsic.rs.VolatilesThe volatile intrinsics provide operations intended to act on I/O memory, which are guaranteed to not be reordered by the compiler across other volatile intrinsics. See the LLVM documentation on [volatile].AtomicsThe atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [atomics].A quick refresher on memory ordering:Acquire - a barrier for acquiring a lock. Subsequent reads and writes take place after the barrier. Release - a barrier for releasing a lock. Preceding reads and writes take place before the barrier. Sequentially consistent - sequentially consistent operations are guaranteed to happen in order. This is the standard mode for working with atomic types and is equivalent to Java's `volatile`."],["isize","The pointer-sized signed integer type.*See also the `isize` primitive type.*"],["iter","Composable external iterationIf you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic Rust code, so it's worth becoming familiar with them.Before explaining more, let's talk about how this module is structured:OrganizationThis module is largely organized by type:Traits are the core portion: these traits define what kind of iterators exist and what you can do with them. The methods of these traits are worth putting some extra study time into. Functions provide some helpful ways to create some basic iterators. Structs are often the return types of the various methods on this module's traits. You'll usually want to look at the method that creates the `struct`, rather than the `struct` itself. For more detail about why, see 'Implementing Iterator'. That's it! Let's dig into iterators.IteratorThe heart and soul of this module is the `Iterator` trait. The core of `Iterator` looks like this:An iterator has a method, `next()`, which when called, returns an `Option``<Item>`. `next()` will return `Some(Item)` as long as there are elements, and once they've all been exhausted, will return `None` to indicate that iteration is finished. Individual iterators may choose to resume iteration, and so calling `next()` again may or may not eventually start returning `Some(Item)` again at some point.`Iterator`'s full definition includes a number of other methods as well, but they are default methods, built on top of `next()`, and so you get them for free.Iterators are also composable, and it's common to chain them together to do more complex forms of processing. See the Adapters section below for more details.The three forms of iterationThere are three common methods which can create iterators from a collection:`iter()`, which iterates over `&T`. `iter_mut()`, which iterates over `&mut T`. `into_iter()`, which iterates over `T`. Various things in the standard library may implement one or more of the three, where appropriate.Implementing IteratorCreating an iterator of your own involves two steps: creating a `struct` to hold the iterator's state, and then `impl`ementing `Iterator` for that `struct`. This is why there are so many `struct`s in this module: there is one for each iterator and iterator adapter.Let's make an iterator named `Counter` which counts from `1` to `5`:This will print `1` through `5`, each on their own line.Calling `next()` this way gets repetitive. Rust has a construct which can call `next()` on your iterator, until it reaches `None`. Let's go over that next.for Loops and IntoIteratorRust's `for` loop syntax is actually sugar for iterators. Here's a basic example of `for`:This will print the numbers one through five, each on their own line. But you'll notice something here: we never called anything on our vector to produce an iterator. What gives?There's a trait in the standard library for converting something into an iterator: `IntoIterator`. This trait has one method, `into_iter()`, which converts the thing implementing `IntoIterator` into an iterator. Let's take a look at that `for` loop again, and what the compiler converts it into:Rust de-sugars this into:First, we call `into_iter()` on the value. Then, we match on the iterator that returns, calling `next()` over and over until we see a `None`. At that point, we `break` out of the loop, and we're done iterating.There's one more subtle bit here: the standard library contains an interesting implementation of `IntoIterator`:In other words, all `Iterator`s implement `IntoIterator`, by just returning themselves. This means two things:If you're writing an `Iterator`, you can use it with a `for` loop. If you're creating a collection, implementing `IntoIterator` for it will allow your collection to be used with the `for` loop. AdaptersFunctions which take an `Iterator` and return another `Iterator` are often called 'iterator adapters', as they're a form of the 'adapter pattern'.Common iterator adapters include `map()`, `take()`, and `collect()`. For more, see their documentation.LazinessIterators (and iterator adapters) are *lazy*. This means that just creating an iterator doesn't _do_ a whole lot. Nothing really happens until you call `next()`. This is sometimes a source of confusion when creating an iterator solely for its side effects. For example, the `map()` method calls a closure on each element it iterates over:This will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:The idiomatic way to write a `map()` for its side effects is to use a `for` loop instead:The two most common ways to evaluate an iterator are to use a `for` loop like this, or using the `collect()` adapter to produce a new collection.InfinityIterators do not have to be finite. As an example, an open-ended range is an infinite iterator:It is common to use the `take()` iterator adapter to turn an infinite iterator into a finite one:This will print the numbers `0` through `4`, each on their own line."],["marker","Primitive traits and marker types representing basic 'kinds' of types.Rust types can be classified in various useful ways according to intrinsic properties of the type. These classifications, often called 'kinds', are represented as traits."],["mem","Basic functions for dealing with memoryThis module contains functions for querying the size and alignment of types, initializing and manipulating memory."],["nonzero","Exposes the NonZero lang item which provides optimization hints."],["num","Numeric traits and functions for the built-in numeric types."],["ops","Overloadable operatorsImplementing these traits allows you to get an effect similar to overloading operators.Some of these traits are imported by the prelude, so they are available in every Rust program.Many of the operators take their operands by value. In non-generic contexts involving built-in types, this is usually not a problem. However, using these operators in generic code, requires some attention if values have to be reused as opposed to letting the operators consume them. One option is to occasionally use `clone()`. Another option is to rely on the types involved providing additional operator implementations for references. For example, for a user-defined type `T` which is supposed to support addition, it is probably a good idea to have both `T` and `&T` implement the traits `Add<T>` and `Add<&T>` so that generic code can be written without unnecessary cloning.ExamplesThis example creates a `Point` struct that implements `Add` and `Sub`, and then demonstrates adding and subtracting two `Point`s.See the documentation for each trait for a minimum implementation that prints something to the screen."],["option","Optional valuesType `Option` represents an optional value: every `Option` is either `Some` and contains a value, or `None`, and does not. `Option` types are very common in Rust code, as they have a number of uses:Initial values Return values for functions that are not defined over their entire input range (partial functions) Return value for otherwise reporting simple errors, where `None` is returned on error Optional struct fields Struct fields that can be loaned or \"taken\" Optional function arguments Nullable pointers Swapping things out of difficult situations Options are commonly paired with pattern matching to query the presence of a value and take action, always accounting for the `None` case.Options and pointers (\"nullable\" pointers)Rust's pointer types must always point to a valid location; there are no \"null\" pointers. Instead, Rust has *optional* pointers, like the optional owned box, `Option<Box<T>>`.The following example uses `Option` to create an optional box of `i32`. Notice that in order to use the inner `i32` value first the `check_optional` function needs to use pattern matching to determine whether the box has a value (i.e. it is `Some(...)`) or not (`None`).This usage of `Option` to create safe nullable pointers is so common that Rust does special optimizations to make the representation of `Option<Box<T>>` a single pointer. Optional pointers in Rust are stored as efficiently as any other pointer type.ExamplesBasic pattern matching on `Option`:Initialize a result to `None` before a loop:"],["panicking","Panic support for libcoreThe core library cannot define panicking, but it does *declare* panicking. This means that the functions inside of libcore are allowed to panic, but to be useful an upstream crate must define panicking for libcore to use. The current interface for panicking is:This definition allows for panicking with any general message, but it does not allow for failing with a `Box<Any>` value. The reason for this is that libcore is not allowed to allocate.This module contains a few other panicking functions, but these are just the necessary lang items for the compiler. All panics are funneled through this one function. Currently, the actual symbol is declared in the standard library, but the location of this may change over time."],["prelude","The libcore prelude"],["ptr","Raw, unsafe pointers, `*const T`, and `*mut T`*See also the pointer primitive types.*"],["raw","Contains struct definitions for the layout of compiler built-in types.They can be used as targets of transmutes in unsafe code for manipulating the raw representations directly.Their definition should always match the ABI defined in `rustc::back::abi`."],["result","Error handling with the `Result` type`Result<T, E>` is the type used for returning and propagating errors. It is an enum with the variants, `Ok(T)`, representing success and containing a value, and `Err(E)`, representing error and containing an error value.Functions return `Result` whenever errors are expected and recoverable. In the `std` crate `Result` is most prominently used for I/O.A simple function returning `Result` might be defined and used like so:Pattern matching on `Result`s is clear and straightforward for simple cases, but `Result` comes with some convenience methods that make working with it more succinct.Results must be usedA common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. Result is annotated with the #[must_use] attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes `Result` especially useful with functions that may encounter errors but don't otherwise return a useful value.Consider the `write_all` method defined for I/O types by the `Write` trait:*Note: The actual definition of `Write` uses `io::Result`, which is just a synonym for `Result<T, io::Error>`.*This method doesn't produce a value, but the write may fail. It's crucial to handle the error case, and *not* write something like this:If you *do* write that in Rust, the compiler will give you a warning (by default, controlled by the `unused_must_use` lint).You might instead, if you don't want to handle the error, simply assert success with `expect`. This will panic if the write fails, providing a marginally useful message indicating why:You might also simply assert success:Or propagate the error up the call stack with `try!`:The `try!` macroWhen writing code that calls many functions that return the `Result` type, the error handling can be tedious.  The `try!` macro hides some of the boilerplate of propagating errors up the call stack.It replaces this:With this:*It's much nicer!*Wrapping an expression in `try!` will result in the unwrapped success (`Ok`) value, unless the result is `Err`, in which case `Err` is returned early from the enclosing function. Its simple definition makes it clear:`try!` is imported by the prelude and is available everywhere, but it can only be used in functions that return `Result` because of the early return of `Err` that it provides."],["slice","Slice management and manipulationFor more details `std::slice`."],["str","String manipulationFor more details, see std::str"],["sync","Synchronization primitives"],["u16","The 16-bit unsigned integer type.*See also the `u16` primitive type.*"],["u32","The 32-bit unsigned integer type.*See also the `u32` primitive type.*"],["u64","The 64-bit unsigned integer type.*See also the `u64` primitive type.*"],["u8","The 8-bit unsigned integer type.*See also the `u8` primitive type.*"],["usize","The pointer-sized unsigned integer type.*See also the `usize` primitive type.*"]]});