<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>The Rust Reference</title>

    <link rel="stylesheet" type="text/css" href="rust.css">

    <link rel="shortcut icon" href="https://www.rust-lang.org/favicon.ico">

<style>
  /* Display the full TOC */
  nav {
    column-count: auto;
    -moz-column-count: auto;
    -webkit-column-count: auto;
  }
  nav ul ul {
    display: block;
    padding-left: 2em;
  }
  #influences blockquote p:last-child {
    color: #999;
  }
</style>


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="versioninfo">
  <img src="https://www.rust-lang.org/logos/rust-logo-32x32-blk.png" width="32" height="32" alt="Rust logo"><br>
  <span class="white-sticker"><a href="https://www.rust-lang.org">Rust</a> 1.14.0-dev</span><br>
  <a href="https://github.com/rust-lang/rust/commit/da5b6467c33f7f86b4964b08b37726f7611a8f0c"
    class="hash white-sticker">da5b6467c</a>
</div>


    <h1 class="title">The Rust Reference</h1>
    <nav id="TOC"><ul>
<li><a href="#introduction">1 Introduction</a><ul></ul></li>
<li><a href="#notation">2 Notation</a><ul>
<li><a href="#unicode-productions">2.1 Unicode productions</a><ul></ul></li>
<li><a href="#string-table-productions">2.2 String table productions</a><ul></ul></li></ul></li>
<li><a href="#lexical-structure">3 Lexical structure</a><ul>
<li><a href="#input-format">3.1 Input format</a><ul></ul></li>
<li><a href="#identifiers">3.2 Identifiers</a><ul></ul></li>
<li><a href="#comments">3.3 Comments</a><ul></ul></li>
<li><a href="#whitespace">3.4 Whitespace</a><ul></ul></li>
<li><a href="#tokens">3.5 Tokens</a><ul>
<li><a href="#literals">3.5.1 Literals</a><ul>
<li><a href="#examples">3.5.1.1 Examples</a><ul>
<li><a href="#characters-and-strings">3.5.1.1.1 Characters and strings</a><ul></ul></li>
<li><a href="#byte-escapes">3.5.1.1.2 Byte escapes</a><ul></ul></li>
<li><a href="#unicode-escapes">3.5.1.1.3 Unicode escapes</a><ul></ul></li>
<li><a href="#quote-escapes">3.5.1.1.4 Quote escapes</a><ul></ul></li>
<li><a href="#numbers">3.5.1.1.5 Numbers</a><ul></ul></li>
<li><a href="#suffixes">3.5.1.1.6 Suffixes</a><ul></ul></li></ul></li>
<li><a href="#character-and-string-literals">3.5.1.2 Character and string literals</a><ul>
<li><a href="#character-literals">3.5.1.2.1 Character literals</a><ul></ul></li>
<li><a href="#string-literals">3.5.1.2.2 String literals</a><ul></ul></li>
<li><a href="#character-escapes">3.5.1.2.3 Character escapes</a><ul></ul></li>
<li><a href="#raw-string-literals">3.5.1.2.4 Raw string literals</a><ul></ul></li></ul></li>
<li><a href="#byte-and-byte-string-literals">3.5.1.3 Byte and byte string literals</a><ul>
<li><a href="#byte-literals">3.5.1.3.1 Byte literals</a><ul></ul></li>
<li><a href="#byte-string-literals">3.5.1.3.2 Byte string literals</a><ul></ul></li>
<li><a href="#raw-byte-string-literals">3.5.1.3.3 Raw byte string literals</a><ul></ul></li></ul></li>
<li><a href="#number-literals">3.5.1.4 Number literals</a><ul>
<li><a href="#integer-literals">3.5.1.4.1 Integer literals</a><ul></ul></li>
<li><a href="#floating-point-literals">3.5.1.4.2 Floating-point literals</a><ul></ul></li></ul></li>
<li><a href="#boolean-literals">3.5.1.5 Boolean literals</a><ul></ul></li></ul></li>
<li><a href="#symbols">3.5.2 Symbols</a><ul></ul></li></ul></li>
<li><a href="#paths">3.6 Paths</a><ul></ul></li></ul></li>
<li><a href="#syntax-extensions">4 Syntax extensions</a><ul>
<li><a href="#macros">4.1 Macros</a><ul>
<li><a href="#macro-by-example">4.1.1 Macro By Example</a><ul></ul></li>
<li><a href="#parsing-limitations">4.1.2 Parsing limitations</a><ul></ul></li></ul></li></ul></li>
<li><a href="#crates-and-source-files">5 Crates and source files</a><ul></ul></li>
<li><a href="#items-and-attributes">6 Items and attributes</a><ul>
<li><a href="#items">6.1 Items</a><ul>
<li><a href="#type-parameters">6.1.1 Type Parameters</a><ul></ul></li>
<li><a href="#modules">6.1.2 Modules</a><ul>
<li><a href="#extern-crate-declarations">6.1.2.1 Extern crate declarations</a><ul></ul></li>
<li><a href="#use-declarations">6.1.2.2 Use declarations</a><ul></ul></li></ul></li>
<li><a href="#functions">6.1.3 Functions</a><ul>
<li><a href="#generic-functions">6.1.3.1 Generic functions</a><ul></ul></li>
<li><a href="#diverging-functions">6.1.3.2 Diverging functions</a><ul></ul></li>
<li><a href="#extern-functions">6.1.3.3 Extern functions</a><ul></ul></li></ul></li>
<li><a href="#type-aliases">6.1.4 Type aliases</a><ul></ul></li>
<li><a href="#structs">6.1.5 Structs</a><ul></ul></li>
<li><a href="#enumerations">6.1.6 Enumerations</a><ul></ul></li>
<li><a href="#constant-items">6.1.7 Constant items</a><ul></ul></li>
<li><a href="#static-items">6.1.8 Static items</a><ul>
<li><a href="#mutable-statics">6.1.8.1 Mutable statics</a><ul></ul></li></ul></li>
<li><a href="#traits">6.1.9 Traits</a><ul></ul></li>
<li><a href="#implementations">6.1.10 Implementations</a><ul></ul></li>
<li><a href="#external-blocks">6.1.11 External blocks</a><ul></ul></li></ul></li>
<li><a href="#visibility-and-privacy">6.2 Visibility and Privacy</a><ul>
<li><a href="#re-exporting-and-visibility">6.2.1 Re-exporting and Visibility</a><ul></ul></li></ul></li>
<li><a href="#attributes">6.3 Attributes</a><ul>
<li><a href="#crate-only-attributes">6.3.1 Crate-only attributes</a><ul></ul></li>
<li><a href="#module-only-attributes">6.3.2 Module-only attributes</a><ul></ul></li>
<li><a href="#function-only-attributes">6.3.3 Function-only attributes</a><ul></ul></li>
<li><a href="#static-only-attributes">6.3.4 Static-only attributes</a><ul></ul></li>
<li><a href="#ffi-attributes">6.3.5 FFI attributes</a><ul></ul></li>
<li><a href="#macro-related-attributes">6.3.6 Macro-related attributes</a><ul></ul></li>
<li><a href="#miscellaneous-attributes">6.3.7 Miscellaneous attributes</a><ul></ul></li>
<li><a href="#conditional-compilation">6.3.8 Conditional compilation</a><ul></ul></li>
<li><a href="#lint-check-attributes">6.3.9 Lint check attributes</a><ul></ul></li>
<li><a href="#language-items">6.3.10 Language items</a><ul></ul></li>
<li><a href="#inline-attributes">6.3.11 Inline attributes</a><ul></ul></li>
<li><a href="#derive">6.3.12 <code>derive</code></a><ul></ul></li>
<li><a href="#compiler-features">6.3.13 Compiler Features</a><ul></ul></li></ul></li></ul></li>
<li><a href="#statements-and-expressions">7 Statements and expressions</a><ul>
<li><a href="#statements">7.1 Statements</a><ul>
<li><a href="#declaration-statements">7.1.1 Declaration statements</a><ul>
<li><a href="#item-declarations">7.1.1.1 Item declarations</a><ul></ul></li>
<li><a href="#let-statements">7.1.1.2 <code>let</code> statements</a><ul></ul></li></ul></li>
<li><a href="#expression-statements">7.1.2 Expression statements</a><ul></ul></li></ul></li>
<li><a href="#expressions">7.2 Expressions</a><ul>
<li><a href="#lvalues-rvalues-and-temporaries">7.2.0.1 Lvalues, rvalues and temporaries</a><ul>
<li><a href="#temporary-lifetimes">7.2.0.1.1 Temporary lifetimes</a><ul></ul></li></ul></li>
<li><a href="#moved-and-copied-types">7.2.0.2 Moved and copied types</a><ul></ul></li>
<li><a href="#literal-expressions">7.2.1 Literal expressions</a><ul></ul></li>
<li><a href="#path-expressions">7.2.2 Path expressions</a><ul></ul></li>
<li><a href="#tuple-expressions">7.2.3 Tuple expressions</a><ul></ul></li>
<li><a href="#struct-expressions">7.2.4 Struct expressions</a><ul></ul></li>
<li><a href="#block-expressions">7.2.5 Block expressions</a><ul></ul></li>
<li><a href="#method-call-expressions">7.2.6 Method-call expressions</a><ul></ul></li>
<li><a href="#field-expressions">7.2.7 Field expressions</a><ul></ul></li>
<li><a href="#array-expressions">7.2.8 Array expressions</a><ul></ul></li>
<li><a href="#index-expressions">7.2.9 Index expressions</a><ul></ul></li>
<li><a href="#range-expressions">7.2.10 Range expressions</a><ul></ul></li>
<li><a href="#unary-operator-expressions">7.2.11 Unary operator expressions</a><ul></ul></li>
<li><a href="#binary-operator-expressions">7.2.12 Binary operator expressions</a><ul>
<li><a href="#arithmetic-operators">7.2.12.1 Arithmetic operators</a><ul></ul></li>
<li><a href="#bitwise-operators">7.2.12.2 Bitwise operators</a><ul></ul></li>
<li><a href="#lazy-boolean-operators">7.2.12.3 Lazy boolean operators</a><ul></ul></li>
<li><a href="#comparison-operators">7.2.12.4 Comparison operators</a><ul></ul></li>
<li><a href="#type-cast-expressions">7.2.12.5 Type cast expressions</a><ul></ul></li>
<li><a href="#assignment-expressions">7.2.12.6 Assignment expressions</a><ul></ul></li>
<li><a href="#compound-assignment-expressions">7.2.12.7 Compound assignment expressions</a><ul></ul></li>
<li><a href="#operator-precedence">7.2.12.8 Operator precedence</a><ul></ul></li></ul></li>
<li><a href="#grouped-expressions">7.2.13 Grouped expressions</a><ul></ul></li>
<li><a href="#call-expressions">7.2.14 Call expressions</a><ul></ul></li>
<li><a href="#lambda-expressions">7.2.15 Lambda expressions</a><ul></ul></li>
<li><a href="#infinite-loops">7.2.16 Infinite loops</a><ul></ul></li>
<li><a href="#break-expressions">7.2.17 <code>break</code> expressions</a><ul></ul></li>
<li><a href="#continue-expressions">7.2.18 <code>continue</code> expressions</a><ul></ul></li>
<li><a href="#while-loops">7.2.19 <code>while</code> loops</a><ul></ul></li>
<li><a href="#for-expressions">7.2.20 <code>for</code> expressions</a><ul></ul></li>
<li><a href="#if-expressions">7.2.21 <code>if</code> expressions</a><ul></ul></li>
<li><a href="#match-expressions">7.2.22 <code>match</code> expressions</a><ul></ul></li>
<li><a href="#if-let-expressions">7.2.23 <code>if let</code> expressions</a><ul></ul></li>
<li><a href="#while-let-loops">7.2.24 <code>while let</code> loops</a><ul></ul></li>
<li><a href="#return-expressions">7.2.25 <code>return</code> expressions</a><ul></ul></li></ul></li></ul></li>
<li><a href="#type-system">8 Type system</a><ul>
<li><a href="#types">8.1 Types</a><ul>
<li><a href="#primitive-types">8.1.1 Primitive types</a><ul>
<li><a href="#machine-types">8.1.1.1 Machine types</a><ul></ul></li>
<li><a href="#machine-dependent-integer-types">8.1.1.2 Machine-dependent integer types</a><ul></ul></li></ul></li>
<li><a href="#textual-types">8.1.2 Textual types</a><ul></ul></li>
<li><a href="#tuple-types">8.1.3 Tuple types</a><ul></ul></li>
<li><a href="#array-and-slice-types">8.1.4 Array, and Slice types</a><ul></ul></li>
<li><a href="#struct-types">8.1.5 Struct types</a><ul></ul></li>
<li><a href="#enumerated-types">8.1.6 Enumerated types</a><ul></ul></li>
<li><a href="#recursive-types">8.1.7 Recursive types</a><ul></ul></li>
<li><a href="#pointer-types">8.1.8 Pointer types</a><ul></ul></li>
<li><a href="#function-types">8.1.9 Function types</a><ul>
<li><a href="#function-types-for-specific-items">8.1.9.1 Function types for specific items</a><ul></ul></li></ul></li>
<li><a href="#closure-types">8.1.10 Closure types</a><ul></ul></li>
<li><a href="#trait-objects">8.1.11 Trait objects</a><ul></ul></li>
<li><a href="#type-parameters-1">8.1.12 Type parameters</a><ul></ul></li>
<li><a href="#self-types">8.1.13 Self types</a><ul></ul></li></ul></li>
<li><a href="#subtyping">8.2 Subtyping</a><ul></ul></li>
<li><a href="#type-coercions">8.3 Type coercions</a><ul>
<li><a href="#coercion-sites">8.3.1 Coercion sites</a><ul></ul></li>
<li><a href="#coercion-types">8.3.2 Coercion types</a><ul></ul></li></ul></li></ul></li>
<li><a href="#special-traits">9 Special traits</a><ul>
<li><a href="#the-copy-trait">9.1 The <code>Copy</code> trait</a><ul></ul></li>
<li><a href="#the-sized-trait">9.2 The <code>Sized</code> trait</a><ul></ul></li>
<li><a href="#the-drop-trait">9.3 The <code>Drop</code> trait</a><ul></ul></li>
<li><a href="#the-deref-trait">9.4 The <code>Deref</code> trait</a><ul></ul></li>
<li><a href="#the-send-trait">9.5 The <code>Send</code> trait</a><ul></ul></li>
<li><a href="#the-sync-trait">9.6 The <code>Sync</code> trait</a><ul></ul></li></ul></li>
<li><a href="#memory-model">10 Memory model</a><ul>
<li><a href="#memory-allocation-and-lifetime">10.0.1 Memory allocation and lifetime</a><ul></ul></li>
<li><a href="#memory-ownership">10.0.2 Memory ownership</a><ul></ul></li>
<li><a href="#variables">10.0.3 Variables</a><ul></ul></li></ul></li>
<li><a href="#linkage">11 Linkage</a><ul></ul></li>
<li><a href="#unsafety">12 Unsafety</a><ul>
<li><a href="#unsafe-functions">12.1 Unsafe functions</a><ul></ul></li>
<li><a href="#unsafe-blocks">12.2 Unsafe blocks</a><ul></ul></li>
<li><a href="#behavior-considered-undefined">12.3 Behavior considered undefined</a><ul></ul></li>
<li><a href="#behavior-not-considered-unsafe">12.4 Behavior not considered unsafe</a><ul></ul></li></ul></li>
<li><a href="#appendix-influences">13 Appendix: Influences</a><ul></ul></li></ul></nav>
<h1 id='introduction' class='section-header'><a href='#introduction'>1 Introduction</a></h1>
<p>This document is the primary reference for the Rust programming language. It
provides three kinds of material:</p>

<ul>
<li>Chapters that informally describe each language construct and their use.</li>
<li>Chapters that informally describe the memory model, concurrency model,
runtime services, linkage model and debugging facilities.</li>
<li>Appendix chapters providing rationale and references to languages that
influenced the design.</li>
</ul>

<p>This document does not serve as an introduction to the language. Background
familiarity with the language is assumed. A separate <a href="book/index.html">book</a> is available to
help acquire such background familiarity.</p>

<p>This document also does not serve as a reference to the <a href="std/index.html">standard</a> library
included in the language distribution. Those libraries are documented
separately by extracting documentation attributes from their source code. Many
of the features that one might expect to be language features are library
features in Rust, so what you&#39;re looking for may be there, not here.</p>

<p>You may also be interested in the <a href="grammar.html">grammar</a>.</p>

<h1 id='notation' class='section-header'><a href='#notation'>2 Notation</a></h1>
<h2 id='unicode-productions' class='section-header'><a href='#unicode-productions'>2.1 Unicode productions</a></h2>
<p>A few productions in Rust&#39;s grammar permit Unicode code points outside the
ASCII range. We define these productions in terms of character properties
specified in the Unicode standard, rather than in terms of ASCII-range code
points. The grammar has a <a href="grammar.html#special-unicode-productions">Special Unicode Productions</a>
section that lists these productions.</p>

<h2 id='string-table-productions' class='section-header'><a href='#string-table-productions'>2.2 String table productions</a></h2>
<p>Some rules in the grammar &mdash; notably <a href="#unary-operator-expressions">unary
operators</a>, <a href="#binary-operator-expressions">binary
operators</a>, and <a href="grammar.html#keywords">keywords</a> &mdash; are
given in a simplified form: as a listing of a table of unquoted, printable
whitespace-separated strings. These cases form a subset of the rules regarding
the <a href="#tokens">token</a> rule, and are assumed to be the result of a
lexical-analysis phase feeding the parser, driven by a DFA, operating over the
disjunction of all such string table entries.</p>

<p>When such a string enclosed in double-quotes (<code>&quot;</code>) occurs inside the grammar,
it is an implicit reference to a single member of such a string table
production. See <a href="#tokens">tokens</a> for more information.</p>

<h1 id='lexical-structure' class='section-header'><a href='#lexical-structure'>3 Lexical structure</a></h1>
<h2 id='input-format' class='section-header'><a href='#input-format'>3.1 Input format</a></h2>
<p>Rust input is interpreted as a sequence of Unicode code points encoded in UTF-8.
Most Rust grammar rules are defined in terms of printable ASCII-range
code points, but a small number are defined in terms of Unicode properties or
explicit code point lists. <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<h2 id='identifiers' class='section-header'><a href='#identifiers'>3.2 Identifiers</a></h2>
<p>An identifier is any nonempty Unicode<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup> string of the following form:</p>

<p>Either</p>

<ul>
<li>The first character has property <code>XID_start</code></li>
<li>The remaining characters have property <code>XID_continue</code></li>
</ul>

<p>Or</p>

<ul>
<li>The first character is <code>_</code></li>
<li>The identifier is more than one character, <code>_</code> alone is not an identifier</li>
<li>The remaining characters have property <code>XID_continue</code></li>
</ul>

<p>that does <em>not</em> occur in the set of <a href="grammar.html#keywords">keywords</a>.</p>

<blockquote>
<p><strong>Note</strong>: <code>XID_start</code> and <code>XID_continue</code> as character properties cover the
character ranges used to form the more familiar C and Java language-family
identifiers.</p>
</blockquote>

<h2 id='comments' class='section-header'><a href='#comments'>3.3 Comments</a></h2>
<p>Comments in Rust code follow the general C++ style of line (<code>//</code>) and
block (<code>/* ... */</code>) comment forms. Nested block comments are supported.</p>

<p>Line comments beginning with exactly <em>three</em> slashes (<code>///</code>), and block
comments (<code>/** ... */</code>), are interpreted as a special syntax for <code>doc</code>
<a href="#attributes">attributes</a>. That is, they are equivalent to writing
<code>#[doc=&quot;...&quot;]</code> around the body of the comment, i.e., <code>/// Foo</code> turns into
<code>#[doc=&quot;Foo&quot;]</code>.</p>

<p>Line comments beginning with <code>//!</code> and block comments <code>/*! ... */</code> are
doc comments that apply to the parent of the comment, rather than the item
that follows.  That is, they are equivalent to writing <code>#![doc=&quot;...&quot;]</code> around
the body of the comment. <code>//!</code> comments are usually used to document
modules that occupy a source file.</p>

<p>Non-doc comments are interpreted as a form of whitespace.</p>

<h2 id='whitespace' class='section-header'><a href='#whitespace'>3.4 Whitespace</a></h2>
<p>Whitespace is any non-empty string containing only characters that have the
<code>Pattern_White_Space</code> Unicode property, namely:</p>

<ul>
<li><code>U+0009</code> (horizontal tab, <code>&#39;\t&#39;</code>)</li>
<li><code>U+000A</code> (line feed, <code>&#39;\n&#39;</code>)</li>
<li><code>U+000B</code> (vertical tab)</li>
<li><code>U+000C</code> (form feed)</li>
<li><code>U+000D</code> (carriage return, <code>&#39;\r&#39;</code>)</li>
<li><code>U+0020</code> (space, <code>&#39; &#39;</code>)</li>
<li><code>U+0085</code> (next line)</li>
<li><code>U+200E</code> (left-to-right mark)</li>
<li><code>U+200F</code> (right-to-left mark)</li>
<li><code>U+2028</code> (line separator)</li>
<li><code>U+2029</code> (paragraph separator)</li>
</ul>

<p>Rust is a &quot;free-form&quot; language, meaning that all forms of whitespace serve only
to separate <em>tokens</em> in the grammar, and have no semantic significance.</p>

<p>A Rust program has identical meaning if each whitespace element is replaced
with any other legal whitespace element, such as a single space character.</p>

<h2 id='tokens' class='section-header'><a href='#tokens'>3.5 Tokens</a></h2>
<p>Tokens are primitive productions in the grammar defined by regular
(non-recursive) languages. &quot;Simple&quot; tokens are given in <a href="#string-table-productions">string table
production</a> form, and occur in the rest of the
grammar as double-quoted strings. Other tokens have exact rules given.</p>

<h3 id='literals' class='section-header'><a href='#literals'>3.5.1 Literals</a></h3>
<p>A literal is an expression consisting of a single token, rather than a sequence
of tokens, that immediately and directly denotes the value it evaluates to,
rather than referring to it by name or some other evaluation rule. A literal is
a form of constant expression, so is evaluated (primarily) at compile time.</p>

<h4 id='examples' class='section-header'><a href='#examples'>3.5.1.1 Examples</a></h4>
<h5 id='characters-and-strings' class='section-header'><a href='#characters-and-strings'>3.5.1.1.1 Characters and strings</a></h5>
<table>
<thead>
<tr>
<th></th>
<th>Example</th>
<th><code>#</code> sets</th>
<th>Characters</th>
<th>Escapes</th>
</tr>
</thead>

<tbody>
<tr>
<td><a href="#character-literals">Character</a></td>
<td><code>&#39;H&#39;</code></td>
<td><code>N/A</code></td>
<td>All Unicode</td>
<td><a href="#quote-escapes">Quote</a> &amp; <a href="#byte-escapes">Byte</a> &amp; <a href="#unicode-escapes">Unicode</a></td>
</tr>
<tr>
<td><a href="#string-literals">String</a></td>
<td><code>&quot;hello&quot;</code></td>
<td><code>N/A</code></td>
<td>All Unicode</td>
<td><a href="#quote-escapes">Quote</a> &amp; <a href="#byte-escapes">Byte</a> &amp; <a href="#unicode-escapes">Unicode</a></td>
</tr>
<tr>
<td><a href="#raw-string-literals">Raw</a></td>
<td><code>r#&quot;hello&quot;#</code></td>
<td><code>0...</code></td>
<td>All Unicode</td>
<td><code>N/A</code></td>
</tr>
<tr>
<td><a href="#byte-literals">Byte</a></td>
<td><code>b&#39;H&#39;</code></td>
<td><code>N/A</code></td>
<td>All ASCII</td>
<td><a href="#quote-escapes">Quote</a> &amp; <a href="#byte-escapes">Byte</a></td>
</tr>
<tr>
<td><a href="#byte-string-literals">Byte string</a></td>
<td><code>b&quot;hello&quot;</code></td>
<td><code>N/A</code></td>
<td>All ASCII</td>
<td><a href="#quote-escapes">Quote</a> &amp; <a href="#byte-escapes">Byte</a></td>
</tr>
<tr>
<td><a href="#raw-byte-string-literals">Raw byte string</a></td>
<td><code>br#&quot;hello&quot;#</code></td>
<td><code>0...</code></td>
<td>All ASCII</td>
<td><code>N/A</code></td>
</tr>
</tbody>
</table>

<h5 id='byte-escapes' class='section-header'><a href='#byte-escapes'>3.5.1.1.2 Byte escapes</a></h5>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>\x7F</code></td>
<td>8-bit character code (exactly 2 digits)</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>Newline</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>Carriage return</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Tab</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>Backslash</td>
</tr>
<tr>
<td><code>\0</code></td>
<td>Null</td>
</tr>
</tbody>
</table>

<h5 id='unicode-escapes' class='section-header'><a href='#unicode-escapes'>3.5.1.1.3 Unicode escapes</a></h5>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>\u{7FFF}</code></td>
<td>24-bit Unicode character code (up to 6 digits)</td>
</tr>
</tbody>
</table>

<h5 id='quote-escapes' class='section-header'><a href='#quote-escapes'>3.5.1.1.4 Quote escapes</a></h5>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>\&#39;</code></td>
<td>Single quote</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>Double quote</td>
</tr>
</tbody>
</table>

<h5 id='numbers' class='section-header'><a href='#numbers'>3.5.1.1.5 Numbers</a></h5>
<table>
<thead>
<tr>
<th><a href="#number-literals">Number literals</a><code>*</code></th>
<th>Example</th>
<th>Exponentiation</th>
<th>Suffixes</th>
</tr>
</thead>

<tbody>
<tr>
<td>Decimal integer</td>
<td><code>98_222</code></td>
<td><code>N/A</code></td>
<td>Integer suffixes</td>
</tr>
<tr>
<td>Hex integer</td>
<td><code>0xff</code></td>
<td><code>N/A</code></td>
<td>Integer suffixes</td>
</tr>
<tr>
<td>Octal integer</td>
<td><code>0o77</code></td>
<td><code>N/A</code></td>
<td>Integer suffixes</td>
</tr>
<tr>
<td>Binary integer</td>
<td><code>0b1111_0000</code></td>
<td><code>N/A</code></td>
<td>Integer suffixes</td>
</tr>
<tr>
<td>Floating-point</td>
<td><code>123.0E+77</code></td>
<td><code>Optional</code></td>
<td>Floating-point suffixes</td>
</tr>
</tbody>
</table>

<p><code>*</code> All number literals allow <code>_</code> as a visual separator: <code>1_234.0E+18f64</code></p>

<h5 id='suffixes' class='section-header'><a href='#suffixes'>3.5.1.1.6 Suffixes</a></h5>
<table>
<thead>
<tr>
<th>Integer</th>
<th>Floating-point</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>isize</code>, <code>usize</code></td>
<td><code>f32</code>, <code>f64</code></td>
</tr>
</tbody>
</table>

<h4 id='character-and-string-literals' class='section-header'><a href='#character-and-string-literals'>3.5.1.2 Character and string literals</a></h4>
<h5 id='character-literals' class='section-header'><a href='#character-literals'>3.5.1.2.1 Character literals</a></h5>
<p>A <em>character literal</em> is a single Unicode character enclosed within two
<code>U+0027</code> (single-quote) characters, with the exception of <code>U+0027</code> itself,
which must be <em>escaped</em> by a preceding <code>U+005C</code> character (<code>\</code>).</p>

<h5 id='string-literals' class='section-header'><a href='#string-literals'>3.5.1.2.2 String literals</a></h5>
<p>A <em>string literal</em> is a sequence of any Unicode characters enclosed within two
<code>U+0022</code> (double-quote) characters, with the exception of <code>U+0022</code> itself,
which must be <em>escaped</em> by a preceding <code>U+005C</code> character (<code>\</code>).</p>

<p>Line-break characters are allowed in string literals. Normally they represent
themselves (i.e. no translation), but as a special exception, when an unescaped
<code>U+005C</code> character (<code>\</code>) occurs immediately before the newline (<code>U+000A</code>), the
<code>U+005C</code> character, the newline, and all whitespace at the beginning of the
next line are ignored. Thus <code>a</code> and <code>b</code> are equal:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='string'>&quot;foobar&quot;</span>;
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='string'>&quot;foo\
         bar&quot;</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>,<span class='ident'>b</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20a%20%3D%20%22foobar%22%3B%0Alet%20b%20%3D%20%22foo%5C%0A%20%20%20%20%20%20%20%20%20bar%22%3B%0A%0Aassert_eq!(a%2Cb)%3B%0A%7D">Run</a></pre>

<h5 id='character-escapes' class='section-header'><a href='#character-escapes'>3.5.1.2.3 Character escapes</a></h5>
<p>Some additional <em>escapes</em> are available in either character or non-raw string
literals. An escape starts with a <code>U+005C</code> (<code>\</code>) and continues with one of the
following forms:</p>

<ul>
<li>An <em>8-bit code point escape</em> starts with <code>U+0078</code> (<code>x</code>) and is
followed by exactly two <em>hex digits</em>. It denotes the Unicode code point
equal to the provided hex value.</li>
<li>A <em>24-bit code point escape</em> starts with <code>U+0075</code> (<code>u</code>) and is followed
by up to six <em>hex digits</em> surrounded by braces <code>U+007B</code> (<code>{</code>) and <code>U+007D</code>
(<code>}</code>). It denotes the Unicode code point equal to the provided hex value.</li>
<li>A <em>whitespace escape</em> is one of the characters <code>U+006E</code> (<code>n</code>), <code>U+0072</code>
(<code>r</code>), or <code>U+0074</code> (<code>t</code>), denoting the Unicode values <code>U+000A</code> (LF),
<code>U+000D</code> (CR) or <code>U+0009</code> (HT) respectively.</li>
<li>The <em>null escape</em> is the character <code>U+0030</code> (<code>0</code>) and denotes the Unicode
value <code>U+0000</code> (NUL).</li>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be
escaped in order to denote <em>itself</em>.</li>
</ul>

<h5 id='raw-string-literals' class='section-header'><a href='#raw-string-literals'>3.5.1.2.4 Raw string literals</a></h5>
<p>Raw string literals do not process any escapes. They start with the character
<code>U+0072</code> (<code>r</code>), followed by zero or more of the character <code>U+0023</code> (<code>#</code>) and a
<code>U+0022</code> (double-quote) character. The <em>raw string body</em> can contain any sequence
of Unicode characters and is terminated only by another <code>U+0022</code> (double-quote)
character, followed by the same number of <code>U+0023</code> (<code>#</code>) characters that preceded
the opening <code>U+0022</code> (double-quote) character.</p>

<p>All Unicode characters contained in the raw string body represent themselves,
the characters <code>U+0022</code> (double-quote) (except when followed by at least as
many <code>U+0023</code> (<code>#</code>) characters as were used to start the raw string literal) or
<code>U+005C</code> (<code>\</code>) do not have any special meaning.</p>

<p>Examples for string literals:</p>

<pre class='rust rust-example-rendered'>
<span class='string'>&quot;foo&quot;</span>; <span class='string'>r&quot;foo&quot;</span>;                     <span class='comment'>// foo</span>
<span class='string'>&quot;\&quot;foo\&quot;&quot;</span>; <span class='string'>r#&quot;&quot;foo&quot;&quot;#</span>;             <span class='comment'>// &quot;foo&quot;</span>

<span class='string'>&quot;foo #\&quot;# bar&quot;</span>;
<span class='string'>r##&quot;foo #&quot;# bar&quot;##</span>;                <span class='comment'>// foo #&quot;# bar</span>

<span class='string'>&quot;\x52&quot;</span>; <span class='string'>&quot;R&quot;</span>; <span class='string'>r&quot;R&quot;</span>;                 <span class='comment'>// R</span>
<span class='string'>&quot;\\x52&quot;</span>; <span class='string'>r&quot;\x52&quot;</span>;                  <span class='comment'>// \x52</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%22foo%22%3B%20r%22foo%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20foo%0A%22%5C%22foo%5C%22%22%3B%20r%23%22%22foo%22%22%23%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%22foo%22%0A%0A%22foo%20%23%5C%22%23%20bar%22%3B%0Ar%23%23%22foo%20%23%22%23%20bar%22%23%23%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20foo%20%23%22%23%20bar%0A%0A%22%5Cx52%22%3B%20%22R%22%3B%20r%22R%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20R%0A%22%5C%5Cx52%22%3B%20r%22%5Cx52%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%5Cx52%0A%7D">Run</a></pre>

<h4 id='byte-and-byte-string-literals' class='section-header'><a href='#byte-and-byte-string-literals'>3.5.1.3 Byte and byte string literals</a></h4>
<h5 id='byte-literals' class='section-header'><a href='#byte-literals'>3.5.1.3.1 Byte literals</a></h5>
<p>A <em>byte literal</em> is a single ASCII character (in the <code>U+0000</code> to <code>U+007F</code>
range) or a single <em>escape</em> preceded by the characters <code>U+0062</code> (<code>b</code>) and
<code>U+0027</code> (single-quote), and followed by the character <code>U+0027</code>. If the character
<code>U+0027</code> is present within the literal, it must be <em>escaped</em> by a preceding
<code>U+005C</code> (<code>\</code>) character. It is equivalent to a <code>u8</code> unsigned 8-bit integer
<em>number literal</em>.</p>

<h5 id='byte-string-literals' class='section-header'><a href='#byte-string-literals'>3.5.1.3.2 Byte string literals</a></h5>
<p>A non-raw <em>byte string literal</em> is a sequence of ASCII characters and <em>escapes</em>,
preceded by the characters <code>U+0062</code> (<code>b</code>) and <code>U+0022</code> (double-quote), and
followed by the character <code>U+0022</code>. If the character <code>U+0022</code> is present within
the literal, it must be <em>escaped</em> by a preceding <code>U+005C</code> (<code>\</code>) character.
Alternatively, a byte string literal can be a <em>raw byte string literal</em>, defined
below. A byte string literal of length <code>n</code> is equivalent to a <code>&amp;&#39;static [u8; n]</code> borrowed fixed-sized array
of unsigned 8-bit integers.</p>

<p>Some additional <em>escapes</em> are available in either byte or non-raw byte string
literals. An escape starts with a <code>U+005C</code> (<code>\</code>) and continues with one of the
following forms:</p>

<ul>
<li>A <em>byte escape</em> escape starts with <code>U+0078</code> (<code>x</code>) and is
followed by exactly two <em>hex digits</em>. It denotes the byte
equal to the provided hex value.</li>
<li>A <em>whitespace escape</em> is one of the characters <code>U+006E</code> (<code>n</code>), <code>U+0072</code>
(<code>r</code>), or <code>U+0074</code> (<code>t</code>), denoting the bytes values <code>0x0A</code> (ASCII LF),
<code>0x0D</code> (ASCII CR) or <code>0x09</code> (ASCII HT) respectively.</li>
<li>The <em>null escape</em> is the character <code>U+0030</code> (<code>0</code>) and denotes the byte
value <code>0x00</code> (ASCII NUL).</li>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be
escaped in order to denote its ASCII encoding <code>0x5C</code>.</li>
</ul>

<h5 id='raw-byte-string-literals' class='section-header'><a href='#raw-byte-string-literals'>3.5.1.3.3 Raw byte string literals</a></h5>
<p>Raw byte string literals do not process any escapes. They start with the
character <code>U+0062</code> (<code>b</code>), followed by <code>U+0072</code> (<code>r</code>), followed by zero or more
of the character <code>U+0023</code> (<code>#</code>), and a <code>U+0022</code> (double-quote) character. The
<em>raw string body</em> can contain any sequence of ASCII characters and is terminated
only by another <code>U+0022</code> (double-quote) character, followed by the same number of
<code>U+0023</code> (<code>#</code>) characters that preceded the opening <code>U+0022</code> (double-quote)
character. A raw byte string literal can not contain any non-ASCII byte.</p>

<p>All characters contained in the raw string body represent their ASCII encoding,
the characters <code>U+0022</code> (double-quote) (except when followed by at least as
many <code>U+0023</code> (<code>#</code>) characters as were used to start the raw string literal) or
<code>U+005C</code> (<code>\</code>) do not have any special meaning.</p>

<p>Examples for byte string literals:</p>

<pre class='rust rust-example-rendered'>
<span class='string'>b&quot;foo&quot;</span>; <span class='string'>br&quot;foo&quot;</span>;                     <span class='comment'>// foo</span>
<span class='string'>b&quot;\&quot;foo\&quot;&quot;</span>; <span class='string'>br#&quot;&quot;foo&quot;&quot;#</span>;             <span class='comment'>// &quot;foo&quot;</span>

<span class='string'>b&quot;foo #\&quot;# bar&quot;</span>;
<span class='string'>br##&quot;foo #&quot;# bar&quot;##</span>;                 <span class='comment'>// foo #&quot;# bar</span>

<span class='string'>b&quot;\x52&quot;</span>; <span class='string'>b&quot;R&quot;</span>; <span class='string'>br&quot;R&quot;</span>;                <span class='comment'>// R</span>
<span class='string'>b&quot;\\x52&quot;</span>; <span class='string'>br&quot;\x52&quot;</span>;                  <span class='comment'>// \x52</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ab%22foo%22%3B%20br%22foo%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20foo%0Ab%22%5C%22foo%5C%22%22%3B%20br%23%22%22foo%22%22%23%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%22foo%22%0A%0Ab%22foo%20%23%5C%22%23%20bar%22%3B%0Abr%23%23%22foo%20%23%22%23%20bar%22%23%23%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20foo%20%23%22%23%20bar%0A%0Ab%22%5Cx52%22%3B%20b%22R%22%3B%20br%22R%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20R%0Ab%22%5C%5Cx52%22%3B%20br%22%5Cx52%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%5Cx52%0A%7D">Run</a></pre>

<h4 id='number-literals' class='section-header'><a href='#number-literals'>3.5.1.4 Number literals</a></h4>
<p>A <em>number literal</em> is either an <em>integer literal</em> or a <em>floating-point
literal</em>. The grammar for recognizing the two kinds of literals is mixed.</p>

<h5 id='integer-literals' class='section-header'><a href='#integer-literals'>3.5.1.4.1 Integer literals</a></h5>
<p>An <em>integer literal</em> has one of four forms:</p>

<ul>
<li>A <em>decimal literal</em> starts with a <em>decimal digit</em> and continues with any
mixture of <em>decimal digits</em> and <em>underscores</em>.</li>
<li>A <em>hex literal</em> starts with the character sequence <code>U+0030</code> <code>U+0078</code>
(<code>0x</code>) and continues as any mixture of hex digits and underscores.</li>
<li>An <em>octal literal</em> starts with the character sequence <code>U+0030</code> <code>U+006F</code>
(<code>0o</code>) and continues as any mixture of octal digits and underscores.</li>
<li>A <em>binary literal</em> starts with the character sequence <code>U+0030</code> <code>U+0062</code>
(<code>0b</code>) and continues as any mixture of binary digits and underscores.</li>
</ul>

<p>Like any literal, an integer literal may be followed (immediately,
without any spaces) by an <em>integer suffix</em>, which forcibly sets the
type of the literal. The integer suffix must be the name of one of the
integral types: <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>,
<code>isize</code>, or <code>usize</code>.</p>

<p>The type of an <em>unsuffixed</em> integer literal is determined by type inference:</p>

<ul>
<li><p>If an integer type can be <em>uniquely</em> determined from the surrounding
program context, the unsuffixed integer literal has that type.</p></li>
<li><p>If the program context under-constrains the type, it defaults to the
signed 32-bit integer <code>i32</code>.</p></li>
<li><p>If the program context over-constrains the type, it is considered a
static type error.</p></li>
</ul>

<p>Examples of integer literals of various forms:</p>

<pre class='rust rust-example-rendered'>
<span class='number'>123i32</span>;                            <span class='comment'>// type i32</span>
<span class='number'>123u32</span>;                            <span class='comment'>// type u32</span>
<span class='number'>123_u32</span>;                           <span class='comment'>// type u32</span>
<span class='number'>0xff_u8</span>;                           <span class='comment'>// type u8</span>
<span class='number'>0o70_i16</span>;                          <span class='comment'>// type i16</span>
<span class='number'>0b1111_1111_1001_0000_i32</span>;         <span class='comment'>// type i32</span>
<span class='number'>0usize</span>;                            <span class='comment'>// type usize</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A123i32%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20type%20i32%0A123u32%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20type%20u32%0A123_u32%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20type%20u32%0A0xff_u8%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20type%20u8%0A0o70_i16%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20type%20i16%0A0b1111_1111_1001_0000_i32%3B%20%20%20%20%20%20%20%20%20%2F%2F%20type%20i32%0A0usize%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20type%20usize%0A%7D">Run</a></pre>

<p>Note that the Rust syntax considers <code>-1i8</code> as an application of the <a href="#unary-operator-expressions">unary minus
operator</a> to an integer literal <code>1i8</code>, rather than
a single integer literal.</p>

<h5 id='floating-point-literals' class='section-header'><a href='#floating-point-literals'>3.5.1.4.2 Floating-point literals</a></h5>
<p>A <em>floating-point literal</em> has one of two forms:</p>

<ul>
<li>A <em>decimal literal</em> followed by a period character <code>U+002E</code> (<code>.</code>). This is
optionally followed by another decimal literal, with an optional <em>exponent</em>.</li>
<li>A single <em>decimal literal</em> followed by an <em>exponent</em>.</li>
</ul>

<p>Like integer literals, a floating-point literal may be followed by a
suffix, so long as the pre-suffix part does not end with <code>U+002E</code> (<code>.</code>).
The suffix forcibly sets the type of the literal. There are two valid
<em>floating-point suffixes</em>, <code>f32</code> and <code>f64</code> (the 32-bit and 64-bit floating point
types), which explicitly determine the type of the literal.</p>

<p>The type of an <em>unsuffixed</em> floating-point literal is determined by
type inference:</p>

<ul>
<li><p>If a floating-point type can be <em>uniquely</em> determined from the
surrounding program context, the unsuffixed floating-point literal
has that type.</p></li>
<li><p>If the program context under-constrains the type, it defaults to <code>f64</code>.</p></li>
<li><p>If the program context over-constrains the type, it is considered a
static type error.</p></li>
</ul>

<p>Examples of floating-point literals of various forms:</p>

<pre class='rust rust-example-rendered'>
<span class='number'>123.0f64</span>;        <span class='comment'>// type f64</span>
<span class='number'>0.1f64</span>;          <span class='comment'>// type f64</span>
<span class='number'>0.1f32</span>;          <span class='comment'>// type f32</span>
<span class='number'>12E+99_f64</span>;      <span class='comment'>// type f64</span>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>f64</span> <span class='op'>=</span> <span class='number'>2.</span>; <span class='comment'>// type f64</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A123.0f64%3B%20%20%20%20%20%20%20%20%2F%2F%20type%20f64%0A0.1f64%3B%20%20%20%20%20%20%20%20%20%20%2F%2F%20type%20f64%0A0.1f32%3B%20%20%20%20%20%20%20%20%20%20%2F%2F%20type%20f32%0A12E%2B99_f64%3B%20%20%20%20%20%20%2F%2F%20type%20f64%0Alet%20x%3A%20f64%20%3D%202.%3B%20%2F%2F%20type%20f64%0A%7D">Run</a></pre>

<p>This last example is different because it is not possible to use the suffix
syntax with a floating point literal ending in a period. <code>2.f64</code> would attempt
to call a method named <code>f64</code> on <code>2</code>.</p>

<p>The representation semantics of floating-point numbers are described in
<a href="#machine-types">&quot;Machine Types&quot;</a>.</p>

<h4 id='boolean-literals' class='section-header'><a href='#boolean-literals'>3.5.1.5 Boolean literals</a></h4>
<p>The two values of the boolean type are written <code>true</code> and <code>false</code>.</p>

<h3 id='symbols' class='section-header'><a href='#symbols'>3.5.2 Symbols</a></h3>
<p>Symbols are a general class of printable <a href="#tokens">tokens</a> that play structural
roles in a variety of grammar productions. They are a
set of remaining miscellaneous printable tokens that do not
otherwise appear as <a href="#unary-operator-expressions">unary operators</a>, <a href="#binary-operator-expressions">binary
operators</a>, or <a href="grammar.html#keywords">keywords</a>.
They are catalogued in <a href="grammar.html#symbols">the Symbols section</a> of the Grammar document.</p>

<h2 id='paths' class='section-header'><a href='#paths'>3.6 Paths</a></h2>
<p>A <em>path</em> is a sequence of one or more path components <em>logically</em> separated by
a namespace qualifier (<code>::</code>). If a path consists of only one component, it may
refer to either an <a href="#items">item</a> or a <a href="#variables">variable</a> in a local control
scope. If a path has multiple components, it refers to an item.</p>

<p>Every item has a <em>canonical path</em> within its crate, but the path naming an item
is only meaningful within a given crate. There is no global namespace across
crates; an item&#39;s canonical path merely identifies it within the crate.</p>

<p>Two examples of simple paths consisting of only identifier components:</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>x</span>;
<span class='ident'>x</span>::<span class='ident'>y</span>::<span class='ident'>z</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ax%3B%0Ax%3A%3Ay%3A%3Az%3B%0A%7D">Run</a></pre>

<p>Path components are usually <a href="#identifiers">identifiers</a>, but they may
also include angle-bracket-enclosed lists of type arguments. In
<a href="#expressions">expression</a> context, the type argument list is given
after a <code>::</code> namespace qualifier in order to disambiguate it from a
relational expression involving the less-than symbol (<code>&lt;</code>). In type
expression context, the final namespace qualifier is omitted.</p>

<p>Two examples of paths with type arguments:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>T</span> <span class='op'>=</span> <span class='ident'>HashMap</span><span class='op'>&lt;</span><span class='ident'>i32</span>,<span class='ident'>String</span><span class='op'>&gt;</span>; <span class='comment'>// Type arguments used in a type expression</span>
<span class='kw'>let</span> <span class='ident'>x</span>  <span class='op'>=</span> <span class='ident'>id</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>(<span class='number'>10</span>);       <span class='comment'>// Type arguments used in a call expression</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20HashMap%3CK%2C%20V%3E(K%2CV)%3B%0Afn%20f()%20%7B%0Afn%20id%3CT%3E(t%3A%20T)%20-%3E%20T%20%7B%20t%20%7D%0Atype%20T%20%3D%20HashMap%3Ci32%2CString%3E%3B%20%2F%2F%20Type%20arguments%20used%20in%20a%20type%20expression%0Alet%20x%20%20%3D%20id%3A%3A%3Ci32%3E(10)%3B%20%20%20%20%20%20%20%2F%2F%20Type%20arguments%20used%20in%20a%20call%20expression%0A%7D%0A%7D">Run</a></pre>

<p>Paths can be denoted with various leading qualifiers to change the meaning of
how it is resolved:</p>

<ul>
<li>Paths starting with <code>::</code> are considered to be global paths where the
components of the path start being resolved from the crate root. Each
identifier in the path must resolve to an item.</li>
</ul>

<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>a</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>() {}
}
<span class='kw'>mod</span> <span class='ident'>b</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>() {
        ::<span class='ident'>a</span>::<span class='ident'>foo</span>(); <span class='comment'>// call a&#39;s foo function</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=mod%20a%20%7B%0A%20%20%20%20pub%20fn%20foo()%20%7B%7D%0A%7D%0Amod%20b%20%7B%0A%20%20%20%20pub%20fn%20foo()%20%7B%0A%20%20%20%20%20%20%20%20%3A%3Aa%3A%3Afoo()%3B%20%2F%2F%20call%20a's%20foo%20function%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%7D%0A">Run</a></pre>

<ul>
<li>Paths starting with the keyword <code>super</code> begin resolution relative to the
parent module. Each further identifier must resolve to an item.</li>
</ul>

<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>a</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>() {}
}
<span class='kw'>mod</span> <span class='ident'>b</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>() {
        <span class='kw'>super</span>::<span class='ident'>a</span>::<span class='ident'>foo</span>(); <span class='comment'>// call a&#39;s foo function</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=mod%20a%20%7B%0A%20%20%20%20pub%20fn%20foo()%20%7B%7D%0A%7D%0Amod%20b%20%7B%0A%20%20%20%20pub%20fn%20foo()%20%7B%0A%20%20%20%20%20%20%20%20super%3A%3Aa%3A%3Afoo()%3B%20%2F%2F%20call%20a's%20foo%20function%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%7D%0A">Run</a></pre>

<ul>
<li>Paths starting with the keyword <code>self</code> begin resolution relative to the
current module. Each further identifier must resolve to an item.</li>
</ul>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {}
<span class='kw'>fn</span> <span class='ident'>bar</span>() {
    <span class='self'>self</span>::<span class='ident'>foo</span>();
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20foo()%20%7B%7D%0Afn%20bar()%20%7B%0A%20%20%20%20self%3A%3Afoo()%3B%0A%7D%0Afn%20main()%20%7B%7D%0A">Run</a></pre>

<p>Additionally keyword <code>super</code> may be repeated several times after the first
<code>super</code> or <code>self</code> to refer to ancestor modules.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>a</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>() {}

    <span class='kw'>mod</span> <span class='ident'>b</span> {
        <span class='kw'>mod</span> <span class='ident'>c</span> {
            <span class='kw'>fn</span> <span class='ident'>foo</span>() {
                <span class='kw'>super</span>::<span class='kw'>super</span>::<span class='ident'>foo</span>(); <span class='comment'>// call a&#39;s foo function</span>
                <span class='self'>self</span>::<span class='kw'>super</span>::<span class='kw'>super</span>::<span class='ident'>foo</span>(); <span class='comment'>// call a&#39;s foo function</span>
            }
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=mod%20a%20%7B%0A%20%20%20%20fn%20foo()%20%7B%7D%0A%0A%20%20%20%20mod%20b%20%7B%0A%20%20%20%20%20%20%20%20mod%20c%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20fn%20foo()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20super%3A%3Asuper%3A%3Afoo()%3B%20%2F%2F%20call%20a's%20foo%20function%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self%3A%3Asuper%3A%3Asuper%3A%3Afoo()%3B%20%2F%2F%20call%20a's%20foo%20function%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%7D%0A">Run</a></pre>

<h1 id='syntax-extensions' class='section-header'><a href='#syntax-extensions'>4 Syntax extensions</a></h1>
<p>A number of minor features of Rust are not central enough to have their own
syntax, and yet are not implementable as functions. Instead, they are given
names, and invoked through a consistent syntax: <code>some_extension!(...)</code>.</p>

<p>Users of <code>rustc</code> can define new syntax extensions in two ways:</p>

<ul>
<li><p><a href="book/compiler-plugins.html">Compiler plugins</a> can include arbitrary Rust code that
manipulates syntax trees at compile time. Note that the interface
for compiler plugins is considered highly unstable.</p></li>
<li><p><a href="book/macros.html">Macros</a> define new syntax in a higher-level,
declarative way.</p></li>
</ul>

<h2 id='macros' class='section-header'><a href='#macros'>4.1 Macros</a></h2>
<p><code>macro_rules</code> allows users to define syntax extension in a declarative way.  We
call such extensions &quot;macros by example&quot; or simply &quot;macros&quot;  to be distinguished
from the &quot;procedural macros&quot; defined in <a href="book/compiler-plugins.html">compiler plugins</a>.</p>

<p>Currently, macros can expand to expressions, statements, items, or patterns.</p>

<p>(A <code>sep_token</code> is any token other than <code>*</code> and <code>+</code>. A <code>non_special_token</code> is
any token other than a delimiter or <code>$</code>.)</p>

<p>The macro expander looks up macro invocations by name, and tries each macro
rule in turn. It transcribes the first successful match. Matching and
transcription are closely related to each other, and we will describe them
together.</p>

<h3 id='macro-by-example' class='section-header'><a href='#macro-by-example'>4.1.1 Macro By Example</a></h3>
<p>The macro expander matches and transcribes every token that does not begin with
a <code>$</code> literally, including delimiters. For parsing reasons, delimiters must be
balanced, but they are otherwise not special.</p>

<p>In the matcher, <code>$</code> <em>name</em> <code>:</code> <em>designator</em> matches the nonterminal in the Rust
syntax named by <em>designator</em>. Valid designators are:</p>

<ul>
<li><code>item</code>: an <a href="#items">item</a></li>
<li><code>block</code>: a <a href="#block-expressions">block</a></li>
<li><code>stmt</code>: a <a href="#statements">statement</a></li>
<li><code>pat</code>: a <a href="#match-expressions">pattern</a></li>
<li><code>expr</code>: an <a href="#expressions">expression</a></li>
<li><code>ty</code>: a <a href="#types">type</a></li>
<li><code>ident</code>: an <a href="#identifiers">identifier</a></li>
<li><code>path</code>: a <a href="#paths">path</a></li>
<li><code>tt</code>: either side of the <code>=&gt;</code> in macro rules</li>
<li><code>meta</code>: the contents of an <a href="#attributes">attribute</a></li>
</ul>

<p>In the transcriber, the
designator is already known, and so only the name of a matched nonterminal comes
after the dollar sign.</p>

<p>In both the matcher and transcriber, the Kleene star-like operator indicates
repetition. The Kleene star operator consists of <code>$</code> and parentheses, optionally
followed by a separator token, followed by <code>*</code> or <code>+</code>. <code>*</code> means zero or more
repetitions, <code>+</code> means at least one repetition. The parentheses are not matched or
transcribed. On the matcher side, a name is bound to <em>all</em> of the names it
matches, in a structure that mimics the structure of the repetition encountered
on a successful match. The job of the transcriber is to sort that structure
out.</p>

<p>The rules for transcription of these repetitions are called &quot;Macro By Example&quot;.
Essentially, one &quot;layer&quot; of repetition is discharged at a time, and all of them
must be discharged by the time a name is transcribed. Therefore, <code>( $( $i:ident ),* ) =&gt; ( $i )</code> is an invalid macro, but <code>( $( $i:ident ),* ) =&gt; ( $( $i:ident ),* )</code> is acceptable (if trivial).</p>

<p>When Macro By Example encounters a repetition, it examines all of the <code>$</code>
<em>name</em> s that occur in its body. At the &quot;current layer&quot;, they all must repeat
the same number of times, so <code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; ( $( ($i,$j) ),* )</code> is valid if given the argument <code>(a,b,c ; d,e,f)</code>, but not
<code>(a,b,c ; d,e)</code>. The repetition walks through the choices at that layer in
lockstep, so the former input transcribes to <code>(a,d), (b,e), (c,f)</code>.</p>

<p>Nested repetitions are allowed.</p>

<h3 id='parsing-limitations' class='section-header'><a href='#parsing-limitations'>4.1.2 Parsing limitations</a></h3>
<p>The parser used by the macro system is reasonably powerful, but the parsing of
Rust syntax is restricted in two ways:</p>

<ol>
<li>Macro definitions are required to include suitable separators after parsing
expressions and other bits of the Rust grammar. This implies that
a macro definition like <code>$i:expr [ , ]</code> is not legal, because <code>[</code> could be part
of an expression. A macro definition like <code>$i:expr,</code> or <code>$i:expr;</code> would be legal,
however, because <code>,</code> and <code>;</code> are legal separators. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md">RFC 550</a> for more information.</li>
<li>The parser must have eliminated all ambiguity by the time it reaches a <code>$</code>
<em>name</em> <code>:</code> <em>designator</em>. This requirement most often affects name-designator
pairs when they occur at the beginning of, or immediately after, a <code>$(...)*</code>;
requiring a distinctive token in front can solve the problem.</li>
</ol>

<h1 id='crates-and-source-files' class='section-header'><a href='#crates-and-source-files'>5 Crates and source files</a></h1>
<p>Although Rust, like any other language, can be implemented by an interpreter as
well as a compiler, the only existing implementation is a compiler,
and the language has
always been designed to be compiled. For these reasons, this section assumes a
compiler.</p>

<p>Rust&#39;s semantics obey a <em>phase distinction</em> between compile-time and
run-time.<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup> Semantic rules that have a <em>static
interpretation</em> govern the success or failure of compilation, while
semantic rules
that have a <em>dynamic interpretation</em> govern the behavior of the program at
run-time.</p>

<p>The compilation model centers on artifacts called <em>crates</em>. Each compilation
processes a single crate in source form, and if successful, produces a single
crate in binary form: either an executable or some sort of
library.<sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup></p>

<p>A <em>crate</em> is a unit of compilation and linking, as well as versioning,
distribution and runtime loading. A crate contains a <em>tree</em> of nested
<a href="#modules">module</a> scopes. The top level of this tree is a module that is
anonymous (from the point of view of paths within the module) and any item
within a crate has a canonical <a href="#paths">module path</a> denoting its location
within the crate&#39;s module tree.</p>

<p>The Rust compiler is always invoked with a single source file as input, and
always produces a single output crate. The processing of that source file may
result in other source files being loaded as modules. Source files have the
extension <code>.rs</code>.</p>

<p>A Rust source file describes a module, the name and location of which &mdash;
in the module tree of the current crate &mdash; are defined from outside the
source file: either by an explicit <code>mod_item</code> in a referencing source file, or
by the name of the crate itself. Every source file is a module, but not every
module needs its own source file: <a href="#modules">module definitions</a> can be nested
within one file.</p>

<p>Each source file contains a sequence of zero or more <code>item</code> definitions, and
may optionally begin with any number of <a href="#items-and-attributes">attributes</a>
that apply to the containing module, most of which influence the behavior of
the compiler. The anonymous crate module can have additional attributes that
apply to the crate as a whole.</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// Specify the crate name.</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_name</span> <span class='op'>=</span> <span class='string'>&quot;projx&quot;</span>]</span>

<span class='comment'>// Specify the type of output artifact.</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_type</span> <span class='op'>=</span> <span class='string'>&quot;lib&quot;</span>]</span>

<span class='comment'>// Turn on a warning.</span>
<span class='comment'>// This can be done in any module, not just the anonymous crate module.</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>warn</span>(<span class='ident'>non_camel_case_types</span>)]</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20Specify%20the%20crate%20name.%0A%23!%5Bcrate_name%20%3D%20%22projx%22%5D%0A%0A%2F%2F%20Specify%20the%20type%20of%20output%20artifact.%0A%23!%5Bcrate_type%20%3D%20%22lib%22%5D%0A%0A%2F%2F%20Turn%20on%20a%20warning.%0A%2F%2F%20This%20can%20be%20done%20in%20any%20module%2C%20not%20just%20the%20anonymous%20crate%20module.%0A%23!%5Bwarn(non_camel_case_types)%5D%0A%7D">Run</a></pre>

<p>A crate that contains a <code>main</code> function can be compiled to an executable. If a
<code>main</code> function is present, its return type must be <code>()</code>
(&quot;<a href="#tuple-types">unit</a>&quot;) and it must take no arguments.</p>

<h1 id='items-and-attributes' class='section-header'><a href='#items-and-attributes'>6 Items and attributes</a></h1>
<p>Crates contain <a href="#items">items</a>, each of which may have some number of
<a href="#attributes">attributes</a> attached to it.</p>

<h2 id='items' class='section-header'><a href='#items'>6.1 Items</a></h2>
<p>An <em>item</em> is a component of a crate. Items are organized within a crate by a
nested set of <a href="#modules">modules</a>. Every crate has a single &quot;outermost&quot;
anonymous module; all further items within the crate have <a href="#paths">paths</a>
within the module tree of the crate.</p>

<p>Items are entirely determined at compile-time, generally remain fixed during
execution, and may reside in read-only memory.</p>

<p>There are several kinds of item:</p>

<ul>
<li><a href="#extern-crate-declarations"><code>extern crate</code> declarations</a></li>
<li><a href="#use-declarations"><code>use</code> declarations</a></li>
<li><a href="#modules">modules</a></li>
<li><a href="#functions">functions</a></li>
<li><a href="grammar.html#type-definitions">type definitions</a></li>
<li><a href="#structs">structs</a></li>
<li><a href="#enumerations">enumerations</a></li>
<li><a href="#constant-items">constant items</a></li>
<li><a href="#static-items">static items</a></li>
<li><a href="#traits">traits</a></li>
<li><a href="#implementations">implementations</a></li>
</ul>

<p>Some items form an implicit scope for the declaration of sub-items. In other
words, within a function or module, declarations of items can (in many cases)
be mixed with the statements, control blocks, and similar artifacts that
otherwise compose the item body. The meaning of these scoped items is the same
as if the item was declared outside the scope &mdash; it is still a static item
&mdash; except that the item&#39;s <em>path name</em> within the module namespace is
qualified by the name of the enclosing item, or is private to the enclosing
item (in the case of functions). The grammar specifies the exact locations in
which sub-item declarations may appear.</p>

<h3 id='type-parameters' class='section-header'><a href='#type-parameters'>6.1.1 Type Parameters</a></h3>
<p>All items except modules, constants and statics may be <em>parameterized</em> by type.
Type parameters are given as a comma-separated list of identifiers enclosed in
angle brackets (<code>&lt;...&gt;</code>), after the name of the item and before its definition.
The type parameters of an item are considered &quot;part of the name&quot;, not part of
the type of the item. A referencing <a href="#paths">path</a> must (in principle) provide
type arguments as a list of comma-separated types enclosed within angle
brackets, in order to refer to the type-parameterized item. In practice, the
type-inference system can usually infer such argument types from context. There
are no general type-parametric types, only type-parametric items. That is, Rust
has no notion of type abstraction: there are no higher-ranked (or &quot;forall&quot;) types
abstracted over other types, though higher-ranked types do exist for lifetimes.</p>

<h3 id='modules' class='section-header'><a href='#modules'>6.1.2 Modules</a></h3>
<p>A module is a container for zero or more <a href="#items">items</a>.</p>

<p>A <em>module item</em> is a module, surrounded in braces, named, and prefixed with the
keyword <code>mod</code>. A module item introduces a new, named module into the tree of
modules making up a crate. Modules can nest arbitrarily.</p>

<p>An example of a module:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>math</span> {
    <span class='kw'>type</span> <span class='ident'>Complex</span> <span class='op'>=</span> (<span class='ident'>f64</span>, <span class='ident'>f64</span>);
    <span class='kw'>fn</span> <span class='ident'>sin</span>(<span class='ident'>f</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='comment'>/* ... */</span>
    }
    <span class='kw'>fn</span> <span class='ident'>cos</span>(<span class='ident'>f</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='comment'>/* ... */</span>
    }
    <span class='kw'>fn</span> <span class='ident'>tan</span>(<span class='ident'>f</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='comment'>/* ... */</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20math%20%7B%0A%20%20%20%20type%20Complex%20%3D%20(f64%2C%20f64)%3B%0A%20%20%20%20fn%20sin(f%3A%20f64)%20-%3E%20f64%20%7B%0A%20%20%20%20%20%20%20%20%2F*%20...%20*%2F%0Apanic!()%3B%0A%20%20%20%20%7D%0A%20%20%20%20fn%20cos(f%3A%20f64)%20-%3E%20f64%20%7B%0A%20%20%20%20%20%20%20%20%2F*%20...%20*%2F%0Apanic!()%3B%0A%20%20%20%20%7D%0A%20%20%20%20fn%20tan(f%3A%20f64)%20-%3E%20f64%20%7B%0A%20%20%20%20%20%20%20%20%2F*%20...%20*%2F%0Apanic!()%3B%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Modules and types share the same namespace. Declaring a named type with
the same name as a module in scope is forbidden: that is, a type definition,
trait, struct, enumeration, or type parameter can&#39;t shadow the name of a module
in scope, or vice versa.</p>

<p>A module without a body is loaded from an external file, by default with the
same name as the module, plus the <code>.rs</code> extension. When a nested submodule is
loaded from an external file, it is loaded from a subdirectory path that
mirrors the module hierarchy.</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// Load the `vec` module from `vec.rs`</span>
<span class='kw'>mod</span> <span class='ident'>vec</span>;

<span class='kw'>mod</span> <span class='ident'>thread</span> {
    <span class='comment'>// Load the `local_data` module from `thread/local_data.rs`</span>
    <span class='comment'>// or `thread/local_data/mod.rs`.</span>
    <span class='kw'>mod</span> <span class='ident'>local_data</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20Load%20the%20%60vec%60%20module%20from%20%60vec.rs%60%0Amod%20vec%3B%0A%0Amod%20thread%20%7B%0A%20%20%20%20%2F%2F%20Load%20the%20%60local_data%60%20module%20from%20%60thread%2Flocal_data.rs%60%0A%20%20%20%20%2F%2F%20or%20%60thread%2Flocal_data%2Fmod.rs%60.%0A%20%20%20%20mod%20local_data%3B%0A%7D%0A%7D">Run</a></pre>

<p>The directories and files used for loading external file modules can be
influenced with the <code>path</code> attribute.</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>path</span> <span class='op'>=</span> <span class='string'>&quot;thread_files&quot;</span>]</span>
<span class='kw'>mod</span> <span class='ident'>thread</span> {
    <span class='comment'>// Load the `local_data` module from `thread_files/tls.rs`</span>
    <span class='attribute'>#[<span class='ident'>path</span> <span class='op'>=</span> <span class='string'>&quot;tls.rs&quot;</span>]</span>
    <span class='kw'>mod</span> <span class='ident'>local_data</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Bpath%20%3D%20%22thread_files%22%5D%0Amod%20thread%20%7B%0A%20%20%20%20%2F%2F%20Load%20the%20%60local_data%60%20module%20from%20%60thread_files%2Ftls.rs%60%0A%20%20%20%20%23%5Bpath%20%3D%20%22tls.rs%22%5D%0A%20%20%20%20mod%20local_data%3B%0A%7D%0A%7D">Run</a></pre>

<h4 id='extern-crate-declarations' class='section-header'><a href='#extern-crate-declarations'>6.1.2.1 Extern crate declarations</a></h4>
<p>An <em><code>extern crate</code> declaration</em> specifies a dependency on an external crate.
The external crate is then bound into the declaring scope as the <code>ident</code>
provided in the <code>extern_crate_decl</code>.</p>

<p>The external crate is resolved to a specific <code>soname</code> at compile time, and a
runtime linkage requirement to that <code>soname</code> is passed to the linker for
loading at runtime. The <code>soname</code> is resolved at compile time by scanning the
compiler&#39;s library path and matching the optional <code>crateid</code> provided against
the <code>crateid</code> attributes that were declared on the external crate when it was
compiled. If no <code>crateid</code> is provided, a default <code>name</code> attribute is assumed,
equal to the <code>ident</code> given in the <code>extern_crate_decl</code>.</p>

<p>Three examples of <code>extern crate</code> declarations:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>pcre</span>;

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>std</span>; <span class='comment'>// equivalent to: extern crate std as std;</span>

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>std</span> <span class='kw'>as</span> <span class='ident'>ruststd</span>; <span class='comment'>// linking to &#39;std&#39; under another name</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aextern%20crate%20pcre%3B%0A%0Aextern%20crate%20std%3B%20%2F%2F%20equivalent%20to%3A%20extern%20crate%20std%20as%20std%3B%0A%0Aextern%20crate%20std%20as%20ruststd%3B%20%2F%2F%20linking%20to%20'std'%20under%20another%20name%0A%7D">Run</a></pre>

<p>When naming Rust crates, hyphens are disallowed. However, Cargo packages may
make use of them. In such case, when <code>Cargo.toml</code> doesn&#39;t specify a crate name,
Cargo will transparently replace <code>-</code> with <code>_</code> (Refer to <a href="https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md">RFC 940</a> for more
details).</p>

<p>Here is an example:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// Importing the Cargo package hello-world</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>hello_world</span>; <span class='comment'>// hyphen replaced with an underscore</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20Importing%20the%20Cargo%20package%20hello-world%0Aextern%20crate%20hello_world%3B%20%2F%2F%20hyphen%20replaced%20with%20an%20underscore%0A%7D">Run</a></pre>

<h4 id='use-declarations' class='section-header'><a href='#use-declarations'>6.1.2.2 Use declarations</a></h4>
<p>A <em>use declaration</em> creates one or more local name bindings synonymous with
some other <a href="#paths">path</a>. Usually a <code>use</code> declaration is used to shorten the
path required to refer to a module item. These declarations may appear in
<a href="#modules">modules</a> and <a href="grammar.html#block-expressions">blocks</a>, usually at the top.</p>

<blockquote>
<p><strong>Note</strong>: Unlike in many languages,
<code>use</code> declarations in Rust do <em>not</em> declare linkage dependency with external crates.
Rather, <a href="#extern-crate-declarations"><code>extern crate</code> declarations</a> declare linkage dependencies.</p>
</blockquote>

<p>Use declarations support a number of convenient shortcuts:</p>

<ul>
<li>Rebinding the target name as a new local name, using the syntax <code>use p::q::r as x;</code></li>
<li>Simultaneously binding a list of paths differing only in their final element,
using the glob-like brace syntax <code>use a::b::{c,d,e,f};</code></li>
<li>Binding all paths matching a given prefix, using the asterisk wildcard syntax
<code>use a::b::*;</code></li>
<li>Simultaneously binding a list of paths differing only in their final element
and their immediate parent module, using the <code>self</code> keyword, such as
<code>use a::b::{self, c, d};</code></li>
</ul>

<p>An example of <code>use</code> declarations:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>option</span>::<span class='prelude-ty'>Option</span>::{<span class='prelude-val'>Some</span>, <span class='prelude-val'>None</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>hash_map</span>::{<span class='self'>self</span>, <span class='ident'>HashMap</span>};

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(_: <span class='ident'>T</span>){}
<span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>map1</span>: <span class='ident'>HashMap</span><span class='op'>&lt;</span><span class='ident'>String</span>, <span class='ident'>usize</span><span class='op'>&gt;</span>, <span class='ident'>map2</span>: <span class='ident'>hash_map</span>::<span class='ident'>HashMap</span><span class='op'>&lt;</span><span class='ident'>String</span>, <span class='ident'>usize</span><span class='op'>&gt;</span>){}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// Equivalent to &#39;foo(vec![std::option::Option::Some(1.0f64),</span>
    <span class='comment'>// std::option::Option::None]);&#39;</span>
    <span class='ident'>foo</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='prelude-val'>Some</span>(<span class='number'>1.0f64</span>), <span class='prelude-val'>None</span>]);

    <span class='comment'>// Both `hash_map` and `HashMap` are in scope.</span>
    <span class='kw'>let</span> <span class='ident'>map1</span> <span class='op'>=</span> <span class='ident'>HashMap</span>::<span class='ident'>new</span>();
    <span class='kw'>let</span> <span class='ident'>map2</span> <span class='op'>=</span> <span class='ident'>hash_map</span>::<span class='ident'>HashMap</span>::<span class='ident'>new</span>();
    <span class='ident'>bar</span>(<span class='ident'>map1</span>, <span class='ident'>map2</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=use%20std%3A%3Aoption%3A%3AOption%3A%3A%7BSome%2C%20None%7D%3B%0Ause%20std%3A%3Acollections%3A%3Ahash_map%3A%3A%7Bself%2C%20HashMap%7D%3B%0A%0Afn%20foo%3CT%3E(_%3A%20T)%7B%7D%0Afn%20bar(map1%3A%20HashMap%3CString%2C%20usize%3E%2C%20map2%3A%20hash_map%3A%3AHashMap%3CString%2C%20usize%3E)%7B%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Equivalent%20to%20'foo(vec!%5Bstd%3A%3Aoption%3A%3AOption%3A%3ASome(1.0f64)%2C%0A%20%20%20%20%2F%2F%20std%3A%3Aoption%3A%3AOption%3A%3ANone%5D)%3B'%0A%20%20%20%20foo(vec!%5BSome(1.0f64)%2C%20None%5D)%3B%0A%0A%20%20%20%20%2F%2F%20Both%20%60hash_map%60%20and%20%60HashMap%60%20are%20in%20scope.%0A%20%20%20%20let%20map1%20%3D%20HashMap%3A%3Anew()%3B%0A%20%20%20%20let%20map2%20%3D%20hash_map%3A%3AHashMap%3A%3Anew()%3B%0A%20%20%20%20bar(map1%2C%20map2)%3B%0A%7D%0A">Run</a></pre>

<p>Like items, <code>use</code> declarations are private to the containing module, by
default. Also like items, a <code>use</code> declaration can be public, if qualified by
the <code>pub</code> keyword. Such a <code>use</code> declaration serves to <em>re-export</em> a name. A
public <code>use</code> declaration can therefore <em>redirect</em> some public name to a
different target definition: even a definition with a private canonical path,
inside a different module. If a sequence of such redirections form a cycle or
cannot be resolved unambiguously, they represent a compile-time error.</p>

<p>An example of re-exporting:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>quux</span> {
    <span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>quux</span>::<span class='ident'>foo</span>::{<span class='ident'>bar</span>, <span class='ident'>baz</span>};

    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>foo</span> {
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>bar</span>() { }
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>baz</span>() { }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%20%7D%0Amod%20quux%20%7B%0A%20%20%20%20pub%20use%20quux%3A%3Afoo%3A%3A%7Bbar%2C%20baz%7D%3B%0A%0A%20%20%20%20pub%20mod%20foo%20%7B%0A%20%20%20%20%20%20%20%20pub%20fn%20bar()%20%7B%20%7D%0A%20%20%20%20%20%20%20%20pub%20fn%20baz()%20%7B%20%7D%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>In this example, the module <code>quux</code> re-exports two public names defined in
<code>foo</code>.</p>

<p>Also note that the paths contained in <code>use</code> items are relative to the crate
root. So, in the previous example, the <code>use</code> refers to <code>quux::foo::{bar, baz}</code>, and not simply to <code>foo::{bar, baz}</code>. This also means that top-level
module declarations should be at the crate root if direct usage of the declared
modules within <code>use</code> items is desired. It is also possible to use <code>self</code> and
<code>super</code> at the beginning of a <code>use</code> item to refer to the current and direct
parent modules respectively. All rules regarding accessing declared modules in
<code>use</code> declarations apply to both module declarations and <code>extern crate</code>
declarations.</p>

<p>An example of what will and will not work for <code>use</code> items:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>baz</span>::<span class='ident'>foobaz</span>;    <span class='comment'>// good: foo is at the root of the crate</span>

<span class='kw'>mod</span> <span class='ident'>foo</span> {

    <span class='kw'>mod</span> <span class='ident'>example</span> {
        <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>iter</span> {}
    }

    <span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>example</span>::<span class='ident'>iter</span>; <span class='comment'>// good: foo is at crate root</span>
<span class='comment'>//  use example::iter;      // bad:  example is not at the crate root</span>
    <span class='kw'>use</span> <span class='self'>self</span>::<span class='ident'>baz</span>::<span class='ident'>foobaz</span>;  <span class='comment'>// good: self refers to module &#39;foo&#39;</span>
    <span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>bar</span>::<span class='ident'>foobar</span>;   <span class='comment'>// good: foo is at crate root</span>

    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>bar</span> {
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foobar</span>() { }
    }

    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>baz</span> {
        <span class='kw'>use</span> <span class='kw'>super</span>::<span class='ident'>bar</span>::<span class='ident'>foobar</span>; <span class='comment'>// good: super refers to module &#39;foo&#39;</span>
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foobaz</span>() { }
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused_imports)%5D%0Ause%20foo%3A%3Abaz%3A%3Afoobaz%3B%20%20%20%20%2F%2F%20good%3A%20foo%20is%20at%20the%20root%20of%20the%20crate%0A%0Amod%20foo%20%7B%0A%0A%20%20%20%20mod%20example%20%7B%0A%20%20%20%20%20%20%20%20pub%20mod%20iter%20%7B%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20use%20foo%3A%3Aexample%3A%3Aiter%3B%20%2F%2F%20good%3A%20foo%20is%20at%20crate%20root%0A%2F%2F%20%20use%20example%3A%3Aiter%3B%20%20%20%20%20%20%2F%2F%20bad%3A%20%20example%20is%20not%20at%20the%20crate%20root%0A%20%20%20%20use%20self%3A%3Abaz%3A%3Afoobaz%3B%20%20%2F%2F%20good%3A%20self%20refers%20to%20module%20'foo'%0A%20%20%20%20use%20foo%3A%3Abar%3A%3Afoobar%3B%20%20%20%2F%2F%20good%3A%20foo%20is%20at%20crate%20root%0A%0A%20%20%20%20pub%20mod%20bar%20%7B%0A%20%20%20%20%20%20%20%20pub%20fn%20foobar()%20%7B%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20pub%20mod%20baz%20%7B%0A%20%20%20%20%20%20%20%20use%20super%3A%3Abar%3A%3Afoobar%3B%20%2F%2F%20good%3A%20super%20refers%20to%20module%20'foo'%0A%20%20%20%20%20%20%20%20pub%20fn%20foobaz()%20%7B%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%7D%0A">Run</a></pre>

<h3 id='functions' class='section-header'><a href='#functions'>6.1.3 Functions</a></h3>
<p>A <em>function item</em> defines a sequence of <a href="#statements">statements</a> and a
final <a href="#expressions">expression</a>, along with a name and a set of
parameters. Other than a name, all these are optional.
Functions are declared with the keyword <code>fn</code>. Functions may declare a
set of <em>input</em> <a href="#variables"><em>variables</em></a> as parameters, through which the caller
passes arguments into the function, and the <em>output</em> <a href="#types"><em>type</em></a>
of the value the function will return to its caller on completion.</p>

<p>A function may also be copied into a first-class <em>value</em>, in which case the
value has the corresponding <a href="#function-types"><em>function type</em></a>, and can be used
otherwise exactly as a function item (with a minor additional cost of calling
the function indirectly).</p>

<p>Every control path in a function logically ends with a <code>return</code> expression or a
diverging expression. If the outermost block of a function has a
value-producing expression in its final-expression position, that expression is
interpreted as an implicit <code>return</code> expression applied to the final-expression.</p>

<p>An example of a function:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>add</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>y</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20x%20%2B%20y%0A%7D%0A%7D">Run</a></pre>

<p>As with <code>let</code> bindings, function arguments are irrefutable patterns, so any
pattern that is valid in a let binding is also valid as an argument.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>first</span>((<span class='ident'>value</span>, _): (<span class='ident'>i32</span>, <span class='ident'>i32</span>)) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>value</span> }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20first((value%2C%20_)%3A%20(i32%2C%20i32))%20-%3E%20i32%20%7B%20value%20%7D%0A%7D">Run</a></pre>

<h4 id='generic-functions' class='section-header'><a href='#generic-functions'>6.1.3.1 Generic functions</a></h4>
<p>A <em>generic function</em> allows one or more <em>parameterized types</em> to appear in its
signature. Each type parameter must be explicitly declared in an
angle-bracket-enclosed and comma-separated list, following the function name.</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// foo is generic over A and B</span>

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>A</span>, <span class='ident'>B</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>A</span>, <span class='ident'>y</span>: <span class='ident'>B</span>) {<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20foo%20is%20generic%20over%20A%20and%20B%0A%0Afn%20foo%3CA%2C%20B%3E(x%3A%20A%2C%20y%3A%20B)%20%7B%0A%7D">Run</a></pre>

<p>Inside the function signature and body, the name of the type parameter can be
used as a type name. <a href="#traits">Trait</a> bounds can be specified for type parameters
to allow methods with that trait to be called on values of that type. This is
specified using the <code>where</code> syntax:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Debug</span> {<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo%3CT%3E(x%3A%20T)%20where%20T%3A%20Debug%20%7B%0A%7D">Run</a></pre>

<p>When a generic function is referenced, its type is instantiated based on the
context of the reference. For example, calling the <code>foo</code> function here:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Debug</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>]) <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Debug</span> {
    <span class='comment'>// details elided</span>
}

<span class='ident'>foo</span>(<span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>2</span>]);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Afmt%3A%3ADebug%3B%0A%0Afn%20foo%3CT%3E(x%3A%20%26%5BT%5D)%20where%20T%3A%20Debug%20%7B%0A%20%20%20%20%2F%2F%20details%20elided%0A()%0A%7D%0A%0Afoo(%26%5B1%2C%202%5D)%3B%0A%7D">Run</a></pre>

<p>will instantiate type parameter <code>T</code> with <code>i32</code>.</p>

<p>The type parameters can also be explicitly supplied in a trailing
<a href="#paths">path</a> component after the function name. This might be necessary if
there is not sufficient context to determine the type parameters. For example,
<code>mem::size_of::&lt;u32&gt;() == 4</code>.</p>

<h4 id='diverging-functions' class='section-header'><a href='#diverging-functions'>6.1.3.2 Diverging functions</a></h4>
<p>A special kind of function can be declared with a <code>!</code> character where the
output type would normally be. For example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>my_err</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='op'>!</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>);
    <span class='macro'>panic</span><span class='macro'>!</span>();
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20my_err(s%3A%20%26str)%20-%3E%20!%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20s)%3B%0A%20%20%20%20panic!()%3B%0A%7D%0A%7D">Run</a></pre>

<p>We call such functions &quot;diverging&quot; because they never return a value to the
caller. Every control path in a diverging function must end with a <code>panic!()</code> or
a call to another diverging function on every control path. The <code>!</code> annotation
does <em>not</em> denote a type.</p>

<p>It might be necessary to declare a diverging function because as mentioned
previously, the typechecker checks that every control path in a function ends
with a <a href="#return-expressions"><code>return</code></a> or diverging expression. So, if <code>my_err</code>
were declared without the <code>!</code> annotation, the following code would not
typecheck:</p>

<pre class='rust rust-example-rendered'>

<span class='kw'>fn</span> <span class='ident'>f</span>(<span class='ident'>i</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>if</span> <span class='ident'>i</span> <span class='op'>==</span> <span class='number'>42</span> {
        <span class='kw'>return</span> <span class='number'>42</span>;
    }
    <span class='kw'>else</span> {
        <span class='ident'>my_err</span>(<span class='string'>&quot;Bad number!&quot;</span>);
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20my_err(s%3A%20%26str)%20-%3E%20!%20%7B%20panic!()%20%7D%0A%0Afn%20f(i%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20return%2042%3B%0A%20%20%20%20%7D%0A%20%20%20%20else%20%7B%0A%20%20%20%20%20%20%20%20my_err(%22Bad%20number!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>This will not compile without the <code>!</code> annotation on <code>my_err</code>, since the <code>else</code>
branch of the conditional in <code>f</code> does not return an <code>i32</code>, as required by the
signature of <code>f</code>. Adding the <code>!</code> annotation to <code>my_err</code> informs the
typechecker that, should control ever enter <code>my_err</code>, no further type judgments
about <code>f</code> need to hold, since control will never resume in any context that
relies on those judgments. Thus the return type on <code>f</code> only needs to reflect
the <code>if</code> branch of the conditional.</p>

<h4 id='extern-functions' class='section-header'><a href='#extern-functions'>6.1.3.3 Extern functions</a></h4>
<p>Extern functions are part of Rust&#39;s foreign function interface, providing the
opposite functionality to <a href="#external-blocks">external blocks</a>. Whereas
external blocks allow Rust code to call foreign code, extern functions with
bodies defined in Rust code <em>can be called by foreign code</em>. They are defined
in the same way as any other Rust function, except that they have the <code>extern</code>
modifier.</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// Declares an extern fn, the ABI defaults to &quot;C&quot;</span>
<span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>new_i32</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>0</span> }

<span class='comment'>// Declares an extern fn with &quot;stdcall&quot; ABI</span>
<span class='kw'>extern</span> <span class='string'>&quot;stdcall&quot;</span> <span class='kw'>fn</span> <span class='ident'>new_i32_stdcall</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>0</span> }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20Declares%20an%20extern%20fn%2C%20the%20ABI%20defaults%20to%20%22C%22%0Aextern%20fn%20new_i32()%20-%3E%20i32%20%7B%200%20%7D%0A%0A%2F%2F%20Declares%20an%20extern%20fn%20with%20%22stdcall%22%20ABI%0Aextern%20%22stdcall%22%20fn%20new_i32_stdcall()%20-%3E%20i32%20%7B%200%20%7D%0A%7D">Run</a></pre>

<p>Unlike normal functions, extern fns have type <code>extern &quot;ABI&quot; fn()</code>. This is the
same type as the functions declared in an extern block.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>fptr</span>: <span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> <span class='kw'>fn</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>new_i32</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aextern%20fn%20new_i32()%20-%3E%20i32%20%7B%200%20%7D%0Alet%20fptr%3A%20extern%20%22C%22%20fn()%20-%3E%20i32%20%3D%20new_i32%3B%0A%7D">Run</a></pre>

<p>Extern functions may be called directly from Rust code as Rust uses large,
contiguous stack segments like C.</p>

<h3 id='type-aliases' class='section-header'><a href='#type-aliases'>6.1.4 Type aliases</a></h3>
<p>A <em>type alias</em> defines a new name for an existing <a href="#types">type</a>. Type
aliases are declared with the keyword <code>type</code>. Every value has a single,
specific type, but may implement several different traits, or be compatible with
several different type constraints.</p>

<p>For example, the following defines the type <code>Point</code> as a synonym for the type
<code>(u8, u8)</code>, the type of pairs of unsigned 8 bit integers:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Point</span> <span class='op'>=</span> (<span class='ident'>u8</span>, <span class='ident'>u8</span>);
<span class='kw'>let</span> <span class='ident'>p</span>: <span class='ident'>Point</span> <span class='op'>=</span> (<span class='number'>41</span>, <span class='number'>68</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atype%20Point%20%3D%20(u8%2C%20u8)%3B%0Alet%20p%3A%20Point%20%3D%20(41%2C%2068)%3B%0A%7D">Run</a></pre>

<p>Currently a type alias to an enum type cannot be used to qualify the
constructors:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>E</span> { <span class='ident'>A</span> }
<span class='kw'>type</span> <span class='ident'>F</span> <span class='op'>=</span> <span class='ident'>E</span>;
<span class='kw'>let</span> _: <span class='ident'>F</span> <span class='op'>=</span> <span class='ident'>E</span>::<span class='ident'>A</span>;  <span class='comment'>// OK</span>
<span class='comment'>// let _: F = F::A;  // Doesn&#39;t work</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aenum%20E%20%7B%20A%20%7D%0Atype%20F%20%3D%20E%3B%0Alet%20_%3A%20F%20%3D%20E%3A%3AA%3B%20%20%2F%2F%20OK%0A%2F%2F%20let%20_%3A%20F%20%3D%20F%3A%3AA%3B%20%20%2F%2F%20Doesn't%20work%0A%7D">Run</a></pre>

<h3 id='structs' class='section-header'><a href='#structs'>6.1.5 Structs</a></h3>
<p>A <em>struct</em> is a nominal <a href="#struct-types">struct type</a> defined with the
keyword <code>struct</code>.</p>

<p>An example of a <code>struct</code> item and its use:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Point</span> {<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>y</span>: <span class='ident'>i32</span>}
<span class='kw'>let</span> <span class='ident'>p</span> <span class='op'>=</span> <span class='ident'>Point</span> {<span class='ident'>x</span>: <span class='number'>10</span>, <span class='ident'>y</span>: <span class='number'>11</span>};
<span class='kw'>let</span> <span class='ident'>px</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>p</span>.<span class='ident'>x</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Point%20%7Bx%3A%20i32%2C%20y%3A%20i32%7D%0Alet%20p%20%3D%20Point%20%7Bx%3A%2010%2C%20y%3A%2011%7D%3B%0Alet%20px%3A%20i32%20%3D%20p.x%3B%0A%7D">Run</a></pre>

<p>A <em>tuple struct</em> is a nominal <a href="#tuple-types">tuple type</a>, also defined with
the keyword <code>struct</code>. For example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Point</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>);
<span class='kw'>let</span> <span class='ident'>p</span> <span class='op'>=</span> <span class='ident'>Point</span>(<span class='number'>10</span>, <span class='number'>11</span>);
<span class='kw'>let</span> <span class='ident'>px</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>p</span> { <span class='ident'>Point</span>(<span class='ident'>x</span>, _) <span class='op'>=&gt;</span> <span class='ident'>x</span> };<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Point(i32%2C%20i32)%3B%0Alet%20p%20%3D%20Point(10%2C%2011)%3B%0Alet%20px%3A%20i32%20%3D%20match%20p%20%7B%20Point(x%2C%20_)%20%3D%3E%20x%20%7D%3B%0A%7D">Run</a></pre>

<p>A <em>unit-like struct</em> is a struct without any fields, defined by leaving off
the list of fields entirely. Such a struct implicitly defines a constant of
its type with the same name. For example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Cookie</span>;
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> [<span class='ident'>Cookie</span>, <span class='ident'>Cookie</span> {}, <span class='ident'>Cookie</span>, <span class='ident'>Cookie</span> {}];<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Cookie%3B%0Alet%20c%20%3D%20%5BCookie%2C%20Cookie%20%7B%7D%2C%20Cookie%2C%20Cookie%20%7B%7D%5D%3B%0A%7D">Run</a></pre>

<p>is equivalent to</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Cookie</span> {}
<span class='kw'>const</span> <span class='ident'>Cookie</span>: <span class='ident'>Cookie</span> <span class='op'>=</span> <span class='ident'>Cookie</span> {};
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> [<span class='ident'>Cookie</span>, <span class='ident'>Cookie</span> {}, <span class='ident'>Cookie</span>, <span class='ident'>Cookie</span> {}];<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Cookie%20%7B%7D%0Aconst%20Cookie%3A%20Cookie%20%3D%20Cookie%20%7B%7D%3B%0Alet%20c%20%3D%20%5BCookie%2C%20Cookie%20%7B%7D%2C%20Cookie%2C%20Cookie%20%7B%7D%5D%3B%0A%7D">Run</a></pre>

<p>The precise memory layout of a struct is not specified. One can specify a
particular layout using the <a href="#ffi-attributes"><code>repr</code> attribute</a>.</p>

<h3 id='enumerations' class='section-header'><a href='#enumerations'>6.1.6 Enumerations</a></h3>
<p>An <em>enumeration</em> is a simultaneous definition of a nominal <a href="#enumerated-types">enumerated
type</a> as well as a set of <em>constructors</em>, that can be used
to create or pattern-match values of the corresponding enumerated type.</p>

<p>Enumerations are declared with the keyword <code>enum</code>.</p>

<p>An example of an <code>enum</code> item and its use:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Animal</span> {
    <span class='ident'>Dog</span>,
    <span class='ident'>Cat</span>,
}

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>a</span>: <span class='ident'>Animal</span> <span class='op'>=</span> <span class='ident'>Animal</span>::<span class='ident'>Dog</span>;
<span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>Animal</span>::<span class='ident'>Cat</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aenum%20Animal%20%7B%0A%20%20%20%20Dog%2C%0A%20%20%20%20Cat%2C%0A%7D%0A%0Alet%20mut%20a%3A%20Animal%20%3D%20Animal%3A%3ADog%3B%0Aa%20%3D%20Animal%3A%3ACat%3B%0A%7D">Run</a></pre>

<p>Enumeration constructors can have either named or unnamed fields:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Animal</span> {
    <span class='ident'>Dog</span> (<span class='ident'>String</span>, <span class='ident'>f64</span>),
    <span class='ident'>Cat</span> { <span class='ident'>name</span>: <span class='ident'>String</span>, <span class='ident'>weight</span>: <span class='ident'>f64</span> },
}

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>a</span>: <span class='ident'>Animal</span> <span class='op'>=</span> <span class='ident'>Animal</span>::<span class='ident'>Dog</span>(<span class='string'>&quot;Cocoa&quot;</span>.<span class='ident'>to_string</span>(), <span class='number'>37.2</span>);
<span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>Animal</span>::<span class='ident'>Cat</span> { <span class='ident'>name</span>: <span class='string'>&quot;Spotty&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>weight</span>: <span class='number'>2.7</span> };<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aenum%20Animal%20%7B%0A%20%20%20%20Dog%20(String%2C%20f64)%2C%0A%20%20%20%20Cat%20%7B%20name%3A%20String%2C%20weight%3A%20f64%20%7D%2C%0A%7D%0A%0Alet%20mut%20a%3A%20Animal%20%3D%20Animal%3A%3ADog(%22Cocoa%22.to_string()%2C%2037.2)%3B%0Aa%20%3D%20Animal%3A%3ACat%20%7B%20name%3A%20%22Spotty%22.to_string()%2C%20weight%3A%202.7%20%7D%3B%0A%7D">Run</a></pre>

<p>In this example, <code>Cat</code> is a <em>struct-like enum variant</em>,
whereas <code>Dog</code> is simply called an enum variant.</p>

<p>Each enum value has a <em>discriminant</em> which is an integer associated to it. You
can specify it explicitly:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>Bar</span> <span class='op'>=</span> <span class='number'>123</span>,
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aenum%20Foo%20%7B%0A%20%20%20%20Bar%20%3D%20123%2C%0A%7D%0A%7D">Run</a></pre>

<p>The right hand side of the specification is interpreted as an <code>isize</code> value,
but the compiler is allowed to use a smaller type in the actual memory layout.
The <a href="#ffi-attributes"><code>repr</code> attribute</a> can be added in order to change
the type of the right hand side and specify the memory layout.</p>

<p>If a discriminant isn&#39;t specified, they start at zero, and add one for each
variant, in order.</p>

<p>You can cast an enum to get its discriminant:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span>::<span class='ident'>Bar</span> <span class='kw'>as</span> <span class='ident'>u32</span>; <span class='comment'>// x is now 123u32</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aenum%20Foo%20%7B%20Bar%20%3D%20123%20%7D%0Alet%20x%20%3D%20Foo%3A%3ABar%20as%20u32%3B%20%2F%2F%20x%20is%20now%20123u32%0A%7D">Run</a></pre>

<p>This only works as long as none of the variants have data attached. If
it were <code>Bar(i32)</code>, this is disallowed.</p>

<h3 id='constant-items' class='section-header'><a href='#constant-items'>6.1.7 Constant items</a></h3>
<p>A <em>constant item</em> is a named <em>constant value</em> which is not associated with a
specific memory location in the program. Constants are essentially inlined
wherever they are used, meaning that they are copied directly into the relevant
context when used. References to the same constant are not necessarily
guaranteed to refer to the same memory address.</p>

<p>Constant values must not have destructors, and otherwise permit most forms of
data. Constants may refer to the address of other constants, in which case the
address will have the <code>static</code> lifetime. The compiler is, however, still at
liberty to translate the constant many times, so the address referred to may not
be stable.</p>

<p>Constants must be explicitly typed. The type may be <code>bool</code>, <code>char</code>, a number, or
a type derived from those primitive types. The derived types are references with
the <code>static</code> lifetime, fixed-size arrays, tuples, enum variants, and structs.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>BIT1</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>1</span> <span class='op'>&lt;&lt;</span> <span class='number'>0</span>;
<span class='kw'>const</span> <span class='ident'>BIT2</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>1</span> <span class='op'>&lt;&lt;</span> <span class='number'>1</span>;

<span class='kw'>const</span> <span class='ident'>BITS</span>: [<span class='ident'>u32</span>; <span class='number'>2</span>] <span class='op'>=</span> [<span class='ident'>BIT1</span>, <span class='ident'>BIT2</span>];
<span class='kw'>const</span> <span class='ident'>STRING</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span> <span class='op'>=</span> <span class='string'>&quot;bitstring&quot;</span>;

<span class='kw'>struct</span> <span class='ident'>BitsNStrings</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>mybits</span>: [<span class='ident'>u32</span>; <span class='number'>2</span>],
    <span class='ident'>mystring</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>,
}

<span class='kw'>const</span> <span class='ident'>BITS_N_STRINGS</span>: <span class='ident'>BitsNStrings</span><span class='op'>&lt;</span><span class='lifetime'>&#39;static</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>BitsNStrings</span> {
    <span class='ident'>mybits</span>: <span class='ident'>BITS</span>,
    <span class='ident'>mystring</span>: <span class='ident'>STRING</span>,
};<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aconst%20BIT1%3A%20u32%20%3D%201%20%3C%3C%200%3B%0Aconst%20BIT2%3A%20u32%20%3D%201%20%3C%3C%201%3B%0A%0Aconst%20BITS%3A%20%5Bu32%3B%202%5D%20%3D%20%5BBIT1%2C%20BIT2%5D%3B%0Aconst%20STRING%3A%20%26'static%20str%20%3D%20%22bitstring%22%3B%0A%0Astruct%20BitsNStrings%3C'a%3E%20%7B%0A%20%20%20%20mybits%3A%20%5Bu32%3B%202%5D%2C%0A%20%20%20%20mystring%3A%20%26'a%20str%2C%0A%7D%0A%0Aconst%20BITS_N_STRINGS%3A%20BitsNStrings%3C'static%3E%20%3D%20BitsNStrings%20%7B%0A%20%20%20%20mybits%3A%20BITS%2C%0A%20%20%20%20mystring%3A%20STRING%2C%0A%7D%3B%0A%7D">Run</a></pre>

<h3 id='static-items' class='section-header'><a href='#static-items'>6.1.8 Static items</a></h3>
<p>A <em>static item</em> is similar to a <em>constant</em>, except that it represents a precise
memory location in the program. A static is never &quot;inlined&quot; at the usage site,
and all references to it refer to the same memory location. Static items have
the <code>static</code> lifetime, which outlives all other lifetimes in a Rust program.
Static items may be placed in read-only memory if they do not contain any
interior mutability.</p>

<p>Statics may contain interior mutability through the <code>UnsafeCell</code> language item.
All access to a static is safe, but there are a number of restrictions on
statics:</p>

<ul>
<li>Statics may not contain any destructors.</li>
<li>The types of static values must ascribe to <code>Sync</code> to allow thread-safe access.</li>
<li>Statics may not refer to other statics by value, only by reference.</li>
<li>Constants cannot refer to statics.</li>
</ul>

<p>Constants should in general be preferred over statics, unless large amounts of
data are being stored, or single-address and mutability properties are required.</p>

<h4 id='mutable-statics' class='section-header'><a href='#mutable-statics'>6.1.8.1 Mutable statics</a></h4>
<p>If a static item is declared with the <code>mut</code> keyword, then it is allowed to
be modified by the program. One of Rust&#39;s goals is to make concurrency bugs
hard to run into, and this is obviously a very large source of race conditions
or other bugs. For this reason, an <code>unsafe</code> block is required when either
reading or writing a mutable static variable. Care should be taken to ensure
that modifications to a mutable static are safe with respect to other threads
running in the same process.</p>

<p>Mutable statics are still very useful, however. They can be used with C
libraries and can also be bound from C libraries (in an <code>extern</code> block).</p>

<pre class='rust rust-example-rendered'>

<span class='kw'>static</span> <span class='kw-2'>mut</span> <span class='ident'>LEVELS</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>0</span>;

<span class='comment'>// This violates the idea of no shared state, and this doesn&#39;t internally</span>
<span class='comment'>// protect against races, so this function is `unsafe`</span>
<span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>bump_levels_unsafe1</span>() <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='kw'>let</span> <span class='ident'>ret</span> <span class='op'>=</span> <span class='ident'>LEVELS</span>;
    <span class='ident'>LEVELS</span> <span class='op'>+=</span> <span class='number'>1</span>;
    <span class='kw'>return</span> <span class='ident'>ret</span>;
}

<span class='comment'>// Assuming that we have an atomic_add function which returns the old value,</span>
<span class='comment'>// this function is &quot;safe&quot; but the meaning of the return value may not be what</span>
<span class='comment'>// callers expect, so it&#39;s still marked as `unsafe`</span>
<span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>bump_levels_unsafe2</span>() <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='kw'>return</span> <span class='ident'>atomic_add</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>LEVELS</span>, <span class='number'>1</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20atomic_add(_%3A%20%26mut%20u32%2C%20_%3A%20u32)%20-%3E%20u32%20%7B%202%20%7D%0A%0Astatic%20mut%20LEVELS%3A%20u32%20%3D%200%3B%0A%0A%2F%2F%20This%20violates%20the%20idea%20of%20no%20shared%20state%2C%20and%20this%20doesn't%20internally%0A%2F%2F%20protect%20against%20races%2C%20so%20this%20function%20is%20%60unsafe%60%0Aunsafe%20fn%20bump_levels_unsafe1()%20-%3E%20u32%20%7B%0A%20%20%20%20let%20ret%20%3D%20LEVELS%3B%0A%20%20%20%20LEVELS%20%2B%3D%201%3B%0A%20%20%20%20return%20ret%3B%0A%7D%0A%0A%2F%2F%20Assuming%20that%20we%20have%20an%20atomic_add%20function%20which%20returns%20the%20old%20value%2C%0A%2F%2F%20this%20function%20is%20%22safe%22%20but%20the%20meaning%20of%20the%20return%20value%20may%20not%20be%20what%0A%2F%2F%20callers%20expect%2C%20so%20it's%20still%20marked%20as%20%60unsafe%60%0Aunsafe%20fn%20bump_levels_unsafe2()%20-%3E%20u32%20%7B%0A%20%20%20%20return%20atomic_add(%26mut%20LEVELS%2C%201)%3B%0A%7D%0A%7D">Run</a></pre>

<p>Mutable statics have the same restrictions as normal statics, except that the
type of the value is not required to ascribe to <code>Sync</code>.</p>

<h3 id='traits' class='section-header'><a href='#traits'>6.1.9 Traits</a></h3>
<p>A <em>trait</em> describes an abstract interface that types can
implement. This interface consists of associated items, which come in
three varieties:</p>

<ul>
<li>functions</li>
<li>constants</li>
<li>types</li>
</ul>

<p>Associated functions whose first parameter is named <code>self</code> are called
methods and may be invoked using <code>.</code> notation (e.g., <code>x.foo()</code>).</p>

<p>All traits define an implicit type parameter <code>Self</code> that refers to
&quot;the type that is implementing this interface&quot;. Traits may also
contain additional type parameters. These type parameters (including
<code>Self</code>) may be constrained by other traits and so forth as usual.</p>

<p>Trait bounds on <code>Self</code> are considered &quot;supertraits&quot;. These are
required to be acyclic.  Supertraits are somewhat different from other
constraints in that they affect what methods are available in the
vtable when the trait is used as a <a href="#trait-objects">trait object</a>.</p>

<p>Traits are implemented for specific types through separate
<a href="#implementations">implementations</a>.</p>

<p>Consider the following trait:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Shape</span> {
    <span class='kw'>fn</span> <span class='ident'>draw</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>Surface</span>);
    <span class='kw'>fn</span> <span class='ident'>bounding_box</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>BoundingBox</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atype%20Surface%20%3D%20i32%3B%0Atype%20BoundingBox%20%3D%20i32%3B%0Atrait%20Shape%20%7B%0A%20%20%20%20fn%20draw(%26self%2C%20Surface)%3B%0A%20%20%20%20fn%20bounding_box(%26self)%20-%3E%20BoundingBox%3B%0A%7D%0A%7D">Run</a></pre>

<p>This defines a trait with two methods. All values that have
<a href="#implementations">implementations</a> of this trait in scope can have their
<code>draw</code> and <code>bounding_box</code> methods called, using <code>value.bounding_box()</code>
<a href="#method-call-expressions">syntax</a>.</p>

<p>Traits can include default implementations of methods, as in:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
    <span class='kw'>fn</span> <span class='ident'>baz</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;We called baz.&quot;</span>); }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Foo%20%7B%0A%20%20%20%20fn%20bar(%26self)%3B%0A%20%20%20%20fn%20baz(%26self)%20%7B%20println!(%22We%20called%20baz.%22)%3B%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Here the <code>baz</code> method has a default implementation, so types that implement
<code>Foo</code> need only implement <code>bar</code>. It is also possible for implementing types
to override a method that has a default implementation.</p>

<p>Type parameters can be specified for a trait to make it generic. These appear
after the trait name, using the same syntax used in <a href="#generic-functions">generic
functions</a>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Seq</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>len</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span>;
    <span class='kw'>fn</span> <span class='ident'>elt_at</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>n</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span>;
    <span class='kw'>fn</span> <span class='ident'>iter</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>F</span>) <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='ident'>T</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Seq%3CT%3E%20%7B%0A%20%20%20%20fn%20len(%26self)%20-%3E%20u32%3B%0A%20%20%20%20fn%20elt_at(%26self%2C%20n%3A%20u32)%20-%3E%20T%3B%0A%20%20%20%20fn%20iter%3CF%3E(%26self%2C%20F)%20where%20F%3A%20Fn(T)%3B%0A%7D%0A%7D">Run</a></pre>

<p>It is also possible to define associated types for a trait. Consider the
following example of a <code>Container</code> trait. Notice how the type is available
for use in the method signatures:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Container</span> {
    <span class='kw'>type</span> <span class='ident'>E</span>;
    <span class='kw'>fn</span> <span class='ident'>empty</span>() <span class='op'>-&gt;</span> <span class='self'>Self</span>;
    <span class='kw'>fn</span> <span class='ident'>insert</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='self'>Self</span>::<span class='ident'>E</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Container%20%7B%0A%20%20%20%20type%20E%3B%0A%20%20%20%20fn%20empty()%20-%3E%20Self%3B%0A%20%20%20%20fn%20insert(%26mut%20self%2C%20Self%3A%3AE)%3B%0A%7D%0A%7D">Run</a></pre>

<p>In order for a type to implement this trait, it must not only provide
implementations for every method, but it must specify the type <code>E</code>. Here&#39;s
an implementation of <code>Container</code> for the standard library type <code>Vec</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Container</span> <span class='kw'>for</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>E</span> <span class='op'>=</span> <span class='ident'>T</span>;
    <span class='kw'>fn</span> <span class='ident'>empty</span>() <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='ident'>Vec</span>::<span class='ident'>new</span>() }
    <span class='kw'>fn</span> <span class='ident'>insert</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>x</span>: <span class='ident'>T</span>) { <span class='self'>self</span>.<span class='ident'>push</span>(<span class='ident'>x</span>); }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Container%20%7B%0A%20%20%20%20type%20E%3B%0A%20%20%20%20fn%20empty()%20-%3E%20Self%3B%0A%20%20%20%20fn%20insert(%26mut%20self%2C%20Self%3A%3AE)%3B%0A%7D%0Aimpl%3CT%3E%20Container%20for%20Vec%3CT%3E%20%7B%0A%20%20%20%20type%20E%20%3D%20T%3B%0A%20%20%20%20fn%20empty()%20-%3E%20Vec%3CT%3E%20%7B%20Vec%3A%3Anew()%20%7D%0A%20%20%20%20fn%20insert(%26mut%20self%2C%20x%3A%20T)%20%7B%20self.push(x)%3B%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Generic functions may use traits as <em>bounds</em> on their type parameters. This
will have two effects:</p>

<ul>
<li>Only types that have the trait may instantiate the parameter.</li>
<li>Within the generic function, the methods of the trait can be
called on values that have the parameter&#39;s type.</li>
</ul>

<p>For example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>draw_twice</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Shape</span><span class='op'>&gt;</span>(<span class='ident'>surface</span>: <span class='ident'>Surface</span>, <span class='ident'>sh</span>: <span class='ident'>T</span>) {
    <span class='ident'>sh</span>.<span class='ident'>draw</span>(<span class='ident'>surface</span>);
    <span class='ident'>sh</span>.<span class='ident'>draw</span>(<span class='ident'>surface</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atype%20Surface%20%3D%20i32%3B%0Atrait%20Shape%20%7B%20fn%20draw(%26self%2C%20Surface)%3B%20%7D%0Afn%20draw_twice%3CT%3A%20Shape%3E(surface%3A%20Surface%2C%20sh%3A%20T)%20%7B%0A%20%20%20%20sh.draw(surface)%3B%0A%20%20%20%20sh.draw(surface)%3B%0A%7D%0A%7D">Run</a></pre>

<p>Traits also define a <a href="#trait-objects">trait object</a> with the same
name as the trait. Values of this type are created by coercing from a
pointer of some specific type to a pointer of trait type. For example,
<code>&amp;T</code> could be coerced to <code>&amp;Shape</code> if <code>T: Shape</code> holds (and similarly
for <code>Box&lt;T&gt;</code>). This coercion can either be implicit or
<a href="#type-cast-expressions">explicit</a>. Here is an example of an explicit
coercion:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Shape</span> { }
<span class='kw'>impl</span> <span class='ident'>Shape</span> <span class='kw'>for</span> <span class='ident'>i32</span> { }
<span class='kw'>let</span> <span class='ident'>mycircle</span> <span class='op'>=</span> <span class='number'>0i32</span>;
<span class='kw'>let</span> <span class='ident'>myshape</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Shape</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>mycircle</span>) <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Shape</span><span class='op'>&gt;</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Shape%20%7B%20%7D%0Aimpl%20Shape%20for%20i32%20%7B%20%7D%0Alet%20mycircle%20%3D%200i32%3B%0Alet%20myshape%3A%20Box%3CShape%3E%20%3D%20Box%3A%3Anew(mycircle)%20as%20Box%3CShape%3E%3B%0A%7D">Run</a></pre>

<p>The resulting value is a box containing the value that was cast, along with
information that identifies the methods of the implementation that was used.
Values with a trait type can have <a href="#method-call-expressions">methods called</a> on
them, for any method in the trait, and can be used to instantiate type
parameters that are bounded by the trait.</p>

<p>Trait methods may be static, which means that they lack a <code>self</code> argument.
This means that they can only be called with function call syntax (<code>f(x)</code>) and
not method call syntax (<code>obj.f()</code>). The way to refer to the name of a static
method is to qualify it with the trait name, treating the trait name like a
module. For example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Num</span> {
    <span class='kw'>fn</span> <span class='ident'>from_i32</span>(<span class='ident'>n</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='self'>Self</span>;
}
<span class='kw'>impl</span> <span class='ident'>Num</span> <span class='kw'>for</span> <span class='ident'>f64</span> {
    <span class='kw'>fn</span> <span class='ident'>from_i32</span>(<span class='ident'>n</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> { <span class='ident'>n</span> <span class='kw'>as</span> <span class='ident'>f64</span> }
}
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>f64</span> <span class='op'>=</span> <span class='ident'>Num</span>::<span class='ident'>from_i32</span>(<span class='number'>42</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Num%20%7B%0A%20%20%20%20fn%20from_i32(n%3A%20i32)%20-%3E%20Self%3B%0A%7D%0Aimpl%20Num%20for%20f64%20%7B%0A%20%20%20%20fn%20from_i32(n%3A%20i32)%20-%3E%20f64%20%7B%20n%20as%20f64%20%7D%0A%7D%0Alet%20x%3A%20f64%20%3D%20Num%3A%3Afrom_i32(42)%3B%0A%7D">Run</a></pre>

<p>Traits may inherit from other traits. Consider the following example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Shape</span> { <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>; }
<span class='kw'>trait</span> <span class='ident'>Circle</span> : <span class='ident'>Shape</span> { <span class='kw'>fn</span> <span class='ident'>radius</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>; }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Shape%20%7B%20fn%20area(%26self)%20-%3E%20f64%3B%20%7D%0Atrait%20Circle%20%3A%20Shape%20%7B%20fn%20radius(%26self)%20-%3E%20f64%3B%20%7D%0A%7D">Run</a></pre>

<p>The syntax <code>Circle : Shape</code> means that types that implement <code>Circle</code> must also
have an implementation for <code>Shape</code>. Multiple supertraits are separated by <code>+</code>,
<code>trait Circle : Shape + PartialEq { }</code>. In an implementation of <code>Circle</code> for a
given type <code>T</code>, methods can refer to <code>Shape</code> methods, since the typechecker
checks that any type with an implementation of <code>Circle</code> also has an
implementation of <code>Shape</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>trait</span> <span class='ident'>Shape</span> { <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>; }
<span class='kw'>trait</span> <span class='ident'>Circle</span> : <span class='ident'>Shape</span> { <span class='kw'>fn</span> <span class='ident'>radius</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>; }
<span class='kw'>impl</span> <span class='ident'>Shape</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='number'>0.0</span>
    }
}
<span class='kw'>impl</span> <span class='ident'>Circle</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>radius</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;calling area: {}&quot;</span>, <span class='self'>self</span>.<span class='ident'>area</span>());

        <span class='number'>0.0</span>
    }
}

<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>Foo</span>;
<span class='ident'>c</span>.<span class='ident'>radius</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Foo%3B%0A%0Atrait%20Shape%20%7B%20fn%20area(%26self)%20-%3E%20f64%3B%20%7D%0Atrait%20Circle%20%3A%20Shape%20%7B%20fn%20radius(%26self)%20-%3E%20f64%3B%20%7D%0Aimpl%20Shape%20for%20Foo%20%7B%0A%20%20%20%20fn%20area(%26self)%20-%3E%20f64%20%7B%0A%20%20%20%20%20%20%20%200.0%0A%20%20%20%20%7D%0A%7D%0Aimpl%20Circle%20for%20Foo%20%7B%0A%20%20%20%20fn%20radius(%26self)%20-%3E%20f64%20%7B%0A%20%20%20%20%20%20%20%20println!(%22calling%20area%3A%20%7B%7D%22%2C%20self.area())%3B%0A%0A%20%20%20%20%20%20%20%200.0%0A%20%20%20%20%7D%0A%7D%0A%0Alet%20c%20%3D%20Foo%3B%0Ac.radius()%3B%0A%7D">Run</a></pre>

<p>In type-parameterized functions, methods of the supertrait may be called on
values of subtrait-bound type parameters. Referring to the previous example of
<code>trait Circle : Shape</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>radius_times_area</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Circle</span><span class='op'>&gt;</span>(<span class='ident'>c</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='comment'>// `c` is both a Circle and a Shape</span>
    <span class='ident'>c</span>.<span class='ident'>radius</span>() <span class='op'>*</span> <span class='ident'>c</span>.<span class='ident'>area</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Shape%20%7B%20fn%20area(%26self)%20-%3E%20f64%3B%20%7D%0Atrait%20Circle%20%3A%20Shape%20%7B%20fn%20radius(%26self)%20-%3E%20f64%3B%20%7D%0Afn%20radius_times_area%3CT%3A%20Circle%3E(c%3A%20T)%20-%3E%20f64%20%7B%0A%20%20%20%20%2F%2F%20%60c%60%20is%20both%20a%20Circle%20and%20a%20Shape%0A%20%20%20%20c.radius()%20*%20c.area()%0A%7D%0A%7D">Run</a></pre>

<p>Likewise, supertrait methods may also be called on trait objects.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>mycircle</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>mycircle</span>) <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Circle</span><span class='op'>&gt;</span>;
<span class='kw'>let</span> <span class='ident'>nonsense</span> <span class='op'>=</span> <span class='ident'>mycircle</span>.<span class='ident'>radius</span>() <span class='op'>*</span> <span class='ident'>mycircle</span>.<span class='ident'>area</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Shape%20%7B%20fn%20area(%26self)%20-%3E%20f64%3B%20%7D%0Atrait%20Circle%20%3A%20Shape%20%7B%20fn%20radius(%26self)%20-%3E%20f64%3B%20%7D%0Aimpl%20Shape%20for%20i32%20%7B%20fn%20area(%26self)%20-%3E%20f64%20%7B%200.0%20%7D%20%7D%0Aimpl%20Circle%20for%20i32%20%7B%20fn%20radius(%26self)%20-%3E%20f64%20%7B%200.0%20%7D%20%7D%0Alet%20mycircle%20%3D%200i32%3B%0Alet%20mycircle%20%3D%20Box%3A%3Anew(mycircle)%20as%20Box%3CCircle%3E%3B%0Alet%20nonsense%20%3D%20mycircle.radius()%20*%20mycircle.area()%3B%0A%7D">Run</a></pre>

<h3 id='implementations' class='section-header'><a href='#implementations'>6.1.10 Implementations</a></h3>
<p>An <em>implementation</em> is an item that implements a <a href="#traits">trait</a> for a
specific type.</p>

<p>Implementations are defined with the keyword <code>impl</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Circle</span> {
    <span class='ident'>radius</span>: <span class='ident'>f64</span>,
    <span class='ident'>center</span>: <span class='ident'>Point</span>,
}

<span class='kw'>impl</span> <span class='ident'>Copy</span> <span class='kw'>for</span> <span class='ident'>Circle</span> {}

<span class='kw'>impl</span> <span class='ident'>Clone</span> <span class='kw'>for</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>clone</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Circle</span> { <span class='op'>*</span><span class='self'>self</span> }
}

<span class='kw'>impl</span> <span class='ident'>Shape</span> <span class='kw'>for</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>draw</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>s</span>: <span class='ident'>Surface</span>) { <span class='ident'>do_draw_circle</span>(<span class='ident'>s</span>, <span class='op'>*</span><span class='self'>self</span>); }
    <span class='kw'>fn</span> <span class='ident'>bounding_box</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>BoundingBox</span> {
        <span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>radius</span>;
        <span class='ident'>BoundingBox</span> {
            <span class='ident'>x</span>: <span class='self'>self</span>.<span class='ident'>center</span>.<span class='ident'>x</span> <span class='op'>-</span> <span class='ident'>r</span>,
            <span class='ident'>y</span>: <span class='self'>self</span>.<span class='ident'>center</span>.<span class='ident'>y</span> <span class='op'>-</span> <span class='ident'>r</span>,
            <span class='ident'>width</span>: <span class='number'>2.0</span> <span class='op'>*</span> <span class='ident'>r</span>,
            <span class='ident'>height</span>: <span class='number'>2.0</span> <span class='op'>*</span> <span class='ident'>r</span>,
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Bderive(Copy%2C%20Clone)%5D%0Astruct%20Point%20%7Bx%3A%20f64%2C%20y%3A%20f64%7D%3B%0Atype%20Surface%20%3D%20i32%3B%0Astruct%20BoundingBox%20%7Bx%3A%20f64%2C%20y%3A%20f64%2C%20width%3A%20f64%2C%20height%3A%20f64%7D%3B%0Atrait%20Shape%20%7B%20fn%20draw(%26self%2C%20Surface)%3B%20fn%20bounding_box(%26self)%20-%3E%20BoundingBox%3B%20%7D%0Afn%20do_draw_circle(s%3A%20Surface%2C%20c%3A%20Circle)%20%7B%20%7D%0Astruct%20Circle%20%7B%0A%20%20%20%20radius%3A%20f64%2C%0A%20%20%20%20center%3A%20Point%2C%0A%7D%0A%0Aimpl%20Copy%20for%20Circle%20%7B%7D%0A%0Aimpl%20Clone%20for%20Circle%20%7B%0A%20%20%20%20fn%20clone(%26self)%20-%3E%20Circle%20%7B%20*self%20%7D%0A%7D%0A%0Aimpl%20Shape%20for%20Circle%20%7B%0A%20%20%20%20fn%20draw(%26self%2C%20s%3A%20Surface)%20%7B%20do_draw_circle(s%2C%20*self)%3B%20%7D%0A%20%20%20%20fn%20bounding_box(%26self)%20-%3E%20BoundingBox%20%7B%0A%20%20%20%20%20%20%20%20let%20r%20%3D%20self.radius%3B%0A%20%20%20%20%20%20%20%20BoundingBox%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20x%3A%20self.center.x%20-%20r%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20y%3A%20self.center.y%20-%20r%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20width%3A%202.0%20*%20r%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20height%3A%202.0%20*%20r%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>It is possible to define an implementation without referring to a trait. The
methods in such an implementation can only be used as direct calls on the values
of the type that the implementation targets. In such an implementation, the
trait type and <code>for</code> after <code>impl</code> are omitted. Such implementations are limited
to nominal types (enums, structs, trait objects), and the implementation must
appear in the same crate as the <code>self</code> type:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Point</span> {<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>y</span>: <span class='ident'>i32</span>}

<span class='kw'>impl</span> <span class='ident'>Point</span> {
    <span class='kw'>fn</span> <span class='ident'>log</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Point is at ({}, {})&quot;</span>, <span class='self'>self</span>.<span class='ident'>x</span>, <span class='self'>self</span>.<span class='ident'>y</span>);
    }
}

<span class='kw'>let</span> <span class='ident'>my_point</span> <span class='op'>=</span> <span class='ident'>Point</span> {<span class='ident'>x</span>: <span class='number'>10</span>, <span class='ident'>y</span>:<span class='number'>11</span>};
<span class='ident'>my_point</span>.<span class='ident'>log</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Point%20%7Bx%3A%20i32%2C%20y%3A%20i32%7D%0A%0Aimpl%20Point%20%7B%0A%20%20%20%20fn%20log(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Point%20is%20at%20(%7B%7D%2C%20%7B%7D)%22%2C%20self.x%2C%20self.y)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Alet%20my_point%20%3D%20Point%20%7Bx%3A%2010%2C%20y%3A11%7D%3B%0Amy_point.log()%3B%0A%7D">Run</a></pre>

<p>When a trait <em>is</em> specified in an <code>impl</code>, all methods declared as part of the
trait must be implemented, with matching types and type parameter counts.</p>

<p>An implementation can take type parameters, which can be different from the
type parameters taken by the trait it implements. Implementation parameters
are written after the <code>impl</code> keyword.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Seq</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='comment'>/* ... */</span>
}
<span class='kw'>impl</span> <span class='ident'>Seq</span><span class='op'>&lt;</span><span class='ident'>bool</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>u32</span> {
    <span class='comment'>/* Treat the integer as a sequence of bits */</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Seq%3CT%3E%20%7B%20fn%20dummy(%26self%2C%20_%3A%20T)%20%7B%20%7D%20%7D%0Aimpl%3CT%3E%20Seq%3CT%3E%20for%20Vec%3CT%3E%20%7B%0A%20%20%20%20%2F*%20...%20*%2F%0A%7D%0Aimpl%20Seq%3Cbool%3E%20for%20u32%20%7B%0A%20%20%20%20%2F*%20Treat%20the%20integer%20as%20a%20sequence%20of%20bits%20*%2F%0A%7D%0A%7D">Run</a></pre>

<h3 id='external-blocks' class='section-header'><a href='#external-blocks'>6.1.11 External blocks</a></h3>
<p>External blocks form the basis for Rust&#39;s foreign function interface.
Declarations in an external block describe symbols in external, non-Rust
libraries.</p>

<p>Functions within external blocks are declared in the same way as other Rust
functions, with the exception that they may not have a body and are instead
terminated by a semicolon.</p>

<p>Functions within external blocks may be called by Rust code, just like
functions defined in Rust. The Rust compiler automatically translates between
the Rust ABI and the foreign ABI.</p>

<p>A number of <a href="#ffi-attributes">attributes</a> control the behavior of external blocks.</p>

<p>By default external blocks assume that the library they are calling uses the
standard C ABI on the specific platform. Other ABIs may be specified using an
<code>abi</code> string, as shown here:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// Interface to the Windows API</span>
<span class='kw'>extern</span> <span class='string'>&quot;stdcall&quot;</span> { }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20Interface%20to%20the%20Windows%20API%0Aextern%20%22stdcall%22%20%7B%20%7D%0A%7D">Run</a></pre>

<p>There are three ABI strings which are cross-platform, and which all compilers
are guaranteed to support:</p>

<ul>
<li><code>extern &quot;Rust&quot;</code> -- The default ABI when you write a normal <code>fn foo()</code> in any
Rust code.</li>
<li><code>extern &quot;C&quot;</code> -- This is the same as <code>extern fn foo()</code>; whatever the default
your C compiler supports.</li>
<li><code>extern &quot;system&quot;</code> -- Usually the same as <code>extern &quot;C&quot;</code>, except on Win32, in
which case it&#39;s <code>&quot;stdcall&quot;</code>, or what you should use to link to the Windows API
itself</li>
</ul>

<p>There are also some platform-specific ABI strings:</p>

<ul>
<li><code>extern &quot;cdecl&quot;</code> -- The default for x86_32 C code.</li>
<li><code>extern &quot;stdcall&quot;</code> -- The default for the Win32 API on x86_32.</li>
<li><code>extern &quot;win64&quot;</code> -- The default for C code on x86_64 Windows.</li>
<li><code>extern &quot;sysv64&quot;</code> -- The default for C code on non-Windows x86_64.</li>
<li><code>extern &quot;aapcs&quot;</code> -- The default for ARM.</li>
<li><code>extern &quot;fastcall&quot;</code> -- The <code>fastcall</code> ABI -- corresponds to MSVC&#39;s
<code>__fastcall</code> and GCC and clang&#39;s <code>__attribute__((fastcall))</code></li>
<li><code>extern &quot;vectorcall&quot;</code> -- The <code>vectorcall</code> ABI -- corresponds to MSVC&#39;s
<code>__vectorcall</code> and clang&#39;s <code>__attribute__((vectorcall))</code></li>
</ul>

<p>Finally, there are some rustc-specific ABI strings:</p>

<ul>
<li><code>extern &quot;rust-intrinsic&quot;</code> -- The ABI of rustc intrinsics.</li>
<li><code>extern &quot;rust-call&quot;</code> -- The ABI of the Fn::call trait functions.</li>
<li><code>extern &quot;platform-intrinsic&quot;</code> -- Specific platform intrinsics -- like, for
example, <code>sqrt</code> -- have this ABI. You should never have to deal with it.</li>
</ul>

<p>The <code>link</code> attribute allows the name of the library to be specified. When
specified the compiler will attempt to link against the native library of the
specified name.</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>link</span>(<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;crypto&quot;</span>)]</span>
<span class='kw'>extern</span> { }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Blink(name%20%3D%20%22crypto%22)%5D%0Aextern%20%7B%20%7D%0A%7D">Run</a></pre>

<p>The type of a function declared in an extern block is <code>extern &quot;abi&quot; fn(A1, ..., An) -&gt; R</code>, where <code>A1...An</code> are the declared types of its arguments and <code>R</code> is
the declared return type.</p>

<p>It is valid to add the <code>link</code> attribute on an empty extern block. You can use
this to satisfy the linking requirements of extern blocks elsewhere in your code
(including upstream crates) instead of adding the attribute to each extern block.</p>

<h2 id='visibility-and-privacy' class='section-header'><a href='#visibility-and-privacy'>6.2 Visibility and Privacy</a></h2>
<p>These two terms are often used interchangeably, and what they are attempting to
convey is the answer to the question &quot;Can this item be used at this location?&quot;</p>

<p>Rust&#39;s name resolution operates on a global hierarchy of namespaces. Each level
in the hierarchy can be thought of as some item. The items are one of those
mentioned above, but also include external crates. Declaring or defining a new
module can be thought of as inserting a new tree into the hierarchy at the
location of the definition.</p>

<p>To control whether interfaces can be used across modules, Rust checks each use
of an item to see whether it should be allowed or not. This is where privacy
warnings are generated, or otherwise &quot;you used a private item of another module
and weren&#39;t allowed to.&quot;</p>

<p>By default, everything in Rust is <em>private</em>, with one exception. Enum variants
in a <code>pub</code> enum are also public by default. When an item is declared as <code>pub</code>,
it can be thought of as being accessible to the outside world. For example:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// Declare a private struct</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='comment'>// Declare a public struct with a private field</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Bar</span> {
    <span class='ident'>field</span>: <span class='ident'>i32</span>,
}

<span class='comment'>// Declare a public enum with two public variants</span>
<span class='kw'>pub</span> <span class='kw'>enum</span> <span class='ident'>State</span> {
    <span class='ident'>PubliclyAccessibleState</span>,
    <span class='ident'>PubliclyAccessibleState2</span>,
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%7D%0A%2F%2F%20Declare%20a%20private%20struct%0Astruct%20Foo%3B%0A%0A%2F%2F%20Declare%20a%20public%20struct%20with%20a%20private%20field%0Apub%20struct%20Bar%20%7B%0A%20%20%20%20field%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20Declare%20a%20public%20enum%20with%20two%20public%20variants%0Apub%20enum%20State%20%7B%0A%20%20%20%20PubliclyAccessibleState%2C%0A%20%20%20%20PubliclyAccessibleState2%2C%0A%7D%0A">Run</a></pre>

<p>With the notion of an item being either public or private, Rust allows item
accesses in two cases:</p>

<ol>
<li>If an item is public, then it can be used externally through any of its
public ancestors.</li>
<li>If an item is private, it may be accessed by the current module and its
descendants.</li>
</ol>

<p>These two cases are surprisingly powerful for creating module hierarchies
exposing public APIs while hiding internal implementation details. To help
explain, here&#39;s a few use cases and what they would entail:</p>

<ul>
<li><p>A library developer needs to expose functionality to crates which link
against their library. As a consequence of the first case, this means that
anything which is usable externally must be <code>pub</code> from the root down to the
destination item. Any private item in the chain will disallow external
accesses.</p></li>
<li><p>A crate needs a global available &quot;helper module&quot; to itself, but it doesn&#39;t
want to expose the helper module as a public API. To accomplish this, the
root of the crate&#39;s hierarchy would have a private module which then
internally has a &quot;public API&quot;. Because the entire crate is a descendant of
the root, then the entire local crate can access this private module through
the second case.</p></li>
<li><p>When writing unit tests for a module, it&#39;s often a common idiom to have an
immediate child of the module to-be-tested named <code>mod test</code>. This module
could access any items of the parent module through the second case, meaning
that internal implementation details could also be seamlessly tested from the
child module.</p></li>
</ul>

<p>In the second case, it mentions that a private item &quot;can be accessed&quot; by the
current module and its descendants, but the exact meaning of accessing an item
depends on what the item is. Accessing a module, for example, would mean
looking inside of it (to import more items). On the other hand, accessing a
function would mean that it is invoked. Additionally, path expressions and
import statements are considered to access an item in the sense that the
import/expression is only valid if the destination is in the current visibility
scope.</p>

<p>Here&#39;s an example of a program which exemplifies the three cases outlined
above:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// This module is private, meaning that no external crate can access this</span>
<span class='comment'>// module. Because it is private at the root of this current crate, however, any</span>
<span class='comment'>// module in the crate may access any publicly visible item in this module.</span>
<span class='kw'>mod</span> <span class='ident'>crate_helper_module</span> {

    <span class='comment'>// This function can be used by anything in the current crate</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>crate_helper</span>() {}

    <span class='comment'>// This function *cannot* be used by anything else in the crate. It is not</span>
    <span class='comment'>// publicly visible outside of the `crate_helper_module`, so only this</span>
    <span class='comment'>// current module and its descendants may access it.</span>
    <span class='kw'>fn</span> <span class='ident'>implementation_detail</span>() {}
}

<span class='comment'>// This function is &quot;public to the root&quot; meaning that it&#39;s available to external</span>
<span class='comment'>// crates linking against this one.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>public_api</span>() {}

<span class='comment'>// Similarly to &#39;public_api&#39;, this module is public so external crates may look</span>
<span class='comment'>// inside of it.</span>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>submodule</span> {
    <span class='kw'>use</span> <span class='ident'>crate_helper_module</span>;

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>my_method</span>() {
        <span class='comment'>// Any item in the local crate may invoke the helper module&#39;s public</span>
        <span class='comment'>// interface through a combination of the two rules above.</span>
        <span class='ident'>crate_helper_module</span>::<span class='ident'>crate_helper</span>();
    }

    <span class='comment'>// This function is hidden to any module which is not a descendant of</span>
    <span class='comment'>// `submodule`</span>
    <span class='kw'>fn</span> <span class='ident'>my_implementation</span>() {}

    <span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>test</span>)]</span>
    <span class='kw'>mod</span> <span class='ident'>test</span> {

        <span class='attribute'>#[<span class='ident'>test</span>]</span>
        <span class='kw'>fn</span> <span class='ident'>test_my_implementation</span>() {
            <span class='comment'>// Because this module is a descendant of `submodule`, it&#39;s allowed</span>
            <span class='comment'>// to access private items inside of `submodule` without a privacy</span>
            <span class='comment'>// violation.</span>
            <span class='kw'>super</span>::<span class='ident'>my_implementation</span>();
        }
    }
}
<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%2F%2F%20This%20module%20is%20private%2C%20meaning%20that%20no%20external%20crate%20can%20access%20this%0A%2F%2F%20module.%20Because%20it%20is%20private%20at%20the%20root%20of%20this%20current%20crate%2C%20however%2C%20any%0A%2F%2F%20module%20in%20the%20crate%20may%20access%20any%20publicly%20visible%20item%20in%20this%20module.%0Amod%20crate_helper_module%20%7B%0A%0A%20%20%20%20%2F%2F%20This%20function%20can%20be%20used%20by%20anything%20in%20the%20current%20crate%0A%20%20%20%20pub%20fn%20crate_helper()%20%7B%7D%0A%0A%20%20%20%20%2F%2F%20This%20function%20*cannot*%20be%20used%20by%20anything%20else%20in%20the%20crate.%20It%20is%20not%0A%20%20%20%20%2F%2F%20publicly%20visible%20outside%20of%20the%20%60crate_helper_module%60%2C%20so%20only%20this%0A%20%20%20%20%2F%2F%20current%20module%20and%20its%20descendants%20may%20access%20it.%0A%20%20%20%20fn%20implementation_detail()%20%7B%7D%0A%7D%0A%0A%2F%2F%20This%20function%20is%20%22public%20to%20the%20root%22%20meaning%20that%20it's%20available%20to%20external%0A%2F%2F%20crates%20linking%20against%20this%20one.%0Apub%20fn%20public_api()%20%7B%7D%0A%0A%2F%2F%20Similarly%20to%20'public_api'%2C%20this%20module%20is%20public%20so%20external%20crates%20may%20look%0A%2F%2F%20inside%20of%20it.%0Apub%20mod%20submodule%20%7B%0A%20%20%20%20use%20crate_helper_module%3B%0A%0A%20%20%20%20pub%20fn%20my_method()%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Any%20item%20in%20the%20local%20crate%20may%20invoke%20the%20helper%20module's%20public%0A%20%20%20%20%20%20%20%20%2F%2F%20interface%20through%20a%20combination%20of%20the%20two%20rules%20above.%0A%20%20%20%20%20%20%20%20crate_helper_module%3A%3Acrate_helper()%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20This%20function%20is%20hidden%20to%20any%20module%20which%20is%20not%20a%20descendant%20of%0A%20%20%20%20%2F%2F%20%60submodule%60%0A%20%20%20%20fn%20my_implementation()%20%7B%7D%0A%0A%20%20%20%20%23%5Bcfg(test)%5D%0A%20%20%20%20mod%20test%20%7B%0A%0A%20%20%20%20%20%20%20%20%23%5Btest%5D%0A%20%20%20%20%20%20%20%20fn%20test_my_implementation()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20Because%20this%20module%20is%20a%20descendant%20of%20%60submodule%60%2C%20it's%20allowed%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20to%20access%20private%20items%20inside%20of%20%60submodule%60%20without%20a%20privacy%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20violation.%0A%20%20%20%20%20%20%20%20%20%20%20%20super%3A%3Amy_implementation()%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%7D%0A">Run</a></pre>

<p>For a Rust program to pass the privacy checking pass, all paths must be valid
accesses given the two rules above. This includes all use statements,
expressions, types, etc.</p>

<h3 id='re-exporting-and-visibility' class='section-header'><a href='#re-exporting-and-visibility'>6.2.1 Re-exporting and Visibility</a></h3>
<p>Rust allows publicly re-exporting items through a <code>pub use</code> directive. Because
this is a public directive, this allows the item to be used in the current
module through the rules above. It essentially allows public access into the
re-exported item. For example, this program is valid:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='self'>self</span>::<span class='ident'>implementation</span>::<span class='ident'>api</span>;

<span class='kw'>mod</span> <span class='ident'>implementation</span> {
    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>api</span> {
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>f</span>() {}
    }
}
<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=pub%20use%20self%3A%3Aimplementation%3A%3Aapi%3B%0A%0Amod%20implementation%20%7B%0A%20%20%20%20pub%20mod%20api%20%7B%0A%20%20%20%20%20%20%20%20pub%20fn%20f()%20%7B%7D%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%7D%0A">Run</a></pre>

<p>This means that any external crate referencing <code>implementation::api::f</code> would
receive a privacy violation, while the path <code>api::f</code> would be allowed.</p>

<p>When re-exporting a private item, it can be thought of as allowing the &quot;privacy
chain&quot; being short-circuited through the reexport instead of passing through
the namespace hierarchy as it normally would.</p>

<h2 id='attributes' class='section-header'><a href='#attributes'>6.3 Attributes</a></h2>
<p>Any item declaration may have an <em>attribute</em> applied to it. Attributes in Rust
are modeled on Attributes in ECMA-335, with the syntax coming from ECMA-334
(C#). An attribute is a general, free-form metadatum that is interpreted
according to name, convention, and language and compiler version. Attributes
may appear as any of:</p>

<ul>
<li>A single identifier, the attribute name</li>
<li>An identifier followed by the equals sign &#39;=&#39; and a literal, providing a
key/value pair</li>
<li>An identifier followed by a parenthesized list of sub-attribute arguments</li>
</ul>

<p>Attributes with a bang (&quot;!&quot;) after the hash (&quot;#&quot;) apply to the item that the
attribute is declared within. Attributes that do not have a bang after the hash
apply to the item that follows the attribute.</p>

<p>An example of attributes:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// General metadata applied to the enclosing module or crate.</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_type</span> <span class='op'>=</span> <span class='string'>&quot;lib&quot;</span>]</span>

<span class='comment'>// A function marked as a unit test</span>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>test_foo</span>() {
    <span class='comment'>/* ... */</span>
}

<span class='comment'>// A conditionally-compiled module</span>
<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>target_os</span><span class='op'>=</span><span class='string'>&quot;linux&quot;</span>)]</span>
<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='comment'>/* ... */</span>
}

<span class='comment'>// A lint attribute used to suppress a warning/error</span>
<span class='attribute'>#[<span class='ident'>allow</span>(<span class='ident'>non_camel_case_types</span>)]</span>
<span class='kw'>type</span> <span class='ident'>int8_t</span> <span class='op'>=</span> <span class='ident'>i8</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20General%20metadata%20applied%20to%20the%20enclosing%20module%20or%20crate.%0A%23!%5Bcrate_type%20%3D%20%22lib%22%5D%0A%0A%2F%2F%20A%20function%20marked%20as%20a%20unit%20test%0A%23%5Btest%5D%0Afn%20test_foo()%20%7B%0A%20%20%20%20%2F*%20...%20*%2F%0A%7D%0A%0A%2F%2F%20A%20conditionally-compiled%20module%0A%23%5Bcfg(target_os%3D%22linux%22)%5D%0Amod%20bar%20%7B%0A%20%20%20%20%2F*%20...%20*%2F%0A%7D%0A%0A%2F%2F%20A%20lint%20attribute%20used%20to%20suppress%20a%20warning%2Ferror%0A%23%5Ballow(non_camel_case_types)%5D%0Atype%20int8_t%20%3D%20i8%3B%0A%7D">Run</a></pre>

<blockquote>
<p><strong>Note:</strong> At some point in the future, the compiler will distinguish between
language-reserved and user-available attributes. Until then, there is
effectively no difference between an attribute handled by a loadable syntax
extension and the compiler.</p>
</blockquote>

<h3 id='crate-only-attributes' class='section-header'><a href='#crate-only-attributes'>6.3.1 Crate-only attributes</a></h3>
<ul>
<li><code>crate_name</code> - specify the crate&#39;s crate name.</li>
<li><code>crate_type</code> - see <a href="#linkage">linkage</a>.</li>
<li><code>feature</code> - see <a href="#compiler-features">compiler features</a>.</li>
<li><code>no_builtins</code> - disable optimizing certain code patterns to invocations of
              library functions that are assumed to exist</li>
<li><code>no_main</code> - disable emitting the <code>main</code> symbol. Useful when some other
object being linked to defines <code>main</code>.</li>
<li><code>no_start</code> - disable linking to the <code>native</code> crate, which specifies the
&quot;start&quot; language item.</li>
<li><code>no_std</code> - disable linking to the <code>std</code> crate.</li>
<li><code>plugin</code> - load a list of named crates as compiler plugins, e.g.
         <code>#![plugin(foo, bar)]</code>. Optional arguments for each plugin,
         i.e. <code>#![plugin(foo(... args ...))]</code>, are provided to the plugin&#39;s
         registrar function.  The <code>plugin</code> feature gate is required to use
         this attribute.</li>
<li><code>recursion_limit</code> - Sets the maximum depth for potentially
                  infinitely-recursive compile-time operations like
                  auto-dereference or macro expansion. The default is
                  <code>#![recursion_limit=&quot;64&quot;]</code>.</li>
</ul>

<h3 id='module-only-attributes' class='section-header'><a href='#module-only-attributes'>6.3.2 Module-only attributes</a></h3>
<ul>
<li><code>no_implicit_prelude</code> - disable injecting <code>use std::prelude::*</code> in this
module.</li>
<li><code>path</code> - specifies the file to load the module from. <code>#[path=&quot;foo.rs&quot;] mod bar;</code> is equivalent to <code>mod bar { /* contents of foo.rs */ }</code>. The path is
taken relative to the directory that the current module is in.</li>
</ul>

<h3 id='function-only-attributes' class='section-header'><a href='#function-only-attributes'>6.3.3 Function-only attributes</a></h3>
<ul>
<li><code>main</code> - indicates that this function should be passed to the entry point,
rather than the function in the crate root named <code>main</code>.</li>
<li><code>plugin_registrar</code> - mark this function as the registration point for
<a href="book/compiler-plugins.html">compiler plugins</a>, such as loadable syntax extensions.</li>
<li><code>start</code> - indicates that this function should be used as the entry point,
overriding the &quot;start&quot; language item. See the &quot;start&quot; <a href="#language-items">language
item</a> for more details.</li>
<li><code>test</code> - indicates that this function is a test function, to only be compiled
in case of <code>--test</code>.</li>
<li><code>should_panic</code> - indicates that this test function should panic, inverting the success condition.</li>
<li><code>cold</code> - The function is unlikely to be executed, so optimize it (and calls
to it) differently.</li>
<li><code>naked</code> - The function utilizes a custom ABI or custom inline ASM that requires
epilogue and prologue to be skipped.</li>
</ul>

<h3 id='static-only-attributes' class='section-header'><a href='#static-only-attributes'>6.3.4 Static-only attributes</a></h3>
<ul>
<li><code>thread_local</code> - on a <code>static mut</code>, this signals that the value of this
static may change depending on the current thread. The exact consequences of
this are implementation-defined.</li>
</ul>

<h3 id='ffi-attributes' class='section-header'><a href='#ffi-attributes'>6.3.5 FFI attributes</a></h3>
<p>On an <code>extern</code> block, the following attributes are interpreted:</p>

<ul>
<li><code>link_args</code> - specify arguments to the linker, rather than just the library
name and type. This is feature gated and the exact behavior is
implementation-defined (due to variety of linker invocation syntax).</li>
<li><code>link</code> - indicate that a native library should be linked to for the
declarations in this block to be linked correctly. <code>link</code> supports an optional
<code>kind</code> key with three possible values: <code>dylib</code>, <code>static</code>, and <code>framework</code>. See
<a href="#external-blocks">external blocks</a> for more about external blocks. Two
examples: <code>#[link(name = &quot;readline&quot;)]</code> and
<code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code>.</li>
<li><code>linked_from</code> - indicates what native library this block of FFI items is
coming from. This attribute is of the form <code>#[linked_from = &quot;foo&quot;]</code> where
<code>foo</code> is the name of a library in either <code>#[link]</code> or a <code>-l</code> flag. This
attribute is currently required to export symbols from a Rust dynamic library
on Windows, and it is feature gated behind the <code>linked_from</code> feature.</li>
</ul>

<p>On declarations inside an <code>extern</code> block, the following attributes are
interpreted:</p>

<ul>
<li><code>link_name</code> - the name of the symbol that this function or static should be
imported as.</li>
<li><code>linkage</code> - on a static, this specifies the <a href="http://llvm.org/docs/LangRef.html#linkage-types">linkage
type</a>.</li>
</ul>

<p>On <code>enum</code>s:</p>

<ul>
<li><code>repr</code> - on C-like enums, this sets the underlying type used for
representation. Takes one argument, which is the primitive
type this enum should be represented for, or <code>C</code>, which specifies that it
should be the default <code>enum</code> size of the C ABI for that platform. Note that
enum representation in C is undefined, and this may be incorrect when the C
code is compiled with certain flags.</li>
</ul>

<p>On <code>struct</code>s:</p>

<ul>
<li><code>repr</code> - specifies the representation to use for this struct. Takes a list
of options. The currently accepted ones are <code>C</code> and <code>packed</code>, which may be
combined. <code>C</code> will use a C ABI compatible struct layout, and <code>packed</code> will
remove any padding between fields (note that this is very fragile and may
break platforms which require aligned access).</li>
</ul>

<h3 id='macro-related-attributes' class='section-header'><a href='#macro-related-attributes'>6.3.6 Macro-related attributes</a></h3>
<ul>
<li><p><code>macro_use</code> on a <code>mod</code>  macros defined in this module will be visible in the
module&#39;s parent, after this module has been included.</p></li>
<li><p><code>macro_use</code> on an <code>extern crate</code>  load macros from this crate.  An optional
list of names <code>#[macro_use(foo, bar)]</code> restricts the import to just those
macros named.  The <code>extern crate</code> must appear at the crate root, not inside
<code>mod</code>, which ensures proper function of the <a href="book/macros.html#the-variable-crate"><code>$crate</code> macro
variable</a>.</p></li>
<li><p><code>macro_reexport</code> on an <code>extern crate</code>  re-export the named macros.</p></li>
<li><p><code>macro_export</code> - export a macro for cross-crate usage.</p></li>
<li><p><code>no_link</code> on an <code>extern crate</code>  even if we load this crate for macros, don&#39;t
link it into the output.</p></li>
</ul>

<p>See the <a href="book/macros.html#scoping-and-macro-importexport">macros section of the
book</a> for more information on
macro scope.</p>

<h3 id='miscellaneous-attributes' class='section-header'><a href='#miscellaneous-attributes'>6.3.7 Miscellaneous attributes</a></h3>
<ul>
<li><code>deprecated</code> - mark the item as deprecated; the full attribute is <code>#[deprecated(since = &quot;crate version&quot;, note = &quot;...&quot;)</code>, where both arguments are optional.</li>
<li><code>export_name</code> - on statics and functions, this determines the name of the
exported symbol.</li>
<li><code>link_section</code> - on statics and functions, this specifies the section of the
object file that this item&#39;s contents will be placed into.</li>
<li><code>no_mangle</code> - on any item, do not apply the standard name mangling. Set the
symbol for this item to its identifier.</li>
<li><code>simd</code> - on certain tuple structs, derive the arithmetic operators, which
lower to the target&#39;s SIMD instructions, if any; the <code>simd</code> feature gate
is necessary to use this attribute.</li>
<li><code>unsafe_destructor_blind_to_params</code> - on <code>Drop::drop</code> method, asserts that the
destructor code (and all potential specializations of that code) will
never attempt to read from nor write to any references with lifetimes
that come in via generic parameters. This is a constraint we cannot
currently express via the type system, and therefore we rely on the
programmer to assert that it holds. Adding this to a Drop impl causes
the associated destructor to be considered &quot;uninteresting&quot; by the
Drop-Check rule, and thus it can help sidestep data ordering
constraints that would otherwise be introduced by the Drop-Check
rule. Such sidestepping of the constraints, if done incorrectly, can
lead to undefined behavior (in the form of reading or writing to data
outside of its dynamic extent), and thus this attribute has the word
&quot;unsafe&quot; in its name. To use this, the
<code>unsafe_destructor_blind_to_params</code> feature gate must be enabled.</li>
<li><code>doc</code> - Doc comments such as <code>/// foo</code> are equivalent to <code>#[doc = &quot;foo&quot;]</code>.</li>
<li><code>rustc_on_unimplemented</code> - Write a custom note to be shown along with the error
when the trait is found to be unimplemented on a type.
You may use format arguments like <code>{T}</code>, <code>{A}</code> to correspond to the
types at the point of use corresponding to the type parameters of the
trait of the same name. <code>{Self}</code> will be replaced with the type that is supposed
to implement the trait but doesn&#39;t. To use this, the <code>on_unimplemented</code> feature gate
must be enabled.</li>
<li><code>must_use</code> - on structs and enums, will warn if a value of this type isn&#39;t used or
assigned to a variable. You may also include an optional message by using
<code>#[must_use = &quot;message&quot;]</code> which will be given alongside the warning.</li>
</ul>

<h3 id='conditional-compilation' class='section-header'><a href='#conditional-compilation'>6.3.8 Conditional compilation</a></h3>
<p>Sometimes one wants to have different compiler outputs from the same code,
depending on build target, such as targeted operating system, or to enable
release builds.</p>

<p>There are two kinds of configuration options, one that is either defined or not
(<code>#[cfg(foo)]</code>), and the other that contains a string that can be checked
against (<code>#[cfg(bar = &quot;baz&quot;)]</code>). Currently, only compiler-defined configuration
options can have the latter form.</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// The function is only included in the build when compiling for OSX</span>
<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>target_os</span> <span class='op'>=</span> <span class='string'>&quot;macos&quot;</span>)]</span>
<span class='kw'>fn</span> <span class='ident'>macos_only</span>() {
  <span class='comment'>// ...</span>
}

<span class='comment'>// This function is only included when either foo or bar is defined</span>
<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>any</span>(<span class='ident'>foo</span>, <span class='ident'>bar</span>))]</span>
<span class='kw'>fn</span> <span class='ident'>needs_foo_or_bar</span>() {
  <span class='comment'>// ...</span>
}

<span class='comment'>// This function is only included when compiling for a unixish OS with a 32-bit</span>
<span class='comment'>// architecture</span>
<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>all</span>(<span class='ident'>unix</span>, <span class='ident'>target_pointer_width</span> <span class='op'>=</span> <span class='string'>&quot;32&quot;</span>))]</span>
<span class='kw'>fn</span> <span class='ident'>on_32bit_unix</span>() {
  <span class='comment'>// ...</span>
}

<span class='comment'>// This function is only included when foo is not defined</span>
<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>not</span>(<span class='ident'>foo</span>))]</span>
<span class='kw'>fn</span> <span class='ident'>needs_not_foo</span>() {
  <span class='comment'>// ...</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20The%20function%20is%20only%20included%20in%20the%20build%20when%20compiling%20for%20OSX%0A%23%5Bcfg(target_os%20%3D%20%22macos%22)%5D%0Afn%20macos_only()%20%7B%0A%20%20%2F%2F%20...%0A%7D%0A%0A%2F%2F%20This%20function%20is%20only%20included%20when%20either%20foo%20or%20bar%20is%20defined%0A%23%5Bcfg(any(foo%2C%20bar))%5D%0Afn%20needs_foo_or_bar()%20%7B%0A%20%20%2F%2F%20...%0A%7D%0A%0A%2F%2F%20This%20function%20is%20only%20included%20when%20compiling%20for%20a%20unixish%20OS%20with%20a%2032-bit%0A%2F%2F%20architecture%0A%23%5Bcfg(all(unix%2C%20target_pointer_width%20%3D%20%2232%22))%5D%0Afn%20on_32bit_unix()%20%7B%0A%20%20%2F%2F%20...%0A%7D%0A%0A%2F%2F%20This%20function%20is%20only%20included%20when%20foo%20is%20not%20defined%0A%23%5Bcfg(not(foo))%5D%0Afn%20needs_not_foo()%20%7B%0A%20%20%2F%2F%20...%0A%7D%0A%7D">Run</a></pre>

<p>This illustrates some conditional compilation can be achieved using the
<code>#[cfg(...)]</code> attribute. <code>any</code>, <code>all</code> and <code>not</code> can be used to assemble
arbitrarily complex configurations through nesting.</p>

<p>The following configurations must be defined by the implementation:</p>

<ul>
<li><code>target_arch = &quot;...&quot;</code> - Target CPU architecture, such as <code>&quot;x86&quot;</code>,
<code>&quot;x86_64&quot;</code> <code>&quot;mips&quot;</code>, <code>&quot;powerpc&quot;</code>, <code>&quot;powerpc64&quot;</code>, <code>&quot;arm&quot;</code>, or
<code>&quot;aarch64&quot;</code>. This value is closely related to the first element of
the platform target triple, though it is not identical.</li>
<li><code>target_os = &quot;...&quot;</code> - Operating system of the target, examples
include <code>&quot;windows&quot;</code>, <code>&quot;macos&quot;</code>, <code>&quot;ios&quot;</code>, <code>&quot;linux&quot;</code>, <code>&quot;android&quot;</code>,
<code>&quot;freebsd&quot;</code>, <code>&quot;dragonfly&quot;</code>, <code>&quot;bitrig&quot;</code> , <code>&quot;openbsd&quot;</code> or
<code>&quot;netbsd&quot;</code>. This value is closely related to the second and third
element of the platform target triple, though it is not identical.</li>
<li><code>target_family = &quot;...&quot;</code> - Operating system family of the target, e. g.
<code>&quot;unix&quot;</code> or <code>&quot;windows&quot;</code>. The value of this configuration option is defined
as a configuration itself, like <code>unix</code> or <code>windows</code>.</li>
<li><code>unix</code> - See <code>target_family</code>.</li>
<li><code>windows</code> - See <code>target_family</code>.</li>
<li><code>target_env = &quot;..&quot;</code> - Further disambiguates the target platform with
information about the ABI/libc. Presently this value is either
<code>&quot;gnu&quot;</code>, <code>&quot;msvc&quot;</code>, <code>&quot;musl&quot;</code>, or the empty string. For historical
reasons this value has only been defined as non-empty when needed
for disambiguation. Thus on many GNU platforms this value will be
empty. This value is closely related to the fourth element of the
platform target triple, though it is not identical. For example,
embedded ABIs such as <code>gnueabihf</code> will simply define <code>target_env</code> as
<code>&quot;gnu&quot;</code>.</li>
<li><code>target_endian = &quot;...&quot;</code> - Endianness of the target CPU, either <code>&quot;little&quot;</code> or
<code>&quot;big&quot;</code>.</li>
<li><code>target_pointer_width = &quot;...&quot;</code> - Target pointer width in bits. This is set
to <code>&quot;32&quot;</code> for targets with 32-bit pointers, and likewise set to <code>&quot;64&quot;</code> for
64-bit pointers.</li>
<li><code>target_has_atomic = &quot;...&quot;</code> - Set of integer sizes on which the target can perform
atomic operations. Values are <code>&quot;8&quot;</code>, <code>&quot;16&quot;</code>, <code>&quot;32&quot;</code>, <code>&quot;64&quot;</code> and <code>&quot;ptr&quot;</code>.</li>
<li><code>target_vendor = &quot;...&quot;</code> - Vendor of the target, for example <code>apple</code>, <code>pc</code>, or
simply <code>&quot;unknown&quot;</code>.</li>
<li><code>test</code> - Enabled when compiling the test harness (using the <code>--test</code> flag).</li>
<li><code>debug_assertions</code> - Enabled by default when compiling without optimizations.
This can be used to enable extra debugging code in development but not in
production.  For example, it controls the behavior of the standard library&#39;s
<code>debug_assert!</code> macro.</li>
</ul>

<p>You can also set another attribute based on a <code>cfg</code> variable with <code>cfg_attr</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>cfg_attr</span>(<span class='ident'>a</span>, <span class='ident'>b</span>)]</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Bcfg_attr(a%2C%20b)%5D%0A%7D">Run</a></pre>

<p>Will be the same as <code>#[b]</code> if <code>a</code> is set by <code>cfg</code>, and nothing otherwise.</p>

<h3 id='lint-check-attributes' class='section-header'><a href='#lint-check-attributes'>6.3.9 Lint check attributes</a></h3>
<p>A lint check names a potentially undesirable coding pattern, such as
unreachable code or omitted documentation, for the static entity to which the
attribute applies.</p>

<p>For any lint check <code>C</code>:</p>

<ul>
<li><code>allow(C)</code> overrides the check for <code>C</code> so that violations will go
unreported,</li>
<li><code>deny(C)</code> signals an error after encountering a violation of <code>C</code>,</li>
<li><code>forbid(C)</code> is the same as <code>deny(C)</code>, but also forbids changing the lint
level afterwards,</li>
<li><code>warn(C)</code> warns about violations of <code>C</code> but continues compilation.</li>
</ul>

<p>The lint checks supported by the compiler can be found via <code>rustc -W help</code>,
along with their default settings.  <a href="book/compiler-plugins.html#lint-plugins">Compiler
plugins</a> can provide additional lint checks.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>m1</span> {
    <span class='comment'>// Missing documentation is ignored here</span>
    <span class='attribute'>#[<span class='ident'>allow</span>(<span class='ident'>missing_docs</span>)]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>undocumented_one</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>1</span> }

    <span class='comment'>// Missing documentation signals a warning here</span>
    <span class='attribute'>#[<span class='ident'>warn</span>(<span class='ident'>missing_docs</span>)]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>undocumented_too</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>2</span> }

    <span class='comment'>// Missing documentation signals an error here</span>
    <span class='attribute'>#[<span class='ident'>deny</span>(<span class='ident'>missing_docs</span>)]</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>undocumented_end</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>3</span> }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20mod%20m1%20%7B%0A%20%20%20%20%2F%2F%20Missing%20documentation%20is%20ignored%20here%0A%20%20%20%20%23%5Ballow(missing_docs)%5D%0A%20%20%20%20pub%20fn%20undocumented_one()%20-%3E%20i32%20%7B%201%20%7D%0A%0A%20%20%20%20%2F%2F%20Missing%20documentation%20signals%20a%20warning%20here%0A%20%20%20%20%23%5Bwarn(missing_docs)%5D%0A%20%20%20%20pub%20fn%20undocumented_too()%20-%3E%20i32%20%7B%202%20%7D%0A%0A%20%20%20%20%2F%2F%20Missing%20documentation%20signals%20an%20error%20here%0A%20%20%20%20%23%5Bdeny(missing_docs)%5D%0A%20%20%20%20pub%20fn%20undocumented_end()%20-%3E%20i32%20%7B%203%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>This example shows how one can use <code>allow</code> and <code>warn</code> to toggle a particular
check on and off:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>warn</span>(<span class='ident'>missing_docs</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>m2</span>{
    <span class='attribute'>#[<span class='ident'>allow</span>(<span class='ident'>missing_docs</span>)]</span>
    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>nested</span> {
        <span class='comment'>// Missing documentation is ignored here</span>
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>undocumented_one</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>1</span> }

        <span class='comment'>// Missing documentation signals a warning here,</span>
        <span class='comment'>// despite the allow above.</span>
        <span class='attribute'>#[<span class='ident'>warn</span>(<span class='ident'>missing_docs</span>)]</span>
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>undocumented_two</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>2</span> }
    }

    <span class='comment'>// Missing documentation signals a warning here</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>undocumented_too</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>3</span> }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Bwarn(missing_docs)%5D%0Apub%20mod%20m2%7B%0A%20%20%20%20%23%5Ballow(missing_docs)%5D%0A%20%20%20%20pub%20mod%20nested%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Missing%20documentation%20is%20ignored%20here%0A%20%20%20%20%20%20%20%20pub%20fn%20undocumented_one()%20-%3E%20i32%20%7B%201%20%7D%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20Missing%20documentation%20signals%20a%20warning%20here%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20despite%20the%20allow%20above.%0A%20%20%20%20%20%20%20%20%23%5Bwarn(missing_docs)%5D%0A%20%20%20%20%20%20%20%20pub%20fn%20undocumented_two()%20-%3E%20i32%20%7B%202%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20Missing%20documentation%20signals%20a%20warning%20here%0A%20%20%20%20pub%20fn%20undocumented_too()%20-%3E%20i32%20%7B%203%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>This example shows how one can use <code>forbid</code> to disallow uses of <code>allow</code> for
that lint check:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>forbid</span>(<span class='ident'>missing_docs</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>m3</span> {
    <span class='comment'>// Attempting to toggle warning signals an error here</span>
    <span class='attribute'>#[<span class='ident'>allow</span>(<span class='ident'>missing_docs</span>)]</span>
    <span class='doccomment'>/// Returns 2.</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>undocumented_too</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>2</span> }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Bforbid(missing_docs)%5D%0Apub%20mod%20m3%20%7B%0A%20%20%20%20%2F%2F%20Attempting%20to%20toggle%20warning%20signals%20an%20error%20here%0A%20%20%20%20%23%5Ballow(missing_docs)%5D%0A%20%20%20%20%2F%2F%2F%20Returns%202.%0A%20%20%20%20pub%20fn%20undocumented_too()%20-%3E%20i32%20%7B%202%20%7D%0A%7D%0A%7D">Run</a></pre>

<h3 id='language-items' class='section-header'><a href='#language-items'>6.3.10 Language items</a></h3>
<p>Some primitive Rust operations are defined in Rust code, rather than being
implemented directly in C or assembly language. The definitions of these
operations have to be easy for the compiler to find. The <code>lang</code> attribute
makes it possible to declare these operations. For example, the <code>str</code> module
in the Rust standard library defines the string equality function:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;str_eq&quot;</span>]</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>eq_slice</span>(<span class='ident'>a</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>b</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='comment'>// details elided</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Blang%20%3D%20%22str_eq%22%5D%0Apub%20fn%20eq_slice(a%3A%20%26str%2C%20b%3A%20%26str)%20-%3E%20bool%20%7B%0A%20%20%20%20%2F%2F%20details%20elided%0A%7D%0A%7D">Run</a></pre>

<p>The name <code>str_eq</code> has a special meaning to the Rust compiler, and the presence
of this definition means that it will use this definition when generating calls
to the string equality function.</p>

<p>The set of language items is currently considered unstable. A complete
list of the built-in language items will be added in the future.</p>

<h3 id='inline-attributes' class='section-header'><a href='#inline-attributes'>6.3.11 Inline attributes</a></h3>
<p>The inline attribute suggests that the compiler should place a copy of
the function or static in the caller, rather than generating code to
call the function or access the static where it is defined.</p>

<p>The compiler automatically inlines functions based on internal heuristics.
Incorrectly inlining functions can actually make the program slower, so it
should be used with care.</p>

<p><code>#[inline]</code> and <code>#[inline(always)]</code> always cause the function to be serialized
into the crate metadata to allow cross-crate inlining.</p>

<p>There are three different types of inline attributes:</p>

<ul>
<li><code>#[inline]</code> hints the compiler to perform an inline expansion.</li>
<li><code>#[inline(always)]</code> asks the compiler to always perform an inline expansion.</li>
<li><code>#[inline(never)]</code> asks the compiler to never perform an inline expansion.</li>
</ul>

<h3 id='derive' class='section-header'><a href='#derive'>6.3.12 <code>derive</code></a></h3>
<p>The <code>derive</code> attribute allows certain traits to be automatically implemented
for data structures. For example, the following will create an <code>impl</code> for the
<code>PartialEq</code> and <code>Clone</code> traits for <code>Foo</code>, the type parameter <code>T</code> will be given
the <code>PartialEq</code> or <code>Clone</code> constraints for the appropriate <code>impl</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>PartialEq</span>, <span class='ident'>Clone</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>a</span>: <span class='ident'>i32</span>,
    <span class='ident'>b</span>: <span class='ident'>T</span>,
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Bderive(PartialEq%2C%20Clone)%5D%0Astruct%20Foo%3CT%3E%20%7B%0A%20%20%20%20a%3A%20i32%2C%0A%20%20%20%20b%3A%20T%2C%0A%7D%0A%7D">Run</a></pre>

<p>The generated <code>impl</code> for <code>PartialEq</code> is equivalent to</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>PartialEq</span><span class='op'>&gt;</span> <span class='ident'>PartialEq</span> <span class='kw'>for</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>eq</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>other</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='self'>self</span>.<span class='ident'>a</span> <span class='op'>==</span> <span class='ident'>other</span>.<span class='ident'>a</span> <span class='op'>&amp;&amp;</span> <span class='self'>self</span>.<span class='ident'>b</span> <span class='op'>==</span> <span class='ident'>other</span>.<span class='ident'>b</span>
    }

    <span class='kw'>fn</span> <span class='ident'>ne</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>other</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='self'>self</span>.<span class='ident'>a</span> <span class='op'>!=</span> <span class='ident'>other</span>.<span class='ident'>a</span> <span class='op'>||</span> <span class='self'>self</span>.<span class='ident'>b</span> <span class='op'>!=</span> <span class='ident'>other</span>.<span class='ident'>b</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Foo%3CT%3E%20%7B%20a%3A%20i32%2C%20b%3A%20T%20%7D%0Aimpl%3CT%3A%20PartialEq%3E%20PartialEq%20for%20Foo%3CT%3E%20%7B%0A%20%20%20%20fn%20eq(%26self%2C%20other%3A%20%26Foo%3CT%3E)%20-%3E%20bool%20%7B%0A%20%20%20%20%20%20%20%20self.a%20%3D%3D%20other.a%20%26%26%20self.b%20%3D%3D%20other.b%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20ne(%26self%2C%20other%3A%20%26Foo%3CT%3E)%20-%3E%20bool%20%7B%0A%20%20%20%20%20%20%20%20self.a%20!%3D%20other.a%20%7C%7C%20self.b%20!%3D%20other.b%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<h3 id='compiler-features' class='section-header'><a href='#compiler-features'>6.3.13 Compiler Features</a></h3>
<p>Certain aspects of Rust may be implemented in the compiler, but they&#39;re not
necessarily ready for every-day use. These features are often of &quot;prototype
quality&quot; or &quot;almost production ready&quot;, but may not be stable enough to be
considered a full-fledged language feature.</p>

<p>For this reason, Rust recognizes a special crate-level attribute of the form:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>feature1</span>, <span class='ident'>feature2</span>, <span class='ident'>feature3</span>)]</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(feature1%2C%20feature2%2C%20feature3)%5D%0Afn%20main()%20%7B%0A%7D&amp;version=nightly">Run</a></pre>

<p>This directive informs the compiler that the feature list: <code>feature1</code>,
<code>feature2</code>, and <code>feature3</code> should all be enabled. This is only recognized at a
crate-level, not at a module-level. Without this directive, all features are
considered off, and using the features will result in a compiler error.</p>

<p>The currently implemented features of the reference compiler are:</p>

<ul>
<li><p><code>advanced_slice_patterns</code> - See the <a href="#match-expressions">match expressions</a>
                          section for discussion; the exact semantics of
                          slice patterns are subject to change, so some types
                          are still unstable.</p></li>
<li><p><code>slice_patterns</code> - OK, actually, slice patterns are just scary and
                 completely unstable.</p></li>
<li><p><code>asm</code> - The <code>asm!</code> macro provides a means for inline assembly. This is often
      useful, but the exact syntax for this feature along with its
      semantics are likely to change, so this macro usage must be opted
      into.</p></li>
<li><p><code>associated_consts</code> - Allows constants to be defined in <code>impl</code> and <code>trait</code>
                    blocks, so that they can be associated with a type or
                    trait in a similar manner to methods and associated
                    types.</p></li>
<li><p><code>box_patterns</code> - Allows <code>box</code> patterns, the exact semantics of which
               is subject to change.</p></li>
<li><p><code>box_syntax</code> - Allows use of <code>box</code> expressions, the exact semantics of which
             is subject to change.</p></li>
<li><p><code>cfg_target_vendor</code> - Allows conditional compilation using the <code>target_vendor</code>
                    matcher which is subject to change.</p></li>
<li><p><code>cfg_target_has_atomic</code> - Allows conditional compilation using the <code>target_has_atomic</code>
                        matcher which is subject to change.</p></li>
<li><p><code>concat_idents</code> - Allows use of the <code>concat_idents</code> macro, which is in many
                ways insufficient for concatenating identifiers, and may be
                removed entirely for something more wholesome.</p></li>
<li><p><code>custom_attribute</code> - Allows the usage of attributes unknown to the compiler
                   so that new attributes can be added in a backwards compatible
                   manner (RFC 572).</p></li>
<li><p><code>custom_derive</code> - Allows the use of <code>#[derive(Foo,Bar)]</code> as sugar for
                <code>#[derive_Foo] #[derive_Bar]</code>, which can be user-defined syntax
                extensions.</p></li>
<li><p><code>inclusive_range_syntax</code> - Allows use of the <code>a...b</code> and <code>...b</code> syntax for inclusive ranges.</p></li>
<li><p><code>inclusive_range</code> - Allows use of the types that represent desugared inclusive ranges.</p></li>
<li><p><code>intrinsics</code> - Allows use of the &quot;rust-intrinsics&quot; ABI. Compiler intrinsics
             are inherently unstable and no promise about them is made.</p></li>
<li><p><code>lang_items</code> - Allows use of the <code>#[lang]</code> attribute. Like <code>intrinsics</code>,
             lang items are inherently unstable and no promise about them
             is made.</p></li>
<li><p><code>link_args</code> - This attribute is used to specify custom flags to the linker,
            but usage is strongly discouraged. The compiler&#39;s usage of the
            system linker is not guaranteed to continue in the future, and
            if the system linker is not used then specifying custom flags
            doesn&#39;t have much meaning.</p></li>
<li><p><code>link_llvm_intrinsics</code>  Allows linking to LLVM intrinsics via
                       <code>#[link_name=&quot;llvm.*&quot;]</code>.</p></li>
<li><p><code>linkage</code> - Allows use of the <code>linkage</code> attribute, which is not portable.</p></li>
<li><p><code>log_syntax</code> - Allows use of the <code>log_syntax</code> macro attribute, which is a
             nasty hack that will certainly be removed.</p></li>
<li><p><code>main</code> - Allows use of the <code>#[main]</code> attribute, which changes the entry point
       into a Rust program. This capability is subject to change.</p></li>
<li><p><code>macro_reexport</code> - Allows macros to be re-exported from one crate after being imported
                 from another. This feature was originally designed with the sole
                 use case of the Rust standard library in mind, and is subject to
                 change.</p></li>
<li><p><code>non_ascii_idents</code> - The compiler supports the use of non-ascii identifiers,
                   but the implementation is a little rough around the
                   edges, so this can be seen as an experimental feature
                   for now until the specification of identifiers is fully
                   fleshed out.</p></li>
<li><p><code>no_std</code> - Allows the <code>#![no_std]</code> crate attribute, which disables the implicit
         <code>extern crate std</code>. This typically requires use of the unstable APIs
         behind the libstd &quot;facade&quot;, such as libcore and libcollections. It
         may also cause problems when using syntax extensions, including
         <code>#[derive]</code>.</p></li>
<li><p><code>on_unimplemented</code> - Allows the <code>#[rustc_on_unimplemented]</code> attribute, which allows
                   trait definitions to add specialized notes to error messages
                   when an implementation was expected but not found.</p></li>
<li><p><code>optin_builtin_traits</code> - Allows the definition of default and negative trait
                       implementations. Experimental.</p></li>
<li><p><code>plugin</code> - Usage of <a href="book/compiler-plugins.html">compiler plugins</a> for custom lints or syntax extensions.
         These depend on compiler internals and are subject to change.</p></li>
<li><p><code>plugin_registrar</code> - Indicates that a crate provides <a href="book/compiler-plugins.html">compiler plugins</a>.</p></li>
<li><p><code>quote</code> - Allows use of the <code>quote_*!</code> family of macros, which are
        implemented very poorly and will likely change significantly
        with a proper implementation.</p></li>
<li><p><code>rustc_attrs</code> - Gates internal <code>#[rustc_*]</code> attributes which may be
              for internal use only or have meaning added to them in the future.</p></li>
<li><p><code>rustc_diagnostic_macros</code>- A mysterious feature, used in the implementation
                         of rustc, not meant for mortals.</p></li>
<li><p><code>simd</code> - Allows use of the <code>#[simd]</code> attribute, which is overly simple and
       not the SIMD interface we want to expose in the long term.</p></li>
<li><p><code>simd_ffi</code> - Allows use of SIMD vectors in signatures for foreign functions.
           The SIMD interface is subject to change.</p></li>
<li><p><code>start</code> - Allows use of the <code>#[start]</code> attribute, which changes the entry point
        into a Rust program. This capability, especially the signature for the
        annotated function, is subject to change.</p></li>
<li><p><code>static_in_const</code> - Enables lifetime elision with a <code>&#39;static</code> default for
                  <code>const</code> and <code>static</code> item declarations.</p></li>
<li><p><code>thread_local</code> - The usage of the <code>#[thread_local]</code> attribute is experimental
               and should be seen as unstable. This attribute is used to
               declare a <code>static</code> as being unique per-thread leveraging
               LLVM&#39;s implementation which works in concert with the kernel
               loader and dynamic linker. This is not necessarily available
               on all platforms, and usage of it is discouraged.</p></li>
<li><p><code>trace_macros</code> - Allows use of the <code>trace_macros</code> macro, which is a nasty
               hack that will certainly be removed.</p></li>
<li><p><code>unboxed_closures</code> - Rust&#39;s new closure design, which is currently a work in
                   progress feature with many known bugs.</p></li>
<li><p><code>unmarked_api</code> - Allows use of items within a <code>#![staged_api]</code> crate
               which have not been marked with a stability marker.
               Such items should not be allowed by the compiler to exist,
               so if you need this there probably is a compiler bug.</p></li>
<li><p><code>allow_internal_unstable</code> - Allows <code>macro_rules!</code> macros to be tagged with the
                          <code>#[allow_internal_unstable]</code> attribute, designed
                          to allow <code>std</code> macros to call
                          <code>#[unstable]</code>/feature-gated functionality
                          internally without imposing on callers
                          (i.e. making them behave like function calls in
                          terms of encapsulation).</p></li>
<li><ul>
<li><code>default_type_parameter_fallback</code> - Allows type parameter defaults to
                                influence type inference.</li>
</ul></li>
<li><ul>
<li><code>stmt_expr_attributes</code> - Allows attributes on expressions.</li>
</ul></li>
<li><ul>
<li><code>type_ascription</code> - Allows type ascription expressions <code>expr: Type</code>.</li>
</ul></li>
<li><ul>
<li><code>abi_vectorcall</code> - Allows the usage of the vectorcall calling convention
                     (e.g. <code>extern &quot;vectorcall&quot; func fn_();</code>)</li>
</ul></li>
<li><ul>
<li><code>dotdot_in_tuple_patterns</code> - Allows <code>..</code> in tuple (struct) patterns.</li>
</ul></li>
<li><ul>
<li><code>abi_sysv64</code> - Allows the usage of the system V AMD64 calling convention
                     (e.g. <code>extern &quot;sysv64&quot; func fn_();</code>)</li>
</ul></li>
</ul>

<p>If a feature is promoted to a language feature, then all existing programs will
start to receive compilation warnings about <code>#![feature]</code> directives which enabled
the new feature (because the directive is no longer necessary). However, if a
feature is decided to be removed from the language, errors will be issued (if
there isn&#39;t a parser error first). The directive in this case is no longer
necessary, and it&#39;s likely that existing code will break if the feature isn&#39;t
removed.</p>

<p>If an unknown feature is found in a directive, it results in a compiler error.
An unknown feature is one which has never been recognized by the compiler.</p>

<h1 id='statements-and-expressions' class='section-header'><a href='#statements-and-expressions'>7 Statements and expressions</a></h1>
<p>Rust is <em>primarily</em> an expression language. This means that most forms of
value-producing or effect-causing evaluation are directed by the uniform syntax
category of <em>expressions</em>. Each kind of expression can typically <em>nest</em> within
each other kind of expression, and rules for evaluation of expressions involve
specifying both the value produced by the expression and the order in which its
sub-expressions are themselves evaluated.</p>

<p>In contrast, statements in Rust serve <em>mostly</em> to contain and explicitly
sequence expression evaluation.</p>

<h2 id='statements' class='section-header'><a href='#statements'>7.1 Statements</a></h2>
<p>A <em>statement</em> is a component of a block, which is in turn a component of an
outer <a href="#expressions">expression</a> or <a href="#functions">function</a>.</p>

<p>Rust has two kinds of statement: <a href="#declaration-statements">declaration
statements</a> and <a href="#expression-statements">expression
statements</a>.</p>

<h3 id='declaration-statements' class='section-header'><a href='#declaration-statements'>7.1.1 Declaration statements</a></h3>
<p>A <em>declaration statement</em> is one that introduces one or more <em>names</em> into the
enclosing statement block. The declared names may denote new variables or new
items.</p>

<h4 id='item-declarations' class='section-header'><a href='#item-declarations'>7.1.1.1 Item declarations</a></h4>
<p>An <em>item declaration statement</em> has a syntactic form identical to an
<a href="#items">item</a> declaration within a module. Declaring an item &mdash; a
function, enumeration, struct, type, static, trait, implementation or module
&mdash; locally within a statement block is simply a way of restricting its
scope to a narrow region containing all of its uses; it is otherwise identical
in meaning to declaring the item outside the statement block.</p>

<blockquote>
<p><strong>Note</strong>: there is no implicit capture of the function&#39;s dynamic environment when
declaring a function-local item.</p>
</blockquote>

<h4 id='let-statements' class='section-header'><a href='#let-statements'>7.1.1.2 <code>let</code> statements</a></h4>
<p>A <em><code>let</code> statement</em> introduces a new set of variables, given by a pattern. The
pattern may be followed by a type annotation, and/or an initializer expression.
When no type annotation is given, the compiler will infer the type, or signal
an error if insufficient type information is available for definite inference.
Any variables introduced by a variable declaration are visible from the point of
declaration until the end of the enclosing block scope.</p>

<h3 id='expression-statements' class='section-header'><a href='#expression-statements'>7.1.2 Expression statements</a></h3>
<p>An <em>expression statement</em> is one that evaluates an <a href="#expressions">expression</a>
and ignores its result. The type of an expression statement <code>e;</code> is always
<code>()</code>, regardless of the type of <code>e</code>. As a rule, an expression statement&#39;s
purpose is to trigger the effects of evaluating its expression.</p>

<h2 id='expressions' class='section-header'><a href='#expressions'>7.2 Expressions</a></h2>
<p>An expression may have two roles: it always produces a <em>value</em>, and it may have
<em>effects</em> (otherwise known as &quot;side effects&quot;). An expression <em>evaluates to</em> a
value, and has effects during <em>evaluation</em>. Many expressions contain
sub-expressions (operands). The meaning of each kind of expression dictates
several things:</p>

<ul>
<li>Whether or not to evaluate the sub-expressions when evaluating the expression</li>
<li>The order in which to evaluate the sub-expressions</li>
<li>How to combine the sub-expressions&#39; values to obtain the value of the expression</li>
</ul>

<p>In this way, the structure of expressions dictates the structure of execution.
Blocks are just another kind of expression, so blocks, statements, expressions,
and blocks again can recursively nest inside each other to an arbitrary depth.</p>

<h4 id='lvalues-rvalues-and-temporaries' class='section-header'><a href='#lvalues-rvalues-and-temporaries'>7.2.0.1 Lvalues, rvalues and temporaries</a></h4>
<p>Expressions are divided into two main categories: <em>lvalues</em> and <em>rvalues</em>.
Likewise within each expression, sub-expressions may occur in <em>lvalue context</em>
or <em>rvalue context</em>. The evaluation of an expression depends both on its own
category and the context it occurs within.</p>

<p>An lvalue is an expression that represents a memory location. These expressions
are <a href="#path-expressions">paths</a> (which refer to local variables, function and
method arguments, or static variables), dereferences (<code>*expr</code>), <a href="#index-expressions">indexing
expressions</a> (<code>expr[expr]</code>), and <a href="#field-expressions">field
references</a> (<code>expr.f</code>). All other expressions are rvalues.</p>

<p>The left operand of an <a href="#assignment-expressions">assignment</a> or
<a href="#compound-assignment-expressions">compound-assignment</a> expression is
an lvalue context, as is the single operand of a unary
<a href="#unary-operator-expressions">borrow</a>. The discriminant or subject of
a <a href="#match-expressions">match expression</a> may be an lvalue context, if
ref bindings are made, but is otherwise an rvalue context. All other
expression contexts are rvalue contexts.</p>

<p>When an lvalue is evaluated in an <em>lvalue context</em>, it denotes a memory
location; when evaluated in an <em>rvalue context</em>, it denotes the value held <em>in</em>
that memory location.</p>

<h5 id='temporary-lifetimes' class='section-header'><a href='#temporary-lifetimes'>7.2.0.1.1 Temporary lifetimes</a></h5>
<p>When an rvalue is used in an lvalue context, a temporary un-named
lvalue is created and used instead. The lifetime of temporary values
is typically the innermost enclosing statement; the tail expression of
a block is considered part of the statement that encloses the block.</p>

<p>When a temporary rvalue is being created that is assigned into a <code>let</code>
declaration, however, the temporary is created with the lifetime of
the enclosing block instead, as using the enclosing statement (the
<code>let</code> declaration) would be a guaranteed error (since a pointer to the
temporary would be stored into a variable, but the temporary would be
freed before the variable could be used). The compiler uses simple
syntactic rules to decide which values are being assigned into a <code>let</code>
binding, and therefore deserve a longer temporary lifetime.</p>

<p>Here are some examples:</p>

<ul>
<li><code>let x = foo(&amp;temp())</code>. The expression <code>temp()</code> is an rvalue. As it
is being borrowed, a temporary is created which will be freed after
the innermost enclosing statement (the <code>let</code> declaration, in this case).</li>
<li><code>let x = temp().foo()</code>. This is the same as the previous example,
except that the value of <code>temp()</code> is being borrowed via autoref on a
method-call. Here we are assuming that <code>foo()</code> is an <code>&amp;self</code> method
defined in some trait, say <code>Foo</code>. In other words, the expression
<code>temp().foo()</code> is equivalent to <code>Foo::foo(&amp;temp())</code>.</li>
<li><code>let x = &amp;temp()</code>. Here, the same temporary is being assigned into
<code>x</code>, rather than being passed as a parameter, and hence the
temporary&#39;s lifetime is considered to be the enclosing block.</li>
<li><code>let x = SomeStruct { foo: &amp;temp() }</code>. As in the previous case, the
temporary is assigned into a struct which is then assigned into a
binding, and hence it is given the lifetime of the enclosing block.</li>
<li><code>let x = [ &amp;temp() ]</code>. As in the previous case, the
temporary is assigned into an array which is then assigned into a
binding, and hence it is given the lifetime of the enclosing block.</li>
<li><code>let ref x = temp()</code>. In this case, the temporary is created using a ref binding,
but the result is the same: the lifetime is extended to the enclosing block.</li>
</ul>

<h4 id='moved-and-copied-types' class='section-header'><a href='#moved-and-copied-types'>7.2.0.2 Moved and copied types</a></h4>
<p>When a <a href="#variables">local variable</a> is used as an
<a href="#lvalues-rvalues-and-temporaries">rvalue</a>, the variable will be copied
if its type implements <code>Copy</code>. All others are moved.</p>

<h3 id='literal-expressions' class='section-header'><a href='#literal-expressions'>7.2.1 Literal expressions</a></h3>
<p>A <em>literal expression</em> consists of one of the <a href="#literals">literal</a> forms
described earlier. It directly describes a number, character, string, boolean
value, or the unit value.</p>

<pre><code class="language-{.literals}">();        // unit type
&quot;hello&quot;;   // string type
&#39;5&#39;;       // character type
5;         // integer type
</code></pre>

<h3 id='path-expressions' class='section-header'><a href='#path-expressions'>7.2.2 Path expressions</a></h3>
<p>A <a href="#paths">path</a> used as an expression context denotes either a local variable
or an item. Path expressions are <a href="#lvalues-rvalues-and-temporaries">lvalues</a>.</p>

<h3 id='tuple-expressions' class='section-header'><a href='#tuple-expressions'>7.2.3 Tuple expressions</a></h3>
<p>Tuples are written by enclosing zero or more comma-separated expressions in
parentheses. They are used to create <a href="#tuple-types">tuple-typed</a> values.</p>

<pre><code class="language-{.tuple}">(0.0, 4.5);
(&quot;a&quot;, 4usize, true);
</code></pre>

<p>You can disambiguate a single-element tuple from a value in parentheses with a
comma:</p>

<pre class='rust rust-example-rendered'>
(<span class='number'>0</span>,); <span class='comment'>// single-element tuple</span>
(<span class='number'>0</span>); <span class='comment'>// zero in parentheses</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A(0%2C)%3B%20%2F%2F%20single-element%20tuple%0A(0)%3B%20%2F%2F%20zero%20in%20parentheses%0A%7D">Run</a></pre>

<h3 id='struct-expressions' class='section-header'><a href='#struct-expressions'>7.2.4 Struct expressions</a></h3>
<p>There are several forms of struct expressions. A <em>struct expression</em>
consists of the <a href="#paths">path</a> of a <a href="#structs">struct item</a>, followed by
a brace-enclosed list of zero or more comma-separated name-value pairs,
providing the field values of a new instance of the struct. A field name
can be any identifier, and is separated from its value expression by a colon.
The location denoted by a struct field is mutable if and only if the
enclosing struct is mutable.</p>

<p>A <em>tuple struct expression</em> consists of the <a href="#paths">path</a> of a <a href="#structs">struct
item</a>, followed by a parenthesized list of one or more
comma-separated expressions (in other words, the path of a struct item
followed by a tuple expression). The struct item must be a tuple struct
item.</p>

<p>A <em>unit-like struct expression</em> consists only of the <a href="#paths">path</a> of a
<a href="#structs">struct item</a>.</p>

<p>The following are examples of struct expressions:</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>Point</span> {<span class='ident'>x</span>: <span class='number'>10.0</span>, <span class='ident'>y</span>: <span class='number'>20.0</span>};
<span class='ident'>NothingInMe</span> {};
<span class='ident'>TuplePoint</span>(<span class='number'>10.0</span>, <span class='number'>20.0</span>);
<span class='kw'>let</span> <span class='ident'>u</span> <span class='op'>=</span> <span class='ident'>game</span>::<span class='ident'>User</span> {<span class='ident'>name</span>: <span class='string'>&quot;Joe&quot;</span>, <span class='ident'>age</span>: <span class='number'>35</span>, <span class='ident'>score</span>: <span class='number'>100_000</span>};
<span class='ident'>some_fn</span>::<span class='op'>&lt;</span><span class='ident'>Cookie</span><span class='op'>&gt;</span>(<span class='ident'>Cookie</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Point%20%7B%20x%3A%20f64%2C%20y%3A%20f64%20%7D%0Astruct%20NothingInMe%20%7B%20%7D%0Astruct%20TuplePoint(f64%2C%20f64)%3B%0Amod%20game%20%7B%20pub%20struct%20User%3C'a%3E%20%7B%20pub%20name%3A%20%26'a%20str%2C%20pub%20age%3A%20u32%2C%20pub%20score%3A%20usize%20%7D%20%7D%0Astruct%20Cookie%3B%20fn%20some_fn%3CT%3E(t%3A%20T)%20%7B%7D%0APoint%20%7Bx%3A%2010.0%2C%20y%3A%2020.0%7D%3B%0ANothingInMe%20%7B%7D%3B%0ATuplePoint(10.0%2C%2020.0)%3B%0Alet%20u%20%3D%20game%3A%3AUser%20%7Bname%3A%20%22Joe%22%2C%20age%3A%2035%2C%20score%3A%20100_000%7D%3B%0Asome_fn%3A%3A%3CCookie%3E(Cookie)%3B%0A%7D">Run</a></pre>

<p>A struct expression forms a new value of the named struct type. Note
that for a given <em>unit-like</em> struct type, this will always be the same
value.</p>

<p>A struct expression can terminate with the syntax <code>..</code> followed by an
expression to denote a functional update. The expression following <code>..</code> (the
base) must have the same struct type as the new struct type being formed.
The entire expression denotes the result of constructing a new struct (with
the same type as the base expression) with the given values for the fields that
were explicitly specified and the values in the base expression for all other
fields.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>base</span> <span class='op'>=</span> <span class='ident'>Point3d</span> {<span class='ident'>x</span>: <span class='number'>1</span>, <span class='ident'>y</span>: <span class='number'>2</span>, <span class='ident'>z</span>: <span class='number'>3</span>};
<span class='ident'>Point3d</span> {<span class='ident'>y</span>: <span class='number'>0</span>, <span class='ident'>z</span>: <span class='number'>10</span>, .. <span class='ident'>base</span>};<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Point3d%20%7B%20x%3A%20i32%2C%20y%3A%20i32%2C%20z%3A%20i32%20%7D%0Alet%20base%20%3D%20Point3d%20%7Bx%3A%201%2C%20y%3A%202%2C%20z%3A%203%7D%3B%0APoint3d%20%7By%3A%200%2C%20z%3A%2010%2C%20..%20base%7D%3B%0A%7D">Run</a></pre>

<h3 id='block-expressions' class='section-header'><a href='#block-expressions'>7.2.5 Block expressions</a></h3>
<p>A <em>block expression</em> is similar to a module in terms of the declarations that
are possible. Each block conceptually introduces a new namespace scope. Use
items can bring new names into scopes and declared items are in scope for only
the block itself.</p>

<p>A block will execute each statement sequentially, and then execute the
expression (if given). If the block ends in a statement, its value is <code>()</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: () <span class='op'>=</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello.&quot;</span>); };<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%3A%20()%20%3D%20%7B%20println!(%22Hello.%22)%3B%20%7D%3B%0A%7D">Run</a></pre>

<p>If it ends in an expression, its value and type are that of the expression:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello.&quot;</span>); <span class='number'>5</span> };

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='ident'>x</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%3A%20i32%20%3D%20%7B%20println!(%22Hello.%22)%3B%205%20%7D%3B%0A%0Aassert_eq!(5%2C%20x)%3B%0A%7D">Run</a></pre>

<h3 id='method-call-expressions' class='section-header'><a href='#method-call-expressions'>7.2.6 Method-call expressions</a></h3>
<p>A <em>method call</em> consists of an expression followed by a single dot, an
identifier, and a parenthesized expression-list. Method calls are resolved to
methods on specific traits, either statically dispatching to a method if the
exact <code>self</code>-type of the left-hand-side is known, or dynamically dispatching if
the left-hand-side expression is an indirect <a href="#trait-objects">trait object</a>.</p>

<h3 id='field-expressions' class='section-header'><a href='#field-expressions'>7.2.7 Field expressions</a></h3>
<p>A <em>field expression</em> consists of an expression followed by a single dot and an
identifier, when not immediately followed by a parenthesized expression-list
(the latter is a <a href="#method-call-expressions">method call expression</a>). A field
expression denotes a field of a <a href="#struct-types">struct</a>.</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>mystruct</span>.<span class='ident'>myfield</span>;
<span class='ident'>foo</span>().<span class='ident'>x</span>;
(<span class='ident'>Struct</span> {<span class='ident'>a</span>: <span class='number'>10</span>, <span class='ident'>b</span>: <span class='number'>20</span>}).<span class='ident'>a</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amystruct.myfield%3B%0Afoo().x%3B%0A(Struct%20%7Ba%3A%2010%2C%20b%3A%2020%7D).a%3B%0A%7D">Run</a></pre>

<p>A field access is an <a href="#lvalues-rvalues-and-temporaries">lvalue</a> referring to
the value of that field. When the type providing the field inherits mutability,
it can be <a href="#assignment-expressions">assigned</a> to.</p>

<p>Also, if the type of the expression to the left of the dot is a
pointer, it is automatically dereferenced as many times as necessary
to make the field access possible. In cases of ambiguity, we prefer
fewer autoderefs to more.</p>

<h3 id='array-expressions' class='section-header'><a href='#array-expressions'>7.2.8 Array expressions</a></h3>
<p>An <a href="#array-and-slice-types">array</a> <em>expression</em> is written by enclosing zero
or more comma-separated expressions of uniform type in square brackets.</p>

<p>In the <code>[expr &#39;;&#39; expr]</code> form, the expression after the <code>&#39;;&#39;</code> must be a
constant expression that can be evaluated at compile time, such as a
<a href="#literals">literal</a> or a <a href="#static-items">static item</a>.</p>

<pre class='rust rust-example-rendered'>
[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
[<span class='string'>&quot;a&quot;</span>, <span class='string'>&quot;b&quot;</span>, <span class='string'>&quot;c&quot;</span>, <span class='string'>&quot;d&quot;</span>];
[<span class='number'>0</span>; <span class='number'>128</span>];              <span class='comment'>// array with 128 zeros</span>
[<span class='number'>0u8</span>, <span class='number'>0u8</span>, <span class='number'>0u8</span>, <span class='number'>0u8</span>];<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%5B1%2C%202%2C%203%2C%204%5D%3B%0A%5B%22a%22%2C%20%22b%22%2C%20%22c%22%2C%20%22d%22%5D%3B%0A%5B0%3B%20128%5D%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20array%20with%20128%20zeros%0A%5B0u8%2C%200u8%2C%200u8%2C%200u8%5D%3B%0A%7D">Run</a></pre>

<h3 id='index-expressions' class='section-header'><a href='#index-expressions'>7.2.9 Index expressions</a></h3>
<p><a href="#array-and-slice-types">Array</a>-typed expressions can be indexed by
writing a square-bracket-enclosed expression (the index) after them. When the
array is mutable, the resulting <a href="#lvalues-rvalues-and-temporaries">lvalue</a> can
be assigned to.</p>

<p>Indices are zero-based, and may be of any integral type. Vector access is
bounds-checked at compile-time for constant arrays being accessed with a constant index value.
Otherwise a check will be performed at run-time that will put the thread in a <em>panicked state</em> if it fails.</p>

<pre><code class="language-{should-fail}">([1, 2, 3, 4])[0];

let x = ([&quot;a&quot;, &quot;b&quot;])[10]; // compiler error: const index-expr is out of bounds

let n = 10;
let y = ([&quot;a&quot;, &quot;b&quot;])[n]; // panics

let arr = [&quot;a&quot;, &quot;b&quot;];
arr[10]; // panics
</code></pre>

<p>Also, if the type of the expression to the left of the brackets is a
pointer, it is automatically dereferenced as many times as necessary
to make the indexing possible. In cases of ambiguity, we prefer fewer
autoderefs to more.</p>

<h3 id='range-expressions' class='section-header'><a href='#range-expressions'>7.2.10 Range expressions</a></h3>
<p>The <code>..</code> operator will construct an object of one of the <code>std::ops::Range</code> variants.</p>

<pre class='rust rust-example-rendered'>
<span class='number'>1</span>..<span class='number'>2</span>;   <span class='comment'>// std::ops::Range</span>
<span class='number'>3</span>..;    <span class='comment'>// std::ops::RangeFrom</span>
..<span class='number'>4</span>;    <span class='comment'>// std::ops::RangeTo</span>
..;     <span class='comment'>// std::ops::RangeFull</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A1..2%3B%20%20%20%2F%2F%20std%3A%3Aops%3A%3ARange%0A3..%3B%20%20%20%20%2F%2F%20std%3A%3Aops%3A%3ARangeFrom%0A..4%3B%20%20%20%20%2F%2F%20std%3A%3Aops%3A%3ARangeTo%0A..%3B%20%20%20%20%20%2F%2F%20std%3A%3Aops%3A%3ARangeFull%0A%7D">Run</a></pre>

<p>The following expressions are equivalent.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Range</span> {<span class='ident'>start</span>: <span class='number'>0</span>, <span class='ident'>end</span>: <span class='number'>10</span>};
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>0</span>..<span class='number'>10</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='ident'>y</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%20%3D%20std%3A%3Aops%3A%3ARange%20%7Bstart%3A%200%2C%20end%3A%2010%7D%3B%0Alet%20y%20%3D%200..10%3B%0A%0Aassert_eq!(x%2C%20y)%3B%0A%7D">Run</a></pre>

<p>Similarly, the <code>...</code> operator will construct an object of one of the
<code>std::ops::RangeInclusive</code> variants.</p>

<pre class='rust rust-example-rendered'>
<span class='number'>1</span>...<span class='number'>2</span>;   <span class='comment'>// std::ops::RangeInclusive</span>
...<span class='number'>4</span>;    <span class='comment'>// std::ops::RangeToInclusive</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(inclusive_range_syntax)%5D%0Afn%20main()%20%7B%0A1...2%3B%20%20%20%2F%2F%20std%3A%3Aops%3A%3ARangeInclusive%0A...4%3B%20%20%20%20%2F%2F%20std%3A%3Aops%3A%3ARangeToInclusive%0A%7D&amp;version=nightly">Run</a></pre>

<p>The following expressions are equivalent.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>RangeInclusive</span>::<span class='ident'>NonEmpty</span> {<span class='ident'>start</span>: <span class='number'>0</span>, <span class='ident'>end</span>: <span class='number'>10</span>};
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>0</span>...<span class='number'>10</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='ident'>y</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(inclusive_range_syntax%2C%20inclusive_range)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20std%3A%3Aops%3A%3ARangeInclusive%3A%3ANonEmpty%20%7Bstart%3A%200%2C%20end%3A%2010%7D%3B%0Alet%20y%20%3D%200...10%3B%0A%0Aassert_eq!(x%2C%20y)%3B%0A%7D&amp;version=nightly">Run</a></pre>

<h3 id='unary-operator-expressions' class='section-header'><a href='#unary-operator-expressions'>7.2.11 Unary operator expressions</a></h3>
<p>Rust defines the following unary operators. They are all written as prefix operators,
before the expression they apply to.</p>

<ul>
<li><code>-</code>
: Negation. Signed integer types and floating-point types support negation. It
is an error to apply negation to unsigned types; for example, the compiler
rejects <code>-1u32</code>.</li>
<li><code>*</code>
: Dereference. When applied to a <a href="#pointer-types">pointer</a> it denotes the
pointed-to location. For pointers to mutable locations, the resulting
<a href="#lvalues-rvalues-and-temporaries">lvalue</a> can be assigned to.
On non-pointer types, it calls the <code>deref</code> method of the <code>std::ops::Deref</code>
trait, or the <code>deref_mut</code> method of the <code>std::ops::DerefMut</code> trait (if
implemented by the type and required for an outer expression that will or
could mutate the dereference), and produces the result of dereferencing the
<code>&amp;</code> or <code>&amp;mut</code> borrowed pointer returned from the overload method.</li>
<li><code>!</code>
: Logical negation. On the boolean type, this flips between <code>true</code> and
<code>false</code>. On integer types, this inverts the individual bits in the
two&#39;s complement representation of the value.</li>
<li><code>&amp;</code> and <code>&amp;mut</code>
: Borrowing. When applied to an lvalue, these operators produce a
reference (pointer) to the lvalue. The lvalue is also placed into
a borrowed state for the duration of the reference. For a shared
borrow (<code>&amp;</code>), this implies that the lvalue may not be mutated, but
it may be read or shared again. For a mutable borrow (<code>&amp;mut</code>), the
lvalue may not be accessed in any way until the borrow expires.
If the <code>&amp;</code> or <code>&amp;mut</code> operators are applied to an rvalue, a
temporary value is created; the lifetime of this temporary value
is defined by <a href="#temporary-lifetimes">syntactic rules</a>.</li>
</ul>

<h3 id='binary-operator-expressions' class='section-header'><a href='#binary-operator-expressions'>7.2.12 Binary operator expressions</a></h3>
<p>Binary operators expressions are given in terms of <a href="#operator-precedence">operator
precedence</a>.</p>

<h4 id='arithmetic-operators' class='section-header'><a href='#arithmetic-operators'>7.2.12.1 Arithmetic operators</a></h4>
<p>Binary arithmetic expressions are syntactic sugar for calls to built-in traits,
defined in the <code>std::ops</code> module of the <code>std</code> library. This means that
arithmetic operators can be overridden for user-defined types. The default
meaning of the operators on standard types is given here.</p>

<ul>
<li><code>+</code>
: Addition and array/string concatenation.
Calls the <code>add</code> method on the <code>std::ops::Add</code> trait.</li>
<li><code>-</code>
: Subtraction.
Calls the <code>sub</code> method on the <code>std::ops::Sub</code> trait.</li>
<li><code>*</code>
: Multiplication.
Calls the <code>mul</code> method on the <code>std::ops::Mul</code> trait.</li>
<li><code>/</code>
: Quotient.
Calls the <code>div</code> method on the <code>std::ops::Div</code> trait.</li>
<li><code>%</code>
: Remainder.
Calls the <code>rem</code> method on the <code>std::ops::Rem</code> trait.</li>
</ul>

<h4 id='bitwise-operators' class='section-header'><a href='#bitwise-operators'>7.2.12.2 Bitwise operators</a></h4>
<p>Like the <a href="#arithmetic-operators">arithmetic operators</a>, bitwise operators are
syntactic sugar for calls to methods of built-in traits. This means that
bitwise operators can be overridden for user-defined types. The default
meaning of the operators on standard types is given here. Bitwise <code>&amp;</code>, <code>|</code> and
<code>^</code> applied to boolean arguments are equivalent to logical <code>&amp;&amp;</code>, <code>||</code> and <code>!=</code>
evaluated in non-lazy fashion.</p>

<ul>
<li><code>&amp;</code>
: Bitwise AND.
Calls the <code>bitand</code> method of the <code>std::ops::BitAnd</code> trait.</li>
<li><code>|</code>
: Bitwise inclusive OR.
Calls the <code>bitor</code> method of the <code>std::ops::BitOr</code> trait.</li>
<li><code>^</code>
: Bitwise exclusive OR.
Calls the <code>bitxor</code> method of the <code>std::ops::BitXor</code> trait.</li>
<li><code>&lt;&lt;</code>
: Left shift.
Calls the <code>shl</code> method of the <code>std::ops::Shl</code> trait.</li>
<li><code>&gt;&gt;</code>
: Right shift (arithmetic).
Calls the <code>shr</code> method of the <code>std::ops::Shr</code> trait.</li>
</ul>

<h4 id='lazy-boolean-operators' class='section-header'><a href='#lazy-boolean-operators'>7.2.12.3 Lazy boolean operators</a></h4>
<p>The operators <code>||</code> and <code>&amp;&amp;</code> may be applied to operands of boolean type. The
<code>||</code> operator denotes logical &#39;or&#39;, and the <code>&amp;&amp;</code> operator denotes logical
&#39;and&#39;. They differ from <code>|</code> and <code>&amp;</code> in that the right-hand operand is only
evaluated when the left-hand operand does not already determine the result of
the expression. That is, <code>||</code> only evaluates its right-hand operand when the
left-hand operand evaluates to <code>false</code>, and <code>&amp;&amp;</code> only when it evaluates to
<code>true</code>.</p>

<h4 id='comparison-operators' class='section-header'><a href='#comparison-operators'>7.2.12.4 Comparison operators</a></h4>
<p>Comparison operators are, like the <a href="#arithmetic-operators">arithmetic
operators</a>, and <a href="#bitwise-operators">bitwise operators</a>,
syntactic sugar for calls to built-in traits. This means that comparison
operators can be overridden for user-defined types. The default meaning of the
operators on standard types is given here.</p>

<ul>
<li><code>==</code>
: Equal to.
Calls the <code>eq</code> method on the <code>std::cmp::PartialEq</code> trait.</li>
<li><code>!=</code>
: Unequal to.
Calls the <code>ne</code> method on the <code>std::cmp::PartialEq</code> trait.</li>
<li><code>&lt;</code>
: Less than.
Calls the <code>lt</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
<li><code>&gt;</code>
: Greater than.
Calls the <code>gt</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
<li><code>&lt;=</code>
: Less than or equal.
Calls the <code>le</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
<li><code>&gt;=</code>
: Greater than or equal.
Calls the <code>ge</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
</ul>

<h4 id='type-cast-expressions' class='section-header'><a href='#type-cast-expressions'>7.2.12.5 Type cast expressions</a></h4>
<p>A type cast expression is denoted with the binary operator <code>as</code>.</p>

<p>Executing an <code>as</code> expression casts the value on the left-hand side to the type
on the right-hand side.</p>

<p>An example of an <code>as</code> expression:</p>

<pre class='rust rust-example-rendered'>

<span class='kw'>fn</span> <span class='ident'>average</span>(<span class='ident'>values</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>let</span> <span class='ident'>sum</span>: <span class='ident'>f64</span> <span class='op'>=</span> <span class='ident'>sum</span>(<span class='ident'>values</span>);
    <span class='kw'>let</span> <span class='ident'>size</span>: <span class='ident'>f64</span> <span class='op'>=</span> <span class='ident'>len</span>(<span class='ident'>values</span>) <span class='kw'>as</span> <span class='ident'>f64</span>;
    <span class='ident'>sum</span> <span class='op'>/</span> <span class='ident'>size</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20sum(values%3A%20%26%5Bf64%5D)%20-%3E%20f64%20%7B%200.0%20%7D%0Afn%20len(values%3A%20%26%5Bf64%5D)%20-%3E%20i32%20%7B%200%20%7D%0A%0Afn%20average(values%3A%20%26%5Bf64%5D)%20-%3E%20f64%20%7B%0A%20%20%20%20let%20sum%3A%20f64%20%3D%20sum(values)%3B%0A%20%20%20%20let%20size%3A%20f64%20%3D%20len(values)%20as%20f64%3B%0A%20%20%20%20sum%20%2F%20size%0A%7D%0A%7D">Run</a></pre>

<p>Some of the conversions which can be done through the <code>as</code> operator
can also be done implicitly at various points in the program, such as
argument passing and assignment to a <code>let</code> binding with an explicit
type. Implicit conversions are limited to &quot;harmless&quot; conversions that
do not lose information and which have minimal or no risk of
surprising side-effects on the dynamic execution semantics.</p>

<h4 id='assignment-expressions' class='section-header'><a href='#assignment-expressions'>7.2.12.6 Assignment expressions</a></h4>
<p>An <em>assignment expression</em> consists of an
<a href="#lvalues-rvalues-and-temporaries">lvalue</a> expression followed by an equals
sign (<code>=</code>) and an <a href="#lvalues-rvalues-and-temporaries">rvalue</a> expression.</p>

<p>Evaluating an assignment expression <a href="#moved-and-copied-types">either copies or
moves</a> its right-hand operand to its left-hand
operand.</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>y</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20x%20%3D%200%3B%0Alet%20y%20%3D%200%3B%0Ax%20%3D%20y%3B%0A%7D">Run</a></pre>

<h4 id='compound-assignment-expressions' class='section-header'><a href='#compound-assignment-expressions'>7.2.12.7 Compound assignment expressions</a></h4>
<p>The <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code> operators may be
composed with the <code>=</code> operator. The expression <code>lval OP= val</code> is equivalent to
<code>lval = lval OP val</code>. For example, <code>x = x + 1</code> may be written as <code>x += 1</code>.</p>

<p>Any such expression always has the <a href="#tuple-types"><code>unit</code></a> type.</p>

<h4 id='operator-precedence' class='section-header'><a href='#operator-precedence'>7.2.12.8 Operator precedence</a></h4>
<p>The precedence of Rust binary operators is ordered as follows, going from
strong to weak:</p>

<pre><code class="language-{.text">as :
* / %
+ -
&lt;&lt; &gt;&gt;
&amp;
^
|
== != &lt; &gt; &lt;= &gt;=
&amp;&amp;
||
.. ...
&lt;-
=
</code></pre>

<p>Operators at the same precedence level are evaluated left-to-right. <a href="#unary-operator-expressions">Unary
operators</a> have the same precedence level and are
stronger than any of the binary operators.</p>

<h3 id='grouped-expressions' class='section-header'><a href='#grouped-expressions'>7.2.13 Grouped expressions</a></h3>
<p>An expression enclosed in parentheses evaluates to the result of the enclosed
expression. Parentheses can be used to explicitly specify evaluation order
within an expression.</p>

<p>An example of a parenthesized expression:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> (<span class='number'>2</span> <span class='op'>+</span> <span class='number'>3</span>) <span class='op'>*</span> <span class='number'>4</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%3A%20i32%20%3D%20(2%20%2B%203)%20*%204%3B%0A%7D">Run</a></pre>

<h3 id='call-expressions' class='section-header'><a href='#call-expressions'>7.2.14 Call expressions</a></h3>
<p>A <em>call expression</em> invokes a function, providing zero or more input variables
and an optional location to move the function&#39;s output into. If the function
eventually returns, then the expression completes.</p>

<p>Some examples of call expressions:</p>

<pre class='rust rust-example-rendered'>

<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>add</span>(<span class='number'>1i32</span>, <span class='number'>2i32</span>);
<span class='kw'>let</span> <span class='ident'>pi</span>: <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>f32</span>, _<span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;3.14&quot;</span>.<span class='ident'>parse</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%200%20%7D%0A%0Alet%20x%3A%20i32%20%3D%20add(1i32%2C%202i32)%3B%0Alet%20pi%3A%20Result%3Cf32%2C%20_%3E%20%3D%20%223.14%22.parse()%3B%0A%7D">Run</a></pre>

<h3 id='lambda-expressions' class='section-header'><a href='#lambda-expressions'>7.2.15 Lambda expressions</a></h3>
<p>A <em>lambda expression</em> (sometimes called an &quot;anonymous function expression&quot;)
defines a function and denotes it as a value, in a single expression. A lambda
expression is a pipe-symbol-delimited (<code>|</code>) list of identifiers followed by an
expression.</p>

<p>A lambda expression denotes a function that maps a list of parameters
(<code>ident_list</code>) onto the expression that follows the <code>ident_list</code>. The
identifiers in the <code>ident_list</code> are the parameters to the function. These
parameters&#39; types need not be specified, as the compiler infers them from
context.</p>

<p>Lambda expressions are most useful when passing functions as arguments to other
functions, as an abbreviation for defining and capturing a separate function.</p>

<p>Significantly, lambda expressions <em>capture their environment</em>, which regular
<a href="#functions">function definitions</a> do not. The exact type of capture depends
on the <a href="#function-types">function type</a> inferred for the lambda expression. In
the simplest and least-expensive form (analogous to a <code>|| { }</code> expression),
the lambda expression captures its environment by reference, effectively
borrowing pointers to all outer variables mentioned inside the function.
Alternately, the compiler may infer that a lambda expression should copy or
move values (depending on their type) from the environment into the lambda
expression&#39;s captured environment. A lambda can be forced to capture its
environment by moving values by prefixing it with the <code>move</code> keyword.</p>

<p>In this example, we define a function <code>ten_times</code> that takes a higher-order
function argument, and we then call it with a lambda expression as an argument,
followed by a lambda expression that moves values from its environment.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>ten_times</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>f</span>: <span class='ident'>F</span>) <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='ident'>i32</span>) {
    <span class='kw'>for</span> <span class='ident'>index</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='ident'>f</span>(<span class='ident'>index</span>);
    }
}

<span class='ident'>ten_times</span>(<span class='op'>|</span><span class='ident'>j</span><span class='op'>|</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;hello, {}&quot;</span>, <span class='ident'>j</span>));

<span class='kw'>let</span> <span class='ident'>word</span> <span class='op'>=</span> <span class='string'>&quot;konnichiwa&quot;</span>.<span class='ident'>to_owned</span>();
<span class='ident'>ten_times</span>(<span class='kw'>move</span> <span class='op'>|</span><span class='ident'>j</span><span class='op'>|</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}&quot;</span>, <span class='ident'>word</span>, <span class='ident'>j</span>));<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20ten_times%3CF%3E(f%3A%20F)%20where%20F%3A%20Fn(i32)%20%7B%0A%20%20%20%20for%20index%20in%200..10%20%7B%0A%20%20%20%20%20%20%20%20f(index)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aten_times(%7Cj%7C%20println!(%22hello%2C%20%7B%7D%22%2C%20j))%3B%0A%0Alet%20word%20%3D%20%22konnichiwa%22.to_owned()%3B%0Aten_times(move%20%7Cj%7C%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20word%2C%20j))%3B%0A%7D">Run</a></pre>

<h3 id='infinite-loops' class='section-header'><a href='#infinite-loops'>7.2.16 Infinite loops</a></h3>
<p>A <code>loop</code> expression denotes an infinite loop.</p>

<p>A <code>loop</code> expression may optionally have a <em>label</em>. The label is written as
a lifetime preceding the loop expression, as in <code>&#39;foo: loop{ }</code>. If a
label is present, then labeled <code>break</code> and <code>continue</code> expressions nested
within this loop may exit out of this loop or return control to its head.
See <a href="#break-expressions">break expressions</a> and <a href="#continue-expressions">continue
expressions</a>.</p>

<h3 id='break-expressions' class='section-header'><a href='#break-expressions'>7.2.17 <code>break</code> expressions</a></h3>
<p>A <code>break</code> expression has an optional <em>label</em>. If the label is absent, then
executing a <code>break</code> expression immediately terminates the innermost loop
enclosing it. It is only permitted in the body of a loop. If the label is
present, then <code>break &#39;foo</code> terminates the loop with label <code>&#39;foo</code>, which need not
be the innermost label enclosing the <code>break</code> expression, but must enclose it.</p>

<h3 id='continue-expressions' class='section-header'><a href='#continue-expressions'>7.2.18 <code>continue</code> expressions</a></h3>
<p>A <code>continue</code> expression has an optional <em>label</em>. If the label is absent, then
executing a <code>continue</code> expression immediately terminates the current iteration
of the innermost loop enclosing it, returning control to the loop <em>head</em>. In
the case of a <code>while</code> loop, the head is the conditional expression controlling
the loop. In the case of a <code>for</code> loop, the head is the call-expression
controlling the loop. If the label is present, then <code>continue &#39;foo</code> returns
control to the head of the loop with label <code>&#39;foo</code>, which need not be the
innermost label enclosing the <code>continue</code> expression, but must enclose it.</p>

<p>A <code>continue</code> expression is only permitted in the body of a loop.</p>

<h3 id='while-loops' class='section-header'><a href='#while-loops'>7.2.19 <code>while</code> loops</a></h3>
<p>A <code>while</code> loop begins by evaluating the boolean loop conditional expression.
If the loop conditional expression evaluates to <code>true</code>, the loop body block
executes and control returns to the loop conditional expression. If the loop
conditional expression evaluates to <code>false</code>, the <code>while</code> expression completes.</p>

<p>An example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='number'>0</span>;

<span class='kw'>while</span> <span class='ident'>i</span> <span class='op'>&lt;</span> <span class='number'>10</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;hello&quot;</span>);
    <span class='ident'>i</span> <span class='op'>=</span> <span class='ident'>i</span> <span class='op'>+</span> <span class='number'>1</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20i%20%3D%200%3B%0A%0Awhile%20i%20%3C%2010%20%7B%0A%20%20%20%20println!(%22hello%22)%3B%0A%20%20%20%20i%20%3D%20i%20%2B%201%3B%0A%7D%0A%7D">Run</a></pre>

<p>Like <code>loop</code> expressions, <code>while</code> loops can be controlled with <code>break</code> or
<code>continue</code>, and may optionally have a <em>label</em>. See <a href="#infinite-loops">infinite
loops</a>, <a href="#break-expressions">break expressions</a>, and
<a href="#continue-expressions">continue expressions</a> for more information.</p>

<h3 id='for-expressions' class='section-header'><a href='#for-expressions'>7.2.20 <code>for</code> expressions</a></h3>
<p>A <code>for</code> expression is a syntactic construct for looping over elements provided
by an implementation of <code>std::iter::IntoIterator</code>.</p>

<p>An example of a <code>for</code> loop over the contents of an array:</p>

<pre class='rust rust-example-rendered'>

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>Foo</span>] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='ident'>a</span>, <span class='ident'>b</span>, <span class='ident'>c</span>];

<span class='kw'>for</span> <span class='ident'>e</span> <span class='kw'>in</span> <span class='ident'>v</span> {
    <span class='ident'>bar</span>(<span class='ident'>e</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atype%20Foo%20%3D%20i32%3B%0Afn%20bar(f%3A%20%26Foo)%20%7B%20%7D%0Alet%20a%20%3D%200%3B%0Alet%20b%20%3D%200%3B%0Alet%20c%20%3D%200%3B%0A%0Alet%20v%3A%20%26%5BFoo%5D%20%3D%20%26%5Ba%2C%20b%2C%20c%5D%3B%0A%0Afor%20e%20in%20v%20%7B%0A%20%20%20%20bar(e)%3B%0A%7D%0A%7D">Run</a></pre>

<p>An example of a for loop over a series of integers:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>256</span> {
    <span class='ident'>bar</span>(<span class='ident'>i</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20bar(b%3Ausize)%20%7B%20%7D%0Afor%20i%20in%200..256%20%7B%0A%20%20%20%20bar(i)%3B%0A%7D%0A%7D">Run</a></pre>

<p>Like <code>loop</code> expressions, <code>for</code> loops can be controlled with <code>break</code> or
<code>continue</code>, and may optionally have a <em>label</em>. See <a href="#infinite-loops">infinite
loops</a>, <a href="#break-expressions">break expressions</a>, and
<a href="#continue-expressions">continue expressions</a> for more information.</p>

<h3 id='if-expressions' class='section-header'><a href='#if-expressions'>7.2.21 <code>if</code> expressions</a></h3>
<p>An <code>if</code> expression is a conditional branch in program control. The form of an
<code>if</code> expression is a condition expression, followed by a consequent block, any
number of <code>else if</code> conditions and blocks, and an optional trailing <code>else</code>
block. The condition expressions must have type <code>bool</code>. If a condition
expression evaluates to <code>true</code>, the consequent block is executed and any
subsequent <code>else if</code> or <code>else</code> block is skipped. If a condition expression
evaluates to <code>false</code>, the consequent block is skipped and any subsequent <code>else if</code> condition is evaluated. If all <code>if</code> and <code>else if</code> conditions evaluate to
<code>false</code> then any <code>else</code> block is executed.</p>

<h3 id='match-expressions' class='section-header'><a href='#match-expressions'>7.2.22 <code>match</code> expressions</a></h3>
<p>A <code>match</code> expression branches on a <em>pattern</em>. The exact form of matching that
occurs depends on the pattern. Patterns consist of some combination of
literals, destructured arrays or enum constructors, structs and tuples,
variable binding specifications, wildcards (<code>..</code>), and placeholders (<code>_</code>). A
<code>match</code> expression has a <em>head expression</em>, which is the value to compare to
the patterns. The type of the patterns must equal the type of the head
expression.</p>

<p>In a pattern whose head expression has an <code>enum</code> type, a placeholder (<code>_</code>)
stands for a <em>single</em> data field, whereas a wildcard <code>..</code> stands for <em>all</em> the
fields of a particular variant.</p>

<p>A <code>match</code> behaves differently depending on whether or not the head expression
is an <a href="#lvalues-rvalues-and-temporaries">lvalue or an rvalue</a>. If the head
expression is an rvalue, it is first evaluated into a temporary location, and
the resulting value is sequentially compared to the patterns in the arms until
a match is found. The first arm with a matching pattern is chosen as the branch
target of the <code>match</code>, any variables bound by the pattern are assigned to local
variables in the arm&#39;s block, and control enters the block.</p>

<p>When the head expression is an lvalue, the match does not allocate a temporary
location (however, a by-value binding may copy or move from the lvalue). When
possible, it is preferable to match on lvalues, as the lifetime of these
matches inherits the lifetime of the lvalue, rather than being restricted to
the inside of the match.</p>

<p>An example of a <code>match</code> expression:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>1</span>;

<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='number'>1</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;one&quot;</span>),
    <span class='number'>2</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;two&quot;</span>),
    <span class='number'>3</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;three&quot;</span>),
    <span class='number'>4</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;four&quot;</span>),
    <span class='number'>5</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;five&quot;</span>),
    _ <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;something else&quot;</span>),
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%20%3D%201%3B%0A%0Amatch%20x%20%7B%0A%20%20%20%201%20%3D%3E%20println!(%22one%22)%2C%0A%20%20%20%202%20%3D%3E%20println!(%22two%22)%2C%0A%20%20%20%203%20%3D%3E%20println!(%22three%22)%2C%0A%20%20%20%204%20%3D%3E%20println!(%22four%22)%2C%0A%20%20%20%205%20%3D%3E%20println!(%22five%22)%2C%0A%20%20%20%20_%20%3D%3E%20println!(%22something%20else%22)%2C%0A%7D%0A%7D">Run</a></pre>

<p>Patterns that bind variables default to binding to a copy or move of the
matched value (depending on the matched value&#39;s type). This can be changed to
bind to a reference by using the <code>ref</code> keyword, or to a mutable reference using
<code>ref mut</code>.</p>

<p>Subpatterns can also be bound to variables by the use of the syntax <code>variable @ subpattern</code>. For example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>1</span>;

<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='ident'>e</span> @ <span class='number'>1</span> ... <span class='number'>5</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;got a range element {}&quot;</span>, <span class='ident'>e</span>),
    _ <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;anything&quot;</span>),
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%20%3D%201%3B%0A%0Amatch%20x%20%7B%0A%20%20%20%20e%20%40%201%20...%205%20%3D%3E%20println!(%22got%20a%20range%20element%20%7B%7D%22%2C%20e)%2C%0A%20%20%20%20_%20%3D%3E%20println!(%22anything%22)%2C%0A%7D%0A%7D">Run</a></pre>

<p>Patterns can also dereference pointers by using the <code>&amp;</code>, <code>&amp;mut</code> and <code>box</code>
symbols, as appropriate. For example, these two matches on <code>x: &amp;i32</code> are
equivalent:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='op'>*</span><span class='ident'>x</span> { <span class='number'>0</span> <span class='op'>=&gt;</span> <span class='string'>&quot;zero&quot;</span>, _ <span class='op'>=&gt;</span> <span class='string'>&quot;some&quot;</span> };
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>x</span> { <span class='kw-2'>&amp;</span><span class='number'>0</span> <span class='op'>=&gt;</span> <span class='string'>&quot;zero&quot;</span>, _ <span class='op'>=&gt;</span> <span class='string'>&quot;some&quot;</span> };

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>y</span>, <span class='ident'>z</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%20%3D%20%263%3B%0Alet%20y%20%3D%20match%20*x%20%7B%200%20%3D%3E%20%22zero%22%2C%20_%20%3D%3E%20%22some%22%20%7D%3B%0Alet%20z%20%3D%20match%20x%20%7B%20%260%20%3D%3E%20%22zero%22%2C%20_%20%3D%3E%20%22some%22%20%7D%3B%0A%0Aassert_eq!(y%2C%20z)%3B%0A%7D">Run</a></pre>

<p>Multiple match patterns may be joined with the <code>|</code> operator. A range of values
may be specified with <code>...</code>. For example:</p>

<pre class='rust rust-example-rendered'>

<span class='kw'>let</span> <span class='ident'>message</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='number'>0</span> <span class='op'>|</span> <span class='number'>1</span>  <span class='op'>=&gt;</span> <span class='string'>&quot;not many&quot;</span>,
    <span class='number'>2</span> ... <span class='number'>9</span> <span class='op'>=&gt;</span> <span class='string'>&quot;a few&quot;</span>,
    _      <span class='op'>=&gt;</span> <span class='string'>&quot;lots&quot;</span>
};<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%20%3D%202%3B%0A%0Alet%20message%20%3D%20match%20x%20%7B%0A%20%20%20%200%20%7C%201%20%20%3D%3E%20%22not%20many%22%2C%0A%20%20%20%202%20...%209%20%3D%3E%20%22a%20few%22%2C%0A%20%20%20%20_%20%20%20%20%20%20%3D%3E%20%22lots%22%0A%7D%3B%0A%7D">Run</a></pre>

<p>Range patterns only work on scalar types (like integers and characters; not
like arrays and structs, which have sub-components). A range pattern may not
be a sub-range of another range pattern inside the same <code>match</code>.</p>

<p>Finally, match patterns can accept <em>pattern guards</em> to further refine the
criteria for matching a case. Pattern guards appear after the pattern and
consist of a bool-typed expression following the <code>if</code> keyword. A pattern guard
may refer to the variables bound within the pattern they follow.</p>

<pre class='rust rust-example-rendered'>

<span class='kw'>let</span> <span class='ident'>message</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>maybe_digit</span> {
    <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>10</span> <span class='op'>=&gt;</span> <span class='ident'>process_digit</span>(<span class='ident'>x</span>),
    <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> <span class='ident'>process_other</span>(<span class='ident'>x</span>),
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(),
};<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20maybe_digit%20%3D%20Some(0)%3B%0Afn%20process_digit(i%3A%20i32)%20%7B%20%7D%0Afn%20process_other(i%3A%20i32)%20%7B%20%7D%0A%0Alet%20message%20%3D%20match%20maybe_digit%20%7B%0A%20%20%20%20Some(x)%20if%20x%20%3C%2010%20%3D%3E%20process_digit(x)%2C%0A%20%20%20%20Some(x)%20%3D%3E%20process_other(x)%2C%0A%20%20%20%20None%20%3D%3E%20panic!()%2C%0A%7D%3B%0A%7D">Run</a></pre>

<h3 id='if-let-expressions' class='section-header'><a href='#if-let-expressions'>7.2.23 <code>if let</code> expressions</a></h3>
<p>An <code>if let</code> expression is semantically identical to an <code>if</code> expression but in
place of a condition expression it expects a <code>let</code> statement with a refutable
pattern. If the value of the expression on the right hand side of the <code>let</code>
statement matches the pattern, the corresponding block will execute, otherwise
flow proceeds to the first <code>else</code> block that follows.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>dish</span> <span class='op'>=</span> (<span class='string'>&quot;Ham&quot;</span>, <span class='string'>&quot;Eggs&quot;</span>);

<span class='comment'>// this body will be skipped because the pattern is refuted</span>
<span class='kw'>if</span> <span class='kw'>let</span> (<span class='string'>&quot;Bacon&quot;</span>, <span class='ident'>b</span>) <span class='op'>=</span> <span class='ident'>dish</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Bacon is served with {}&quot;</span>, <span class='ident'>b</span>);
}

<span class='comment'>// this body will execute</span>
<span class='kw'>if</span> <span class='kw'>let</span> (<span class='string'>&quot;Ham&quot;</span>, <span class='ident'>b</span>) <span class='op'>=</span> <span class='ident'>dish</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Ham is served with {}&quot;</span>, <span class='ident'>b</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20dish%20%3D%20(%22Ham%22%2C%20%22Eggs%22)%3B%0A%0A%2F%2F%20this%20body%20will%20be%20skipped%20because%20the%20pattern%20is%20refuted%0Aif%20let%20(%22Bacon%22%2C%20b)%20%3D%20dish%20%7B%0A%20%20%20%20println!(%22Bacon%20is%20served%20with%20%7B%7D%22%2C%20b)%3B%0A%7D%0A%0A%2F%2F%20this%20body%20will%20execute%0Aif%20let%20(%22Ham%22%2C%20b)%20%3D%20dish%20%7B%0A%20%20%20%20println!(%22Ham%20is%20served%20with%20%7B%7D%22%2C%20b)%3B%0A%7D%0A%7D">Run</a></pre>

<h3 id='while-let-loops' class='section-header'><a href='#while-let-loops'>7.2.24 <code>while let</code> loops</a></h3>
<p>A <code>while let</code> loop is semantically identical to a <code>while</code> loop but in place of
a condition expression it expects <code>let</code> statement with a refutable pattern. If
the value of the expression on the right hand side of the <code>let</code> statement
matches the pattern, the loop body block executes and control returns to the
pattern matching statement. Otherwise, the while expression completes.</p>

<h3 id='return-expressions' class='section-header'><a href='#return-expressions'>7.2.25 <code>return</code> expressions</a></h3>
<p>Return expressions are denoted with the keyword <code>return</code>. Evaluating a <code>return</code>
expression moves its argument into the designated output location for the
current function call, destroys the current function activation frame, and
transfers control to the caller frame.</p>

<p>An example of a <code>return</code> expression:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>max</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>, <span class='ident'>b</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> {
        <span class='kw'>return</span> <span class='ident'>a</span>;
    }
    <span class='kw'>return</span> <span class='ident'>b</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20max(a%3A%20i32%2C%20b%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20if%20a%20%3E%20b%20%7B%0A%20%20%20%20%20%20%20%20return%20a%3B%0A%20%20%20%20%7D%0A%20%20%20%20return%20b%3B%0A%7D%0A%7D">Run</a></pre>

<h1 id='type-system' class='section-header'><a href='#type-system'>8 Type system</a></h1>
<h2 id='types' class='section-header'><a href='#types'>8.1 Types</a></h2>
<p>Every variable, item and value in a Rust program has a type. The <em>type</em> of a
<em>value</em> defines the interpretation of the memory holding it.</p>

<p>Built-in types and type-constructors are tightly integrated into the language,
in nontrivial ways that are not possible to emulate in user-defined types.
User-defined types have limited capabilities.</p>

<h3 id='primitive-types' class='section-header'><a href='#primitive-types'>8.1.1 Primitive types</a></h3>
<p>The primitive types are the following:</p>

<ul>
<li>The boolean type <code>bool</code> with values <code>true</code> and <code>false</code>.</li>
<li>The machine types (integer and floating-point).</li>
<li>The machine-dependent integer types.</li>
<li>Arrays</li>
<li>Tuples</li>
<li>Slices</li>
<li>Function pointers</li>
</ul>

<h4 id='machine-types' class='section-header'><a href='#machine-types'>8.1.1.1 Machine types</a></h4>
<p>The machine types are the following:</p>

<ul>
<li><p>The unsigned word types <code>u8</code>, <code>u16</code>, <code>u32</code> and <code>u64</code>, with values drawn from
the integer intervals [0, 2<sup>8</sup> - 1], [0, 2<sup>16</sup> - 1], [0, 2<sup>32</sup> - 1] and
[0, 2<sup>64</sup> - 1] respectively.</p></li>
<li><p>The signed two&#39;s complement word types <code>i8</code>, <code>i16</code>, <code>i32</code> and <code>i64</code>, with
values drawn from the integer intervals [-(2<sup>7</sup>), 2<sup>7</sup> - 1],
[-(2<sup>15</sup>), 2<sup>15</sup> - 1], [-(2<sup>31</sup>), 2<sup>31</sup> - 1], [-(2<sup>63</sup>), 2<sup>63</sup> - 1]
respectively.</p></li>
<li><p>The IEEE 754-2008 <code>binary32</code> and <code>binary64</code> floating-point types: <code>f32</code> and
<code>f64</code>, respectively.</p></li>
</ul>

<h4 id='machine-dependent-integer-types' class='section-header'><a href='#machine-dependent-integer-types'>8.1.1.2 Machine-dependent integer types</a></h4>
<p>The <code>usize</code> type is an unsigned integer type with the same number of bits as the
platform&#39;s pointer type. It can represent every memory address in the process.</p>

<p>The <code>isize</code> type is a signed integer type with the same number of bits as the
platform&#39;s pointer type. The theoretical upper bound on object and array size
is the maximum <code>isize</code> value. This ensures that <code>isize</code> can be used to calculate
differences between pointers into an object or array and can address every byte
within an object along with one byte past the end.</p>

<h3 id='textual-types' class='section-header'><a href='#textual-types'>8.1.2 Textual types</a></h3>
<p>The types <code>char</code> and <code>str</code> hold textual data.</p>

<p>A value of type <code>char</code> is a <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a> (i.e. a code point that
is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to
0xD7FF or 0xE000 to 0x10FFFF range. A <code>[char]</code> array is effectively an UCS-4 /
UTF-32 string.</p>

<p>A value of type <code>str</code> is a Unicode string, represented as an array of 8-bit
unsigned bytes holding a sequence of UTF-8 code points. Since <code>str</code> is of
unknown size, it is not a <em>first-class</em> type, but can only be instantiated
through a pointer type, such as <code>&amp;str</code>.</p>

<h3 id='tuple-types' class='section-header'><a href='#tuple-types'>8.1.3 Tuple types</a></h3>
<p>A tuple <em>type</em> is a heterogeneous product of other types, called the <em>elements</em>
of the tuple. It has no nominal name and is instead structurally typed.</p>

<p>Tuple types and values are denoted by listing the types or values of their
elements, respectively, in a parenthesized, comma-separated list.</p>

<p>Because tuple elements don&#39;t have a name, they can only be accessed by
pattern-matching or by using <code>N</code> directly as a field to access the
<code>N</code>th element.</p>

<p>An example of a tuple type and its use:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Pair</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='op'>=</span> (<span class='ident'>i32</span>, <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>);
<span class='kw'>let</span> <span class='ident'>p</span>: <span class='ident'>Pair</span><span class='op'>&lt;</span><span class='lifetime'>&#39;static</span><span class='op'>&gt;</span> <span class='op'>=</span> (<span class='number'>10</span>, <span class='string'>&quot;ten&quot;</span>);
<span class='kw'>let</span> (<span class='ident'>a</span>, <span class='ident'>b</span>) <span class='op'>=</span> <span class='ident'>p</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>, <span class='number'>10</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>b</span>, <span class='string'>&quot;ten&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>p</span>.<span class='number'>0</span>, <span class='number'>10</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>p</span>.<span class='number'>1</span>, <span class='string'>&quot;ten&quot;</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atype%20Pair%3C'a%3E%20%3D%20(i32%2C%20%26'a%20str)%3B%0Alet%20p%3A%20Pair%3C'static%3E%20%3D%20(10%2C%20%22ten%22)%3B%0Alet%20(a%2C%20b)%20%3D%20p%3B%0A%0Aassert_eq!(a%2C%2010)%3B%0Aassert_eq!(b%2C%20%22ten%22)%3B%0Aassert_eq!(p.0%2C%2010)%3B%0Aassert_eq!(p.1%2C%20%22ten%22)%3B%0A%7D">Run</a></pre>

<p>For historical reasons and convenience, the tuple type with no elements (<code>()</code>)
is often called unit or the unit type.</p>

<h3 id='array-and-slice-types' class='section-header'><a href='#array-and-slice-types'>8.1.4 Array, and Slice types</a></h3>
<p>Rust has two different types for a list of items:</p>

<ul>
<li><code>[T; N]</code>, an &#39;array&#39;</li>
<li><code>&amp;[T]</code>, a &#39;slice&#39;</li>
</ul>

<p>An array has a fixed size, and can be allocated on either the stack or the
heap.</p>

<p>A slice is a &#39;view&#39; into an array. It doesn&#39;t own the data it points
to, it borrows it.</p>

<p>Examples:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// A stack-allocated array</span>
<span class='kw'>let</span> <span class='ident'>array</span>: [<span class='ident'>i32</span>; <span class='number'>3</span>] <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='comment'>// A heap-allocated array</span>
<span class='kw'>let</span> <span class='ident'>vector</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='comment'>// A slice into an array</span>
<span class='kw'>let</span> <span class='ident'>slice</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>i32</span>] <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>vector</span>[..];<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20A%20stack-allocated%20array%0Alet%20array%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%0A%2F%2F%20A%20heap-allocated%20array%0Alet%20vector%3A%20Vec%3Ci32%3E%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0A%2F%2F%20A%20slice%20into%20an%20array%0Alet%20slice%3A%20%26%5Bi32%5D%20%3D%20%26vector%5B..%5D%3B%0A%7D">Run</a></pre>

<p>As you can see, the <code>vec!</code> macro allows you to create a <code>Vec&lt;T&gt;</code> easily. The
<code>vec!</code> macro is also part of the standard library, rather than the language.</p>

<p>All in-bounds elements of arrays and slices are always initialized, and access
to an array or slice is always bounds-checked.</p>

<h3 id='struct-types' class='section-header'><a href='#struct-types'>8.1.5 Struct types</a></h3>
<p>A <code>struct</code> <em>type</em> is a heterogeneous product of other types, called the
<em>fields</em> of the type.<sup id="fnref5"><a href="#fn5" rel="footnote">5</a></sup></p>

<p>New instances of a <code>struct</code> can be constructed with a <a href="#struct-expressions">struct
expression</a>.</p>

<p>The memory layout of a <code>struct</code> is undefined by default to allow for compiler
optimizations like field reordering, but it can be fixed with the
<code>#[repr(...)]</code> attribute. In either case, fields may be given in any order in
a corresponding struct <em>expression</em>; the resulting <code>struct</code> value will always
have the same memory layout.</p>

<p>The fields of a <code>struct</code> may be qualified by <a href="#visibility-and-privacy">visibility
modifiers</a>, to allow access to data in a
struct outside a module.</p>

<p>A <em>tuple struct</em> type is just like a struct type, except that the fields are
anonymous.</p>

<p>A <em>unit-like struct</em> type is like a struct type, except that it has no
fields. The one value constructed by the associated <a href="#struct-expressions">struct
expression</a> is the only value that inhabits such a
type.</p>

<h3 id='enumerated-types' class='section-header'><a href='#enumerated-types'>8.1.6 Enumerated types</a></h3>
<p>An <em>enumerated type</em> is a nominal, heterogeneous disjoint union type, denoted
by the name of an <a href="#enumerations"><code>enum</code> item</a>. <sup id="fnref6"><a href="#fn6" rel="footnote">6</a></sup></p>

<p>An <a href="#enumerations"><code>enum</code> item</a> declares both the type and a number of <em>variant
constructors</em>, each of which is independently named and takes an optional tuple
of arguments.</p>

<p>New instances of an <code>enum</code> can be constructed by calling one of the variant
constructors, in a <a href="#call-expressions">call expression</a>.</p>

<p>Any <code>enum</code> value consumes as much memory as the largest variant constructor for
its corresponding <code>enum</code> type.</p>

<p>Enum types cannot be denoted <em>structurally</em> as types, but must be denoted by
named reference to an <a href="#enumerations"><code>enum</code> item</a>.</p>

<h3 id='recursive-types' class='section-header'><a href='#recursive-types'>8.1.7 Recursive types</a></h3>
<p>Nominal types &mdash; <a href="#enumerated-types">enumerations</a> and
<a href="#struct-types">structs</a> &mdash; may be recursive. That is, each <code>enum</code>
constructor or <code>struct</code> field may refer, directly or indirectly, to the
enclosing <code>enum</code> or <code>struct</code> type itself. Such recursion has restrictions:</p>

<ul>
<li>Recursive types must include a nominal type in the recursion
(not mere <a href="grammar.html#type-definitions">type definitions</a>,
or other structural types such as <a href="#array-and-slice-types">arrays</a> or <a href="#tuple-types">tuples</a>).</li>
<li>A recursive <code>enum</code> item must have at least one non-recursive constructor
(in order to give the recursion a basis case).</li>
<li>The size of a recursive type must be finite;
in other words the recursive fields of the type must be <a href="#pointer-types">pointer types</a>.</li>
<li>Recursive type definitions can cross module boundaries, but not module <em>visibility</em> boundaries,
or crate boundaries (in order to simplify the module system and type checker).</li>
</ul>

<p>An example of a <em>recursive</em> type and its use:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>Nil</span>,
    <span class='ident'>Cons</span>(<span class='ident'>T</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>)
}

<span class='kw'>let</span> <span class='ident'>a</span>: <span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>List</span>::<span class='ident'>Cons</span>(<span class='number'>7</span>, <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>List</span>::<span class='ident'>Cons</span>(<span class='number'>13</span>, <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>List</span>::<span class='ident'>Nil</span>))));<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aenum%20List%3CT%3E%20%7B%0A%20%20%20%20Nil%2C%0A%20%20%20%20Cons(T%2C%20Box%3CList%3CT%3E%3E)%0A%7D%0A%0Alet%20a%3A%20List%3Ci32%3E%20%3D%20List%3A%3ACons(7%2C%20Box%3A%3Anew(List%3A%3ACons(13%2C%20Box%3A%3Anew(List%3A%3ANil))))%3B%0A%7D">Run</a></pre>

<h3 id='pointer-types' class='section-header'><a href='#pointer-types'>8.1.8 Pointer types</a></h3>
<p>All pointers in Rust are explicit first-class values. They can be copied,
stored into data structs, and returned from functions. There are two
varieties of pointer in Rust:</p>

<ul>
<li><p>References (<code>&amp;</code>)
: These point to memory <em>owned by some other value</em>.
A reference type is written <code>&amp;type</code>,
or <code>&amp;&#39;a type</code> when you need to specify an explicit lifetime.
Copying a reference is a &quot;shallow&quot; operation:
it involves only copying the pointer itself.
Releasing a reference has no effect on the value it points to,
but a reference of a temporary value will keep it alive during the scope
of the reference itself.</p></li>
<li><p>Raw pointers (<code>*</code>)
: Raw pointers are pointers without safety or liveness guarantees.
Raw pointers are written as <code>*const T</code> or <code>*mut T</code>,
for example <code>*const i32</code> means a raw pointer to a 32-bit integer.
Copying or dropping a raw pointer has no effect on the lifecycle of any
other value. Dereferencing a raw pointer or converting it to any other
pointer type is an <a href="#unsafe-functions"><code>unsafe</code> operation</a>.
Raw pointers are generally discouraged in Rust code;
they exist to support interoperability with foreign code,
and writing performance-critical or low-level functions.</p></li>
</ul>

<p>The standard library contains additional &#39;smart pointer&#39; types beyond references
and raw pointers.</p>

<h3 id='function-types' class='section-header'><a href='#function-types'>8.1.9 Function types</a></h3>
<p>The function type constructor <code>fn</code> forms new function types. A function type
consists of a possibly-empty set of function-type modifiers (such as <code>unsafe</code>
or <code>extern</code>), a sequence of input types and an output type.</p>

<p>An example of a <code>fn</code> type:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>add</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>y</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>
}

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>add</span>(<span class='number'>5</span>,<span class='number'>7</span>);

<span class='kw'>type</span> <span class='ident'>Binop</span> <span class='op'>=</span> <span class='kw'>fn</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>;
<span class='kw'>let</span> <span class='ident'>bo</span>: <span class='ident'>Binop</span> <span class='op'>=</span> <span class='ident'>add</span>;
<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>bo</span>(<span class='number'>5</span>,<span class='number'>7</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20x%20%2B%20y%0A%7D%0A%0Alet%20mut%20x%20%3D%20add(5%2C7)%3B%0A%0Atype%20Binop%20%3D%20fn(i32%2C%20i32)%20-%3E%20i32%3B%0Alet%20bo%3A%20Binop%20%3D%20add%3B%0Ax%20%3D%20bo(5%2C7)%3B%0A%7D">Run</a></pre>

<h4 id='function-types-for-specific-items' class='section-header'><a href='#function-types-for-specific-items'>8.1.9.1 Function types for specific items</a></h4>
<p>Internal to the compiler, there are also function types that are specific to a particular
function item. In the following snippet, for example, the internal types of the functions
<code>foo</code> and <code>bar</code> are different, despite the fact that they have the same signature:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() { }
<span class='kw'>fn</span> <span class='ident'>bar</span>() { }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo()%20%7B%20%7D%0Afn%20bar()%20%7B%20%7D%0A%7D">Run</a></pre>

<p>The types of <code>foo</code> and <code>bar</code> can both be implicitly coerced to the fn
pointer type <code>fn()</code>. There is currently no syntax for unique fn types,
though the compiler will emit a type like <code>fn() {foo}</code> in error
messages to indicate &quot;the unique fn type for the function <code>foo</code>&quot;.</p>

<h3 id='closure-types' class='section-header'><a href='#closure-types'>8.1.10 Closure types</a></h3>
<p>A <a href="#lambda-expressions">lambda expression</a> produces a closure value with
a unique, anonymous type that cannot be written out.</p>

<p>Depending on the requirements of the closure, its type implements one or
more of the closure traits:</p>

<ul>
<li><p><code>FnOnce</code>
: The closure can be called once. A closure called as <code>FnOnce</code>
can move out values from its environment.</p></li>
<li><p><code>FnMut</code>
: The closure can be called multiple times as mutable. A closure called as
<code>FnMut</code> can mutate values from its environment. <code>FnMut</code> inherits from
<code>FnOnce</code> (i.e. anything implementing <code>FnMut</code> also implements <code>FnOnce</code>).</p></li>
<li><p><code>Fn</code>
: The closure can be called multiple times through a shared reference.
A closure called as <code>Fn</code> can neither move out from nor mutate values
from its environment. <code>Fn</code> inherits from <code>FnMut</code>, which itself
inherits from <code>FnOnce</code>.</p></li>
</ul>

<h3 id='trait-objects' class='section-header'><a href='#trait-objects'>8.1.11 Trait objects</a></h3>
<p>In Rust, a type like <code>&amp;SomeTrait</code> or <code>Box&lt;SomeTrait&gt;</code> is called a <em>trait object</em>.
Each instance of a trait object includes:</p>

<ul>
<li>a pointer to an instance of a type <code>T</code> that implements <code>SomeTrait</code></li>
<li>a <em>virtual method table</em>, often just called a <em>vtable</em>, which contains, for
each method of <code>SomeTrait</code> that <code>T</code> implements, a pointer to <code>T</code>&#39;s
implementation (i.e. a function pointer).</li>
</ul>

<p>The purpose of trait objects is to permit &quot;late binding&quot; of methods. Calling a
method on a trait object results in virtual dispatch at runtime: that is, a
function pointer is loaded from the trait object vtable and invoked indirectly.
The actual implementation for each vtable entry can vary on an object-by-object
basis.</p>

<p>Note that for a trait object to be instantiated, the trait must be
<em>object-safe</em>. Object safety rules are defined in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">RFC 255</a>.</p>

<p>Given a pointer-typed expression <code>E</code> of type <code>&amp;T</code> or <code>Box&lt;T&gt;</code>, where <code>T</code>
implements trait <code>R</code>, casting <code>E</code> to the corresponding pointer type <code>&amp;R</code> or
<code>Box&lt;R&gt;</code> results in a value of the <em>trait object</em> <code>R</code>. This result is
represented as a pair of pointers: the vtable pointer for the <code>T</code>
implementation of <code>R</code>, and the pointer value of <code>E</code>.</p>

<p>An example of a trait object:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Printable</span> {
    <span class='kw'>fn</span> <span class='ident'>stringify</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span>;
}

<span class='kw'>impl</span> <span class='ident'>Printable</span> <span class='kw'>for</span> <span class='ident'>i32</span> {
    <span class='kw'>fn</span> <span class='ident'>stringify</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span> { <span class='self'>self</span>.<span class='ident'>to_string</span>() }
}

<span class='kw'>fn</span> <span class='ident'>print</span>(<span class='ident'>a</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Printable</span><span class='op'>&gt;</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>.<span class='ident'>stringify</span>());
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>print</span>(<span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>10</span>) <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Printable</span><span class='op'>&gt;</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=trait%20Printable%20%7B%0A%20%20%20%20fn%20stringify(%26self)%20-%3E%20String%3B%0A%7D%0A%0Aimpl%20Printable%20for%20i32%20%7B%0A%20%20%20%20fn%20stringify(%26self)%20-%3E%20String%20%7B%20self.to_string()%20%7D%0A%7D%0A%0Afn%20print(a%3A%20Box%3CPrintable%3E)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a.stringify())%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20print(Box%3A%3Anew(10)%20as%20Box%3CPrintable%3E)%3B%0A%7D%0A">Run</a></pre>

<p>In this example, the trait <code>Printable</code> occurs as a trait object in both the
type signature of <code>print</code>, and the cast expression in <code>main</code>.</p>

<h3 id='type-parameters-1' class='section-header'><a href='#type-parameters-1'>8.1.12 Type parameters</a></h3>
<p>Within the body of an item that has type parameter declarations, the names of
its type parameters are types:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>to_vec</span><span class='op'>&lt;</span><span class='ident'>A</span>: <span class='ident'>Clone</span><span class='op'>&gt;</span>(<span class='ident'>xs</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>A</span>]) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> {
    <span class='kw'>if</span> <span class='ident'>xs</span>.<span class='ident'>is_empty</span>() {
        <span class='kw'>return</span> <span class='macro'>vec</span><span class='macro'>!</span>[];
    }
    <span class='kw'>let</span> <span class='ident'>first</span>: <span class='ident'>A</span> <span class='op'>=</span> <span class='ident'>xs</span>[<span class='number'>0</span>].<span class='ident'>clone</span>();
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rest</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>to_vec</span>(<span class='kw-2'>&amp;</span><span class='ident'>xs</span>[<span class='number'>1</span>..]);
    <span class='ident'>rest</span>.<span class='ident'>insert</span>(<span class='number'>0</span>, <span class='ident'>first</span>);
    <span class='ident'>rest</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20to_vec%3CA%3A%20Clone%3E(xs%3A%20%26%5BA%5D)%20-%3E%20Vec%3CA%3E%20%7B%0A%20%20%20%20if%20xs.is_empty()%20%7B%0A%20%20%20%20%20%20%20%20return%20vec!%5B%5D%3B%0A%20%20%20%20%7D%0A%20%20%20%20let%20first%3A%20A%20%3D%20xs%5B0%5D.clone()%3B%0A%20%20%20%20let%20mut%20rest%3A%20Vec%3CA%3E%20%3D%20to_vec(%26xs%5B1..%5D)%3B%0A%20%20%20%20rest.insert(0%2C%20first)%3B%0A%20%20%20%20rest%0A%7D%0A%7D">Run</a></pre>

<p>Here, <code>first</code> has type <code>A</code>, referring to <code>to_vec</code>&#39;s <code>A</code> type parameter; and <code>rest</code>
has type <code>Vec&lt;A&gt;</code>, a vector with element type <code>A</code>.</p>

<h3 id='self-types' class='section-header'><a href='#self-types'>8.1.13 Self types</a></h3>
<p>The special type <code>Self</code> has a meaning within traits and impls. In a trait definition, it refers
to an implicit type parameter representing the &quot;implementing&quot; type. In an impl,
it is an alias for the implementing type. For example, in:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Printable</span> {
    <span class='kw'>fn</span> <span class='ident'>make_string</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span>;
}

<span class='kw'>impl</span> <span class='ident'>Printable</span> <span class='kw'>for</span> <span class='ident'>String</span> {
    <span class='kw'>fn</span> <span class='ident'>make_string</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span> {
        (<span class='op'>*</span><span class='self'>self</span>).<span class='ident'>clone</span>()
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Printable%20%7B%0A%20%20%20%20fn%20make_string(%26self)%20-%3E%20String%3B%0A%7D%0A%0Aimpl%20Printable%20for%20String%20%7B%0A%20%20%20%20fn%20make_string(%26self)%20-%3E%20String%20%7B%0A%20%20%20%20%20%20%20%20(*self).clone()%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>The notation <code>&amp;self</code> is a shorthand for <code>self: &amp;Self</code>. In this case,
in the impl, <code>Self</code> refers to the value of type <code>String</code> that is the
receiver for a call to the method <code>make_string</code>.</p>

<h2 id='subtyping' class='section-header'><a href='#subtyping'>8.2 Subtyping</a></h2>
<p>Subtyping is implicit and can occur at any stage in type checking or
inference. Subtyping in Rust is very restricted and occurs only due to
variance with respect to lifetimes and between types with higher ranked
lifetimes. If we were to erase lifetimes from types, then the only subtyping
would be due to type equality.</p>

<p>Consider the following example: string literals always have <code>&#39;static</code>
lifetime. Nevertheless, we can assign <code>s</code> to <code>t</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>() {
    <span class='kw'>let</span> <span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span> <span class='op'>=</span> <span class='string'>&quot;hi&quot;</span>;
    <span class='kw'>let</span> <span class='ident'>t</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span> <span class='op'>=</span> <span class='ident'>s</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20bar%3C'a%3E()%20%7B%0A%20%20%20%20let%20s%3A%20%26'static%20str%20%3D%20%22hi%22%3B%0A%20%20%20%20let%20t%3A%20%26'a%20str%20%3D%20s%3B%0A%7D%0A%7D">Run</a></pre>

<p>Since <code>&#39;static</code> &quot;lives longer&quot; than <code>&#39;a</code>, <code>&amp;&#39;static str</code> is a subtype of
<code>&amp;&#39;a str</code>.</p>

<h2 id='type-coercions' class='section-header'><a href='#type-coercions'>8.3 Type coercions</a></h2>
<p>Coercions are defined in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401</a>. A coercion is implicit and has no syntax.</p>

<h3 id='coercion-sites' class='section-header'><a href='#coercion-sites'>8.3.1 Coercion sites</a></h3>
<p>A coercion can only occur at certain coercion sites in a program; these are
typically places where the desired type is explicit or can be derived by
propagation from explicit types (without type inference). Possible coercion
sites are:</p>

<ul>
<li><p><code>let</code> statements where an explicit type is given.</p>

<p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> _: <span class='ident'>i8</span> <span class='op'>=</span> <span class='number'>42</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20_%3A%20i8%20%3D%2042%3B%0A%7D">Run</a></pre></li>
<li><p><code>static</code> and <code>const</code> statements (similar to <code>let</code> statements).</p></li>
<li><p>Arguments for function calls</p>

<p>The value being coerced is the actual parameter, and it is coerced to
the type of the formal parameter.</p>

<p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>bar</span>(_: <span class='ident'>i8</span>) { }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
  <span class='ident'>bar</span>(<span class='number'>42</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20bar(_%3A%20i8)%20%7B%20%7D%0A%0Afn%20main()%20%7B%0A%20%20bar(42)%3B%0A%7D%0A">Run</a></pre></li>
<li><p>Instantiations of struct or variant fields</p>

<p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='ident'>i8</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
  <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='number'>42</span> };
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=struct%20Foo%20%7B%20x%3A%20i8%20%7D%0A%0Afn%20main()%20%7B%0A%20%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%7D%0A">Run</a></pre></li>
<li><p>Function results, either the final line of a block if it is not
semicolon-terminated or any expression in a <code>return</code> statement</p>

<p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>i8</span> {
  <span class='number'>42</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo()%20-%3E%20i8%20%7B%0A%20%2042%0A%7D%0A%7D">Run</a></pre></li>
</ul>

<p>If the expression in one of these coercion sites is a coercion-propagating
expression, then the relevant sub-expressions in that expression are also
coercion sites. Propagation recurses from these new coercion sites.
Propagating expressions and their relevant sub-expressions are:</p>

<ul>
<li><p>Array literals, where the array has type <code>[U; n]</code>. Each sub-expression in
the array literal is a coercion site for coercion to type <code>U</code>.</p></li>
<li><p>Array literals with repeating syntax, where the array has type <code>[U; n]</code>. The
repeated sub-expression is a coercion site for coercion to type <code>U</code>.</p></li>
<li><p>Tuples, where a tuple is a coercion site to type <code>(U_0, U_1, ..., U_n)</code>.
Each sub-expression is a coercion site to the respective type, e.g. the
zeroth sub-expression is a coercion site to type <code>U_0</code>.</p></li>
<li><p>Parenthesized sub-expressions (<code>(e)</code>): if the expression has type <code>U</code>, then
the sub-expression is a coercion site to <code>U</code>.</p></li>
<li><p>Blocks: if a block has type <code>U</code>, then the last expression in the block (if
it is not semicolon-terminated) is a coercion site to <code>U</code>. This includes
blocks which are part of control flow statements, such as <code>if</code>/<code>else</code>, if
the block has a known type.</p></li>
</ul>

<h3 id='coercion-types' class='section-header'><a href='#coercion-types'>8.3.2 Coercion types</a></h3>
<p>Coercion is allowed between the following types:</p>

<ul>
<li><p><code>T</code> to <code>U</code> if <code>T</code> is a subtype of <code>U</code> (<em>reflexive case</em>)</p></li>
<li><p><code>T_1</code> to <code>T_3</code> where <code>T_1</code> coerces to <code>T_2</code> and <code>T_2</code> coerces to <code>T_3</code>
(<em>transitive case</em>)</p>

<p>Note that this is not fully supported yet</p></li>
<li><p><code>&amp;mut T</code> to <code>&amp;T</code></p></li>
<li><p><code>*mut T</code> to <code>*const T</code></p></li>
<li><p><code>&amp;T</code> to <code>*const T</code></p></li>
<li><p><code>&amp;mut T</code> to <code>*mut T</code></p></li>
<li><p><code>&amp;T</code> to <code>&amp;U</code> if <code>T</code> implements <code>Deref&lt;Target = U&gt;</code>. For example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Deref</span>;

<span class='kw'>struct</span> <span class='ident'>CharContainer</span> {
  <span class='ident'>value</span>: <span class='ident'>char</span>,
}

<span class='kw'>impl</span> <span class='ident'>Deref</span> <span class='kw'>for</span> <span class='ident'>CharContainer</span> {
  <span class='kw'>type</span> <span class='ident'>Target</span> <span class='op'>=</span> <span class='ident'>char</span>;

  <span class='kw'>fn</span> <span class='ident'>deref</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>char</span> {
      <span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>value</span>
  }
}

<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>arg</span>: <span class='kw-2'>&amp;</span><span class='ident'>char</span>) {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
  <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>CharContainer</span> { <span class='ident'>value</span>: <span class='string'>&#39;y&#39;</span> };
  <span class='ident'>foo</span>(<span class='ident'>x</span>); <span class='comment'>//&amp;mut CharContainer is coerced to &amp;char.</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=use%20std%3A%3Aops%3A%3ADeref%3B%0A%0Astruct%20CharContainer%20%7B%0A%20%20value%3A%20char%2C%0A%7D%0A%0Aimpl%20Deref%20for%20CharContainer%20%7B%0A%20%20type%20Target%20%3D%20char%3B%0A%0A%20%20fn%20deref%3C'a%3E(%26'a%20self)%20-%3E%20%26'a%20char%20%7B%0A%20%20%20%20%20%20%26self.value%0A%20%20%7D%0A%7D%0A%0Afn%20foo(arg%3A%20%26char)%20%7B%7D%0A%0Afn%20main()%20%7B%0A%20%20let%20x%20%3D%20%26mut%20CharContainer%20%7B%20value%3A%20'y'%20%7D%3B%0A%20%20foo(x)%3B%20%2F%2F%26mut%20CharContainer%20is%20coerced%20to%20%26char.%0A%7D%0A">Run</a></pre></li>
<li><p><code>&amp;mut T</code> to <code>&amp;mut U</code> if <code>T</code> implements <code>DerefMut&lt;Target = U&gt;</code>.</p></li>
<li><p>TyCtor(<code>T</code>) to TyCtor(coerce_inner(<code>T</code>)), where TyCtor(<code>T</code>) is one of</p>

<ul>
<li><code>&amp;T</code></li>
<li><code>&amp;mut T</code></li>
<li><code>*const T</code></li>
<li><code>*mut T</code></li>
<li><code>Box&lt;T&gt;</code></li>
</ul>

<p>and where
- coerce_inner(<code>[T, ..n]</code>) = <code>[T]</code>
- coerce_inner(<code>T</code>) = <code>U</code> where <code>T</code> is a concrete type which implements the
trait <code>U</code>.</p>

<p>In the future, coerce_inner will be recursively extended to tuples and
structs. In addition, coercions from sub-traits to super-traits will be
added. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401</a> for more details.</p></li>
</ul>

<h1 id='special-traits' class='section-header'><a href='#special-traits'>9 Special traits</a></h1>
<p>Several traits define special evaluation behavior.</p>

<h2 id='the-copy-trait' class='section-header'><a href='#the-copy-trait'>9.1 The <code>Copy</code> trait</a></h2>
<p>The <code>Copy</code> trait changes the semantics of a type implementing it. Values whose
type implements <code>Copy</code> are copied rather than moved upon assignment.</p>

<h2 id='the-sized-trait' class='section-header'><a href='#the-sized-trait'>9.2 The <code>Sized</code> trait</a></h2>
<p>The <code>Sized</code> trait indicates that the size of this type is known at compile-time.</p>

<h2 id='the-drop-trait' class='section-header'><a href='#the-drop-trait'>9.3 The <code>Drop</code> trait</a></h2>
<p>The <code>Drop</code> trait provides a destructor, to be run whenever a value of this type
is to be destroyed.</p>

<h2 id='the-deref-trait' class='section-header'><a href='#the-deref-trait'>9.4 The <code>Deref</code> trait</a></h2>
<p>The <code>Deref&lt;Target = U&gt;</code> trait allows a type to implicitly implement all the methods
of the type <code>U</code>. When attempting to resolve a method call, the compiler will search
the top-level type for the implementation of the called method. If no such method is
found, <code>.deref()</code> is called and the compiler continues to search for the method
implementation in the returned type <code>U</code>.</p>

<h2 id='the-send-trait' class='section-header'><a href='#the-send-trait'>9.5 The <code>Send</code> trait</a></h2>
<p>The <code>Send</code> trait indicates that a value of this type is safe to send from one
thread to another.</p>

<h2 id='the-sync-trait' class='section-header'><a href='#the-sync-trait'>9.6 The <code>Sync</code> trait</a></h2>
<p>The <code>Sync</code> trait indicates that a value of this type is safe to share between
multiple threads.</p>

<h1 id='memory-model' class='section-header'><a href='#memory-model'>10 Memory model</a></h1>
<p>A Rust program&#39;s memory consists of a static set of <em>items</em> and a <em>heap</em>.
Immutable portions of the heap may be safely shared between threads, mutable
portions may not be safely shared, but several mechanisms for effectively-safe
sharing of mutable values, built on unsafe code but enforcing a safe locking
discipline, exist in the standard library.</p>

<p>Allocations in the stack consist of <em>variables</em>, and allocations in the heap
consist of <em>boxes</em>.</p>

<h3 id='memory-allocation-and-lifetime' class='section-header'><a href='#memory-allocation-and-lifetime'>10.0.1 Memory allocation and lifetime</a></h3>
<p>The <em>items</em> of a program are those functions, modules and types that have their
value calculated at compile-time and stored uniquely in the memory image of the
rust process. Items are neither dynamically allocated nor freed.</p>

<p>The <em>heap</em> is a general term that describes boxes.  The lifetime of an
allocation in the heap depends on the lifetime of the box values pointing to
it. Since box values may themselves be passed in and out of frames, or stored
in the heap, heap allocations may outlive the frame they are allocated within.
An allocation in the heap is guaranteed to reside at a single location in the
heap for the whole lifetime of the allocation - it will never be relocated as
a result of moving a box value.</p>

<h3 id='memory-ownership' class='section-header'><a href='#memory-ownership'>10.0.2 Memory ownership</a></h3>
<p>When a stack frame is exited, its local allocations are all released, and its
references to boxes are dropped.</p>

<h3 id='variables' class='section-header'><a href='#variables'>10.0.3 Variables</a></h3>
<p>A <em>variable</em> is a component of a stack frame, either a named function parameter,
an anonymous <a href="#lvalues-rvalues-and-temporaries">temporary</a>, or a named local
variable.</p>

<p>A <em>local variable</em> (or <em>stack-local</em> allocation) holds a value directly,
allocated within the stack&#39;s memory. The value is a part of the stack frame.</p>

<p>Local variables are immutable unless declared otherwise like: <code>let mut x = ...</code>.</p>

<p>Function parameters are immutable unless declared with <code>mut</code>. The <code>mut</code> keyword
applies only to the following parameter (so <code>|mut x, y|</code> and <code>fn f(mut x: Box&lt;i32&gt;, y: Box&lt;i32&gt;)</code> declare one mutable variable <code>x</code> and one immutable
variable <code>y</code>).</p>

<p>Methods that take either <code>self</code> or <code>Box&lt;Self&gt;</code> can optionally place them in a
mutable variable by prefixing them with <code>mut</code> (similar to regular arguments):</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Changer</span> {
    <span class='kw'>fn</span> <span class='ident'>change</span>(<span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='self'>Self</span>;
    <span class='kw'>fn</span> <span class='ident'>modify</span>(<span class='kw-2'>mut</span> <span class='self'>self</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='self'>Self</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='self'>Self</span><span class='op'>&gt;</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Changer%20%7B%0A%20%20%20%20fn%20change(mut%20self)%20-%3E%20Self%3B%0A%20%20%20%20fn%20modify(mut%20self%3A%20Box%3CSelf%3E)%20-%3E%20Box%3CSelf%3E%3B%0A%7D%0A%7D">Run</a></pre>

<p>Local variables are not initialized when allocated; the entire frame worth of
local variables are allocated at once, on frame-entry, in an uninitialized
state. Subsequent statements within a function may or may not initialize the
local variables. Local variables can be used only after they have been
initialized; this is enforced by the compiler.</p>

<h1 id='linkage' class='section-header'><a href='#linkage'>11 Linkage</a></h1>
<p>The Rust compiler supports various methods to link crates together both
statically and dynamically. This section will explore the various methods to
link Rust crates together, and more information about native libraries can be
found in the <a href="book/ffi.html">FFI section of the book</a>.</p>

<p>In one session of compilation, the compiler can generate multiple artifacts
through the usage of either command line flags or the <code>crate_type</code> attribute.
If one or more command line flags are specified, all <code>crate_type</code> attributes will
be ignored in favor of only building the artifacts specified by command line.</p>

<ul>
<li><p><code>--crate-type=bin</code>, <code>#[crate_type = &quot;bin&quot;]</code> - A runnable executable will be
produced. This requires that there is a <code>main</code> function in the crate which
will be run when the program begins executing. This will link in all Rust and
native dependencies, producing a distributable binary.</p></li>
<li><p><code>--crate-type=lib</code>, <code>#[crate_type = &quot;lib&quot;]</code> - A Rust library will be produced.
This is an ambiguous concept as to what exactly is produced because a library
can manifest itself in several forms. The purpose of this generic <code>lib</code> option
is to generate the &quot;compiler recommended&quot; style of library. The output library
will always be usable by rustc, but the actual type of library may change from
time-to-time. The remaining output types are all different flavors of
libraries, and the <code>lib</code> type can be seen as an alias for one of them (but the
actual one is compiler-defined).</p></li>
<li><p><code>--crate-type=dylib</code>, <code>#[crate_type = &quot;dylib&quot;]</code> - A dynamic Rust library will
be produced. This is different from the <code>lib</code> output type in that this forces
dynamic library generation. The resulting dynamic library can be used as a
dependency for other libraries and/or executables. This output type will
create <code>*.so</code> files on linux, <code>*.dylib</code> files on osx, and <code>*.dll</code> files on
windows.</p></li>
<li><p><code>--crate-type=staticlib</code>, <code>#[crate_type = &quot;staticlib&quot;]</code> - A static system
library will be produced. This is different from other library outputs in that
the Rust compiler will never attempt to link to <code>staticlib</code> outputs. The
purpose of this output type is to create a static library containing all of
the local crate&#39;s code along with all upstream dependencies. The static
library is actually a <code>*.a</code> archive on linux and osx and a <code>*.lib</code> file on
windows. This format is recommended for use in situations such as linking
Rust code into an existing non-Rust application because it will not have
dynamic dependencies on other Rust code.</p></li>
<li><p><code>--crate-type=rlib</code>, <code>#[crate_type = &quot;rlib&quot;]</code> - A &quot;Rust library&quot; file will be
produced. This is used as an intermediate artifact and can be thought of as a
&quot;static Rust library&quot;. These <code>rlib</code> files, unlike <code>staticlib</code> files, are
interpreted by the Rust compiler in future linkage. This essentially means
that <code>rustc</code> will look for metadata in <code>rlib</code> files like it looks for metadata
in dynamic libraries. This form of output is used to produce statically linked
executables as well as <code>staticlib</code> outputs.</p></li>
</ul>

<p>Note that these outputs are stackable in the sense that if multiple are
specified, then the compiler will produce each form of output at once without
having to recompile. However, this only applies for outputs specified by the
same method. If only <code>crate_type</code> attributes are specified, then they will all
be built, but if one or more <code>--crate-type</code> command line flags are specified,
then only those outputs will be built.</p>

<p>With all these different kinds of outputs, if crate A depends on crate B, then
the compiler could find B in various different forms throughout the system. The
only forms looked for by the compiler, however, are the <code>rlib</code> format and the
dynamic library format. With these two options for a dependent library, the
compiler must at some point make a choice between these two formats. With this
in mind, the compiler follows these rules when determining what format of
dependencies will be used:</p>

<ol>
<li><p>If a static library is being produced, all upstream dependencies are
required to be available in <code>rlib</code> formats. This requirement stems from the
reason that a dynamic library cannot be converted into a static format.</p>

<p>Note that it is impossible to link in native dynamic dependencies to a static
library, and in this case warnings will be printed about all unlinked native
dynamic dependencies.</p></li>
<li><p>If an <code>rlib</code> file is being produced, then there are no restrictions on what
format the upstream dependencies are available in. It is simply required that
all upstream dependencies be available for reading metadata from.</p>

<p>The reason for this is that <code>rlib</code> files do not contain any of their upstream
dependencies. It wouldn&#39;t be very efficient for all <code>rlib</code> files to contain a
copy of <code>libstd.rlib</code>!</p></li>
<li><p>If an executable is being produced and the <code>-C prefer-dynamic</code> flag is not
specified, then dependencies are first attempted to be found in the <code>rlib</code>
format. If some dependencies are not available in an rlib format, then
dynamic linking is attempted (see below).</p></li>
<li><p>If a dynamic library or an executable that is being dynamically linked is
being produced, then the compiler will attempt to reconcile the available
dependencies in either the rlib or dylib format to create a final product.</p>

<p>A major goal of the compiler is to ensure that a library never appears more
than once in any artifact. For example, if dynamic libraries B and C were
each statically linked to library A, then a crate could not link to B and C
together because there would be two copies of A. The compiler allows mixing
the rlib and dylib formats, but this restriction must be satisfied.</p>

<p>The compiler currently implements no method of hinting what format a library
should be linked with. When dynamically linking, the compiler will attempt to
maximize dynamic dependencies while still allowing some dependencies to be
linked in via an rlib.</p>

<p>For most situations, having all libraries available as a dylib is recommended
if dynamically linking. For other situations, the compiler will emit a
warning if it is unable to determine which formats to link each library with.</p></li>
</ol>

<p>In general, <code>--crate-type=bin</code> or <code>--crate-type=lib</code> should be sufficient for
all compilation needs, and the other options are just available if more
fine-grained control is desired over the output format of a Rust crate.</p>

<h1 id='unsafety' class='section-header'><a href='#unsafety'>12 Unsafety</a></h1>
<p>Unsafe operations are those that potentially violate the memory-safety
guarantees of Rust&#39;s static semantics.</p>

<p>The following language level features cannot be used in the safe subset of
Rust:</p>

<ul>
<li>Dereferencing a <a href="#pointer-types">raw pointer</a>.</li>
<li>Reading or writing a <a href="#mutable-statics">mutable static variable</a>.</li>
<li>Calling an unsafe function (including an intrinsic or foreign function).</li>
</ul>

<h2 id='unsafe-functions' class='section-header'><a href='#unsafe-functions'>12.1 Unsafe functions</a></h2>
<p>Unsafe functions are functions that are not safe in all contexts and/or for all
possible inputs. Such a function must be prefixed with the keyword <code>unsafe</code> and
can only be called from an <code>unsafe</code> block or another <code>unsafe</code> function.</p>

<h2 id='unsafe-blocks' class='section-header'><a href='#unsafe-blocks'>12.2 Unsafe blocks</a></h2>
<p>A block of code can be prefixed with the <code>unsafe</code> keyword, to permit calling
<code>unsafe</code> functions or dereferencing raw pointers within a safe function.</p>

<p>When a programmer has sufficient conviction that a sequence of potentially
unsafe operations is actually safe, they can encapsulate that sequence (taken
as a whole) within an <code>unsafe</code> block. The compiler will consider uses of such
code safe, in the surrounding context.</p>

<p>Unsafe blocks are used to wrap foreign libraries, make direct use of hardware
or implement features not directly present in the language. For example, Rust
provides the language features necessary to implement memory-safe concurrency
in the language but the implementation of threads and message passing is in the
standard library.</p>

<p>Rust&#39;s type system is a conservative approximation of the dynamic safety
requirements, so in some cases there is a performance cost to using safe code.
For example, a doubly-linked list is not a tree structure and can only be
represented with reference-counted pointers in safe code. By using <code>unsafe</code>
blocks to represent the reverse links as raw pointers, it can be implemented
with only boxes.</p>

<h2 id='behavior-considered-undefined' class='section-header'><a href='#behavior-considered-undefined'>12.3 Behavior considered undefined</a></h2>
<p>The following is a list of behavior which is forbidden in all Rust code,
including within <code>unsafe</code> blocks and <code>unsafe</code> functions. Type checking provides
the guarantee that these issues are never caused by safe code.</p>

<ul>
<li>Data races</li>
<li>Dereferencing a null/dangling raw pointer</li>
<li>Reads of <a href="http://llvm.org/docs/LangRef.html#undefined-values">undef</a>
(uninitialized) memory</li>
<li>Breaking the <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">pointer aliasing
rules</a>
with raw pointers (a subset of the rules used by C)</li>
<li><code>&amp;mut T</code> and <code>&amp;T</code> follow LLVMs scoped <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a> model, except if the <code>&amp;T</code>
contains an <code>UnsafeCell&lt;U&gt;</code>. Unsafe code must not violate these aliasing
guarantees.</li>
<li>Mutating non-mutable data (that is, data reached through a shared reference or
data owned by a <code>let</code> binding), unless that data is contained within an <code>UnsafeCell&lt;U&gt;</code>.</li>
<li>Invoking undefined behavior via compiler intrinsics:

<ul>
<li>Indexing outside of the bounds of an object with <code>std::ptr::offset</code>
(<code>offset</code> intrinsic), with
the exception of one byte past the end which is permitted.</li>
<li>Using <code>std::ptr::copy_nonoverlapping_memory</code> (<code>memcpy32</code>/<code>memcpy64</code>
intrinsics) on overlapping buffers</li>
</ul></li>
<li>Invalid values in primitive types, even in private fields/locals:

<ul>
<li>Dangling/null references or boxes</li>
<li>A value other than <code>false</code> (0) or <code>true</code> (1) in a <code>bool</code></li>
<li>A discriminant in an <code>enum</code> not included in the type definition</li>
<li>A value in a <code>char</code> which is a surrogate or above <code>char::MAX</code></li>
<li>Non-UTF-8 byte sequences in a <code>str</code></li>
</ul></li>
<li>Unwinding into Rust from foreign code or unwinding from Rust into foreign
code. Rust&#39;s failure system is not compatible with exception handling in
other languages. Unwinding must be caught and handled at FFI boundaries.</li>
</ul>

<h2 id='behavior-not-considered-unsafe' class='section-header'><a href='#behavior-not-considered-unsafe'>12.4 Behavior not considered unsafe</a></h2>
<p>This is a list of behavior not considered <em>unsafe</em> in Rust terms, but that may
be undesired.</p>

<ul>
<li>Deadlocks</li>
<li>Leaks of memory and other resources</li>
<li>Exiting without calling destructors</li>
<li>Integer overflow

<ul>
<li>Overflow is considered &quot;unexpected&quot; behavior and is always user-error,
unless the <code>wrapping</code> primitives are used. In non-optimized builds, the compiler
will insert debug checks that panic on overflow, but in optimized builds overflow
instead results in wrapped values. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">RFC 560</a> for the rationale and more details.</li>
</ul></li>
</ul>

<h1 id='appendix-influences' class='section-header'><a href='#appendix-influences'>13 Appendix: Influences</a></h1>
<p>Rust is not a particularly original language, with design elements coming from
a wide range of sources. Some of these are listed below (including elements
that have since been removed):</p>

<ul>
<li>SML, OCaml: algebraic data types, pattern matching, type inference,
semicolon statement separation</li>
<li>C++: references, RAII, smart pointers, move semantics, monomorphization,
memory model</li>
<li>ML Kit, Cyclone: region based memory management</li>
<li>Haskell (GHC): typeclasses, type families</li>
<li>Newsqueak, Alef, Limbo: channels, concurrency</li>
<li>Erlang: message passing, thread failure, <del>linked thread failure</del>,
<del>lightweight concurrency</del></li>
<li>Swift: optional bindings</li>
<li>Scheme: hygienic macros</li>
<li>C#: attributes</li>
<li>Ruby: <del>block syntax</del></li>
<li>NIL, Hermes: <del>typestate</del></li>
<li><a href="http://www.unicode.org/reports/tr31/">Unicode Annex #31</a>: identifier and
pattern syntax</li>
</ul>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Substitute definitions for the special Unicode productions are
provided to the grammar verifier, restricted to ASCII range, when verifying the
grammar in this document.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>Non-ASCII characters in identifiers are currently feature
gated. This is expected to improve soon.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>This distinction would also exist in an interpreter.
Static checks like syntactic analysis, type checking, and lints should
happen before the program is executed regardless of when it is executed.&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

<li id="fn4">
<p>A crate is somewhat analogous to an <em>assembly</em> in the
ECMA-335 CLI model, a <em>library</em> in the SML/NJ Compilation Manager, a <em>unit</em>
in the Owens and Flatt module system, or a <em>configuration</em> in Mesa.&nbsp;<a href="#fnref4" rev="footnote">&#8617;</a></p>
</li>

<li id="fn5">
<p><code>struct</code> types are analogous to <code>struct</code> types in C,
the <em>record</em> types of the ML family,
or the <em>struct</em> types of the Lisp family.&nbsp;<a href="#fnref5" rev="footnote">&#8617;</a></p>
</li>

<li id="fn6">
<p>The <code>enum</code> type is analogous to a <code>data</code> constructor declaration in
         ML, or a <em>pick ADT</em> in Limbo.&nbsp;<a href="#fnref6" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

    <footer><p>
Copyright &copy; 2011 The Rust Project Developers. Licensed under the
<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>
or the <a href="https://opensource.org/licenses/MIT">MIT license</a>, at your option.
</p><p>
This file may not be copied, modified, or distributed except according to those terms.
</p></footer>


</body>
</html>