<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Traits</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Guessing Game</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Syntax and Semantics</a>
<ol class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Loops</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vectors</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Method Syntax</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Generics</a>
</li>
<li><a class='active' href='traits.html'><b>4.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ol>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ol class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Error Handling</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Choosing your Guarantees</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Release Channels</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Using Rust without the standard library</a>
</li>
<li><a  href='procedural-macros.html'><b>5.13.</b> Procedural Macros (and custom derive)</a>
</li>
</ol>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ol class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Advanced linking</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Custom Allocators</a>
</li>
</ol>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Syntax Index</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> Bibliography</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Traits</h1>
    <p>A trait is a language feature that tells the Rust compiler about
functionality a type must provide.</p>

<p>Recall the <code>impl</code> keyword, used to call a function with <a href="method-syntax.html">method
syntax</a>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Circle</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>,
    <span class='ident'>radius</span>: <span class='ident'>f64</span>,
}

<span class='kw'>impl</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span> <span class='op'>*</span> (<span class='self'>self</span>.<span class='ident'>radius</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>radius</span>)
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Circle%20%7B%0A%20%20%20%20x%3A%20f64%2C%0A%20%20%20%20y%3A%20f64%2C%0A%20%20%20%20radius%3A%20f64%2C%0A%7D%0A%0Aimpl%20Circle%20%7B%0A%20%20%20%20fn%20area(%26self)%20-%3E%20f64%20%7B%0A%20%20%20%20%20%20%20%20std%3A%3Af64%3A%3Aconsts%3A%3API%20*%20(self.radius%20*%20self.radius)%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Traits are similar, except that we first define a trait with a method
signature, then implement the trait for a type. In this example, we implement the trait <code>HasArea</code> for <code>Circle</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Circle</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>,
    <span class='ident'>radius</span>: <span class='ident'>f64</span>,
}

<span class='kw'>trait</span> <span class='ident'>HasArea</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>;
}

<span class='kw'>impl</span> <span class='ident'>HasArea</span> <span class='kw'>for</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span> <span class='op'>*</span> (<span class='self'>self</span>.<span class='ident'>radius</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>radius</span>)
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Circle%20%7B%0A%20%20%20%20x%3A%20f64%2C%0A%20%20%20%20y%3A%20f64%2C%0A%20%20%20%20radius%3A%20f64%2C%0A%7D%0A%0Atrait%20HasArea%20%7B%0A%20%20%20%20fn%20area(%26self)%20-%3E%20f64%3B%0A%7D%0A%0Aimpl%20HasArea%20for%20Circle%20%7B%0A%20%20%20%20fn%20area(%26self)%20-%3E%20f64%20%7B%0A%20%20%20%20%20%20%20%20std%3A%3Af64%3A%3Aconsts%3A%3API%20*%20(self.radius%20*%20self.radius)%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>As you can see, the <code>trait</code> block looks very similar to the <code>impl</code> block,
but we don’t define a body, only a type signature. When we <code>impl</code> a trait,
we use <code>impl Trait for Item</code>, rather than only <code>impl Item</code>.</p>

<p><code>Self</code> may be used in a type annotation to refer to an instance of the type
implementing this trait passed as a parameter. <code>Self</code>, <code>&amp;Self</code> or <code>&amp;mut Self</code>
may be used depending on the level of ownership required.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Circle</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>,
    <span class='ident'>radius</span>: <span class='ident'>f64</span>,
}

<span class='kw'>trait</span> <span class='ident'>HasArea</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>;

    <span class='kw'>fn</span> <span class='ident'>is_larger</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='self'>Self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
}

<span class='kw'>impl</span> <span class='ident'>HasArea</span> <span class='kw'>for</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span> <span class='op'>*</span> (<span class='self'>self</span>.<span class='ident'>radius</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>radius</span>)
    }

    <span class='kw'>fn</span> <span class='ident'>is_larger</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>other</span>: <span class='kw-2'>&amp;</span><span class='self'>Self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='self'>self</span>.<span class='ident'>area</span>() <span class='op'>&gt;</span> <span class='ident'>other</span>.<span class='ident'>area</span>()
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Circle%20%7B%0A%20%20%20%20x%3A%20f64%2C%0A%20%20%20%20y%3A%20f64%2C%0A%20%20%20%20radius%3A%20f64%2C%0A%7D%0A%0Atrait%20HasArea%20%7B%0A%20%20%20%20fn%20area(%26self)%20-%3E%20f64%3B%0A%0A%20%20%20%20fn%20is_larger(%26self%2C%20%26Self)%20-%3E%20bool%3B%0A%7D%0A%0Aimpl%20HasArea%20for%20Circle%20%7B%0A%20%20%20%20fn%20area(%26self)%20-%3E%20f64%20%7B%0A%20%20%20%20%20%20%20%20std%3A%3Af64%3A%3Aconsts%3A%3API%20*%20(self.radius%20*%20self.radius)%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20is_larger(%26self%2C%20other%3A%20%26Self)%20-%3E%20bool%20%7B%0A%20%20%20%20%20%20%20%20self.area()%20%3E%20other.area()%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<h2 id='trait-bounds-on-generic-functions' class='section-header'><a href='#trait-bounds-on-generic-functions'>Trait bounds on generic functions</a></h2>
<p>Traits are useful because they allow a type to make certain promises about its
behavior. Generic functions can exploit this to constrain, or <a href="glossary.html#bounds">bound</a>, the types they
accept. Consider this function, which does not compile:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>print_area</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>shape</span>: <span class='ident'>T</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;This shape has an area of {}&quot;</span>, <span class='ident'>shape</span>.<span class='ident'>area</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20print_area%3CT%3E(shape%3A%20T)%20%7B%0A%20%20%20%20println!(%22This%20shape%20has%20an%20area%20of%20%7B%7D%22%2C%20shape.area())%3B%0A%7D%0A%7D">Run</a></pre>

<p>Rust complains:</p>

<pre><code class="language-text">error: no method named `area` found for type `T` in the current scope
</code></pre>

<p>Because <code>T</code> can be any type, we can’t be sure that it implements the <code>area</code>
method. But we can add a trait bound to our generic <code>T</code>, ensuring
that it does:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>print_area</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>HasArea</span><span class='op'>&gt;</span>(<span class='ident'>shape</span>: <span class='ident'>T</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;This shape has an area of {}&quot;</span>, <span class='ident'>shape</span>.<span class='ident'>area</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20HasArea%20%7B%0A%20%20%20%20fn%20area(%26self)%20-%3E%20f64%3B%0A%7D%0Afn%20print_area%3CT%3A%20HasArea%3E(shape%3A%20T)%20%7B%0A%20%20%20%20println!(%22This%20shape%20has%20an%20area%20of%20%7B%7D%22%2C%20shape.area())%3B%0A%7D%0A%7D">Run</a></pre>

<p>The syntax <code>&lt;T: HasArea&gt;</code> means “any type that implements the <code>HasArea</code> trait.”
Because traits define function type signatures, we can be sure that any type
which implements <code>HasArea</code> will have an <code>.area()</code> method.</p>

<p>Here’s an extended example of how this works:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>HasArea</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>;
}

<span class='kw'>struct</span> <span class='ident'>Circle</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>,
    <span class='ident'>radius</span>: <span class='ident'>f64</span>,
}

<span class='kw'>impl</span> <span class='ident'>HasArea</span> <span class='kw'>for</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span> <span class='op'>*</span> (<span class='self'>self</span>.<span class='ident'>radius</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>radius</span>)
    }
}

<span class='kw'>struct</span> <span class='ident'>Square</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>,
    <span class='ident'>side</span>: <span class='ident'>f64</span>,
}

<span class='kw'>impl</span> <span class='ident'>HasArea</span> <span class='kw'>for</span> <span class='ident'>Square</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='self'>self</span>.<span class='ident'>side</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>side</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>print_area</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>HasArea</span><span class='op'>&gt;</span>(<span class='ident'>shape</span>: <span class='ident'>T</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;This shape has an area of {}&quot;</span>, <span class='ident'>shape</span>.<span class='ident'>area</span>());
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>Circle</span> {
        <span class='ident'>x</span>: <span class='number'>0.0f64</span>,
        <span class='ident'>y</span>: <span class='number'>0.0f64</span>,
        <span class='ident'>radius</span>: <span class='number'>1.0f64</span>,
    };

    <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>Square</span> {
        <span class='ident'>x</span>: <span class='number'>0.0f64</span>,
        <span class='ident'>y</span>: <span class='number'>0.0f64</span>,
        <span class='ident'>side</span>: <span class='number'>1.0f64</span>,
    };

    <span class='ident'>print_area</span>(<span class='ident'>c</span>);
    <span class='ident'>print_area</span>(<span class='ident'>s</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=trait%20HasArea%20%7B%0A%20%20%20%20fn%20area(%26self)%20-%3E%20f64%3B%0A%7D%0A%0Astruct%20Circle%20%7B%0A%20%20%20%20x%3A%20f64%2C%0A%20%20%20%20y%3A%20f64%2C%0A%20%20%20%20radius%3A%20f64%2C%0A%7D%0A%0Aimpl%20HasArea%20for%20Circle%20%7B%0A%20%20%20%20fn%20area(%26self)%20-%3E%20f64%20%7B%0A%20%20%20%20%20%20%20%20std%3A%3Af64%3A%3Aconsts%3A%3API%20*%20(self.radius%20*%20self.radius)%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20Square%20%7B%0A%20%20%20%20x%3A%20f64%2C%0A%20%20%20%20y%3A%20f64%2C%0A%20%20%20%20side%3A%20f64%2C%0A%7D%0A%0Aimpl%20HasArea%20for%20Square%20%7B%0A%20%20%20%20fn%20area(%26self)%20-%3E%20f64%20%7B%0A%20%20%20%20%20%20%20%20self.side%20*%20self.side%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20print_area%3CT%3A%20HasArea%3E(shape%3A%20T)%20%7B%0A%20%20%20%20println!(%22This%20shape%20has%20an%20area%20of%20%7B%7D%22%2C%20shape.area())%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20c%20%3D%20Circle%20%7B%0A%20%20%20%20%20%20%20%20x%3A%200.0f64%2C%0A%20%20%20%20%20%20%20%20y%3A%200.0f64%2C%0A%20%20%20%20%20%20%20%20radius%3A%201.0f64%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20s%20%3D%20Square%20%7B%0A%20%20%20%20%20%20%20%20x%3A%200.0f64%2C%0A%20%20%20%20%20%20%20%20y%3A%200.0f64%2C%0A%20%20%20%20%20%20%20%20side%3A%201.0f64%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20print_area(c)%3B%0A%20%20%20%20print_area(s)%3B%0A%7D%0A">Run</a></pre>

<p>This program outputs:</p>

<pre><code class="language-text">This shape has an area of 3.141593
This shape has an area of 1
</code></pre>

<p>As you can see, <code>print_area</code> is now generic, but also ensures that we have
passed in the correct types. If we pass in an incorrect type:</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>print_area</span>(<span class='number'>5</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aprint_area(5)%3B%0A%7D">Run</a></pre>

<p>We get a compile-time error:</p>

<pre><code class="language-text">error: the trait bound `_ : HasArea` is not satisfied [E0277]
</code></pre>

<h2 id='trait-bounds-on-generic-structs' class='section-header'><a href='#trait-bounds-on-generic-structs'>Trait bounds on generic structs</a></h2>
<p>Your generic structs can also benefit from trait bounds. All you need to
do is append the bound when you declare type parameters. Here is a new
type <code>Rectangle&lt;T&gt;</code> and its operation <code>is_square()</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Rectangle</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>x</span>: <span class='ident'>T</span>,
    <span class='ident'>y</span>: <span class='ident'>T</span>,
    <span class='ident'>width</span>: <span class='ident'>T</span>,
    <span class='ident'>height</span>: <span class='ident'>T</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>PartialEq</span><span class='op'>&gt;</span> <span class='ident'>Rectangle</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>is_square</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='self'>self</span>.<span class='ident'>width</span> <span class='op'>==</span> <span class='self'>self</span>.<span class='ident'>height</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>Rectangle</span> {
        <span class='ident'>x</span>: <span class='number'>0</span>,
        <span class='ident'>y</span>: <span class='number'>0</span>,
        <span class='ident'>width</span>: <span class='number'>47</span>,
        <span class='ident'>height</span>: <span class='number'>47</span>,
    };

    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>r</span>.<span class='ident'>is_square</span>());

    <span class='ident'>r</span>.<span class='ident'>height</span> <span class='op'>=</span> <span class='number'>42</span>;
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>r</span>.<span class='ident'>is_square</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=struct%20Rectangle%3CT%3E%20%7B%0A%20%20%20%20x%3A%20T%2C%0A%20%20%20%20y%3A%20T%2C%0A%20%20%20%20width%3A%20T%2C%0A%20%20%20%20height%3A%20T%2C%0A%7D%0A%0Aimpl%3CT%3A%20PartialEq%3E%20Rectangle%3CT%3E%20%7B%0A%20%20%20%20fn%20is_square(%26self)%20-%3E%20bool%20%7B%0A%20%20%20%20%20%20%20%20self.width%20%3D%3D%20self.height%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20r%20%3D%20Rectangle%20%7B%0A%20%20%20%20%20%20%20%20x%3A%200%2C%0A%20%20%20%20%20%20%20%20y%3A%200%2C%0A%20%20%20%20%20%20%20%20width%3A%2047%2C%0A%20%20%20%20%20%20%20%20height%3A%2047%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20assert!(r.is_square())%3B%0A%0A%20%20%20%20r.height%20%3D%2042%3B%0A%20%20%20%20assert!(!r.is_square())%3B%0A%7D%0A">Run</a></pre>

<p><code>is_square()</code> needs to check that the sides are equal, so the sides must be of
a type that implements the <a href="../core/cmp/trait.PartialEq.html"><code>core::cmp::PartialEq</code></a> trait:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>PartialEq</span><span class='op'>&gt;</span> <span class='ident'>Rectangle</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { ... }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CT%3A%20PartialEq%3E%20Rectangle%3CT%3E%20%7B%20...%20%7D%0A%7D">Run</a></pre>

<p>Now, a rectangle can be defined in terms of any type that can be compared for
equality.</p>

<p>Here we defined a new struct <code>Rectangle</code> that accepts numbers of any
precision—really, objects of pretty much any type—as long as they can be
compared for equality. Could we do the same for our <code>HasArea</code> structs, <code>Square</code>
and <code>Circle</code>? Yes, but they need multiplication, and to work with that we need
to know more about <a href="operators-and-overloading.html">operator traits</a>.</p>

<h1 id='rules-for-implementing-traits' class='section-header'><a href='#rules-for-implementing-traits'>Rules for implementing traits</a></h1>
<p>So far, we’ve only added trait implementations to structs, but you can
implement a trait for any type such as <code>f32</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>ApproxEqual</span> {
    <span class='kw'>fn</span> <span class='ident'>approx_equal</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>other</span>: <span class='kw-2'>&amp;</span><span class='self'>Self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
}
<span class='kw'>impl</span> <span class='ident'>ApproxEqual</span> <span class='kw'>for</span> <span class='ident'>f32</span> {
    <span class='kw'>fn</span> <span class='ident'>approx_equal</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>other</span>: <span class='kw-2'>&amp;</span><span class='self'>Self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='comment'>// Appropriate for `self` and `other` being close to 1.0.</span>
        (<span class='self'>self</span> <span class='op'>-</span> <span class='ident'>other</span>).<span class='ident'>abs</span>() <span class='op'>&lt;=</span> ::<span class='ident'>std</span>::<span class='ident'>f32</span>::<span class='ident'>EPSILON</span>
    }
}

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='number'>1.0</span>.<span class='ident'>approx_equal</span>(<span class='kw-2'>&amp;</span><span class='number'>1.00000001</span>));<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20ApproxEqual%20%7B%0A%20%20%20%20fn%20approx_equal(%26self%2C%20other%3A%20%26Self)%20-%3E%20bool%3B%0A%7D%0Aimpl%20ApproxEqual%20for%20f32%20%7B%0A%20%20%20%20fn%20approx_equal(%26self%2C%20other%3A%20%26Self)%20-%3E%20bool%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Appropriate%20for%20%60self%60%20and%20%60other%60%20being%20close%20to%201.0.%0A%20%20%20%20%20%20%20%20(self%20-%20other).abs()%20%3C%3D%20%3A%3Astd%3A%3Af32%3A%3AEPSILON%0A%20%20%20%20%7D%0A%7D%0A%0Aprintln!(%22%7B%7D%22%2C%201.0.approx_equal(%261.00000001))%3B%0A%7D">Run</a></pre>

<p>This may seem like the Wild West, but there are two restrictions around
implementing traits that prevent this from getting out of hand. The first is
that if the trait isn’t defined in your scope, it doesn’t apply. Here’s an
example: the standard library provides a <a href="../std/io/trait.Write.html"><code>Write</code></a> trait which adds
extra functionality to <code>File</code>s, for doing file I/O. By default, a <code>File</code>
won’t have its methods:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>).<span class='ident'>expect</span>(<span class='string'>&quot;Couldn’t create foo.txt&quot;</span>);
<span class='kw'>let</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='string'>b&quot;whatever&quot;</span>; <span class='comment'>// buf: &amp;[u8; 8], a byte string literal.</span>
<span class='kw'>let</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='ident'>f</span>.<span class='ident'>write</span>(<span class='ident'>buf</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20f%20%3D%20std%3A%3Afs%3A%3AFile%3A%3Acreate(%22foo.txt%22).expect(%22Couldn%E2%80%99t%20create%20foo.txt%22)%3B%0Alet%20buf%20%3D%20b%22whatever%22%3B%20%2F%2F%20buf%3A%20%26%5Bu8%3B%208%5D%2C%20a%20byte%20string%20literal.%0Alet%20result%20%3D%20f.write(buf)%3B%0Aresult.unwrap()%3B%20%2F%2F%20Ignore%20the%20error.%0A%7D">Run</a></pre>

<p>Here’s the error:</p>

<pre><code class="language-text">error: type `std::fs::File` does not implement any method in scope named `write`
let result = f.write(buf);
               ^~~~~~~~~~
</code></pre>

<p>We need to <code>use</code> the <code>Write</code> trait first:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Write</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>).<span class='ident'>expect</span>(<span class='string'>&quot;Couldn’t create foo.txt&quot;</span>);
<span class='kw'>let</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='string'>b&quot;whatever&quot;</span>;
<span class='kw'>let</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='ident'>f</span>.<span class='ident'>write</span>(<span class='ident'>buf</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Aio%3A%3AWrite%3B%0A%0Alet%20mut%20f%20%3D%20std%3A%3Afs%3A%3AFile%3A%3Acreate(%22foo.txt%22).expect(%22Couldn%E2%80%99t%20create%20foo.txt%22)%3B%0Alet%20buf%20%3D%20b%22whatever%22%3B%0Alet%20result%20%3D%20f.write(buf)%3B%0Aresult.unwrap()%3B%20%2F%2F%20Ignore%20the%20error.%0A%7D">Run</a></pre>

<p>This will compile without error.</p>

<p>This means that even if someone does something bad like add methods to <code>i32</code>,
it won’t affect you, unless you <code>use</code> that trait.</p>

<p>There’s one more restriction on implementing traits: either the trait
or the type you’re implementing it for must be defined by you. Or more
precisely, one of them must be defined in the same crate as the <code>impl</code>
you&#39;re writing. For more on Rust&#39;s module and package system, see the
chapter on <a href="crates-and-modules.html">crates and modules</a>.</p>

<p>So, we could implement the <code>HasArea</code> type for <code>i32</code>, because we defined
<code>HasArea</code> in our code. But if we tried to implement <code>ToString</code>, a trait
provided by Rust, for <code>i32</code>, we could not, because neither the trait nor
the type are defined in our crate.</p>

<p>One last thing about traits: generic functions with a trait bound use
‘monomorphization’ (mono: one, morph: form), so they are statically dispatched.
What’s that mean? Check out the chapter on <a href="trait-objects.html">trait objects</a> for more details.</p>

<h1 id='multiple-trait-bounds' class='section-header'><a href='#multiple-trait-bounds'>Multiple trait bounds</a></h1>
<p>You’ve seen that you can bound a generic type parameter with a trait:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Clone</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='ident'>x</span>.<span class='ident'>clone</span>();
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo%3CT%3A%20Clone%3E(x%3A%20T)%20%7B%0A%20%20%20%20x.clone()%3B%0A%7D%0A%7D">Run</a></pre>

<p>If you need more than one bound, you can use <code>+</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Debug</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Clone</span> <span class='op'>+</span> <span class='ident'>Debug</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='ident'>x</span>.<span class='ident'>clone</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>x</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Afmt%3A%3ADebug%3B%0A%0Afn%20foo%3CT%3A%20Clone%20%2B%20Debug%3E(x%3A%20T)%20%7B%0A%20%20%20%20x.clone()%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20x)%3B%0A%7D%0A%7D">Run</a></pre>

<p><code>T</code> now needs to be both <code>Clone</code> as well as <code>Debug</code>.</p>

<h1 id='where-clause' class='section-header'><a href='#where-clause'>Where clause</a></h1>
<p>Writing functions with only a few generic types and a small number of trait
bounds isn’t too bad, but as the number increases, the syntax gets increasingly
awkward:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Debug</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Clone</span>, <span class='ident'>K</span>: <span class='ident'>Clone</span> <span class='op'>+</span> <span class='ident'>Debug</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>, <span class='ident'>y</span>: <span class='ident'>K</span>) {
    <span class='ident'>x</span>.<span class='ident'>clone</span>();
    <span class='ident'>y</span>.<span class='ident'>clone</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>y</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Afmt%3A%3ADebug%3B%0A%0Afn%20foo%3CT%3A%20Clone%2C%20K%3A%20Clone%20%2B%20Debug%3E(x%3A%20T%2C%20y%3A%20K)%20%7B%0A%20%20%20%20x.clone()%3B%0A%20%20%20%20y.clone()%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20y)%3B%0A%7D%0A%7D">Run</a></pre>

<p>The name of the function is on the far left, and the parameter list is on the
far right. The bounds are getting in the way.</p>

<p>Rust has a solution, and it’s called a ‘<code>where</code> clause’:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Debug</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Clone</span>, <span class='ident'>K</span>: <span class='ident'>Clone</span> <span class='op'>+</span> <span class='ident'>Debug</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>, <span class='ident'>y</span>: <span class='ident'>K</span>) {
    <span class='ident'>x</span>.<span class='ident'>clone</span>();
    <span class='ident'>y</span>.<span class='ident'>clone</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>y</span>);
}

<span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>K</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>, <span class='ident'>y</span>: <span class='ident'>K</span>) <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Clone</span>, <span class='ident'>K</span>: <span class='ident'>Clone</span> <span class='op'>+</span> <span class='ident'>Debug</span> {
    <span class='ident'>x</span>.<span class='ident'>clone</span>();
    <span class='ident'>y</span>.<span class='ident'>clone</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>y</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>foo</span>(<span class='string'>&quot;Hello&quot;</span>, <span class='string'>&quot;world&quot;</span>);
    <span class='ident'>bar</span>(<span class='string'>&quot;Hello&quot;</span>, <span class='string'>&quot;world&quot;</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=use%20std%3A%3Afmt%3A%3ADebug%3B%0A%0Afn%20foo%3CT%3A%20Clone%2C%20K%3A%20Clone%20%2B%20Debug%3E(x%3A%20T%2C%20y%3A%20K)%20%7B%0A%20%20%20%20x.clone()%3B%0A%20%20%20%20y.clone()%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20y)%3B%0A%7D%0A%0Afn%20bar%3CT%2C%20K%3E(x%3A%20T%2C%20y%3A%20K)%20where%20T%3A%20Clone%2C%20K%3A%20Clone%20%2B%20Debug%20%7B%0A%20%20%20%20x.clone()%3B%0A%20%20%20%20y.clone()%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20y)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20foo(%22Hello%22%2C%20%22world%22)%3B%0A%20%20%20%20bar(%22Hello%22%2C%20%22world%22)%3B%0A%7D%0A">Run</a></pre>

<p><code>foo()</code> uses the syntax we showed earlier, and <code>bar()</code> uses a <code>where</code> clause.
All you need to do is leave off the bounds when defining your type parameters,
and then add <code>where</code> after the parameter list. For longer lists, whitespace can
be added:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Debug</span>;

<span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>K</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>, <span class='ident'>y</span>: <span class='ident'>K</span>)
    <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Clone</span>,
          <span class='ident'>K</span>: <span class='ident'>Clone</span> <span class='op'>+</span> <span class='ident'>Debug</span> {

    <span class='ident'>x</span>.<span class='ident'>clone</span>();
    <span class='ident'>y</span>.<span class='ident'>clone</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>y</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Afmt%3A%3ADebug%3B%0A%0Afn%20bar%3CT%2C%20K%3E(x%3A%20T%2C%20y%3A%20K)%0A%20%20%20%20where%20T%3A%20Clone%2C%0A%20%20%20%20%20%20%20%20%20%20K%3A%20Clone%20%2B%20Debug%20%7B%0A%0A%20%20%20%20x.clone()%3B%0A%20%20%20%20y.clone()%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20y)%3B%0A%7D%0A%7D">Run</a></pre>

<p>This flexibility can add clarity in complex situations.</p>

<p><code>where</code> is also more powerful than the simpler syntax. For example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>Output</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>convert</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Output</span>;
}

<span class='kw'>impl</span> <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>i64</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>i32</span> {
    <span class='kw'>fn</span> <span class='ident'>convert</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>i64</span> { <span class='kw-2'>*</span><span class='self'>self</span> <span class='kw'>as</span> <span class='ident'>i64</span> }
}

<span class='comment'>// Can be called with T == i32.</span>
<span class='kw'>fn</span> <span class='ident'>normal</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>i64</span><span class='op'>&gt;&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>i64</span> {
    <span class='ident'>x</span>.<span class='ident'>convert</span>()
}

<span class='comment'>// Can be called with T == i64.</span>
<span class='kw'>fn</span> <span class='ident'>inverse</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span>
        <span class='comment'>// This is using ConvertTo as if it were &quot;ConvertTo&lt;i64&gt;&quot;.</span>
        <span class='kw'>where</span> <span class='ident'>i32</span>: <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>x</span>.<span class='ident'>convert</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20ConvertTo%3COutput%3E%20%7B%0A%20%20%20%20fn%20convert(%26self)%20-%3E%20Output%3B%0A%7D%0A%0Aimpl%20ConvertTo%3Ci64%3E%20for%20i32%20%7B%0A%20%20%20%20fn%20convert(%26self)%20-%3E%20i64%20%7B%20*self%20as%20i64%20%7D%0A%7D%0A%0A%2F%2F%20Can%20be%20called%20with%20T%20%3D%3D%20i32.%0Afn%20normal%3CT%3A%20ConvertTo%3Ci64%3E%3E(x%3A%20%26T)%20-%3E%20i64%20%7B%0A%20%20%20%20x.convert()%0A%7D%0A%0A%2F%2F%20Can%20be%20called%20with%20T%20%3D%3D%20i64.%0Afn%20inverse%3CT%3E(x%3A%20i32)%20-%3E%20T%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20is%20using%20ConvertTo%20as%20if%20it%20were%20%22ConvertTo%3Ci64%3E%22.%0A%20%20%20%20%20%20%20%20where%20i32%3A%20ConvertTo%3CT%3E%20%7B%0A%20%20%20%20x.convert()%0A%7D%0A%7D">Run</a></pre>

<p>This shows off the additional feature of <code>where</code> clauses: they allow bounds
on the left-hand side not only of type parameters <code>T</code>, but also of types (<code>i32</code> in this case). In this example, <code>i32</code> must implement
<code>ConvertTo&lt;T&gt;</code>. Rather than defining what <code>i32</code> is (since that&#39;s obvious), the
<code>where</code> clause here constrains <code>T</code>.</p>

<h1 id='default-methods' class='section-header'><a href='#default-methods'>Default methods</a></h1>
<p>A default method can be added to a trait definition if it is already known how a typical implementor will define a method. For example, <code>is_invalid()</code> is defined as the opposite of <code>is_valid()</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>is_valid</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;

    <span class='kw'>fn</span> <span class='ident'>is_invalid</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='op'>!</span><span class='self'>self</span>.<span class='ident'>is_valid</span>() }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Foo%20%7B%0A%20%20%20%20fn%20is_valid(%26self)%20-%3E%20bool%3B%0A%0A%20%20%20%20fn%20is_invalid(%26self)%20-%3E%20bool%20%7B%20!self.is_valid()%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Implementors of the <code>Foo</code> trait need to implement <code>is_valid()</code> but not <code>is_invalid()</code> due to the added default behavior. This default behavior can still be overridden as in:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>UseDefault</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>UseDefault</span> {
    <span class='kw'>fn</span> <span class='ident'>is_valid</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Called UseDefault.is_valid.&quot;</span>);
        <span class='bool-val'>true</span>
    }
}

<span class='kw'>struct</span> <span class='ident'>OverrideDefault</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>OverrideDefault</span> {
    <span class='kw'>fn</span> <span class='ident'>is_valid</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Called OverrideDefault.is_valid.&quot;</span>);
        <span class='bool-val'>true</span>
    }

    <span class='kw'>fn</span> <span class='ident'>is_invalid</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Called OverrideDefault.is_invalid!&quot;</span>);
        <span class='bool-val'>true</span> <span class='comment'>// Overrides the expected value of `is_invalid()`.</span>
    }
}

<span class='kw'>let</span> <span class='ident'>default</span> <span class='op'>=</span> <span class='ident'>UseDefault</span>;
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>default</span>.<span class='ident'>is_invalid</span>()); <span class='comment'>// Prints &quot;Called UseDefault.is_valid.&quot;</span>

<span class='kw'>let</span> <span class='ident'>over</span> <span class='op'>=</span> <span class='ident'>OverrideDefault</span>;
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>over</span>.<span class='ident'>is_invalid</span>()); <span class='comment'>// Prints &quot;Called OverrideDefault.is_invalid!&quot;</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Foo%20%7B%0A%20%20%20%20fn%20is_valid(%26self)%20-%3E%20bool%3B%0A%0A%20%20%20%20fn%20is_invalid(%26self)%20-%3E%20bool%20%7B%20!self.is_valid()%20%7D%0A%7D%0Astruct%20UseDefault%3B%0A%0Aimpl%20Foo%20for%20UseDefault%20%7B%0A%20%20%20%20fn%20is_valid(%26self)%20-%3E%20bool%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Called%20UseDefault.is_valid.%22)%3B%0A%20%20%20%20%20%20%20%20true%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20OverrideDefault%3B%0A%0Aimpl%20Foo%20for%20OverrideDefault%20%7B%0A%20%20%20%20fn%20is_valid(%26self)%20-%3E%20bool%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Called%20OverrideDefault.is_valid.%22)%3B%0A%20%20%20%20%20%20%20%20true%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20is_invalid(%26self)%20-%3E%20bool%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Called%20OverrideDefault.is_invalid!%22)%3B%0A%20%20%20%20%20%20%20%20true%20%2F%2F%20Overrides%20the%20expected%20value%20of%20%60is_invalid()%60.%0A%20%20%20%20%7D%0A%7D%0A%0Alet%20default%20%3D%20UseDefault%3B%0Aassert!(!default.is_invalid())%3B%20%2F%2F%20Prints%20%22Called%20UseDefault.is_valid.%22%0A%0Alet%20over%20%3D%20OverrideDefault%3B%0Aassert!(over.is_invalid())%3B%20%2F%2F%20Prints%20%22Called%20OverrideDefault.is_invalid!%22%0A%7D">Run</a></pre>

<h1 id='inheritance' class='section-header'><a href='#inheritance'>Inheritance</a></h1>
<p>Sometimes, implementing a trait requires implementing another trait:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}

<span class='kw'>trait</span> <span class='ident'>FooBar</span> : <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foobar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Foo%20%7B%0A%20%20%20%20fn%20foo(%26self)%3B%0A%7D%0A%0Atrait%20FooBar%20%3A%20Foo%20%7B%0A%20%20%20%20fn%20foobar(%26self)%3B%0A%7D%0A%7D">Run</a></pre>

<p>Implementors of <code>FooBar</code> must also implement <code>Foo</code>, like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Baz</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Baz</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;foo&quot;</span>); }
}

<span class='kw'>impl</span> <span class='ident'>FooBar</span> <span class='kw'>for</span> <span class='ident'>Baz</span> {
    <span class='kw'>fn</span> <span class='ident'>foobar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;foobar&quot;</span>); }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Foo%20%7B%0A%20%20%20%20fn%20foo(%26self)%3B%0A%7D%0Atrait%20FooBar%20%3A%20Foo%20%7B%0A%20%20%20%20fn%20foobar(%26self)%3B%0A%7D%0Astruct%20Baz%3B%0A%0Aimpl%20Foo%20for%20Baz%20%7B%0A%20%20%20%20fn%20foo(%26self)%20%7B%20println!(%22foo%22)%3B%20%7D%0A%7D%0A%0Aimpl%20FooBar%20for%20Baz%20%7B%0A%20%20%20%20fn%20foobar(%26self)%20%7B%20println!(%22foobar%22)%3B%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>If we forget to implement <code>Foo</code>, Rust will tell us:</p>

<pre><code class="language-text">error: the trait bound `main::Baz : main::Foo` is not satisfied [E0277]
</code></pre>

<h1 id='deriving' class='section-header'><a href='#deriving'>Deriving</a></h1>
<p>Implementing traits like <code>Debug</code> and <code>Default</code> repeatedly can become
quite tedious. For that reason, Rust provides an <a href="attributes.html">attribute</a> that
allows you to let Rust automatically implement traits for you:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>Foo</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23%5Bderive(Debug)%5D%0Astruct%20Foo%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20Foo)%3B%0A%7D%0A">Run</a></pre>

<p>However, deriving is limited to a certain set of traits:</p>

<ul>
<li><a href="../core/clone/trait.Clone.html"><code>Clone</code></a></li>
<li><a href="../core/marker/trait.Copy.html"><code>Copy</code></a></li>
<li><a href="../core/fmt/trait.Debug.html"><code>Debug</code></a></li>
<li><a href="../core/default/trait.Default.html"><code>Default</code></a></li>
<li><a href="../core/cmp/trait.Eq.html"><code>Eq</code></a></li>
<li><a href="../core/hash/trait.Hash.html"><code>Hash</code></a></li>
<li><a href="../core/cmp/trait.Ord.html"><code>Ord</code></a></li>
<li><a href="../core/cmp/trait.PartialEq.html"><code>PartialEq</code></a></li>
<li><a href="../core/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></li>
</ul>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>