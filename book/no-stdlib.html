<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>No stdlib</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='./README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Installing Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Learn Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> Guessing Game</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> Dining Philosophers</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust Inside Other Languages</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Error Handling</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Release Channels</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Syntax and Semantics</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='for-loops.html'><b>5.6.</b> for loops</a>
</li>
<li><a  href='while-loops.html'><b>5.7.</b> while loops</a>
</li>
<li><a  href='ownership.html'><b>5.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>5.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>5.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>5.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>5.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>5.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>5.16.</b> Method Syntax</a>
</li>
<li><a  href='vectors.html'><b>5.17.</b> Vectors</a>
</li>
<li><a  href='strings.html'><b>5.18.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>5.19.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>5.20.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.21.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.22.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.23.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>5.24.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.25.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.26.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>5.27.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>5.28.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>5.29.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>5.30.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>5.31.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>5.32.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.33.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>5.34.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>5.35.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.36.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>5.37.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a class='active' href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Link args</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Academic Research</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">No stdlib</h1>
    <p>By default, <code>std</code> is linked to every Rust crate. In some contexts,
this is undesirable, and can be avoided with the <code>#![no_std]</code>
attribute attached to the crate.</p>
<span class='rusttest'>// a minimal library
#![crate_type=&quot;lib&quot;]
#![feature(no_std)]
#![no_std]
// fn main() {} tricked you, rustdoc!
</span><pre id='rust-example-rendered' class='rust '>
<span class='comment'>// a minimal library</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_type</span><span class='op'>=</span><span class='string'>&quot;lib&quot;</span>]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>no_std</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span>
</pre>

<p>Obviously there&#39;s more to life than just libraries: one can use
<code>#[no_std]</code> with an executable, controlling the entry point is
possible in two ways: the <code>#[start]</code> attribute, or overriding the
default shim for the C <code>main</code> function with your own.</p>

<p>The function marked <code>#[start]</code> is passed the command line parameters
in the same format as C:</p>
<span class='rusttest'>#![feature(lang_items, start, no_std, libc)]
#![no_std]

// Pull in the system libc library for what crt0.o likely requires
extern crate libc;

// Entry point for this program
#[start]
fn start(_argc: isize, _argv: *const *const u8) -&gt; isize {
    0
}

// These functions and traits are used by the compiler, but not
// for a bare-bones hello world. These are normally
// provided by libstd.
#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
// fn main() {} tricked you, rustdoc!
</span><pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>lang_items</span>, <span class='ident'>start</span>, <span class='ident'>no_std</span>, <span class='ident'>libc</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span>

<span class='comment'>// Pull in the system libc library for what crt0.o likely requires</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;

<span class='comment'>// Entry point for this program</span>
<span class='attribute'>#[<span class='ident'>start</span>]</span>
<span class='kw'>fn</span> <span class='ident'>start</span>(<span class='ident'>_argc</span>: <span class='ident'>isize</span>, <span class='ident'>_argv</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>isize</span> {
    <span class='number'>0</span>
}

<span class='comment'>// These functions and traits are used by the compiler, but not</span>
<span class='comment'>// for a bare-bones hello world. These are normally</span>
<span class='comment'>// provided by libstd.</span>
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;stack_exhausted&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>stack_exhausted</span>() {}
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;eh_personality&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>eh_personality</span>() {}
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;panic_fmt&quot;</span>]</span> <span class='kw'>fn</span> <span class='ident'>panic_fmt</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> { <span class='kw'>loop</span> {} }
</pre>

<p>To override the compiler-inserted <code>main</code> shim, one has to disable it
with <code>#![no_main]</code> and then create the appropriate symbol with the
correct ABI and the correct name, which requires overriding the
compiler&#39;s name mangling too:</p>
<span class='rusttest'>#![feature(no_std)]
#![no_std]
#![no_main]
#![feature(lang_items, start)]

extern crate libc;

#[no_mangle] // ensure that this symbol is called `main` in the output
pub extern fn main(argc: i32, argv: *const *const u8) -&gt; i32 {
    0
}

#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
// fn main() {} tricked you, rustdoc!
</span><pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>no_std</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_main</span>]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>lang_items</span>, <span class='ident'>start</span>)]</span>

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;

<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span> <span class='comment'>// ensure that this symbol is called `main` in the output</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>main</span>(<span class='ident'>argc</span>: <span class='ident'>i32</span>, <span class='ident'>argv</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='number'>0</span>
}

<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;stack_exhausted&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>stack_exhausted</span>() {}
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;eh_personality&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>eh_personality</span>() {}
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;panic_fmt&quot;</span>]</span> <span class='kw'>fn</span> <span class='ident'>panic_fmt</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> { <span class='kw'>loop</span> {} }
</pre>

<p>The compiler currently makes a few assumptions about symbols which are available
in the executable to call. Normally these functions are provided by the standard
library, but without it you must define your own.</p>

<p>The first of these three functions, <code>stack_exhausted</code>, is invoked whenever stack
overflow is detected.  This function has a number of restrictions about how it
can be called and what it must do, but if the stack limit register is not being
maintained then a thread always has an &quot;infinite stack&quot; and this function
shouldn&#39;t get triggered.</p>

<p>The second of these three functions, <code>eh_personality</code>, is used by the
failure mechanisms of the compiler. This is often mapped to GCC&#39;s
personality function (see the
<a href="../std/rt/unwind/index.html">libstd implementation</a> for more
information), but crates which do not trigger a panic can be assured
that this function is never called. The final function, <code>panic_fmt</code>, is
also used by the failure mechanisms of the compiler.</p>

<h2 id="using-libcore" class='section-header'><a
                           href="#using-libcore">Using libcore</a></h2>
<blockquote>
<p><strong>Note</strong>: the core library&#39;s structure is unstable, and it is recommended to
use the standard library instead wherever possible.</p>
</blockquote>

<p>With the above techniques, we&#39;ve got a bare-metal executable running some Rust
code. There is a good deal of functionality provided by the standard library,
however, that is necessary to be productive in Rust. If the standard library is
not sufficient, then <a href="../core/index.html">libcore</a> is designed to be used
instead.</p>

<p>The core library has very few dependencies and is much more portable than the
standard library itself. Additionally, the core library has most of the
necessary functionality for writing idiomatic and effective Rust code.</p>

<p>As an example, here is a program that will calculate the dot product of two
vectors provided from C, using idiomatic Rust practices.</p>
<span class='rusttest'>#![feature(lang_items, start, no_std, core, libc)]
#![no_std]

extern crate libc;
extern crate core;

use core::prelude::*;

use core::mem;

#[no_mangle]
pub extern fn dot_product(a: *const u32, a_len: u32,
                          b: *const u32, b_len: u32) -&gt; u32 {
    use core::raw::Slice;

    // Convert the provided arrays into Rust slices.
    // The core::raw module guarantees that the Slice
    // structure has the same memory layout as a &amp;[T]
    // slice.
    //
    // This is an unsafe operation because the compiler
    // cannot tell the pointers are valid.
    let (a_slice, b_slice): (&amp;[u32], &amp;[u32]) = unsafe {
        mem::transmute((
            Slice { data: a, len: a_len as usize },
            Slice { data: b, len: b_len as usize },
        ))
    };

    // Iterate over the slices, collecting the result
    let mut ret = 0;
    for (i, j) in a_slice.iter().zip(b_slice.iter()) {
        ret += (*i) * (*j);
    }
    return ret;
}

#[lang = &quot;panic_fmt&quot;]
extern fn panic_fmt(args: &amp;core::fmt::Arguments,
                    file: &amp;str,
                    line: u32) -&gt; ! {
    loop {}
}

#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[start] fn start(argc: isize, argv: *const *const u8) -&gt; isize { 0 }
fn main() {}
</span><pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>lang_items</span>, <span class='ident'>start</span>, <span class='ident'>no_std</span>, <span class='ident'>core</span>, <span class='ident'>libc</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span>

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>core</span>;

<span class='kw'>use</span> <span class='ident'>core</span>::<span class='ident'>prelude</span>::<span class='op'>*</span>;

<span class='kw'>use</span> <span class='ident'>core</span>::<span class='ident'>mem</span>;

<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>dot_product</span>(<span class='ident'>a</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span>, <span class='ident'>a_len</span>: <span class='ident'>u32</span>,
                          <span class='ident'>b</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span>, <span class='ident'>b_len</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='kw'>use</span> <span class='ident'>core</span>::<span class='ident'>raw</span>::<span class='ident'>Slice</span>;

    <span class='comment'>// Convert the provided arrays into Rust slices.</span>
    <span class='comment'>// The core::raw module guarantees that the Slice</span>
    <span class='comment'>// structure has the same memory layout as a &amp;[T]</span>
    <span class='comment'>// slice.</span>
    <span class='comment'>//</span>
    <span class='comment'>// This is an unsafe operation because the compiler</span>
    <span class='comment'>// cannot tell the pointers are valid.</span>
    <span class='kw'>let</span> (<span class='ident'>a_slice</span>, <span class='ident'>b_slice</span>): (<span class='kw-2'>&amp;</span>[<span class='ident'>u32</span>], <span class='kw-2'>&amp;</span>[<span class='ident'>u32</span>]) <span class='op'>=</span> <span class='kw'>unsafe</span> {
        <span class='ident'>mem</span>::<span class='ident'>transmute</span>((
            <span class='ident'>Slice</span> { <span class='ident'>data</span>: <span class='ident'>a</span>, <span class='ident'>len</span>: <span class='ident'>a_len</span> <span class='kw'>as</span> <span class='ident'>usize</span> },
            <span class='ident'>Slice</span> { <span class='ident'>data</span>: <span class='ident'>b</span>, <span class='ident'>len</span>: <span class='ident'>b_len</span> <span class='kw'>as</span> <span class='ident'>usize</span> },
        ))
    };

    <span class='comment'>// Iterate over the slices, collecting the result</span>
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>ret</span> <span class='op'>=</span> <span class='number'>0</span>;
    <span class='kw'>for</span> (<span class='ident'>i</span>, <span class='ident'>j</span>) <span class='kw'>in</span> <span class='ident'>a_slice</span>.<span class='ident'>iter</span>().<span class='ident'>zip</span>(<span class='ident'>b_slice</span>.<span class='ident'>iter</span>()) {
        <span class='ident'>ret</span> <span class='op'>+=</span> (<span class='op'>*</span><span class='ident'>i</span>) <span class='op'>*</span> (<span class='op'>*</span><span class='ident'>j</span>);
    }
    <span class='kw'>return</span> <span class='ident'>ret</span>;
}

<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;panic_fmt&quot;</span>]</span>
<span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>panic_fmt</span>(<span class='ident'>args</span>: <span class='kw-2'>&amp;</span><span class='ident'>core</span>::<span class='ident'>fmt</span>::<span class='ident'>Arguments</span>,
                    <span class='ident'>file</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>,
                    <span class='ident'>line</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='op'>!</span> {
    <span class='kw'>loop</span> {}
}

<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;stack_exhausted&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>stack_exhausted</span>() {}
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;eh_personality&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>eh_personality</span>() {}
</pre>

<p>Note that there is one extra lang item here which differs from the examples
above, <code>panic_fmt</code>. This must be defined by consumers of libcore because the
core library declares panics, but it does not define it. The <code>panic_fmt</code>
lang item is this crate&#39;s definition of panic, and it must be guaranteed to
never return.</p>

<p>As can be seen in this example, the core library is intended to provide the
power of Rust in all circumstances, regardless of platform requirements. Further
libraries, such as liballoc, add functionality to libcore which make other
platform-specific assumptions, but continue to be more portable than the
standard library itself.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>