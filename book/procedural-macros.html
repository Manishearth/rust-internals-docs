<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Procedural Macros (and custom Derive)</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Guessing Game</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Syntax and Semantics</a>
<ol class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Loops</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vectors</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Method Syntax</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ol>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ol class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Error Handling</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Choosing your Guarantees</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Release Channels</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Using Rust without the standard library</a>
</li>
<li><a class='active' href='procedural-macros.html'><b>5.13.</b> Procedural Macros (and custom derive)</a>
</li>
</ol>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ol class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Advanced linking</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Custom Allocators</a>
</li>
</ol>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Syntax Index</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> Bibliography</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Procedural Macros (and custom Derive)</h1>
    <p>As you&#39;ve seen throughout the rest of the book, Rust provides a mechanism
called &quot;derive&quot; that lets you implement traits easily. For example,</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Bderive(Debug)%5D%0Astruct%20Point%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%20%20%20%20y%3A%20i32%2C%0A%7D%0A%7D">Run</a></pre>

<p>is a lot simpler than</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>;

<span class='kw'>impl</span> <span class='ident'>fmt</span>::<span class='ident'>Debug</span> <span class='kw'>for</span> <span class='ident'>Point</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>, <span class='string'>&quot;Point {{ x: {}, y: {} }}&quot;</span>, <span class='self'>self</span>.<span class='ident'>x</span>, <span class='self'>self</span>.<span class='ident'>y</span>)
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Point%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%20%20%20%20y%3A%20i32%2C%0A%7D%0A%0Ause%20std%3A%3Afmt%3B%0A%0Aimpl%20fmt%3A%3ADebug%20for%20Point%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20fmt%3A%3AFormatter)%20-%3E%20fmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20write!(f%2C%20%22Point%20%7B%7B%20x%3A%20%7B%7D%2C%20y%3A%20%7B%7D%20%7D%7D%22%2C%20self.x%2C%20self.y)%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Rust includes several traits that you can derive, but it also lets you define
your own. We can accomplish this task through a feature of Rust called
&quot;procedural macros.&quot; Eventually, procedural macros will allow for all sorts of
advanced metaprogramming in Rust, but today, they&#39;re only for custom derive.</p>

<p>Let&#39;s build a very simple trait, and derive it with custom derive.</p>

<h2 id='hello-world' class='section-header'><a href='#hello-world'>Hello World</a></h2>
<p>So the first thing we need to do is start a new crate for our project.</p>

<pre><code class="language-bash">$ cargo new --bin hello-world
</code></pre>

<p>All we want is to be able to call <code>hello_world()</code> on a derived type. Something
like this:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>HelloWorld</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Pancakes</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>Pancakes</span>::<span class='ident'>hello_world</span>();
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23%5Bderive(HelloWorld)%5D%0Astruct%20Pancakes%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20Pancakes%3A%3Ahello_world()%3B%0A%7D%0A">Run</a></pre>

<p>With some kind of nice output, like <code>Hello, World! My name is Pancakes.</code>. </p>

<p>Let&#39;s go ahead and write up what we think our macro will look like from a user
perspective. In <code>src/main.rs</code> we write:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>hello_world_derive</span>;

<span class='kw'>trait</span> <span class='ident'>HelloWorld</span> {
    <span class='kw'>fn</span> <span class='ident'>hello_world</span>();
}

<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>HelloWorld</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>FrenchToast</span>;

<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>HelloWorld</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Waffles</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>FrenchToast</span>::<span class='ident'>hello_world</span>();
    <span class='ident'>Waffles</span>::<span class='ident'>hello_world</span>();
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23%5Bmacro_use%5D%0Aextern%20crate%20hello_world_derive%3B%0A%0Atrait%20HelloWorld%20%7B%0A%20%20%20%20fn%20hello_world()%3B%0A%7D%0A%0A%23%5Bderive(HelloWorld)%5D%0Astruct%20FrenchToast%3B%0A%0A%23%5Bderive(HelloWorld)%5D%0Astruct%20Waffles%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20FrenchToast%3A%3Ahello_world()%3B%0A%20%20%20%20Waffles%3A%3Ahello_world()%3B%0A%7D%0A">Run</a></pre>

<p>Great. So now we just need to actually write the procedural macro. At the
moment, procedural macros need to be in their own crate. Eventually, this
restriction may be lifted, but for now, it&#39;s required. As such, there&#39;s a
convention; for a crate named <code>foo</code>, a custom derive procedural macro is called
<code>foo-derive</code>. Let&#39;s start a new crate called <code>hello-world-derive</code> inside our
<code>hello-world</code> project.</p>

<pre><code class="language-bash">$ cargo new hello-world-derive
</code></pre>

<p>To make sure that our <code>hello-world</code> crate is able to find this new crate we&#39;ve
created, we&#39;ll add it to our toml:</p>

<pre><code class="language-toml">[dependencies]
hello-world-derive = { path = &quot;hello-world-derive&quot; }
</code></pre>

<p>As for our the source of our <code>hello-world-derive</code> crate, here&#39;s an example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>proc_macro</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>syn</span>;
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>quote</span>;

<span class='kw'>use</span> <span class='ident'>proc_macro</span>::<span class='ident'>TokenStream</span>;

<span class='attribute'>#[<span class='ident'>proc_macro_derive</span>(<span class='ident'>HelloWorld</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>hello_world</span>(<span class='ident'>input</span>: <span class='ident'>TokenStream</span>) <span class='op'>-&gt;</span> <span class='ident'>TokenStream</span> {
    <span class='comment'>// Construct a string representation of the type definition</span>
    <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>input</span>.<span class='ident'>to_string</span>();
    
    <span class='comment'>// Parse the string representation</span>
    <span class='kw'>let</span> <span class='ident'>ast</span> <span class='op'>=</span> <span class='ident'>syn</span>::<span class='ident'>parse_macro_input</span>(<span class='kw-2'>&amp;</span><span class='ident'>s</span>).<span class='ident'>unwrap</span>();

    <span class='comment'>// Build the impl</span>
    <span class='kw'>let</span> <span class='ident'>gen</span> <span class='op'>=</span> <span class='ident'>impl_hello_world</span>(<span class='kw-2'>&amp;</span><span class='ident'>ast</span>);
    
    <span class='comment'>// Return the generated impl</span>
    <span class='ident'>gen</span>.<span class='ident'>parse</span>().<span class='ident'>unwrap</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aextern%20crate%20proc_macro%3B%0Aextern%20crate%20syn%3B%0A%23%5Bmacro_use%5D%0Aextern%20crate%20quote%3B%0A%0Ause%20proc_macro%3A%3ATokenStream%3B%0A%0A%23%5Bproc_macro_derive(HelloWorld)%5D%0Apub%20fn%20hello_world(input%3A%20TokenStream)%20-%3E%20TokenStream%20%7B%0A%20%20%20%20%2F%2F%20Construct%20a%20string%20representation%20of%20the%20type%20definition%0A%20%20%20%20let%20s%20%3D%20input.to_string()%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Parse%20the%20string%20representation%0A%20%20%20%20let%20ast%20%3D%20syn%3A%3Aparse_macro_input(%26s).unwrap()%3B%0A%0A%20%20%20%20%2F%2F%20Build%20the%20impl%0A%20%20%20%20let%20gen%20%3D%20impl_hello_world(%26ast)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Return%20the%20generated%20impl%0A%20%20%20%20gen.parse().unwrap()%0A%7D%0A%7D">Run</a></pre>

<p>So there is a lot going on here. We have introduced two new crates: <a href="https://crates.io/crates/syn"><code>syn</code></a> and
<a href="https://crates.io/crates/quote"><code>quote</code></a>. As you may have noticed, <code>input: TokenSteam</code> is immediately converted
to a <code>String</code>. This <code>String</code> is a string representation of the Rust code for which
we are deriving <code>HelloWorld</code> for. At the moment, the only thing you can do with a
<code>TokenStream</code> is convert it to a string. A richer API will exist in the future.</p>

<p>So what we really need is to be able to <em>parse</em> Rust code into something
usable. This is where <code>syn</code> comes to play. <code>syn</code> is a crate for parsing Rust
code. The other crate we&#39;ve introduced is <code>quote</code>. It&#39;s essentially the dual of
<code>syn</code> as it will make generating Rust code really easy. We could write this
stuff on our own, but it&#39;s much simpler to use these libraries. Writing a full
parser for Rust code is no simple task.</p>

<p>The comments seem to give us a pretty good idea of our overall strategy. We
are going to take a <code>String</code> of the Rust code for the type we are deriving, parse
it using <code>syn</code>, construct the implementation of <code>hello_world</code> (using <code>quote</code>),
then pass it back to Rust compiler.</p>

<p>One last note: you&#39;ll see some <code>unwrap()</code>s there. If you want to provide an
error for a procedural macro, then you should <code>panic!</code> with the error message.
In this case, we&#39;re keeping it as simple as possible.</p>

<p>Great, so let&#39;s write <code>impl_hello_world(&amp;ast)</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>impl_hello_world</span>(<span class='ident'>ast</span>: <span class='kw-2'>&amp;</span><span class='ident'>syn</span>::<span class='ident'>MacroInput</span>) <span class='op'>-&gt;</span> <span class='ident'>quote</span>::<span class='ident'>Tokens</span> {
    <span class='kw'>let</span> <span class='ident'>name</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>ast</span>.<span class='ident'>ident</span>;
    <span class='macro'>quote</span><span class='macro'>!</span> {
        <span class='kw'>impl</span> <span class='ident'>HelloWorld</span> <span class='kw'>for</span> <span class='attribute'>#<span class='ident'>name</span> {
            <span class='kw'>fn</span> <span class='ident'>hello_world</span>() {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, World! My name is {}&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='attribute'>#<span class='ident'>name</span>));
            }
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20impl_hello_world(ast%3A%20%26syn%3A%3AMacroInput)%20-%3E%20quote%3A%3ATokens%20%7B%0A%20%20%20%20let%20name%20%3D%20%26ast.ident%3B%0A%20%20%20%20quote!%20%7B%0A%20%20%20%20%20%20%20%20impl%20HelloWorld%20for%20%23name%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20fn%20hello_world()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22Hello%2C%20World!%20My%20name%20is%20%7B%7D%22%2C%20stringify!(%23name))%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>So this is where quotes comes in. The <code>ast</code> argument is a struct that gives us
a representation of our type (which can be either a <code>struct</code> or an <code>enum</code>).
Check out the <a href="https://docs.rs/syn/0.10.5/syn/struct.MacroInput.html">docs</a>,
there is some useful information there. We are able to get the name of the
type using <code>ast.ident</code>. The <code>quote!</code> macro let&#39;s us write up the Rust code
that we wish to return and convert it into <code>Tokens</code>. <code>quote!</code> let&#39;s us use some
really cool templating mechanics; we simply write <code>#name</code> and <code>quote!</code> will
replace it with the variable named <code>name</code>. You can even do some repetition
similar to regular macros work. You should check out the
<a href="https://docs.rs/quote">docs</a> for a good introduction.</p>

<p>So I think that&#39;s it. Oh, well, we do need to add dependencies for <code>syn</code> and
<code>quote</code> in the <code>cargo.toml</code> for <code>hello-world-derive</code>.</p>

<pre><code class="language-toml">[dependencies]
syn = &quot;0.10.5&quot;
quote = &quot;0.3.10&quot;
</code></pre>

<p>That should be it. Let&#39;s try to compile <code>hello-world</code>.</p>

<pre><code class="language-bash">error: the `#[proc_macro_derive]` attribute is only usable with crates of the `proc-macro` crate type
 --&gt; hello-world-derive/src/lib.rs:8:3
  |
8 | #[proc_macro_derive(HelloWorld)]
  |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>

<p>Oh, so it appears that we need to declare that our <code>hello-world-derive</code> crate is
a <code>proc-macro</code> crate type. How do we do this? Like this:</p>

<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>

<p>Ok so now, let&#39;s compile <code>hello-world</code>. Executing <code>cargo run</code> now yields:</p>

<pre><code class="language-bash">Hello, World! My name is FrenchToast
Hello, World! My name is Waffles
</code></pre>

<p>We&#39;ve done it!</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>