<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>`Box&lt;T&gt;` Points to Data on the Heap and Has a Known Size - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> Common Programming Concepts</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> Understanding Ownership</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> Slices</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> Structs</a></li><li><ul class="section"><li><a href="ch05-01-method-syntax.html"><strong>5.1.</strong> Method Syntax</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> Enums and Pattern Matching</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> The <code>match</code> Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> Concise Control Flow with <code>if let</code></a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> Modules</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code> and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> Controlling Visibility with <code>pub</code></a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> Importing Names with <code>use</code></a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> Common Collections</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> Hash Maps</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> Error Handling</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> Unrecoverable Errors with <code>panic!</code></a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong>9.2.</strong> Recoverable Errors with <code>Result</code></a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> To <code>panic!</code> or Not To <code>panic!</code></a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> Validating References with Lifetimes</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> Testing</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> Test Organization</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> An I/O Project</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> Writing to <code>stderr</code> instead of <code>stdout</code></a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Functional Language Features in Rust</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> Performance</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> More about Cargo and Crates.io</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> Installing Binaries from Crates.io with <code>cargo install</code></a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Extending Cargo with Custom Commands</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="ch15-01-box.html" class="active"><strong>15.1.</strong> <code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> The <code>Deref</code> Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> The <code>Drop</code> Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> Fearless Concurrency</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> Extensible Concurrency: <code>Sync</code> and <code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> Is Rust OOP?</a></li><li><a href="ch18-00-patterns.html"><strong>18.</strong> Patterns</a></li><li><a href="ch19-00-advanced-features.html"><strong>19.</strong> Advanced Features</a></li><li><ul class="section"><li><a href="ch19-01-unsafe-rust.html"><strong>19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong>19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong>19.3.</strong> Advanced Traits</a></li></ul></li><li><a href="ch20-00-unnamed-project.html"><strong>20.</strong> Un-named project</a></li><li><a href="appendix-00.html"><strong>21.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong>21.2.</strong> B - Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong>21.3.</strong> C - Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong>21.4.</strong> D - Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong>21.5.</strong> E - Macros</a></li><li><a href="appendix-06-translation.html"><strong>21.6.</strong> F - Translations</a></li><li><a href="appendix-07-newest-features.html"><strong>21.7.</strong> G - Newest Features</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="ch15-01-box.html#boxt-points-to-data-on-the-heap-and-has-a-known-size" name="boxt-points-to-data-on-the-heap-and-has-a-known-size"><h2><code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</h2></a>
<p>The most straightforward smart pointer is a <em>box</em>, whose type is written
<code>Box&lt;T&gt;</code>. Boxes allow you to put a single value on the heap (we talked about
the stack vs. the heap in Chapter 4). Listing 15-1 shows how to use a box to
store an <code>i32</code> on the heap:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Listing 15-1: Storing an <code>i32</code> value on the heap using a
box</span></p>
<p>This will print <code>b = 5</code>. In this case, we can access the data in the box in a
similar way as we would if this data was on the stack. Just like any value that
has ownership of data, when a box goes out of scope like <code>b</code> does at the end of
<code>main</code>, it will be deallocated. The deallocation happens for both the box
(stored on the stack) and the data it points to (stored on the heap).</p>
<p>Putting a single value on the heap isn't very useful, so you won't use boxes by
themselves in the way that Listing 15-1 does very often. A time when boxes are
useful is when you want to ensure that your type has a known size. For example,
consider Listing 15-2, which contains an enum definition for a <em>cons list</em>, a
type of data structure that comes from functional programming. Note that this
won't compile quite yet:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<p><span class="caption">Listing 15-2: The first attempt of defining an enum to
represent a cons list data structure of <code>i32</code> values</span></p>
<p>We're implementing a cons list that holds only <code>i32</code> values. We
could have also chosen to implement a cons list independent of the
type of value by using generics as discussed in Chapter 10.</p>
<blockquote>
<a class="header" href="ch15-01-box.html#more-information-about-the-cons-list" name="more-information-about-the-cons-list"><h4>More Information About the Cons List</h4></a>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming
language and its dialects. In Lisp, the <code>cons</code> function (short for &quot;construct
function&quot;) constructs a new list from its two arguments, which usually are a
single value and another list.</p>
<p>The cons function concept has made its way into more general functional
programming jargon; &quot;to cons x onto y&quot; informally means to construct a new
container instance by putting the element x at the start of this new
container, followed by the container y.</p>
<p>A cons list is produced by recursively calling the <code>cons</code> function.
The canonical name to denote the base case of the recursion is <code>Nil</code>, which
announces the end of the list. Note that this is not the same as the &quot;null&quot;
or &quot;nil&quot; concept from Chapter 6, which is an invalid or absent value.</p>
</blockquote>
<p>A cons list is a list where each element contains both a single value as well
as the remains of the list at that point. The remains of the list are defined
by nested cons lists. The end of the list is signified by the value <code>Nil</code>. Cons
lists aren't used very often in Rust; <code>Vec&lt;T&gt;</code> is usually a better choice.
Implementing this data structure is a good example of a situation where
<code>Box&lt;T&gt;</code> is useful, though. Let's find out why!</p>
<p>Using a cons list to store the list <code>1, 2, 3</code> would look like this:</p>
<pre><code class="language-rust ignore">use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p>The first <code>Cons</code> value holds <code>1</code> and another <code>List</code> value. This <code>List</code>
value is another <code>Cons</code> value that holds <code>2</code> and another <code>List</code> value. This
is one more <code>Cons</code> value that holds <code>3</code> and a <code>List</code> value, which is finally
<code>Nil</code>, the non-recursive variant that signals the end of the list.</p>
<p>If we try to compile the above code, we get the error shown in Listing 15-3:</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
 --&gt;
  |
1 |   enum List {
  |  _^ starting here...
2 | |     Cons(i32, List),
3 | |     Nil,
4 | | }
  | |_^ ...ending here: recursive type has infinite size
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p><span class="caption">Listing 15-3: The error we get when attempting to define
a recursive enum</span></p>
<p>The error says this type 'has infinite size'. Why is that? It's because we've
defined <code>List</code> to have a variant that is recursive: it holds another value of
itself. This means Rust can't figure out how much space it needs in order to
store a <code>List</code> value. Let's break this down a bit: first let's look at how Rust
decides how much space it needs to store a value of a non-recursive type.
Recall the <code>Message</code> enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

#}</code></pre></pre>
<p>When Rust needs to know how much space to allocate for a <code>Message</code> value, it
can go through each of the variants and see that <code>Message::Quit</code> does not need
any space, <code>Message::Move</code> needs enough space to store two <code>i32</code> values, and so
forth. Therefore, the most space a <code>Message</code> value will need is the space it
would take to store the largest of its variants.</p>
<p>Contrast this to what happens when the Rust compiler looks at a recursive type
like <code>List</code> in Listing 15-2. The compiler tries to figure out how much memory
is needed to store a value of the <code>List</code> enum, and starts by looking at the <code>Cons</code>
variant. The <code>Cons</code> variant holds a value of type <code>i32</code> and a value of type
<code>List</code>, so <code>Cons</code> needs an amount of space equal to the size of an <code>i32</code> plus
the size of a <code>List</code>. To figure out how much memory a <code>List</code> needs, it looks at
its variants, starting with the <code>Cons</code> variant. The <code>Cons</code> variant holds a
value of type <code>i32</code> and a value of type <code>List</code>, and this continues infinitely,
as shown in Figure 15-4.</p>
<p><img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 15-4: An infinite <code>List</code> consisting of infinite
<code>Cons</code> variants</span></p>
<p>Rust can't figure out how much space to allocate for recursively defined types,
so the compiler gives the error in Listing 15-3. The error did include this
helpful suggestion:</p>
<pre><code class="language-text">= help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
        make `List` representable
</code></pre>
<p>Because a <code>Box&lt;T&gt;</code> is a pointer, we always know how much space it needs: a
pointer takes up a <code>usize</code> amount of space. The value of the <code>usize</code> will be
the address of the heap data. The heap data can be any size, but the address to
the start of that heap data will always fit in a <code>usize</code>. So if we change our
definition from Listing 15-2 to look like the definition here in Listing 15-5,
and change <code>main</code> to use <code>Box::new</code> for the values inside the <code>Cons</code> variants
like so:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">Listing 15-5: Definition of <code>List</code> that uses <code>Box&lt;T&gt;</code> in
order to have a known size</span></p>
<p>The compiler will be able to figure out the size it needs to store a <code>List</code>
value. Rust will look at <code>List</code>, and again start by looking at the <code>Cons</code>
variant. The <code>Cons</code> variant will need the size of <code>i32</code> plus the space to store
a <code>usize</code>, since a box always has the size of a <code>usize</code>, no matter what it's
pointing to. Then Rust looks at the <code>Nil</code> variant, which does not store a
value, so <code>Nil</code> doesn't need any space. We've broken the infinite, recursive
chain by adding in a box. Figure 15-6 shows what the <code>Cons</code> variant looks like
now:</p>
<p><img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" /></p>
<p><span class="caption">Figure 15-6: A <code>List</code> that is not infinitely sized since
<code>Cons</code> holds a <code>Box</code></span></p>
<p>This is the main area where boxes are useful: breaking up an infinite data
structure so that the compiler can know what size it is. We'll look at another
case where Rust has data of unknown size in Chapter 17 when we discuss trait
objects.</p>
<p>Even though you won't be using boxes very often, they are a good way to
understand the smart pointer pattern. Two of the aspects of <code>Box&lt;T&gt;</code> that are
commonly used with smart pointers are its implementations of the <code>Deref</code> trait
and the <code>Drop</code> trait. Let's investigate how these traits work and how smart
pointers use them.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch15-00-smart-pointers.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch15-02-deref.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch15-00-smart-pointers.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch15-02-deref.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
