<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Inline Assembly - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="README.html">Introduction</a></li><li><a href="getting-started.html"><strong>1.</strong> Getting Started</a></li><li><a href="guessing-game.html"><strong>2.</strong> Tutorial: Guessing Game</a></li><li><a href="syntax-and-semantics.html"><strong>3.</strong> Syntax and Semantics</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>3.1.</strong> Variable Bindings</a></li><li><a href="functions.html"><strong>3.2.</strong> Functions</a></li><li><a href="primitive-types.html"><strong>3.3.</strong> Primitive Types</a></li><li><a href="comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="if.html"><strong>3.5.</strong> if</a></li><li><a href="loops.html"><strong>3.6.</strong> Loops</a></li><li><a href="vectors.html"><strong>3.7.</strong> Vectors</a></li><li><a href="ownership.html"><strong>3.8.</strong> Ownership</a></li><li><a href="references-and-borrowing.html"><strong>3.9.</strong> References and Borrowing</a></li><li><a href="lifetimes.html"><strong>3.10.</strong> Lifetimes</a></li><li><a href="mutability.html"><strong>3.11.</strong> Mutability</a></li><li><a href="structs.html"><strong>3.12.</strong> Structs</a></li><li><a href="enums.html"><strong>3.13.</strong> Enums</a></li><li><a href="match.html"><strong>3.14.</strong> Match</a></li><li><a href="patterns.html"><strong>3.15.</strong> Patterns</a></li><li><a href="method-syntax.html"><strong>3.16.</strong> Method Syntax</a></li><li><a href="strings.html"><strong>3.17.</strong> Strings</a></li><li><a href="generics.html"><strong>3.18.</strong> Generics</a></li><li><a href="traits.html"><strong>3.19.</strong> Traits</a></li><li><a href="drop.html"><strong>3.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>3.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>3.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>3.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>3.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>3.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>3.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>3.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>3.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>3.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>3.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>3.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>3.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>3.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>3.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>3.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>3.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>4.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>4.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>4.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>4.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>4.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>4.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>4.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>4.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>4.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>4.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>4.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>4.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>4.12.</strong> Using Rust without the standard library</a></li><li><a href="procedural-macros.html"><strong>4.13.</strong> Procedural Macros (and custom derive)</a></li></ul></li><li><a href="nightly-rust.html"><strong>5.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>5.1.</strong> Compiler Plugins</a></li><li><a href="inline-assembly.html" class="active"><strong>5.2.</strong> Inline Assembly</a></li><li><a href="no-stdlib.html"><strong>5.3.</strong> No stdlib</a></li><li><a href="intrinsics.html"><strong>5.4.</strong> Intrinsics</a></li><li><a href="lang-items.html"><strong>5.5.</strong> Lang items</a></li><li><a href="advanced-linking.html"><strong>5.6.</strong> Advanced linking</a></li><li><a href="benchmark-tests.html"><strong>5.7.</strong> Benchmark Tests</a></li><li><a href="box-syntax-and-patterns.html"><strong>5.8.</strong> Box Syntax and Patterns</a></li><li><a href="slice-patterns.html"><strong>5.9.</strong> Slice Patterns</a></li><li><a href="associated-constants.html"><strong>5.10.</strong> Associated Constants</a></li><li><a href="custom-allocators.html"><strong>5.11.</strong> Custom Allocators</a></li></ul></li><li><a href="glossary.html"><strong>6.</strong> Glossary</a></li><li><a href="syntax-index.html"><strong>7.</strong> Syntax Index</a></li><li><a href="bibliography.html"><strong>8.</strong> Bibliography</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="#inline-assembly" name="inline-assembly"><h1>Inline Assembly</h1></a>
<p>For extremely low-level manipulations and performance reasons, one
might wish to control the CPU directly. Rust supports using inline
assembly to do this via the <code>asm!</code> macro.</p>
<pre><code class="language-rust,ignore">asm!(assembly template
   : output operands
   : input operands
   : clobbers
   : options
   );
</code></pre>
<p>Any use of <code>asm</code> is feature gated (requires <code>#![feature(asm)]</code> on the
crate to allow) and of course requires an <code>unsafe</code> block.</p>
<blockquote>
<p><strong>Note</strong>: the examples here are given in x86/x86-64 assembly, but
all platforms are supported.</p>
</blockquote>
<a class="header" href="#assembly-template" name="assembly-template"><h2>Assembly template</h2></a>
<p>The <code>assembly template</code> is the only required parameter and must be a
literal string (i.e. <code>&quot;&quot;</code>)</p>
<pre><code class="language-rust">#![feature(asm)]

#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn foo() {
    unsafe {
        asm!(&quot;NOP&quot;);
    }
}

// Other platforms:
#[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
fn foo() { /* ... */ }

fn main() {
    // ...
    foo();
    // ...
}
</code></pre>
<p>(The <code>feature(asm)</code> and <code>#[cfg]</code>s are omitted from now on.)</p>
<p>Output operands, input operands, clobbers and options are all optional
but you must add the right number of <code>:</code> if you skip them:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot;
    :
    :
    : &quot;eax&quot;
   );
# } }
# #[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
# fn main() {}
</code></pre>
<p>Whitespace also doesn't matter:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot; ::: &quot;eax&quot;);
# } }
# #[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
# fn main() {}
</code></pre>
<a class="header" href="#operands" name="operands"><h2>Operands</h2></a>
<p>Input and output operands follow the same format: <code>: &quot;constraints1&quot;(expr1), &quot;constraints2&quot;(expr2), ...&quot;</code>. Output operand
expressions must be mutable lvalues, or not yet assigned:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn add(a: i32, b: i32) -&gt; i32 {
    let c: i32;
    unsafe {
        asm!(&quot;add $2, $0&quot;
             : &quot;=r&quot;(c)
             : &quot;0&quot;(a), &quot;r&quot;(b)
             );
    }
    c
}
# #[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
# fn add(a: i32, b: i32) -&gt; i32 { a + b }

fn main() {
    assert_eq!(add(3, 14159), 14162)
}
</code></pre>
<p>If you would like to use real operands in this position, however,
you are required to put curly braces <code>{}</code> around the register that
you want, and you are required to put the specific size of the
operand. This is useful for very low level programming, where
which register you use is important:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# unsafe fn read_byte_in(port: u16) -&gt; u8 {
let result: u8;
asm!(&quot;in %dx, %al&quot; : &quot;={al}&quot;(result) : &quot;{dx}&quot;(port));
result
# }
</code></pre>
<a class="header" href="#clobbers" name="clobbers"><h2>Clobbers</h2></a>
<p>Some instructions modify registers which might otherwise have held
different values so we use the clobbers list to indicate to the
compiler not to assume any values loaded into those registers will
stay valid.</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
// Put the value 0x200 in eax:
asm!(&quot;mov $$0x200, %eax&quot; : /* no outputs */ : /* no inputs */ : &quot;eax&quot;);
# } }
# #[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
# fn main() {}
</code></pre>
<p>Input and output registers need not be listed since that information
is already communicated by the given constraints. Otherwise, any other
registers used either implicitly or explicitly should be listed.</p>
<p>If the assembly changes the condition code register <code>cc</code> should be
specified as one of the clobbers. Similarly, if the assembly modifies
memory, <code>memory</code> should also be specified.</p>
<a class="header" href="#options" name="options"><h2>Options</h2></a>
<p>The last section, <code>options</code> is specific to Rust. The format is comma
separated literal strings (i.e. <code>:&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>). It's used to
specify some extra info about the inline assembly:</p>
<p>Current valid options are:</p>
<ol>
<li><em>volatile</em> - specifying this is analogous to
<code>__asm__ __volatile__ (...)</code> in gcc/clang.</li>
<li><em>alignstack</em> - certain instructions expect the stack to be
aligned a certain way (i.e. SSE) and specifying this indicates to
the compiler to insert its usual stack alignment code</li>
<li><em>intel</em> - use intel syntax instead of the default AT&amp;T.</li>
</ol>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() {
let result: i32;
unsafe {
   asm!(&quot;mov eax, 2&quot; : &quot;={eax}&quot;(result) : : : &quot;intel&quot;)
}
println!(&quot;eax is currently {}&quot;, result);
# }
# #[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
# fn main() {}
</code></pre>
<a class="header" href="#more-information" name="more-information"><h2>More Information</h2></a>
<p>The current implementation of the <code>asm!</code> macro is a direct binding to <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">LLVM's
inline assembler expressions</a>, so be sure to check out <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">their
documentation as well</a> for more information about clobbers,
constraints, etc.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="compiler-plugins.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="no-stdlib.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="compiler-plugins.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="no-stdlib.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
