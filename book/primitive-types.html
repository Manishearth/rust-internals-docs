<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Primitive Types</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Guessing Game</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Syntax and Semantics</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Functions</a>
</li>
<li><a class='active' href='primitive-types.html'><b>4.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Loops</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vectors</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Method Syntax</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Error Handling</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Choosing your Guarantees</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Release Channels</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Using Rust without the standard library</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Advanced linking</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Custom Allocators</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Syntax Index</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> Bibliography</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Primitive Types</h1>
    <p>The Rust language has a number of types that are considered ‘primitive’. This
means that they’re built-in to the language. Rust is structured in such a way
that the standard library also provides a number of useful types built on top
of these ones, as well, but these are the most primitive.</p>

<h1 id='booleans' class='section-header'><a href='#booleans'>Booleans</a></h1>
<p>Rust has a built-in boolean type, named <code>bool</code>. It has two values, <code>true</code> and <code>false</code>:</p>

<span class='rusttest'>fn main() {
    let x = true;

let y: bool = false;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='bool-val'>true</span>;

<span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>bool</span> <span class='op'>=</span> <span class='bool-val'>false</span>;</pre>

<p>A common use of booleans is in <a href="if.html"><code>if</code> conditionals</a>.</p>

<p>You can find more documentation for <code>bool</code>s <a href="../std/primitive.bool.html">in the standard library
documentation</a>.</p>

<h1 id='char' class='section-header'><a href='#char'><code>char</code></a></h1>
<p>The <code>char</code> type represents a single Unicode scalar value. You can create <code>char</code>s
with a single tick: (<code>&#39;</code>)</p>

<span class='rusttest'>fn main() {
    let x = &#39;x&#39;;
let two_hearts = &#39;💕&#39;;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&#39;x&#39;</span>;
<span class='kw'>let</span> <span class='ident'>two_hearts</span> <span class='op'>=</span> <span class='string'>&#39;💕&#39;</span>;</pre>

<p>Unlike some other languages, this means that Rust’s <code>char</code> is not a single byte,
but four.</p>

<p>You can find more documentation for <code>char</code>s <a href="../std/primitive.char.html">in the standard library
documentation</a>.</p>

<h1 id='numeric-types' class='section-header'><a href='#numeric-types'>Numeric types</a></h1>
<p>Rust has a variety of numeric types in a few categories: signed and unsigned,
fixed and variable, floating-point and integer.</p>

<p>These types consist of two parts: the category, and the size. For example,
<code>u16</code> is an unsigned type with sixteen bits of size. More bits lets you have
bigger numbers.</p>

<p>If a number literal has nothing to cause its type to be inferred, it defaults:</p>

<span class='rusttest'>fn main() {
    let x = 42; // x has type i32

let y = 1.0; // y has type f64
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>42</span>; <span class='comment'>// x has type i32</span>

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>1.0</span>; <span class='comment'>// y has type f64</span></pre>

<p>Here’s a list of the different numeric types, with links to their documentation
in the standard library:</p>

<ul>
<li><a href="../std/primitive.i8.html">i8</a></li>
<li><a href="../std/primitive.i16.html">i16</a></li>
<li><a href="../std/primitive.i32.html">i32</a></li>
<li><a href="../std/primitive.i64.html">i64</a></li>
<li><a href="../std/primitive.u8.html">u8</a></li>
<li><a href="../std/primitive.u16.html">u16</a></li>
<li><a href="../std/primitive.u32.html">u32</a></li>
<li><a href="../std/primitive.u64.html">u64</a></li>
<li><a href="../std/primitive.isize.html">isize</a></li>
<li><a href="../std/primitive.usize.html">usize</a></li>
<li><a href="../std/primitive.f32.html">f32</a></li>
<li><a href="../std/primitive.f64.html">f64</a></li>
</ul>

<p>Let’s go over them by category:</p>

<h2 id='signed-and-unsigned' class='section-header'><a href='#signed-and-unsigned'>Signed and Unsigned</a></h2>
<p>Integer types come in two varieties: signed and unsigned. To understand the
difference, let’s consider a number with four bits of size. A signed, four-bit
number would let you store numbers from <code>-8</code> to <code>+7</code>. Signed numbers use
“two’s complement representation”. An unsigned four bit number, since it does
not need to store negatives, can store values from <code>0</code> to <code>+15</code>.</p>

<p>Unsigned types use a <code>u</code> for their category, and signed types use <code>i</code>. The <code>i</code>
is for ‘integer’. So <code>u8</code> is an eight-bit unsigned number, and <code>i8</code> is an
eight-bit signed number.</p>

<h2 id='fixed-size-types' class='section-header'><a href='#fixed-size-types'>Fixed-size types</a></h2>
<p>Fixed-size types have a specific number of bits in their representation. Valid
bit sizes are <code>8</code>, <code>16</code>, <code>32</code>, and <code>64</code>. So, <code>u32</code> is an unsigned, 32-bit integer,
and <code>i64</code> is a signed, 64-bit integer.</p>

<h2 id='variable-size-types' class='section-header'><a href='#variable-size-types'>Variable-size types</a></h2>
<p>Rust also provides types whose particular size depends on the underlying machine
architecture. Their range is sufficient to express the size of any collection, so
these types have ‘size’ as the category. They come in signed and unsigned varieties
which account for two types: <code>isize</code> and <code>usize</code>.</p>

<h2 id='floating-point-types' class='section-header'><a href='#floating-point-types'>Floating-point types</a></h2>
<p>Rust also has two floating point types: <code>f32</code> and <code>f64</code>. These correspond to
IEEE-754 single and double precision numbers.</p>

<h1 id='arrays' class='section-header'><a href='#arrays'>Arrays</a></h1>
<p>Like many programming languages, Rust has list types to represent a sequence of
things. The most basic is the <em>array</em>, a fixed-size list of elements of the
same type. By default, arrays are immutable.</p>

<span class='rusttest'>fn main() {
    let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>]; <span class='comment'>// a: [i32; 3]</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>m</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>]; <span class='comment'>// m: [i32; 3]</span></pre>

<p>Arrays have type <code>[T; N]</code>. We’ll talk about this <code>T</code> notation <a href="generics.html">in the generics
section</a>. The <code>N</code> is a compile-time constant, for the length of the
array.</p>

<p>There’s a shorthand for initializing each element of an array to the same
value. In this example, each element of <code>a</code> will be initialized to <code>0</code>:</p>

<span class='rusttest'>fn main() {
    let a = [0; 20]; // a: [i32; 20]
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>0</span>; <span class='number'>20</span>]; <span class='comment'>// a: [i32; 20]</span></pre>

<p>You can get the number of elements in an array <code>a</code> with <code>a.len()</code>:</p>

<span class='rusttest'>fn main() {
    let a = [1, 2, 3];

println!(&quot;a has {} elements&quot;, a.len());
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;a has {} elements&quot;</span>, <span class='ident'>a</span>.<span class='ident'>len</span>());</pre>

<p>You can access a particular element of an array with <em>subscript notation</em>:</p>

<span class='rusttest'>fn main() {
    let names = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // names: [&amp;str; 3]

println!(&quot;The second name is: {}&quot;, names[1]);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>names</span> <span class='op'>=</span> [<span class='string'>&quot;Graydon&quot;</span>, <span class='string'>&quot;Brian&quot;</span>, <span class='string'>&quot;Niko&quot;</span>]; <span class='comment'>// names: [&amp;str; 3]</span>

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The second name is: {}&quot;</span>, <span class='ident'>names</span>[<span class='number'>1</span>]);</pre>

<p>Subscripts start at zero, like in most programming languages, so the first name
is <code>names[0]</code> and the second name is <code>names[1]</code>. The above example prints
<code>The second name is: Brian</code>. If you try to use a subscript that is not in the
array, you will get an error: array access is bounds-checked at run-time. Such
errant access is the source of many bugs in other systems programming
languages.</p>

<p>You can find more documentation for <code>array</code>s <a href="../std/primitive.array.html">in the standard library
documentation</a>.</p>

<h1 id='slices' class='section-header'><a href='#slices'>Slices</a></h1>
<p>A ‘slice’ is a reference to (or “view” into) another data structure. They are
useful for allowing safe, efficient access to a portion of an array without
copying. For example, you might want to reference only one line of a file read
into memory. By nature, a slice is not created directly, but from an existing
variable binding. Slices have a defined length, and can be mutable or immutable.</p>

<p>Internally, slices are represented as a pointer to the beginning of the data
and a length.</p>

<h2 id='slicing-syntax' class='section-header'><a href='#slicing-syntax'>Slicing syntax</a></h2>
<p>You can use a combo of <code>&amp;</code> and <code>[]</code> to create a slice from various things. The
<code>&amp;</code> indicates that slices are similar to <a href="references-and-borrowing.html">references</a>, which we will cover in
detail later in this section. The <code>[]</code>s, with a range, let you define the
length of the slice:</p>

<span class='rusttest'>fn main() {
    let a = [0, 1, 2, 3, 4];
let complete = &amp;a[..]; // A slice containing all of the elements in a
let middle = &amp;a[1..4]; // A slice of a: only the elements 1, 2, and 3
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>let</span> <span class='ident'>complete</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>a</span>[..]; <span class='comment'>// A slice containing all of the elements in a</span>
<span class='kw'>let</span> <span class='ident'>middle</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>a</span>[<span class='number'>1</span>..<span class='number'>4</span>]; <span class='comment'>// A slice of a: only the elements 1, 2, and 3</span></pre>

<p>Slices have type <code>&amp;[T]</code>. We’ll talk about that <code>T</code> when we cover
<a href="generics.html">generics</a>.</p>

<p>You can find more documentation for slices <a href="../std/primitive.slice.html">in the standard library
documentation</a>.</p>

<h1 id='str' class='section-header'><a href='#str'><code>str</code></a></h1>
<p>Rust’s <code>str</code> type is the most primitive string type. As an <a href="unsized-types.html">unsized type</a>,
it’s not very useful by itself, but becomes useful when placed behind a
reference, like <code>&amp;str</code>. We&#39;ll elaborate further when we cover
<a href="strings.html">Strings</a> and <a href="references-and-borrowing.html">references</a>.</p>

<p>You can find more documentation for <code>str</code> <a href="../std/primitive.str.html">in the standard library
documentation</a>.</p>

<h1 id='tuples' class='section-header'><a href='#tuples'>Tuples</a></h1>
<p>A tuple is an ordered list of fixed size. Like this:</p>

<span class='rusttest'>fn main() {
    let x = (1, &quot;hello&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;hello&quot;</span>);</pre>

<p>The parentheses and commas form this two-length tuple. Here’s the same code, but
with the type annotated:</p>

<span class='rusttest'>fn main() {
    let x: (i32, &amp;str) = (1, &quot;hello&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: (<span class='ident'>i32</span>, <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;hello&quot;</span>);</pre>

<p>As you can see, the type of a tuple looks like the tuple, but with each
position having a type name rather than the value. Careful readers will also
note that tuples are heterogeneous: we have an <code>i32</code> and a <code>&amp;str</code> in this tuple.
In systems programming languages, strings are a bit more complex than in other
languages. For now, read <code>&amp;str</code> as a <em>string slice</em>, and we’ll learn more
soon.</p>

<p>You can assign one tuple into another, if they have the same contained types
and <a href="glossary.html#arity">arity</a>. Tuples have the same arity when they have the same length.</p>

<span class='rusttest'>fn main() {
    let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>); <span class='comment'>// x: (i32, i32)</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>3</span>); <span class='comment'>// y: (i32, i32)</span>

<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>y</span>;</pre>

<p>You can access the fields in a tuple through a <em>destructuring let</em>. Here’s
an example:</p>

<span class='rusttest'>fn main() {
    let (x, y, z) = (1, 2, 3);

println!(&quot;x is {}&quot;, x);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>, <span class='ident'>z</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is {}&quot;</span>, <span class='ident'>x</span>);</pre>

<p>Remember <a href="variable-bindings.html">before</a> when I said the left-hand side of a <code>let</code> statement was more
powerful than assigning a binding? Here we are. We can put a pattern on
the left-hand side of the <code>let</code>, and if it matches up to the right-hand side,
we can assign multiple bindings at once. In this case, <code>let</code> “destructures”
or “breaks up” the tuple, and assigns the bits to three bindings.</p>

<p>This pattern is very powerful, and we’ll see it repeated more later.</p>

<p>You can disambiguate a single-element tuple from a value in parentheses with a
comma:</p>

<span class='rusttest'>fn main() {
    (0,); // single-element tuple
(0); // zero in parentheses
}</span><pre class='rust rust-example-rendered'>
(<span class='number'>0</span>,); <span class='comment'>// single-element tuple</span>
(<span class='number'>0</span>); <span class='comment'>// zero in parentheses</span></pre>

<h2 id='tuple-indexing' class='section-header'><a href='#tuple-indexing'>Tuple Indexing</a></h2>
<p>You can also access fields of a tuple with indexing syntax:</p>

<span class='rusttest'>fn main() {
    let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!(&quot;x is {}&quot;, x);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>tuple</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>tuple</span>.<span class='number'>0</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>tuple</span>.<span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='ident'>tuple</span>.<span class='number'>2</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is {}&quot;</span>, <span class='ident'>x</span>);</pre>

<p>Like array indexing, it starts at zero, but unlike array indexing, it uses a
<code>.</code>, rather than <code>[]</code>s.</p>

<p>You can find more documentation for tuples <a href="../std/primitive.tuple.html">in the standard library
documentation</a>.</p>

<h1 id='functions' class='section-header'><a href='#functions'>Functions</a></h1>
<p>Functions also have a type! They look like this:</p>

<span class='rusttest'>fn main() {
    fn foo(x: i32) -&gt; i32 { x }

let x: fn(i32) -&gt; i32 = foo;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> }

<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw'>fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>foo</span>;</pre>

<p>In this case, <code>x</code> is a ‘function pointer’ to a function that takes an <code>i32</code> and
returns an <code>i32</code>.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>