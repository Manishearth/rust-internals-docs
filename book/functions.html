<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Functions</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='./README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Installing Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Learn Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> Guessing Game</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> Dining Philosophers</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust Inside Other Languages</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Error Handling</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Release Channels</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Syntax and Semantics</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Variable Bindings</a>
</li>
<li><a class='active' href='functions.html'><b>5.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='for-loops.html'><b>5.6.</b> for loops</a>
</li>
<li><a  href='while-loops.html'><b>5.7.</b> while loops</a>
</li>
<li><a  href='ownership.html'><b>5.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>5.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>5.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>5.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>5.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>5.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>5.16.</b> Method Syntax</a>
</li>
<li><a  href='vectors.html'><b>5.17.</b> Vectors</a>
</li>
<li><a  href='strings.html'><b>5.18.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>5.19.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>5.20.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.21.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.22.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.23.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>5.24.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.25.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.26.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>5.27.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>5.28.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>5.29.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>5.30.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>5.31.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>5.32.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.33.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>5.34.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>5.35.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.36.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>5.37.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Link args</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Academic Research</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Functions</h1>
    <p>Every Rust program has at least one function, the <code>main</code> function:</p>
<span class='rusttest'>fn main() {
}
</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
}
</pre>

<p>This is the simplest possible function declaration. As we mentioned before,
<code>fn</code> says ‘this is a function’, followed by the name, some parentheses because
this function takes no arguments, and then some curly braces to indicate the
body. Here’s a function named <code>foo</code>:</p>
<span class='rusttest'>fn main() {
    fn foo() {
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {
}
</pre>

<p>So, what about taking arguments? Here’s a function that prints a number:</p>
<span class='rusttest'>fn main() {
    fn print_number(x: i32) {
        println!(&quot;x is: {}&quot;, x);
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>print_number</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is: {}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>Here’s a complete program that uses <code>print_number</code>:</p>
<span class='rusttest'>fn main() {
    print_number(5);
}

fn print_number(x: i32) {
    println!(&quot;x is: {}&quot;, x);
}
</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>print_number</span>(<span class='number'>5</span>);
}

<span class='kw'>fn</span> <span class='ident'>print_number</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is: {}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>As you can see, function arguments work very similar to <code>let</code> declarations:
you add a type to the argument name, after a colon.</p>

<p>Here’s a complete program that adds two numbers together and prints them:</p>
<span class='rusttest'>fn main() {
    print_sum(5, 6);
}

fn print_sum(x: i32, y: i32) {
    println!(&quot;sum is: {}&quot;, x + y);
}
</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>print_sum</span>(<span class='number'>5</span>, <span class='number'>6</span>);
}

<span class='kw'>fn</span> <span class='ident'>print_sum</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>y</span>: <span class='ident'>i32</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;sum is: {}&quot;</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>);
}
</pre>

<p>You separate arguments with a comma, both when you call the function, as well
as when you declare it.</p>

<p>Unlike <code>let</code>, you <em>must</em> declare the types of function arguments. This does
not work:</p>
<span class='rusttest'>fn main() {
    fn print_sum(x, y) {
        println!(&quot;sum is: {}&quot;, x + y);
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>print_sum</span>(<span class='ident'>x</span>, <span class='ident'>y</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;sum is: {}&quot;</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>);
}
</pre>

<p>You get this error:</p>

<pre><code class="language-text">expected one of `!`, `:`, or `@`, found `)`
fn print_number(x, y) {
</code></pre>

<p>This is a deliberate design decision. While full-program inference is possible,
languages which have it, like Haskell, often suggest that documenting your
types explicitly is a best-practice. We agree that forcing functions to declare
types while allowing for inference inside of function bodies is a wonderful
sweet spot between full inference and no inference.</p>

<p>What about returning a value? Here’s a function that adds one to an integer:</p>
<span class='rusttest'>fn main() {
    fn add_one(x: i32) -&gt; i32 {
        x + 1
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}
</pre>

<p>Rust functions return exactly one value, and you declare the type after an
‘arrow’, which is a dash (<code>-</code>) followed by a greater-than sign (<code>&gt;</code>). The last
line of a function determines what it returns. You’ll note the lack of a
semicolon here. If we added it in:</p>
<span class='rusttest'>fn main() {
    fn add_one(x: i32) -&gt; i32 {
        x + 1;
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>;
}
</pre>

<p>We would get an error:</p>

<pre><code class="language-text">error: not all control paths return a value
fn add_one(x: i32) -&gt; i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
</code></pre>

<p>This reveals two interesting things about Rust: it is an expression-based
language, and semicolons are different from semicolons in other ‘curly brace
and semicolon’-based languages. These two things are related.</p>

<h2 id="expressions-vs.-statements" class='section-header'><a
                           href="#expressions-vs.-statements">Expressions vs. Statements</a></h2>
<p>Rust is primarily an expression-based language. There are only two kinds of
statements, and everything else is an expression.</p>

<p>So what&#39;s the difference? Expressions return a value, and statements do not.
That’s why we end up with ‘not all control paths return a value’ here: the
statement <code>x + 1;</code> doesn’t return a value. There are two kinds of statements in
Rust: ‘declaration statements’ and ‘expression statements’. Everything else is
an expression. Let’s talk about declaration statements first.</p>

<p>In some languages, variable bindings can be written as expressions, not just
statements. Like Ruby:</p>

<pre><code class="language-ruby">x = y = 5
</code></pre>

<p>In Rust, however, using <code>let</code> to introduce a binding is <em>not</em> an expression. The
following will produce a compile-time error:</p>
<span class='rusttest'>fn main() {
    let x = (let y = 5); // expected identifier, found keyword `let`
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>5</span>); <span class='comment'>// expected identifier, found keyword `let`</span>
</pre>

<p>The compiler is telling us here that it was expecting to see the beginning of
an expression, and a <code>let</code> can only begin a statement, not an expression.</p>

<p>Note that assigning to an already-bound variable (e.g. <code>y = 5</code>) is still an
expression, although its value is not particularly useful. Unlike other
languages where an assignment evaluates to the assigned value (e.g. <code>5</code> in the
previous example), in Rust the value of an assignment is an empty tuple <code>()</code>:</p>
<span class='rusttest'>fn main() {
    let mut y = 5;
    
    let x = (y = 6);  // x has the value `()`, not `6`
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>5</span>;

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='ident'>y</span> <span class='op'>=</span> <span class='number'>6</span>);  <span class='comment'>// x has the value `()`, not `6`</span>
</pre>

<p>The second kind of statement in Rust is the <em>expression statement</em>. Its
purpose is to turn any expression into a statement. In practical terms, Rust&#39;s
grammar expects statements to follow other statements. This means that you use
semicolons to separate expressions from each other. This means that Rust
looks a lot like most other languages that require you to use semicolons
at the end of every line, and you will see semicolons at the end of almost
every line of Rust code you see.</p>

<p>What is this exception that makes us say &quot;almost&quot;? You saw it already, in this
code:</p>
<span class='rusttest'>fn main() {
    fn add_one(x: i32) -&gt; i32 {
        x + 1
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}
</pre>

<p>Our function claims to return an <code>i32</code>, but with a semicolon, it would return
<code>()</code> instead. Rust realizes this probably isn’t what we want, and suggests
removing the semicolon in the error we saw before.</p>

<h2 id="early-returns" class='section-header'><a
                           href="#early-returns">Early returns</a></h2>
<p>But what about early returns? Rust does have a keyword for that, <code>return</code>:</p>
<span class='rusttest'>fn main() {
    fn foo(x: i32) -&gt; i32 {
        return x;
    
        // we never run this code!
        x + 1
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>return</span> <span class='ident'>x</span>;

    <span class='comment'>// we never run this code!</span>
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}
</pre>

<p>Using a <code>return</code> as the last line of a function works, but is considered poor
style:</p>
<span class='rusttest'>fn main() {
    fn foo(x: i32) -&gt; i32 {
        return x + 1;
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>return</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>;
}
</pre>

<p>The previous definition without <code>return</code> may look a bit strange if you haven’t
worked in an expression-based language before, but it becomes intuitive over
time.</p>

<h2 id="diverging-functions" class='section-header'><a
                           href="#diverging-functions">Diverging functions</a></h2>
<p>Rust has some special syntax for ‘diverging functions’, which are functions that
do not return:</p>
<span class='rusttest'>fn main() {
    fn diverges() -&gt; ! {
        panic!(&quot;This function never returns!&quot;);
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>diverges</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> {
    <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;This function never returns!&quot;</span>);
}
</pre>

<p><code>panic!</code> is a macro, similar to <code>println!()</code> that we’ve already seen. Unlike
<code>println!()</code>, <code>panic!()</code> causes the current thread of execution to crash with
the given message.</p>

<p>Because this function will cause a crash, it will never return, and so it has
the type ‘<code>!</code>’, which is read ‘diverges’. A diverging function can be used
as any type:</p>
<span class='rusttest'>fn main() {
    fn diverges() -&gt; ! {
       panic!(&quot;This function never returns!&quot;);
    }
    let x: i32 = diverges();
    let x: String = diverges();
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>diverges</span>();
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='ident'>diverges</span>();
</pre>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>