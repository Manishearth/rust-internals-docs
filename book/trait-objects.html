<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Trait Objects</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Guessing Game</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Syntax and Semantics</a>
<ol class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Loops</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vectors</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Method Syntax</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a class='active' href='trait-objects.html'><b>4.22.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ol>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ol class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Error Handling</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Choosing your Guarantees</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Release Channels</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Using Rust without the standard library</a>
</li>
<li><a  href='procedural-macros.html'><b>5.13.</b> Procedural Macros (and custom derive)</a>
</li>
</ol>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ol class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Advanced linking</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Custom Allocators</a>
</li>
</ol>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Syntax Index</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> Bibliography</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Trait Objects</h1>
    <p>When code involves polymorphism, there needs to be a mechanism to determine
which specific version is actually run. This is called ‘dispatch’. There are
two major forms of dispatch: static dispatch and dynamic dispatch. While Rust
favors static dispatch, it also supports dynamic dispatch through a mechanism
called ‘trait objects’.</p>

<h2 id='background' class='section-header'><a href='#background'>Background</a></h2>
<p>For the rest of this chapter, we’ll need a trait and some implementations.
Let’s make a simple one, <code>Foo</code>. It has one method that is expected to return a
<code>String</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Foo%20%7B%0A%20%20%20%20fn%20method(%26self)%20-%3E%20String%3B%0A%7D%0A%7D">Run</a></pre>

<p>We’ll also implement this trait for <code>u8</code> and <code>String</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>u8</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span> { <span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;u8: {}&quot;</span>, <span class='kw-2'>*</span><span class='self'>self</span>) }
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>String</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span> { <span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;string: {}&quot;</span>, <span class='kw-2'>*</span><span class='self'>self</span>) }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Foo%20%7B%20fn%20method(%26self)%20-%3E%20String%3B%20%7D%0Aimpl%20Foo%20for%20u8%20%7B%0A%20%20%20%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22u8%3A%20%7B%7D%22%2C%20*self)%20%7D%0A%7D%0A%0Aimpl%20Foo%20for%20String%20%7B%0A%20%20%20%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22string%3A%20%7B%7D%22%2C%20*self)%20%7D%0A%7D%0A%7D">Run</a></pre>

<h2 id='static-dispatch' class='section-header'><a href='#static-dispatch'>Static dispatch</a></h2>
<p>We can use this trait to perform static dispatch with trait bounds:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>do_something</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();

    <span class='ident'>do_something</span>(<span class='ident'>x</span>);
    <span class='ident'>do_something</span>(<span class='ident'>y</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=trait%20Foo%20%7B%20fn%20method(%26self)%20-%3E%20String%3B%20%7D%0Aimpl%20Foo%20for%20u8%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22u8%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Aimpl%20Foo%20for%20String%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22string%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Afn%20do_something%3CT%3A%20Foo%3E(x%3A%20T)%20%7B%0A%20%20%20%20x.method()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%205u8%3B%0A%20%20%20%20let%20y%20%3D%20%22Hello%22.to_string()%3B%0A%0A%20%20%20%20do_something(x)%3B%0A%20%20%20%20do_something(y)%3B%0A%7D%0A">Run</a></pre>

<p>Rust uses ‘monomorphization’ to perform static dispatch here. This means that
Rust will create a special version of <code>do_something()</code> for both <code>u8</code> and
<code>String</code>, and then replace the call sites with calls to these specialized
functions. In other words, Rust generates something like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>do_something_u8</span>(<span class='ident'>x</span>: <span class='ident'>u8</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>do_something_string</span>(<span class='ident'>x</span>: <span class='ident'>String</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();

    <span class='ident'>do_something_u8</span>(<span class='ident'>x</span>);
    <span class='ident'>do_something_string</span>(<span class='ident'>y</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=trait%20Foo%20%7B%20fn%20method(%26self)%20-%3E%20String%3B%20%7D%0Aimpl%20Foo%20for%20u8%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22u8%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Aimpl%20Foo%20for%20String%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22string%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Afn%20do_something_u8(x%3A%20u8)%20%7B%0A%20%20%20%20x.method()%3B%0A%7D%0A%0Afn%20do_something_string(x%3A%20String)%20%7B%0A%20%20%20%20x.method()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%205u8%3B%0A%20%20%20%20let%20y%20%3D%20%22Hello%22.to_string()%3B%0A%0A%20%20%20%20do_something_u8(x)%3B%0A%20%20%20%20do_something_string(y)%3B%0A%7D%0A">Run</a></pre>

<p>This has a great upside: static dispatch allows function calls to be
inlined because the callee is known at compile time, and inlining is
the key to good optimization. Static dispatch is fast, but it comes at
a tradeoff: ‘code bloat’, due to many copies of the same function
existing in the binary, one for each type.</p>

<p>Furthermore, compilers aren’t perfect and may “optimize” code to become slower.
For example, functions inlined too eagerly will bloat the instruction cache
(cache rules everything around us). This is part of the reason that <code>#[inline]</code>
and <code>#[inline(always)]</code> should be used carefully, and one reason why using a
dynamic dispatch is sometimes more efficient.</p>

<p>However, the common case is that it is more efficient to use static dispatch,
and one can always have a thin statically-dispatched wrapper function that does
a dynamic dispatch, but not vice versa, meaning static calls are more flexible.
The standard library tries to be statically dispatched where possible for this
reason.</p>

<h2 id='dynamic-dispatch' class='section-header'><a href='#dynamic-dispatch'>Dynamic dispatch</a></h2>
<p>Rust provides dynamic dispatch through a feature called ‘trait objects’. Trait
objects, like <code>&amp;Foo</code> or <code>Box&lt;Foo&gt;</code>, are normal values that store a value of
<em>any</em> type that implements the given trait, where the precise type can only be
known at runtime.</p>

<p>A trait object can be obtained from a pointer to a concrete type that
implements the trait by <em>casting</em> it (e.g. <code>&amp;x as &amp;Foo</code>) or <em>coercing</em> it
(e.g. using <code>&amp;x</code> as an argument to a function that takes <code>&amp;Foo</code>).</p>

<p>These trait object coercions and casts also work for pointers like <code>&amp;mut T</code> to
<code>&amp;mut Foo</code> and <code>Box&lt;T&gt;</code> to <code>Box&lt;Foo&gt;</code>, but that’s all at the moment. Coercions
and casts are identical.</p>

<p>This operation can be seen as ‘erasing’ the compiler’s knowledge about the
specific type of the pointer, and hence trait objects are sometimes referred to
as ‘type erasure’.</p>

<p>Coming back to the example above, we can use the same trait to perform dynamic
dispatch with trait objects by casting:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='ident'>do_something</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span> <span class='kw'>as</span> <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=trait%20Foo%20%7B%20fn%20method(%26self)%20-%3E%20String%3B%20%7D%0Aimpl%20Foo%20for%20u8%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22u8%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Aimpl%20Foo%20for%20String%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22string%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Afn%20do_something(x%3A%20%26Foo)%20%7B%0A%20%20%20%20x.method()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%205u8%3B%0A%20%20%20%20do_something(%26x%20as%20%26Foo)%3B%0A%7D%0A">Run</a></pre>

<p>or by coercing:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();
    <span class='ident'>do_something</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=trait%20Foo%20%7B%20fn%20method(%26self)%20-%3E%20String%3B%20%7D%0Aimpl%20Foo%20for%20u8%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22u8%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Aimpl%20Foo%20for%20String%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22string%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Afn%20do_something(x%3A%20%26Foo)%20%7B%0A%20%20%20%20x.method()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%20%22Hello%22.to_string()%3B%0A%20%20%20%20do_something(%26x)%3B%0A%7D%0A">Run</a></pre>

<p>A function that takes a trait object is not specialized to each of the types
that implements <code>Foo</code>: only one copy is generated, often (but not always)
resulting in less code bloat. However, this comes at the cost of requiring
slower virtual function calls, and effectively inhibiting any chance of
inlining and related optimizations from occurring.</p>

<h3 id='why-pointers' class='section-header'><a href='#why-pointers'>Why pointers?</a></h3>
<p>Rust does not put things behind a pointer by default, unlike many managed
languages, so types can have different sizes. Knowing the size of the value at
compile time is important for things like passing it as an argument to a
function, moving it about on the stack and allocating (and deallocating) space
on the heap to store it.</p>

<p>For <code>Foo</code>, we would need to have a value that could be at least either a
<code>String</code> (24 bytes) or a <code>u8</code> (1 byte), as well as any other type for which
dependent crates may implement <code>Foo</code> (any number of bytes at all). There’s no
way to guarantee that this last point can work if the values are stored without
a pointer, because those other types can be arbitrarily large.</p>

<p>Putting the value behind a pointer means the size of the value is not relevant
when we are tossing a trait object around, only the size of the pointer itself.</p>

<h3 id='representation' class='section-header'><a href='#representation'>Representation</a></h3>
<p>The methods of the trait can be called on a trait object via a special record
of function pointers traditionally called a ‘vtable’ (created and managed by
the compiler).</p>

<p>Trait objects are both simple and complicated: their core representation and
layout is quite straight-forward, but there are some curly error messages and
surprising behaviors to discover.</p>

<p>Let’s start simple, with the runtime representation of a trait object. The
<code>std::raw</code> module contains structs with layouts that are the same as the
complicated built-in types, <a href="../std/raw/struct.TraitObject.html">including trait objects</a>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>TraitObject</span> {
    <span class='kw'>pub</span> <span class='ident'>data</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> (),
    <span class='kw'>pub</span> <span class='ident'>vtable</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> (),
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20foo%20%7B%0Apub%20struct%20TraitObject%20%7B%0A%20%20%20%20pub%20data%3A%20*mut%20()%2C%0A%20%20%20%20pub%20vtable%3A%20*mut%20()%2C%0A%7D%0A%7D%0A%7D">Run</a></pre>

<p>That is, a trait object like <code>&amp;Foo</code> consists of a ‘data’ pointer and a ‘vtable’
pointer.</p>

<p>The data pointer addresses the data (of some unknown type <code>T</code>) that the trait
object is storing, and the vtable pointer points to the vtable (‘virtual method
table’) corresponding to the implementation of <code>Foo</code> for <code>T</code>.</p>

<p>A vtable is essentially a struct of function pointers, pointing to the concrete
piece of machine code for each method in the implementation. A method call like
<code>trait_object.method()</code> will retrieve the correct pointer out of the vtable and
then do a dynamic call of it. For example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='kw'>fn</span>(<span class='kw-2'>*</span><span class='kw-2'>mut</span> ()),
    <span class='ident'>size</span>: <span class='ident'>usize</span>,
    <span class='ident'>align</span>: <span class='ident'>usize</span>,
    <span class='ident'>method</span>: <span class='kw'>fn</span>(<span class='kw-2'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
}

<span class='comment'>// u8:</span>

<span class='kw'>fn</span> <span class='ident'>call_method_on_u8</span>(<span class='ident'>x</span>: <span class='kw-2'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='comment'>// The compiler guarantees that this function is only called</span>
    <span class='comment'>// with `x` pointing to a u8.</span>
    <span class='kw'>let</span> <span class='ident'>byte</span>: <span class='kw-2'>&amp;</span><span class='ident'>u8</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='kw-2'>*</span>(<span class='ident'>x</span> <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>) };

    <span class='ident'>byte</span>.<span class='ident'>method</span>()
}

<span class='kw'>static</span> <span class='ident'>Foo_for_u8_vtable</span>: <span class='ident'>FooVtable</span> <span class='op'>=</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='comment'>/* compiler magic */</span>,
    <span class='ident'>size</span>: <span class='number'>1</span>,
    <span class='ident'>align</span>: <span class='number'>1</span>,

    <span class='comment'>// Cast to a function pointer:</span>
    <span class='ident'>method</span>: <span class='ident'>call_method_on_u8</span> <span class='kw'>as</span> <span class='kw'>fn</span>(<span class='kw-2'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
};


<span class='comment'>// String:</span>

<span class='kw'>fn</span> <span class='ident'>call_method_on_String</span>(<span class='ident'>x</span>: <span class='kw-2'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='comment'>// The compiler guarantees that this function is only called</span>
    <span class='comment'>// with `x` pointing to a String.</span>
    <span class='kw'>let</span> <span class='ident'>string</span>: <span class='kw-2'>&amp;</span><span class='ident'>String</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='kw-2'>*</span>(<span class='ident'>x</span> <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>String</span>) };

    <span class='ident'>string</span>.<span class='ident'>method</span>()
}

<span class='kw'>static</span> <span class='ident'>Foo_for_String_vtable</span>: <span class='ident'>FooVtable</span> <span class='op'>=</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='comment'>/* compiler magic */</span>,
    <span class='comment'>// Values for a 64-bit computer, halve them for 32-bit ones.</span>
    <span class='ident'>size</span>: <span class='number'>24</span>,
    <span class='ident'>align</span>: <span class='number'>8</span>,

    <span class='ident'>method</span>: <span class='ident'>call_method_on_String</span> <span class='kw'>as</span> <span class='kw'>fn</span>(<span class='kw-2'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
};<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20FooVtable%20%7B%0A%20%20%20%20destructor%3A%20fn(*mut%20())%2C%0A%20%20%20%20size%3A%20usize%2C%0A%20%20%20%20align%3A%20usize%2C%0A%20%20%20%20method%3A%20fn(*const%20())%20-%3E%20String%2C%0A%7D%0A%0A%2F%2F%20u8%3A%0A%0Afn%20call_method_on_u8(x%3A%20*const%20())%20-%3E%20String%20%7B%0A%20%20%20%20%2F%2F%20The%20compiler%20guarantees%20that%20this%20function%20is%20only%20called%0A%20%20%20%20%2F%2F%20with%20%60x%60%20pointing%20to%20a%20u8.%0A%20%20%20%20let%20byte%3A%20%26u8%20%3D%20unsafe%20%7B%20%26*(x%20as%20*const%20u8)%20%7D%3B%0A%0A%20%20%20%20byte.method()%0A%7D%0A%0Astatic%20Foo_for_u8_vtable%3A%20FooVtable%20%3D%20FooVtable%20%7B%0A%20%20%20%20destructor%3A%20%2F*%20compiler%20magic%20*%2F%2C%0A%20%20%20%20size%3A%201%2C%0A%20%20%20%20align%3A%201%2C%0A%0A%20%20%20%20%2F%2F%20Cast%20to%20a%20function%20pointer%3A%0A%20%20%20%20method%3A%20call_method_on_u8%20as%20fn(*const%20())%20-%3E%20String%2C%0A%7D%3B%0A%0A%0A%2F%2F%20String%3A%0A%0Afn%20call_method_on_String(x%3A%20*const%20())%20-%3E%20String%20%7B%0A%20%20%20%20%2F%2F%20The%20compiler%20guarantees%20that%20this%20function%20is%20only%20called%0A%20%20%20%20%2F%2F%20with%20%60x%60%20pointing%20to%20a%20String.%0A%20%20%20%20let%20string%3A%20%26String%20%3D%20unsafe%20%7B%20%26*(x%20as%20*const%20String)%20%7D%3B%0A%0A%20%20%20%20string.method()%0A%7D%0A%0Astatic%20Foo_for_String_vtable%3A%20FooVtable%20%3D%20FooVtable%20%7B%0A%20%20%20%20destructor%3A%20%2F*%20compiler%20magic%20*%2F%2C%0A%20%20%20%20%2F%2F%20Values%20for%20a%2064-bit%20computer%2C%20halve%20them%20for%2032-bit%20ones.%0A%20%20%20%20size%3A%2024%2C%0A%20%20%20%20align%3A%208%2C%0A%0A%20%20%20%20method%3A%20call_method_on_String%20as%20fn(*const%20())%20-%3E%20String%2C%0A%7D%3B%0A%7D">Run</a></pre>

<p>The <code>destructor</code> field in each vtable points to a function that will clean up
any resources of the vtable’s type: for <code>u8</code> it is trivial, but for <code>String</code> it
will free the memory. This is necessary for owning trait objects like
<code>Box&lt;Foo&gt;</code>, which need to clean-up both the <code>Box</code> allocation as well as the
internal type when they go out of scope. The <code>size</code> and <code>align</code> fields store
the size of the erased type, and its alignment requirements.</p>

<p>Suppose we’ve got some values that implement <code>Foo</code>. The explicit form of
construction and use of <code>Foo</code> trait objects might look a bit like (ignoring the
type mismatches: they’re all pointers anyway):</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>u8</span> <span class='op'>=</span> <span class='number'>1</span>;

<span class='comment'>// let b: &amp;Foo = &amp;a;</span>
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>TraitObject</span> {
    <span class='comment'>// Store the data:</span>
    <span class='ident'>data</span>: <span class='kw-2'>&amp;</span><span class='ident'>a</span>,
    <span class='comment'>// Store the methods:</span>
    <span class='ident'>vtable</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo_for_String_vtable</span>
};

<span class='comment'>// let y: &amp;Foo = x;</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>TraitObject</span> {
    <span class='comment'>// Store the data:</span>
    <span class='ident'>data</span>: <span class='kw-2'>&amp;</span><span class='ident'>x</span>,
    <span class='comment'>// Store the methods:</span>
    <span class='ident'>vtable</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo_for_u8_vtable</span>
};

<span class='comment'>// b.method();</span>
(<span class='ident'>b</span>.<span class='ident'>vtable</span>.<span class='ident'>method</span>)(<span class='ident'>b</span>.<span class='ident'>data</span>);

<span class='comment'>// y.method();</span>
(<span class='ident'>y</span>.<span class='ident'>vtable</span>.<span class='ident'>method</span>)(<span class='ident'>y</span>.<span class='ident'>data</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20a%3A%20String%20%3D%20%22foo%22.to_string()%3B%0Alet%20x%3A%20u8%20%3D%201%3B%0A%0A%2F%2F%20let%20b%3A%20%26Foo%20%3D%20%26a%3B%0Alet%20b%20%3D%20TraitObject%20%7B%0A%20%20%20%20%2F%2F%20Store%20the%20data%3A%0A%20%20%20%20data%3A%20%26a%2C%0A%20%20%20%20%2F%2F%20Store%20the%20methods%3A%0A%20%20%20%20vtable%3A%20%26Foo_for_String_vtable%0A%7D%3B%0A%0A%2F%2F%20let%20y%3A%20%26Foo%20%3D%20x%3B%0Alet%20y%20%3D%20TraitObject%20%7B%0A%20%20%20%20%2F%2F%20Store%20the%20data%3A%0A%20%20%20%20data%3A%20%26x%2C%0A%20%20%20%20%2F%2F%20Store%20the%20methods%3A%0A%20%20%20%20vtable%3A%20%26Foo_for_u8_vtable%0A%7D%3B%0A%0A%2F%2F%20b.method()%3B%0A(b.vtable.method)(b.data)%3B%0A%0A%2F%2F%20y.method()%3B%0A(y.vtable.method)(y.data)%3B%0A%7D">Run</a></pre>

<h2 id='object-safety' class='section-header'><a href='#object-safety'>Object Safety</a></h2>
<p>Not every trait can be used to make a trait object. For example, vectors implement
<code>Clone</code>, but if we try to make a trait object:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>o</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>v</span> <span class='kw'>as</span> <span class='kw-2'>&amp;</span><span class='ident'>Clone</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Alet%20o%20%3D%20%26v%20as%20%26Clone%3B%0A%7D">Run</a></pre>

<p>We get an error:</p>

<pre><code class="language-text">error: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]
let o = &amp;v as &amp;Clone;
        ^~
note: the trait cannot require that `Self : Sized`
let o = &amp;v as &amp;Clone;
        ^~
</code></pre>

<p>The error says that <code>Clone</code> is not ‘object-safe’. Only traits that are
object-safe can be made into trait objects. A trait is object-safe if both of
these are true:</p>

<ul>
<li>the trait does not require that <code>Self: Sized</code></li>
<li>all of its methods are object-safe</li>
</ul>

<p>So what makes a method object-safe? Each method must require that <code>Self: Sized</code>
or all of the following:</p>

<ul>
<li>must not have any type parameters</li>
<li>must not use <code>Self</code></li>
</ul>

<p>Whew! As we can see, almost all of these rules talk about <code>Self</code>. A good intuition
is “except in special circumstances, if your trait’s method uses <code>Self</code>, it is not
object-safe.”</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>