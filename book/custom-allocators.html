<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Custom Allocators</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Guessing Game</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Syntax and Semantics</a>
<ol class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Loops</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vectors</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Method Syntax</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ol>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ol class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Error Handling</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Choosing your Guarantees</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Release Channels</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Using Rust without the standard library</a>
</li>
<li><a  href='procedural-macros.html'><b>5.13.</b> Procedural Macros (and custom derive)</a>
</li>
</ol>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ol class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Advanced linking</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
<li><a class='active' href='custom-allocators.html'><b>6.11.</b> Custom Allocators</a>
</li>
</ol>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Syntax Index</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> Bibliography</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Custom Allocators</h1>
    <p>Allocating memory isn&#39;t always the easiest thing to do, and while Rust generally
takes care of this by default it often becomes necessary to customize how
allocation occurs. The compiler and standard library currently allow switching
out the default global allocator in use at compile time. The design is currently
spelled out in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1183-swap-out-jemalloc.md">RFC 1183</a> but this will walk you through how to get your
own allocator up and running.</p>

<h1 id='default-allocator' class='section-header'><a href='#default-allocator'>Default Allocator</a></h1>
<p>The compiler currently ships two default allocators: <code>alloc_system</code> and
<code>alloc_jemalloc</code> (some targets don&#39;t have jemalloc, however). These allocators
are normal Rust crates and contain an implementation of the routines to
allocate and deallocate memory. The standard library is not compiled assuming
either one, and the compiler will decide which allocator is in use at
compile-time depending on the type of output artifact being produced.</p>

<p>Binaries generated by the compiler will use <code>alloc_jemalloc</code> by default (where
available). In this situation the compiler &quot;controls the world&quot; in the sense of
it has power over the final link. Primarily this means that the allocator
decision can be left up the compiler.</p>

<p>Dynamic and static libraries, however, will use <code>alloc_system</code> by default. Here
Rust is typically a &#39;guest&#39; in another application or another world where it
cannot authoritatively decide what allocator is in use. As a result it resorts
back to the standard APIs (e.g. <code>malloc</code> and <code>free</code>) for acquiring and releasing
memory.</p>

<h1 id='switching-allocators' class='section-header'><a href='#switching-allocators'>Switching Allocators</a></h1>
<p>Although the compiler&#39;s default choices may work most of the time, it&#39;s often
necessary to tweak certain aspects. Overriding the compiler&#39;s decision about
which allocator is in use is done simply by linking to the desired allocator:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>alloc_system</span>)]</span>

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>alloc_system</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>4</span>); <span class='comment'>// Allocates from the system allocator.</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(alloc_system)%5D%0A%0Aextern%20crate%20alloc_system%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20Box%3A%3Anew(4)%3B%20%2F%2F%20Allocates%20from%20the%20system%20allocator.%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>In this example the binary generated will not link to jemalloc by default but
instead use the system allocator. Conversely to generate a dynamic library which
uses jemalloc by default one would write:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>alloc_jemalloc</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_type</span> <span class='op'>=</span> <span class='string'>&quot;dylib&quot;</span>]</span>

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>alloc_jemalloc</span>;

<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>4</span>); <span class='comment'>// Allocates from jemalloc.</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(alloc_jemalloc)%5D%0A%23!%5Bcrate_type%20%3D%20%22dylib%22%5D%0A%0Aextern%20crate%20alloc_jemalloc%3B%0A%0Apub%20fn%20foo()%20%7B%0A%20%20%20%20let%20a%20%3D%20Box%3A%3Anew(4)%3B%20%2F%2F%20Allocates%20from%20jemalloc.%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0Afn%20main()%20%7B%7D%0A&amp;version=nightly">Run</a></pre>

<h1 id='writing-a-custom-allocator' class='section-header'><a href='#writing-a-custom-allocator'>Writing a custom allocator</a></h1>
<p>Sometimes even the choices of jemalloc vs the system allocator aren&#39;t enough and
an entirely new custom allocator is required. In this you&#39;ll write your own
crate which implements the allocator API (e.g. the same as <code>alloc_system</code> or
<code>alloc_jemalloc</code>). As an example, let&#39;s take a look at a simplified and
annotated version of <code>alloc_system</code></p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// The compiler needs to be instructed that this crate is an allocator in order</span>
<span class='comment'>// to realize that when this is linked in another allocator like jemalloc should</span>
<span class='comment'>// not be linked in.</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>allocator</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>allocator</span>]</span>

<span class='comment'>// Allocators are not allowed to depend on the standard library which in turn</span>
<span class='comment'>// requires an allocator in order to avoid circular dependencies. This crate,</span>
<span class='comment'>// however, can use all of libcore.</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span>

<span class='comment'>// Let&#39;s give a unique name to our custom allocator:</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_name</span> <span class='op'>=</span> <span class='string'>&quot;my_allocator&quot;</span>]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_type</span> <span class='op'>=</span> <span class='string'>&quot;rlib&quot;</span>]</span>

<span class='comment'>// Our system allocator will use the in-tree libc crate for FFI bindings. Note</span>
<span class='comment'>// that currently the external (crates.io) libc cannot be used because it links</span>
<span class='comment'>// to the standard library (e.g. `#![no_std]` isn&#39;t stable yet), so that&#39;s why</span>
<span class='comment'>// this specifically requires the in-tree version.</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>libc</span>)]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;

<span class='comment'>// Listed below are the five allocation functions currently required by custom</span>
<span class='comment'>// allocators. Their signatures and symbol names are not currently typechecked</span>
<span class='comment'>// by the compiler, but this is a future extension and are required to match</span>
<span class='comment'>// what is found below.</span>
<span class='comment'>//</span>
<span class='comment'>// Note that the standard `malloc` and `realloc` functions do not provide a way</span>
<span class='comment'>// to communicate alignment so this implementation would need to be improved</span>
<span class='comment'>// with respect to alignment in that aspect.</span>

<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>__rust_allocate</span>(<span class='ident'>size</span>: <span class='ident'>usize</span>, <span class='ident'>_align</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>u8</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>libc</span>::<span class='ident'>malloc</span>(<span class='ident'>size</span> <span class='kw'>as</span> <span class='ident'>libc</span>::<span class='ident'>size_t</span>) <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>u8</span> }
}

<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>__rust_deallocate</span>(<span class='ident'>ptr</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>u8</span>, <span class='ident'>_old_size</span>: <span class='ident'>usize</span>, <span class='ident'>_align</span>: <span class='ident'>usize</span>) {
    <span class='kw'>unsafe</span> { <span class='ident'>libc</span>::<span class='ident'>free</span>(<span class='ident'>ptr</span> <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>libc</span>::<span class='ident'>c_void</span>) }
}

<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>__rust_reallocate</span>(<span class='ident'>ptr</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>u8</span>, <span class='ident'>_old_size</span>: <span class='ident'>usize</span>, <span class='ident'>size</span>: <span class='ident'>usize</span>,
                                <span class='ident'>_align</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>u8</span> {
    <span class='kw'>unsafe</span> {
        <span class='ident'>libc</span>::<span class='ident'>realloc</span>(<span class='ident'>ptr</span> <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>libc</span>::<span class='ident'>c_void</span>, <span class='ident'>size</span> <span class='kw'>as</span> <span class='ident'>libc</span>::<span class='ident'>size_t</span>) <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>u8</span>
    }
}

<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>__rust_reallocate_inplace</span>(<span class='ident'>_ptr</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>u8</span>, <span class='ident'>old_size</span>: <span class='ident'>usize</span>,
                                        <span class='ident'>_size</span>: <span class='ident'>usize</span>, <span class='ident'>_align</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
    <span class='ident'>old_size</span> <span class='comment'>// This api is not supported by libc.</span>
}

<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>__rust_usable_size</span>(<span class='ident'>size</span>: <span class='ident'>usize</span>, <span class='ident'>_align</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
    <span class='ident'>size</span>
}
<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%2F%2F%20Only%20needed%20for%20rustdoc%20--test%20down%20below.%0A%23!%5Bfeature(lang_items)%5D%0A%2F%2F%20The%20compiler%20needs%20to%20be%20instructed%20that%20this%20crate%20is%20an%20allocator%20in%20order%0A%2F%2F%20to%20realize%20that%20when%20this%20is%20linked%20in%20another%20allocator%20like%20jemalloc%20should%0A%2F%2F%20not%20be%20linked%20in.%0A%23!%5Bfeature(allocator)%5D%0A%23!%5Ballocator%5D%0A%0A%2F%2F%20Allocators%20are%20not%20allowed%20to%20depend%20on%20the%20standard%20library%20which%20in%20turn%0A%2F%2F%20requires%20an%20allocator%20in%20order%20to%20avoid%20circular%20dependencies.%20This%20crate%2C%0A%2F%2F%20however%2C%20can%20use%20all%20of%20libcore.%0A%23!%5Bno_std%5D%0A%0A%2F%2F%20Let's%20give%20a%20unique%20name%20to%20our%20custom%20allocator%3A%0A%23!%5Bcrate_name%20%3D%20%22my_allocator%22%5D%0A%23!%5Bcrate_type%20%3D%20%22rlib%22%5D%0A%0A%2F%2F%20Our%20system%20allocator%20will%20use%20the%20in-tree%20libc%20crate%20for%20FFI%20bindings.%20Note%0A%2F%2F%20that%20currently%20the%20external%20(crates.io)%20libc%20cannot%20be%20used%20because%20it%20links%0A%2F%2F%20to%20the%20standard%20library%20(e.g.%20%60%23!%5Bno_std%5D%60%20isn't%20stable%20yet)%2C%20so%20that's%20why%0A%2F%2F%20this%20specifically%20requires%20the%20in-tree%20version.%0A%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0A%0A%2F%2F%20Listed%20below%20are%20the%20five%20allocation%20functions%20currently%20required%20by%20custom%0A%2F%2F%20allocators.%20Their%20signatures%20and%20symbol%20names%20are%20not%20currently%20typechecked%0A%2F%2F%20by%20the%20compiler%2C%20but%20this%20is%20a%20future%20extension%20and%20are%20required%20to%20match%0A%2F%2F%20what%20is%20found%20below.%0A%2F%2F%0A%2F%2F%20Note%20that%20the%20standard%20%60malloc%60%20and%20%60realloc%60%20functions%20do%20not%20provide%20a%20way%0A%2F%2F%20to%20communicate%20alignment%20so%20this%20implementation%20would%20need%20to%20be%20improved%0A%2F%2F%20with%20respect%20to%20alignment%20in%20that%20aspect.%0A%0A%23%5Bno_mangle%5D%0Apub%20extern%20fn%20__rust_allocate(size%3A%20usize%2C%20_align%3A%20usize)%20-%3E%20*mut%20u8%20%7B%0A%20%20%20%20unsafe%20%7B%20libc%3A%3Amalloc(size%20as%20libc%3A%3Asize_t)%20as%20*mut%20u8%20%7D%0A%7D%0A%0A%23%5Bno_mangle%5D%0Apub%20extern%20fn%20__rust_deallocate(ptr%3A%20*mut%20u8%2C%20_old_size%3A%20usize%2C%20_align%3A%20usize)%20%7B%0A%20%20%20%20unsafe%20%7B%20libc%3A%3Afree(ptr%20as%20*mut%20libc%3A%3Ac_void)%20%7D%0A%7D%0A%0A%23%5Bno_mangle%5D%0Apub%20extern%20fn%20__rust_reallocate(ptr%3A%20*mut%20u8%2C%20_old_size%3A%20usize%2C%20size%3A%20usize%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_align%3A%20usize)%20-%3E%20*mut%20u8%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20libc%3A%3Arealloc(ptr%20as%20*mut%20libc%3A%3Ac_void%2C%20size%20as%20libc%3A%3Asize_t)%20as%20*mut%20u8%0A%20%20%20%20%7D%0A%7D%0A%0A%23%5Bno_mangle%5D%0Apub%20extern%20fn%20__rust_reallocate_inplace(_ptr%3A%20*mut%20u8%2C%20old_size%3A%20usize%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_size%3A%20usize%2C%20_align%3A%20usize)%20-%3E%20usize%20%7B%0A%20%20%20%20old_size%20%2F%2F%20This%20api%20is%20not%20supported%20by%20libc.%0A%7D%0A%0A%23%5Bno_mangle%5D%0Apub%20extern%20fn%20__rust_usable_size(size%3A%20usize%2C%20_align%3A%20usize)%20-%3E%20usize%20%7B%0A%20%20%20%20size%0A%7D%0A%0A%2F%2F%20Only%20needed%20to%20get%20rustdoc%20to%20test%20this%3A%0Afn%20main()%20%7B%7D%0A%23%5Blang%20%3D%20%22panic_fmt%22%5D%20fn%20panic_fmt()%20%7B%7D%0A%23%5Blang%20%3D%20%22eh_personality%22%5D%20fn%20eh_personality()%20%7B%7D%0A%23%5Blang%20%3D%20%22eh_unwind_resume%22%5D%20extern%20fn%20eh_unwind_resume()%20%7B%7D%0A%23%5Bno_mangle%5D%20pub%20extern%20fn%20rust_eh_register_frames%20()%20%7B%7D%0A%23%5Bno_mangle%5D%20pub%20extern%20fn%20rust_eh_unregister_frames%20()%20%7B%7D%0A&amp;version=nightly">Run</a></pre>

<p>After we compile this crate, it can be used as follows:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>my_allocator</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>8</span>); <span class='comment'>// Allocates memory via our custom allocator crate.</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20my_allocator%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20Box%3A%3Anew(8)%3B%20%2F%2F%20Allocates%20memory%20via%20our%20custom%20allocator%20crate.%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0A">Run</a></pre>

<h1 id='custom-allocator-limitations' class='section-header'><a href='#custom-allocator-limitations'>Custom allocator limitations</a></h1>
<p>There are a few restrictions when working with custom allocators which may cause
compiler errors:</p>

<ul>
<li><p>Any one artifact may only be linked to at most one allocator. Binaries,
dylibs, and staticlibs must link to exactly one allocator, and if none have
been explicitly chosen the compiler will choose one. On the other hand rlibs
do not need to link to an allocator (but still can).</p></li>
<li><p>A consumer of an allocator is tagged with <code>#![needs_allocator]</code> (e.g. the
<code>liballoc</code> crate currently) and an <code>#[allocator]</code> crate cannot transitively
depend on a crate which needs an allocator (e.g. circular dependencies are not
allowed). This basically means that allocators must restrict themselves to
libcore currently.</p></li>
</ul>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>