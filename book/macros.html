<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Macros</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Guessing Game</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Syntax and Semantics</a>
<ol class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Loops</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vectors</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Method Syntax</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Deref coercions</a>
</li>
<li><a class='active' href='macros.html'><b>4.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ol>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ol class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Error Handling</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Choosing your Guarantees</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Release Channels</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Using Rust without the standard library</a>
</li>
<li><a  href='procedural-macros.html'><b>5.13.</b> Procedural Macros (and custom derive)</a>
</li>
</ol>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ol class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Advanced linking</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Custom Allocators</a>
</li>
</ol>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Syntax Index</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> Bibliography</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Macros</h1>
    <p>By now you’ve learned about many of the tools Rust provides for abstracting and
reusing code. These units of code reuse have a rich semantic structure. For
example, functions have a type signature, type parameters have trait bounds,
and overloaded functions must belong to a particular trait.</p>

<p>This structure means that Rust’s core abstractions have powerful compile-time
correctness checking. But this comes at the price of reduced flexibility. If
you visually identify a pattern of repeated code, you may find it’s difficult
or cumbersome to express that pattern as a generic function, a trait, or
anything else within Rust’s semantics.</p>

<p>Macros allow us to abstract at a syntactic level. A macro invocation is
shorthand for an &quot;expanded&quot; syntactic form. This expansion happens early in
compilation, before any static checking. As a result, macros can capture many
patterns of code reuse that Rust’s core abstractions cannot.</p>

<p>The drawback is that macro-based code can be harder to understand, because
fewer of the built-in rules apply. Like an ordinary function, a well-behaved
macro can be used without understanding its implementation. However, it can be
difficult to design a well-behaved macro!  Additionally, compiler errors in
macro code are harder to interpret, because they describe problems in the
expanded code, not the source-level form that developers use.</p>

<p>These drawbacks make macros something of a &quot;feature of last resort&quot;. That’s not
to say that macros are bad; they are part of Rust because sometimes they’re
needed for truly concise, well-abstracted code. Just keep this tradeoff in
mind.</p>

<h1 id='defining-a-macro' class='section-header'><a href='#defining-a-macro'>Defining a macro</a></h1>
<p>You may have seen the <code>vec!</code> macro, used to initialize a <a href="vectors.html">vector</a> with
any number of elements.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%3A%20Vec%3Cu32%3E%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Aassert_eq!(x%2C%20%5B1%2C%202%2C%203%5D)%3B%0A%7D">Run</a></pre>

<p>This can’t be an ordinary function, because it takes any number of arguments.
But we can imagine it as syntactic shorthand for</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>1</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>2</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>3</span>);
    <span class='ident'>temp_vec</span>
};<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%3A%20Vec%3Cu32%3E%20%3D%20%7B%0A%20%20%20%20let%20mut%20temp_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20temp_vec.push(1)%3B%0A%20%20%20%20temp_vec.push(2)%3B%0A%20%20%20%20temp_vec.push(3)%3B%0A%20%20%20%20temp_vec%0A%7D%3B%0Aassert_eq!(x%2C%20%5B1%2C%202%2C%203%5D)%3B%0A%7D">Run</a></pre>

<p>We can implement this shorthand, using a macro: <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> {
    ( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> {
        {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
            $(
                <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
            )<span class='op'>*</span>
            <span class='ident'>temp_vec</span>
        }
    };
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=macro_rules!%20vec%20%7B%0A%20%20%20%20(%20%24(%20%24x%3Aexpr%20)%2C*%20)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20temp_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20temp_vec.push(%24x)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20)*%0A%20%20%20%20%20%20%20%20%20%20%20%20temp_vec%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20assert_eq!(vec!%5B1%2C2%2C3%5D%2C%20%5B1%2C%202%2C%203%5D)%3B%0A%7D%0A">Run</a></pre>

<p>Whoa, that’s a lot of new syntax! Let’s break it down.</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> { ... }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amacro_rules!%20vec%20%7B%20...%20%7D%0A%7D">Run</a></pre>

<p>This says we’re defining a macro named <code>vec</code>, much as <code>fn vec</code> would define a
function named <code>vec</code>. In prose, we informally write a macro’s name with an
exclamation point, e.g. <code>vec!</code>. The exclamation point is part of the invocation
syntax and serves to distinguish a macro from an ordinary function.</p>

<h2 id='matching' class='section-header'><a href='#matching'>Matching</a></h2>
<p>The macro is defined through a series of rules, which are pattern-matching
cases. Above, we had</p>

<pre class='rust rust-example-rendered'>
( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> { ... };<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A(%20%24(%20%24x%3Aexpr%20)%2C*%20)%20%3D%3E%20%7B%20...%20%7D%3B%0A%7D">Run</a></pre>

<p>This is like a <code>match</code> expression arm, but the matching happens on Rust syntax
trees, at compile time. The semicolon is optional on the last (here, only)
case. The &quot;pattern&quot; on the left-hand side of <code>=&gt;</code> is known as a ‘matcher’.
These have <a href="../reference.html#macros">their own little grammar</a> within the language.</p>

<p>The matcher <code>$x:expr</code> will match any Rust expression, binding that syntax tree
to the ‘metavariable’ <code>$x</code>. The identifier <code>expr</code> is a ‘fragment specifier’;
the full possibilities are enumerated later in this chapter.
Surrounding the matcher with <code>$(...),*</code> will match zero or more expressions,
separated by commas.</p>

<p>Aside from the special matcher syntax, any Rust tokens that appear in a matcher
must match exactly. For example,</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='ident'>x</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mode X: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
    (<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mode Y: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=macro_rules!%20foo%20%7B%0A%20%20%20%20(x%20%3D%3E%20%24e%3Aexpr)%20%3D%3E%20(println!(%22mode%20X%3A%20%7B%7D%22%2C%20%24e))%3B%0A%20%20%20%20(y%20%3D%3E%20%24e%3Aexpr)%20%3D%3E%20(println!(%22mode%20Y%3A%20%7B%7D%22%2C%20%24e))%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20foo!(y%20%3D%3E%203)%3B%0A%7D%0A">Run</a></pre>

<p>will print</p>

<pre><code class="language-text">mode Y: 3
</code></pre>

<p>With</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>z</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afoo!(z%20%3D%3E%203)%3B%0A%7D">Run</a></pre>

<p>we get the compiler error</p>

<pre><code class="language-text">error: no rules expected the token `z`
</code></pre>

<h2 id='expansion' class='section-header'><a href='#expansion'>Expansion</a></h2>
<p>The right-hand side of a macro rule is ordinary Rust syntax, for the most part.
But we can splice in bits of syntax captured by the matcher. From the original
example:</p>

<pre class='rust rust-example-rendered'>
$(
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
)<span class='kw-2'>*</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%24(%0A%20%20%20%20temp_vec.push(%24x)%3B%0A)*%0A%7D">Run</a></pre>

<p>Each matched expression <code>$x</code> will produce a single <code>push</code> statement in the
macro expansion. The repetition in the expansion proceeds in &quot;lockstep&quot; with
repetition in the matcher (more on this in a moment).</p>

<p>Because <code>$x</code> was already declared as matching an expression, we don’t repeat
<code>:expr</code> on the right-hand side. Also, we don’t include a separating comma as
part of the repetition operator. Instead, we have a terminating semicolon
within the repeated block.</p>

<p>Another detail: the <code>vec!</code> macro has <em>two</em> pairs of braces on the right-hand
side. They are often combined like so:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> {{
        ...
    }}
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amacro_rules!%20foo%20%7B%0A%20%20%20%20()%20%3D%3E%20%7B%7B%0A%20%20%20%20%20%20%20%20...%0A%20%20%20%20%7D%7D%0A%7D%0A%7D">Run</a></pre>

<p>The outer braces are part of the syntax of <code>macro_rules!</code>. In fact, you can use
<code>()</code> or <code>[]</code> instead. They simply delimit the right-hand side as a whole.</p>

<p>The inner braces are part of the expanded syntax. Remember, the <code>vec!</code> macro is
used in an expression context. To write an expression with multiple statements,
including <code>let</code>-bindings, we use a block. If your macro expands to a single
expression, you don’t need this extra layer of braces.</p>

<p>Note that we never <em>declared</em> that the macro produces an expression. In fact,
this is not determined until we use the macro as an expression. With care, you
can write a macro whose expansion works in several contexts. For example,
shorthand for a data type could be valid as either an expression or a pattern.</p>

<h2 id='repetition' class='section-header'><a href='#repetition'>Repetition</a></h2>
<p>The repetition operator follows two principal rules:</p>

<ol>
<li><code>$(...)*</code> walks through one &quot;layer&quot; of repetitions, for all of the <code>$name</code>s
it contains, in lockstep, and</li>
<li>each <code>$name</code> must be under at least as many <code>$(...)*</code>s as it was matched
against. If it is under more, it’ll be duplicated, as appropriate.</li>
</ol>

<p>This baroque macro illustrates the duplication of variables from outer
repetition levels.</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>o_O</span> {
    (
        $(
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>; [ $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ]
        );<span class='op'>*</span>
    ) <span class='op'>=&gt;</span> {
        <span class='kw-2'>&amp;</span>[ $($( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span> <span class='op'>+</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span> ),<span class='kw-2'>*</span>),<span class='op'>*</span> ]
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>i32</span>]
        <span class='op'>=</span> <span class='macro'>o_O</span><span class='macro'>!</span>(<span class='number'>10</span>; [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
               <span class='number'>20</span>; [<span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>, [<span class='number'>11</span>, <span class='number'>12</span>, <span class='number'>13</span>, <span class='number'>24</span>, <span class='number'>25</span>, <span class='number'>26</span>]);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=macro_rules!%20o_O%20%7B%0A%20%20%20%20(%0A%20%20%20%20%20%20%20%20%24(%0A%20%20%20%20%20%20%20%20%20%20%20%20%24x%3Aexpr%3B%20%5B%20%24(%20%24y%3Aexpr%20)%2C*%20%5D%0A%20%20%20%20%20%20%20%20)%3B*%0A%20%20%20%20)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%26%5B%20%24(%24(%20%24x%20%2B%20%24y%20)%2C*)%2C*%20%5D%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%5Bi32%5D%0A%20%20%20%20%20%20%20%20%3D%20o_O!(10%3B%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2020%3B%20%5B4%2C%205%2C%206%5D)%3B%0A%0A%20%20%20%20assert_eq!(a%2C%20%5B11%2C%2012%2C%2013%2C%2024%2C%2025%2C%2026%5D)%3B%0A%7D%0A">Run</a></pre>

<p>That’s most of the matcher syntax. These examples use <code>$(...)*</code>, which is a
&quot;zero or more&quot; match. Alternatively you can write <code>$(...)+</code> for a &quot;one or
more&quot; match. Both forms optionally include a separator, which can be any token
except <code>+</code> or <code>*</code>.</p>

<p>This system is based on
&quot;<a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>&quot;
(PDF link).</p>

<h1 id='hygiene' class='section-header'><a href='#hygiene'>Hygiene</a></h1>
<p>Some languages implement macros using simple text substitution, which leads to
various problems. For example, this C program prints <code>13</code> instead of the
expected <code>25</code>.</p>

<pre><code class="language-text">#define FIVE_TIMES(x) 5 * x

int main() {
    printf(&quot;%d\n&quot;, FIVE_TIMES(2 + 3));
    return 0;
}
</code></pre>

<p>After expansion we have <code>5 * 2 + 3</code>, and multiplication has greater precedence
than addition. If you’ve used C macros a lot, you probably know the standard
idioms for avoiding this problem, as well as five or six others. In Rust, we
don’t have to worry about it.</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>five_times</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='number'>5</span> <span class='op'>*</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>25</span>, <span class='macro'>five_times</span><span class='macro'>!</span>(<span class='number'>2</span> <span class='op'>+</span> <span class='number'>3</span>));
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=macro_rules!%20five_times%20%7B%0A%20%20%20%20(%24x%3Aexpr)%20%3D%3E%20(5%20*%20%24x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20assert_eq!(25%2C%20five_times!(2%20%2B%203))%3B%0A%7D%0A">Run</a></pre>

<p>The metavariable <code>$x</code> is parsed as a single expression node, and keeps its
place in the syntax tree even after substitution.</p>

<p>Another common problem in macro systems is ‘variable capture’. Here’s a C
macro, using <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">a GNU C extension</a> to emulate Rust’s expression blocks.</p>

<pre><code class="language-text">#define LOG(msg) ({ \
    int state = get_log_state(); \
    if (state &gt; 0) { \
        printf(&quot;log(%d): %s\n&quot;, state, msg); \
    } \
})
</code></pre>

<p>Here’s a simple use case that goes terribly wrong:</p>

<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
LOG(state)
</code></pre>

<p>This expands to</p>

<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
{
    int state = get_log_state();
    if (state &gt; 0) {
        printf(&quot;log(%d): %s\n&quot;, state, state);
    }
}
</code></pre>

<p>The second variable named <code>state</code> shadows the first one.  This is a problem
because the print statement should refer to both of them.</p>

<p>The equivalent Rust macro has the desired behavior.</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>log</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msg</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {{
        <span class='kw'>let</span> <span class='ident'>state</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>get_log_state</span>();
        <span class='kw'>if</span> <span class='ident'>state</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;log({}): {}&quot;</span>, <span class='ident'>state</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msg</span>);
        }
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>state</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='string'>&quot;reticulating splines&quot;</span>;
    <span class='macro'>log</span><span class='macro'>!</span>(<span class='ident'>state</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20get_log_state()%20-%3E%20i32%20%7B%203%20%7D%0Amacro_rules!%20log%20%7B%0A%20%20%20%20(%24msg%3Aexpr)%20%3D%3E%20%7B%7B%0A%20%20%20%20%20%20%20%20let%20state%3A%20i32%20%3D%20get_log_state()%3B%0A%20%20%20%20%20%20%20%20if%20state%20%3E%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22log(%7B%7D)%3A%20%7B%7D%22%2C%20state%2C%20%24msg)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%7D%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20state%3A%20%26str%20%3D%20%22reticulating%20splines%22%3B%0A%20%20%20%20log!(state)%3B%0A%7D%0A">Run</a></pre>

<p>This works because Rust has a <a href="https://en.wikipedia.org/wiki/Hygienic_macro">hygienic macro system</a>. Each macro expansion
happens in a distinct ‘syntax context’, and each variable is tagged with the
syntax context where it was introduced. It’s as though the variable <code>state</code>
inside <code>main</code> is painted a different &quot;color&quot; from the variable <code>state</code> inside
the macro, and therefore they don’t conflict.</p>

<p>This also restricts the ability of macros to introduce new bindings at the
invocation site. Code such as the following will not work:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>;);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=macro_rules!%20foo%20%7B%0A%20%20%20%20()%20%3D%3E%20(let%20x%20%3D%203%3B)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20foo!()%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A">Run</a></pre>

<p>Instead you need to pass the variable name into the invocation, so that it’s
tagged with the right syntax context.</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span>:<span class='ident'>ident</span>) <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span> <span class='op'>=</span> <span class='number'>3</span>;);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>x</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=macro_rules!%20foo%20%7B%0A%20%20%20%20(%24v%3Aident)%20%3D%3E%20(let%20%24v%20%3D%203%3B)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20foo!(x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A">Run</a></pre>

<p>This holds for <code>let</code> bindings and loop labels, but not for <a href="../reference.html#items">items</a>.
So the following code does compile:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>fn</span> <span class='ident'>x</span>() { });
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='ident'>x</span>();
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=macro_rules!%20foo%20%7B%0A%20%20%20%20()%20%3D%3E%20(fn%20x()%20%7B%20%7D)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20foo!()%3B%0A%20%20%20%20x()%3B%0A%7D%0A">Run</a></pre>

<h1 id='recursive-macros' class='section-header'><a href='#recursive-macros'>Recursive macros</a></h1>
<p>A macro’s expansion can include more macro invocations, including invocations
of the very same macro being expanded.  These recursive macros are useful for
processing tree-structured input, as illustrated by this (simplistic) HTML
shorthand:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>write_html</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, ) <span class='op'>=&gt;</span> (());

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>tt</span>) <span class='op'>=&gt;</span> (<span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;{}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>:<span class='ident'>ident</span> [ $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>:<span class='ident'>tt</span>)<span class='op'>*</span> ] $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>:<span class='ident'>tt</span>)<span class='kw-2'>*</span>) <span class='op'>=&gt;</span> {{
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>)<span class='kw-2'>*</span>);
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;/{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>)<span class='kw-2'>*</span>);
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Write</span>;
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>out</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>out</span>,
        <span class='ident'>html</span>[
            <span class='ident'>head</span>[<span class='ident'>title</span>[<span class='string'>&quot;Macros guide&quot;</span>]]
            <span class='ident'>body</span>[<span class='ident'>h1</span>[<span class='string'>&quot;Macros are the best!&quot;</span>]]
        ]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>out</span>,
        <span class='string'>&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused_must_use)%5D%0Amacro_rules!%20write_html%20%7B%0A%20%20%20%20(%24w%3Aexpr%2C%20)%20%3D%3E%20(())%3B%0A%0A%20%20%20%20(%24w%3Aexpr%2C%20%24e%3Att)%20%3D%3E%20(write!(%24w%2C%20%22%7B%7D%22%2C%20%24e))%3B%0A%0A%20%20%20%20(%24w%3Aexpr%2C%20%24tag%3Aident%20%5B%20%24(%24inner%3Att)*%20%5D%20%24(%24rest%3Att)*)%20%3D%3E%20%7B%7B%0A%20%20%20%20%20%20%20%20write!(%24w%2C%20%22%3C%7B%7D%3E%22%2C%20stringify!(%24tag))%3B%0A%20%20%20%20%20%20%20%20write_html!(%24w%2C%20%24(%24inner)*)%3B%0A%20%20%20%20%20%20%20%20write!(%24w%2C%20%22%3C%2F%7B%7D%3E%22%2C%20stringify!(%24tag))%3B%0A%20%20%20%20%20%20%20%20write_html!(%24w%2C%20%24(%24rest)*)%3B%0A%20%20%20%20%7D%7D%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%2F%2F%20FIXME(%2321826)%0A%20%20%20%20use%20std%3A%3Afmt%3A%3AWrite%3B%0A%20%20%20%20let%20mut%20out%20%3D%20String%3A%3Anew()%3B%0A%0A%20%20%20%20write_html!(%26mut%20out%2C%0A%20%20%20%20%20%20%20%20html%5B%0A%20%20%20%20%20%20%20%20%20%20%20%20head%5Btitle%5B%22Macros%20guide%22%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20body%5Bh1%5B%22Macros%20are%20the%20best!%22%5D%5D%0A%20%20%20%20%20%20%20%20%5D)%3B%0A%0A%20%20%20%20assert_eq!(out%2C%0A%20%20%20%20%20%20%20%20%22%3Chtml%3E%3Chead%3E%3Ctitle%3EMacros%20guide%3C%2Ftitle%3E%3C%2Fhead%3E%5C%0A%20%20%20%20%20%20%20%20%20%3Cbody%3E%3Ch1%3EMacros%20are%20the%20best!%3C%2Fh1%3E%3C%2Fbody%3E%3C%2Fhtml%3E%22)%3B%0A%7D%0A">Run</a></pre>

<h1 id='debugging-macro-code' class='section-header'><a href='#debugging-macro-code'>Debugging macro code</a></h1>
<p>To see the results of expanding macros, run <code>rustc --pretty expanded</code>. The
output represents a whole crate, so you can also feed it back in to <code>rustc</code>,
which will sometimes produce better error messages than the original
compilation. Note that the <code>--pretty expanded</code> output may have a different
meaning if multiple variables of the same name (but different syntax contexts)
are in play in the same scope. In this case <code>--pretty expanded,hygiene</code> will
tell you about the syntax contexts.</p>

<p><code>rustc</code> provides two syntax extensions that help with macro debugging. For now,
they are unstable and require feature gates.</p>

<ul>
<li><p><code>log_syntax!(...)</code> will print its arguments to standard output, at compile
time, and &quot;expand&quot; to nothing.</p></li>
<li><p><code>trace_macros!(true)</code> will enable a compiler message every time a macro is
expanded. Use <code>trace_macros!(false)</code> later in expansion to turn it off.</p></li>
</ul>

<h1 id='syntactic-requirements' class='section-header'><a href='#syntactic-requirements'>Syntactic requirements</a></h1>
<p>Even when Rust code contains un-expanded macros, it can be parsed as a full
<a href="glossary.html#abstract-syntax-tree">syntax tree</a>. This property can be very useful for editors and other
tools that process code. It also has a few consequences for the design of
Rust’s macro system.</p>

<p>One consequence is that Rust must determine, when it parses a macro invocation,
whether the macro stands in for</p>

<ul>
<li>zero or more items,</li>
<li>zero or more methods,</li>
<li>an expression,</li>
<li>a statement, or</li>
<li>a pattern.</li>
</ul>

<p>A macro invocation within a block could stand for some items, or for an
expression / statement. Rust uses a simple rule to resolve this ambiguity. A
macro invocation that stands for items must be either</p>

<ul>
<li>delimited by curly braces, e.g. <code>foo! { ... }</code>, or</li>
<li>terminated by a semicolon, e.g. <code>foo!(...);</code></li>
</ul>

<p>Another consequence of pre-expansion parsing is that the macro invocation must
consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces
must be balanced within a macro invocation. For example, <code>foo!([)</code> is
forbidden. This allows Rust to know where the macro invocation ends.</p>

<p>More formally, the macro invocation body must be a sequence of ‘token trees’.
A token tree is defined recursively as either</p>

<ul>
<li>a sequence of token trees surrounded by matching <code>()</code>, <code>[]</code>, or <code>{}</code>, or</li>
<li>any other single token.</li>
</ul>

<p>Within a matcher, each metavariable has a ‘fragment specifier’, identifying
which syntactic form it matches.</p>

<ul>
<li><code>ident</code>: an identifier. Examples: <code>x</code>; <code>foo</code>.</li>
<li><code>path</code>: a qualified name. Example: <code>T::SpecialA</code>.</li>
<li><code>expr</code>: an expression. Examples: <code>2 + 2</code>; <code>if true { 1 } else { 2 }</code>; <code>f(42)</code>.</li>
<li><code>ty</code>: a type. Examples: <code>i32</code>; <code>Vec&lt;(char, String)&gt;</code>; <code>&amp;T</code>.</li>
<li><code>pat</code>: a pattern. Examples: <code>Some(t)</code>; <code>(17, &#39;a&#39;)</code>; <code>_</code>.</li>
<li><code>stmt</code>: a single statement. Example: <code>let x = 3</code>.</li>
<li><code>block</code>: a brace-delimited sequence of statements and optionally an expression. Example:
<code>{ log(error, &quot;hi&quot;); return 12; }</code>.</li>
<li><code>item</code>: an <a href="../reference.html#items">item</a>. Examples: <code>fn foo() { }</code>; <code>struct Bar;</code>.</li>
<li><code>meta</code>: a &quot;meta item&quot;, as found in attributes. Example: <code>cfg(target_os = &quot;windows&quot;)</code>.</li>
<li><code>tt</code>: a single token tree.</li>
</ul>

<p>There are additional rules regarding the next token after a metavariable:</p>

<ul>
<li><code>expr</code> and <code>stmt</code> variables may only be followed by one of: <code>=&gt; , ;</code></li>
<li><code>ty</code> and <code>path</code> variables may only be followed by one of: <code>=&gt; , = | ; : &gt; [ { as where</code></li>
<li><code>pat</code> variables may only be followed by one of: <code>=&gt; , = | if in</code></li>
<li>Other variables may be followed by any token.</li>
</ul>

<p>These rules provide some flexibility for Rust’s syntax to evolve without
breaking existing macros.</p>

<p>The macro system does not deal with parse ambiguity at all. For example, the
grammar <code>$($i:ident)* $e:expr</code> will always fail to parse, because the parser would
be forced to choose between parsing <code>$i</code> and parsing <code>$e</code>. Changing the
invocation syntax to put a distinctive token in front can solve the problem. In
this case, you can write <code>$(I $i:ident)* E $e:expr</code>.</p>

<h1 id='scoping-and-macro-importexport' class='section-header'><a href='#scoping-and-macro-importexport'>Scoping and macro import/export</a></h1>
<p>Macros are expanded at an early stage in compilation, before name resolution.
One downside is that scoping works differently for macros, compared to other
constructs in the language.</p>

<p>Definition and expansion of macros both happen in a single depth-first,
lexical-order traversal of a crate’s source. So a macro defined at module scope
is visible to any subsequent code in the same module, which includes the body
of any subsequent child <code>mod</code> items.</p>

<p>A macro defined within the body of a single <code>fn</code>, or anywhere else not at
module scope, is visible only within that item.</p>

<p>If a module has the <code>macro_use</code> attribute, its macros are also visible in its
parent module after the child’s <code>mod</code> item. If the parent also has <code>macro_use</code>
then the macros will be visible in the grandparent after the parent’s <code>mod</code>
item, and so forth.</p>

<p>The <code>macro_use</code> attribute can also appear on <code>extern crate</code>. In this context
it controls which macros are loaded from the external crate, e.g.</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_use</span>(<span class='ident'>foo</span>, <span class='ident'>bar</span>)]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>baz</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%23%5Bmacro_use(foo%2C%20bar)%5D%0Aextern%20crate%20baz%3B%0A%7D">Run</a></pre>

<p>If the attribute is given simply as <code>#[macro_use]</code>, all macros are loaded. If
there is no <code>#[macro_use]</code> attribute then no macros are loaded. Only macros
defined with the <code>#[macro_export]</code> attribute may be loaded.</p>

<p>To load a crate’s macros without linking it into the output, use <code>#[no_link]</code>
as well.</p>

<p>An example:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m1</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// Visible here: `m1`.</span>

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='comment'>// Visible here: `m1`.</span>

    <span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m2</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// Visible here: `m1`, `m2`.</span>
}

<span class='comment'>// Visible here: `m1`.</span>

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m3</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// Visible here: `m1`, `m3`.</span>

<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='comment'>// Visible here: `m1`, `m3`.</span>

    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m4</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// Visible here: `m1`, `m3`, `m4`.</span>
}

<span class='comment'>// Visible here: `m1`, `m3`, `m4`.</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=macro_rules!%20m1%20%7B%20()%20%3D%3E%20(())%20%7D%0A%0A%2F%2F%20Visible%20here%3A%20%60m1%60.%0A%0Amod%20foo%20%7B%0A%20%20%20%20%2F%2F%20Visible%20here%3A%20%60m1%60.%0A%0A%20%20%20%20%23%5Bmacro_export%5D%0A%20%20%20%20macro_rules!%20m2%20%7B%20()%20%3D%3E%20(())%20%7D%0A%0A%20%20%20%20%2F%2F%20Visible%20here%3A%20%60m1%60%2C%20%60m2%60.%0A%7D%0A%0A%2F%2F%20Visible%20here%3A%20%60m1%60.%0A%0Amacro_rules!%20m3%20%7B%20()%20%3D%3E%20(())%20%7D%0A%0A%2F%2F%20Visible%20here%3A%20%60m1%60%2C%20%60m3%60.%0A%0A%23%5Bmacro_use%5D%0Amod%20bar%20%7B%0A%20%20%20%20%2F%2F%20Visible%20here%3A%20%60m1%60%2C%20%60m3%60.%0A%0A%20%20%20%20macro_rules!%20m4%20%7B%20()%20%3D%3E%20(())%20%7D%0A%0A%20%20%20%20%2F%2F%20Visible%20here%3A%20%60m1%60%2C%20%60m3%60%2C%20%60m4%60.%0A%7D%0A%0A%2F%2F%20Visible%20here%3A%20%60m1%60%2C%20%60m3%60%2C%20%60m4%60.%0Afn%20main()%20%7B%20%7D%0A">Run</a></pre>

<p>When this library is loaded with <code>#[macro_use] extern crate</code>, only <code>m2</code> will
be imported.</p>

<p>The Rust Reference has a <a href="../reference.html#macro-related-attributes">listing of macro-related
attributes</a>.</p>

<h1 id='the-variable-crate' class='section-header'><a href='#the-variable-crate'>The variable <code>$crate</code></a></h1>
<p>A further difficulty occurs when a macro is used in multiple crates. Say that
<code>mylib</code> defines</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>increment</span>(<span class='ident'>x</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_a</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_b</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>mylib</span>::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=pub%20fn%20increment(x%3A%20u32)%20-%3E%20u32%20%7B%0A%20%20%20%20x%20%2B%201%0A%7D%0A%0A%23%5Bmacro_export%5D%0Amacro_rules!%20inc_a%20%7B%0A%20%20%20%20(%24x%3Aexpr)%20%3D%3E%20(%20%3A%3Aincrement(%24x)%20)%0A%7D%0A%0A%23%5Bmacro_export%5D%0Amacro_rules!%20inc_b%20%7B%0A%20%20%20%20(%24x%3Aexpr)%20%3D%3E%20(%20%3A%3Amylib%3A%3Aincrement(%24x)%20)%0A%7D%0Afn%20main()%20%7B%20%7D%0A">Run</a></pre>

<p><code>inc_a</code> only works within <code>mylib</code>, while <code>inc_b</code> only works outside the
library. Furthermore, <code>inc_b</code> will break if the user imports <code>mylib</code> under
another name.</p>

<p>Rust does not (yet) have a hygiene system for crate references, but it does
provide a simple workaround for this problem. Within a macro imported from a
crate named <code>foo</code>, the special macro variable <code>$crate</code> will expand to <code>::foo</code>.
By contrast, when a macro is defined and then used in the same crate, <code>$crate</code>
will expand to nothing. This means we can write</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( <span class='macro-nonterminal'>$</span><span class='kw'>crate</span>::<span class='macro-nonterminal'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23%5Bmacro_export%5D%0Amacro_rules!%20inc%20%7B%0A%20%20%20%20(%24x%3Aexpr)%20%3D%3E%20(%20%24crate%3A%3Aincrement(%24x)%20)%0A%7D%0Afn%20main()%20%7B%20%7D%0A">Run</a></pre>

<p>to define a single macro that works both inside and outside our library. The
function name will expand to either <code>::increment</code> or <code>::mylib::increment</code>.</p>

<p>To keep this system simple and correct, <code>#[macro_use] extern crate ...</code> may
only appear at the root of your crate, not inside <code>mod</code>.</p>

<h1 id='the-deep-end' class='section-header'><a href='#the-deep-end'>The deep end</a></h1>
<p>The introductory chapter mentioned recursive macros, but it did not give the
full story. Recursive macros are useful for another reason: Each recursive
invocation gives you another opportunity to pattern-match the macro’s
arguments.</p>

<p>As an extreme example, it is possible, though hardly advisable, to implement
the <a href="https://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise Cyclic Tag</a> automaton
within Rust’s macro system.</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>bct</span> {
    <span class='comment'>// cmd 0:  d ... =&gt; ...</span>
    (<span class='number'>0</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_d</span>:<span class='ident'>tt</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='kw-2'>*</span>, <span class='number'>0</span> ; ));
    (<span class='number'>0</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_d</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='kw-2'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='kw-2'>*</span>, <span class='number'>0</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='kw-2'>*</span>));

    <span class='comment'>// cmd 1p:  1 ... =&gt; 1 ... p</span>
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='number'>1</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='kw-2'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>));
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='number'>1</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='kw-2'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='kw-2'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; <span class='number'>1</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='kw-2'>*</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>));

    <span class='comment'>// cmd 1p:  0 ... =&gt; 0 ...</span>
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='kw-2'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='kw-2'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='kw-2'>*</span>));

    <span class='comment'>// Halt on empty data string:</span>
    ( $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; )
        <span class='op'>=&gt;</span> (());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amacro_rules!%20bct%20%7B%0A%20%20%20%20%2F%2F%20cmd%200%3A%20%20d%20...%20%3D%3E%20...%0A%20%20%20%20(0%2C%20%24(%24ps%3Att)%2C*%20%3B%20%24_d%3Att)%0A%20%20%20%20%20%20%20%20%3D%3E%20(bct!(%24(%24ps)%2C*%2C%200%20%3B%20))%3B%0A%20%20%20%20(0%2C%20%24(%24ps%3Att)%2C*%20%3B%20%24_d%3Att%2C%20%24(%24ds%3Att)%2C*)%0A%20%20%20%20%20%20%20%20%3D%3E%20(bct!(%24(%24ps)%2C*%2C%200%20%3B%20%24(%24ds)%2C*))%3B%0A%0A%20%20%20%20%2F%2F%20cmd%201p%3A%20%201%20...%20%3D%3E%201%20...%20p%0A%20%20%20%20(1%2C%20%24p%3Att%2C%20%24(%24ps%3Att)%2C*%20%3B%201)%0A%20%20%20%20%20%20%20%20%3D%3E%20(bct!(%24(%24ps)%2C*%2C%201%2C%20%24p%20%3B%201%2C%20%24p))%3B%0A%20%20%20%20(1%2C%20%24p%3Att%2C%20%24(%24ps%3Att)%2C*%20%3B%201%2C%20%24(%24ds%3Att)%2C*)%0A%20%20%20%20%20%20%20%20%3D%3E%20(bct!(%24(%24ps)%2C*%2C%201%2C%20%24p%20%3B%201%2C%20%24(%24ds)%2C*%2C%20%24p))%3B%0A%0A%20%20%20%20%2F%2F%20cmd%201p%3A%20%200%20...%20%3D%3E%200%20...%0A%20%20%20%20(1%2C%20%24p%3Att%2C%20%24(%24ps%3Att)%2C*%20%3B%20%24(%24ds%3Att)%2C*)%0A%20%20%20%20%20%20%20%20%3D%3E%20(bct!(%24(%24ps)%2C*%2C%201%2C%20%24p%20%3B%20%24(%24ds)%2C*))%3B%0A%0A%20%20%20%20%2F%2F%20Halt%20on%20empty%20data%20string%3A%0A%20%20%20%20(%20%24(%24ps%3Att)%2C*%20%3B%20)%0A%20%20%20%20%20%20%20%20%3D%3E%20(())%3B%0A%7D%0A%7D">Run</a></pre>

<p>Exercise: use macros to reduce duplication in the above definition of the
<code>bct!</code> macro.</p>

<h1 id='common-macros' class='section-header'><a href='#common-macros'>Common macros</a></h1>
<p>Here are some common macros you’ll see in Rust code.</p>

<h2 id='panic' class='section-header'><a href='#panic'>panic!</a></h2>
<p>This macro causes the current thread to panic. You can give it a message
to panic with:</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;oh no!&quot;</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apanic!(%22oh%20no!%22)%3B%0A%7D">Run</a></pre>

<h2 id='vec' class='section-header'><a href='#vec'>vec!</a></h2>
<p>The <code>vec!</code> macro is used throughout the book, so you’ve probably seen it
already. It creates <code>Vec&lt;T&gt;</code>s with ease:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%0A%7D">Run</a></pre>

<p>It also lets you make vectors with repeating values. For example, a hundred
zeroes:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0</span>; <span class='number'>100</span>];<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B0%3B%20100%5D%3B%0A%7D">Run</a></pre>

<h2 id='assert-and-assert_eq' class='section-header'><a href='#assert-and-assert_eq'>assert! and assert_eq!</a></h2>
<p>These two macros are used in tests. <code>assert!</code> takes a boolean. <code>assert_eq!</code>
takes two values and checks them for equality. <code>true</code> passes, <code>false</code> <code>panic!</code>s.
Like this:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// A-ok!</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='bool-val'>true</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='number'>3</span> <span class='op'>+</span> <span class='number'>2</span>);

<span class='comment'>// Nope :(</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='number'>5</span> <span class='op'>&lt;</span> <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='number'>3</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20A-ok!%0A%0Aassert!(true)%3B%0Aassert_eq!(5%2C%203%20%2B%202)%3B%0A%0A%2F%2F%20Nope%20%3A(%0A%0Aassert!(5%20%3C%203)%3B%0Aassert_eq!(5%2C%203)%3B%0A%7D">Run</a></pre>

<h2 id='try' class='section-header'><a href='#try'>try!</a></h2>
<p><code>try!</code> is used for error handling. It takes something that can return a
<code>Result&lt;T, E&gt;</code>, and gives <code>T</code> if it’s a <code>Ok&lt;T&gt;</code>, and <code>return</code>s with the
<code>Err(E)</code> if it’s that. Like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>));

    <span class='prelude-val'>Ok</span>(())
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Afs%3A%3AFile%3B%0A%0Afn%20foo()%20-%3E%20std%3A%3Aio%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20let%20f%20%3D%20try!(File%3A%3Acreate(%22foo.txt%22))%3B%0A%0A%20%20%20%20Ok(())%0A%7D%0A%7D">Run</a></pre>

<p>This is cleaner than doing this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>f</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>t</span>) <span class='op'>=&gt;</span> <span class='ident'>t</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>),
    };

    <span class='prelude-val'>Ok</span>(())
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Afs%3A%3AFile%3B%0A%0Afn%20foo()%20-%3E%20std%3A%3Aio%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20let%20f%20%3D%20File%3A%3Acreate(%22foo.txt%22)%3B%0A%0A%20%20%20%20let%20f%20%3D%20match%20f%20%7B%0A%20%20%20%20%20%20%20%20Ok(t)%20%3D%3E%20t%2C%0A%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20return%20Err(e)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20Ok(())%0A%7D%0A%7D">Run</a></pre>

<h2 id='unreachable' class='section-header'><a href='#unreachable'>unreachable!</a></h2>
<p>This macro is used when you think some code should never execute:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>if</span> <span class='bool-val'>false</span> {
    <span class='macro'>unreachable</span><span class='macro'>!</span>();
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aif%20false%20%7B%0A%20%20%20%20unreachable!()%3B%0A%7D%0A%7D">Run</a></pre>

<p>Sometimes, the compiler may make you have a different branch that you know
will never, ever run. In these cases, use this macro, so that if you end
up wrong, you’ll get a <code>panic!</code> about it.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-val'>None</span>;

<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='prelude-val'>Some</span>(_) <span class='op'>=&gt;</span> <span class='macro'>unreachable</span><span class='macro'>!</span>(),
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;I know x is None!&quot;</span>),
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%3A%20Option%3Ci32%3E%20%3D%20None%3B%0A%0Amatch%20x%20%7B%0A%20%20%20%20Some(_)%20%3D%3E%20unreachable!()%2C%0A%20%20%20%20None%20%3D%3E%20println!(%22I%20know%20x%20is%20None!%22)%2C%0A%7D%0A%7D">Run</a></pre>

<h2 id='unimplemented' class='section-header'><a href='#unimplemented'>unimplemented!</a></h2>
<p>The <code>unimplemented!</code> macro can be used when you’re trying to get your functions
to typecheck, and don’t want to worry about writing out the body of the
function. One example of this situation is implementing a trait with multiple
required methods, where you want to tackle one at a time. Define the others
as <code>unimplemented!</code> until you’re ready to write them.</p>

<h1 id='procedural-macros' class='section-header'><a href='#procedural-macros'>Procedural macros</a></h1>
<p>If Rust’s macro system can’t do what you need, you may want to write a
<a href="compiler-plugins.html">compiler plugin</a> instead. Compared to <code>macro_rules!</code>
macros, this is significantly more work, the interfaces are much less stable,
and bugs can be much harder to track down. In exchange you get the
flexibility of running arbitrary Rust code within the compiler. Syntax
extension plugins are sometimes called ‘procedural macros’ for this reason.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>The actual definition of <code>vec!</code> in libcollections differs from the
       one presented here, for reasons of efficiency and reusability.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>