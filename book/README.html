<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>The Rust Programming Language</title>

    <link rel="stylesheet" type="text/css" href="./rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a class='active' href='./README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='./getting-started.html'><b>2.</b> Getting Started</a>
<ul class='section'>
<li><a  href='./installing-rust.html'><b>2.1.</b> Installing Rust</a>
</li>
<li><a  href='./hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a  href='./hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='./learn-rust.html'><b>3.</b> Learn Rust</a>
<ul class='section'>
<li><a  href='./guessing-game.html'><b>3.1.</b> Guessing Game</a>
</li>
<li><a  href='./dining-philosophers.html'><b>3.2.</b> Dining Philosophers</a>
</li>
<li><a  href='./rust-inside-other-languages.html'><b>3.3.</b> Rust Inside Other Languages</a>
</li>
</ul>
</li>
<li><a  href='./effective-rust.html'><b>4.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='./the-stack-and-the-heap.html'><b>4.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='./testing.html'><b>4.2.</b> Testing</a>
</li>
<li><a  href='./conditional-compilation.html'><b>4.3.</b> Conditional Compilation</a>
</li>
<li><a  href='./documentation.html'><b>4.4.</b> Documentation</a>
</li>
<li><a  href='./iterators.html'><b>4.5.</b> Iterators</a>
</li>
<li><a  href='./concurrency.html'><b>4.6.</b> Concurrency</a>
</li>
<li><a  href='./error-handling.html'><b>4.7.</b> Error Handling</a>
</li>
<li><a  href='./choosing-your-guarantees.html'><b>4.8.</b> Choosing your Guarantees</a>
</li>
<li><a  href='./ffi.html'><b>4.9.</b> FFI</a>
</li>
<li><a  href='./borrow-and-asref.html'><b>4.10.</b> Borrow and AsRef</a>
</li>
<li><a  href='./release-channels.html'><b>4.11.</b> Release Channels</a>
</li>
</ul>
</li>
<li><a  href='./syntax-and-semantics.html'><b>5.</b> Syntax and Semantics</a>
<ul class='section'>
<li><a  href='./variable-bindings.html'><b>5.1.</b> Variable Bindings</a>
</li>
<li><a  href='./functions.html'><b>5.2.</b> Functions</a>
</li>
<li><a  href='./primitive-types.html'><b>5.3.</b> Primitive Types</a>
</li>
<li><a  href='./comments.html'><b>5.4.</b> Comments</a>
</li>
<li><a  href='./if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='./loops.html'><b>5.6.</b> Loops</a>
</li>
<li><a  href='./ownership.html'><b>5.7.</b> Ownership</a>
</li>
<li><a  href='./references-and-borrowing.html'><b>5.8.</b> References and Borrowing</a>
</li>
<li><a  href='./lifetimes.html'><b>5.9.</b> Lifetimes</a>
</li>
<li><a  href='./mutability.html'><b>5.10.</b> Mutability</a>
</li>
<li><a  href='./structs.html'><b>5.11.</b> Structs</a>
</li>
<li><a  href='./enums.html'><b>5.12.</b> Enums</a>
</li>
<li><a  href='./match.html'><b>5.13.</b> Match</a>
</li>
<li><a  href='./patterns.html'><b>5.14.</b> Patterns</a>
</li>
<li><a  href='./method-syntax.html'><b>5.15.</b> Method Syntax</a>
</li>
<li><a  href='./vectors.html'><b>5.16.</b> Vectors</a>
</li>
<li><a  href='./strings.html'><b>5.17.</b> Strings</a>
</li>
<li><a  href='./generics.html'><b>5.18.</b> Generics</a>
</li>
<li><a  href='./traits.html'><b>5.19.</b> Traits</a>
</li>
<li><a  href='./drop.html'><b>5.20.</b> Drop</a>
</li>
<li><a  href='./if-let.html'><b>5.21.</b> if let</a>
</li>
<li><a  href='./trait-objects.html'><b>5.22.</b> Trait Objects</a>
</li>
<li><a  href='./closures.html'><b>5.23.</b> Closures</a>
</li>
<li><a  href='./ufcs.html'><b>5.24.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='./crates-and-modules.html'><b>5.25.</b> Crates and Modules</a>
</li>
<li><a  href='./const-and-static.html'><b>5.26.</b> `const` and `static`</a>
</li>
<li><a  href='./attributes.html'><b>5.27.</b> Attributes</a>
</li>
<li><a  href='./type-aliases.html'><b>5.28.</b> `type` aliases</a>
</li>
<li><a  href='./casting-between-types.html'><b>5.29.</b> Casting between types</a>
</li>
<li><a  href='./associated-types.html'><b>5.30.</b> Associated Types</a>
</li>
<li><a  href='./unsized-types.html'><b>5.31.</b> Unsized Types</a>
</li>
<li><a  href='./operators-and-overloading.html'><b>5.32.</b> Operators and Overloading</a>
</li>
<li><a  href='./deref-coercions.html'><b>5.33.</b> Deref coercions</a>
</li>
<li><a  href='./macros.html'><b>5.34.</b> Macros</a>
</li>
<li><a  href='./raw-pointers.html'><b>5.35.</b> Raw Pointers</a>
</li>
<li><a  href='./unsafe.html'><b>5.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='./nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='./compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='./inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='./no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='./intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='./lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='./advanced-linking.html'><b>6.6.</b> Advanced linking</a>
</li>
<li><a  href='./benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='./box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='./slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='./associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
</ul>
</li>
<li><a  href='./glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='./academic-research.html'><b>8.</b> Academic Research</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">The Rust Programming Language</h1>
    <p>Welcome! This book will teach you about the <a href="https://www.rust-lang.org">Rust Programming Language</a>.
Rust is a systems programming language focused on three goals: safety, speed,
and concurrency. It maintains these goals without having a garbage collector,
making it a useful language for a number of use cases other languages aren’t
good at: embedding in other languages, programs with specific space and time
requirements, and writing low-level code, like device drivers and operating
systems. It improves on current languages targeting this space by having a
number of compile-time safety checks that produce no runtime overhead, while
eliminating all data races. Rust also aims to achieve ‘zero-cost abstractions’
even though some of these abstractions feel like those of a high-level
language. Even then, Rust still allows precise control like a low-level
language would.</p>

<p>“The Rust Programming Language” is split into eight sections. This introduction
is the first. After this:</p>

<ul>
<li><a href="getting-started.html">Getting started</a> - Set up your computer for Rust development.</li>
<li><a href="learn-rust.html">Learn Rust</a> - Learn Rust programming through small projects.</li>
<li><a href="effective-rust.html">Effective Rust</a> - Higher-level concepts for writing excellent Rust code.</li>
<li><a href="syntax-and-semantics.html">Syntax and Semantics</a> - Each bit of Rust, broken down into small chunks.</li>
<li><a href="nightly-rust.html">Nightly Rust</a> - Cutting-edge features that aren’t in stable builds yet.</li>
<li><a href="glossary.html">Glossary</a> - A reference of terms used in the book.</li>
<li><a href="academic-research.html">Academic Research</a> - Literature that influenced Rust.</li>
</ul>

<p>After reading this introduction, you’ll want to dive into either ‘Learn Rust’
or ‘Syntax and Semantics’, depending on your preference: ‘Learn Rust’ if you
want to dive in with a project, or ‘Syntax and Semantics’ if you prefer to
start small, and learn a single concept thoroughly before moving onto the next.
Copious cross-linking connects these parts together.</p>

<h3 id="contributing" class='section-header'><a
                           href="#contributing">Contributing</a></h3>
<p>The source files from which this book is generated can be found on Github:
<a href="https://github.com/rust-lang/rust/tree/master/src/doc/trpl">github.com/rust-lang/rust/tree/master/src/doc/trpl</a></p>

<h2 id="a-brief-introduction-to-rust" class='section-header'><a
                           href="#a-brief-introduction-to-rust">A brief introduction to Rust</a></h2>
<p>Is Rust a language you might be interested in? Let’s examine a few small code
samples to show off a few of its strengths.</p>

<p>The main concept that makes Rust unique is called ‘ownership’. Consider this
small example:</p>
<span class='rusttest'>fn main() {
    let mut x = vec![&quot;Hello&quot;, &quot;world&quot;];
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;Hello&quot;</span>, <span class='string'>&quot;world&quot;</span>];
}</pre>

<p>This program makes a <a href="variable-bindings.html">variable binding</a> named <code>x</code>. The value of this
binding is a <code>Vec&lt;T&gt;</code>, a ‘vector’, that we create through a <a href="macros.html">macro</a>
defined in the standard library. This macro is called <code>vec</code>, and we invoke
macros with a <code>!</code>. This follows a general principle of Rust: make things
explicit. Macros can do significantly more complicated things than function
calls, and so they’re visually distinct. The <code>!</code> also helps with parsing,
making tooling easier to write, which is also important.</p>

<p>We used <code>mut</code> to make <code>x</code> mutable: bindings are immutable by default in Rust.
We’ll be mutating this vector later in the example.</p>

<p>It’s also worth noting that we didn’t need a type annotation here: while Rust
is statically typed, we didn’t need to explicitly annotate the type. Rust has
type inference to balance out the power of static typing with the verbosity of
annotating types.</p>

<p>Rust prefers stack allocation to heap allocation: <code>x</code> is placed directly on the
stack. However, the <code>Vec&lt;T&gt;</code> type allocates space for the elements of the
vector on the heap. If you’re not familiar with this distinction, you can
ignore it for now, or check out <a href="the-stack-and-the-heap.html">‘The Stack and the Heap’</a>. As a systems
programming language, Rust gives you the ability to control how your memory is
allocated, but when we’re getting started, it’s less of a big deal.</p>

<p>Earlier, we mentioned that ‘ownership’ is the key new concept in Rust. In Rust
parlance, <code>x</code> is said to ‘own’ the vector. This means that when <code>x</code> goes out of
scope, the vector’s memory will be de-allocated. This is done deterministically
by the Rust compiler, rather than through a mechanism such as a garbage
collector. In other words, in Rust, you don’t call functions like <code>malloc</code> and
<code>free</code> yourself: the compiler statically determines when you need to allocate
or deallocate memory, and inserts those calls itself. To err is to be human,
but compilers never forget.</p>

<p>Let’s add another line to our example:</p>
<span class='rusttest'>fn main() {
    let mut x = vec![&quot;Hello&quot;, &quot;world&quot;];

    let y = &amp;x[0];
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;Hello&quot;</span>, <span class='string'>&quot;world&quot;</span>];

    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>[<span class='number'>0</span>];
}</pre>

<p>We’ve introduced another binding, <code>y</code>. In this case, <code>y</code> is a ‘reference’ to
the first element of the vector. Rust’s references are similar to pointers in
other languages, but with additional compile-time safety checks. References
interact with the ownership system by <a href="references-and-borrowing.html">‘borrowing’</a> what they point
to, rather than owning it. The difference is, when the reference goes out of
scope, it will not deallocate the underlying memory. If it did, we’d
de-allocate twice, which is bad!</p>

<p>Let’s add a third line. It looks innocent enough, but causes a compiler error:</p>
<span class='rusttest'>fn main() {
    let mut x = vec![&quot;Hello&quot;, &quot;world&quot;];

    let y = &amp;x[0];

    x.push(&quot;foo&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;Hello&quot;</span>, <span class='string'>&quot;world&quot;</span>];

    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>[<span class='number'>0</span>];

    <span class='ident'>x</span>.<span class='ident'>push</span>(<span class='string'>&quot;foo&quot;</span>);
}</pre>

<p><code>push</code> is a method on vectors that appends another element to the end of the
vector. When we try to compile this program, we get an error:</p>

<pre><code class="language-text">error: cannot borrow `x` as mutable because it is also borrowed as immutable
    x.push(&quot;foo&quot;);
    ^
note: previous borrow of `x` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `x` until the borrow ends
    let y = &amp;x[0];
             ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>

<p>Whew! The Rust compiler gives quite detailed errors at times, and this is one
of those times. As the error explains, while we made our binding mutable, we
still cannot call <code>push</code>. This is because we already have a reference to an
element of the vector, <code>y</code>. Mutating something while another reference exists
is dangerous, because we may invalidate the reference. In this specific case,
when we create the vector, we may have only allocated space for two elements.
Adding a third would mean allocating a new chunk of memory for all those elements,
copying the old values over, and updating the internal pointer to that memory.
That all works just fine. The problem is that <code>y</code> wouldn’t get updated, and so
we’d have a ‘dangling pointer’. That’s bad. Any use of <code>y</code> would be an error in
this case, and so the compiler has caught this for us.</p>

<p>So how do we solve this problem? There are two approaches we can take. The first
is making a copy rather than using a reference:</p>
<span class='rusttest'>fn main() {
    let mut x = vec![&quot;Hello&quot;, &quot;world&quot;];

    let y = x[0].clone();

    x.push(&quot;foo&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;Hello&quot;</span>, <span class='string'>&quot;world&quot;</span>];

    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>[<span class='number'>0</span>].<span class='ident'>clone</span>();

    <span class='ident'>x</span>.<span class='ident'>push</span>(<span class='string'>&quot;foo&quot;</span>);
}</pre>

<p>Rust has <a href="ownership.html#move-semantics">move semantics</a> by default, so if we want to make a copy of some
data, we call the <code>clone()</code> method. In this example, <code>y</code> is no longer a reference
to the vector stored in <code>x</code>, but a copy of its first element, <code>&quot;Hello&quot;</code>. Now
that we don’t have a reference, our <code>push()</code> works just fine.</p>

<p>If we truly want a reference, we need the other option: ensure that our reference
goes out of scope before we try to do the mutation. That looks like this:</p>
<span class='rusttest'>fn main() {
    let mut x = vec![&quot;Hello&quot;, &quot;world&quot;];

    {
        let y = &amp;x[0];
    }

    x.push(&quot;foo&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;Hello&quot;</span>, <span class='string'>&quot;world&quot;</span>];

    {
        <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>[<span class='number'>0</span>];
    }

    <span class='ident'>x</span>.<span class='ident'>push</span>(<span class='string'>&quot;foo&quot;</span>);
}</pre>

<p>We created an inner scope with an additional set of curly braces. <code>y</code> will go out of
scope before we call <code>push()</code>, and so we’re all good.</p>

<p>This concept of ownership isn’t just good for preventing dangling pointers, but an
entire set of related problems, like iterator invalidation, concurrency, and more.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    
<script type="text/javascript" src="rust-book.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>