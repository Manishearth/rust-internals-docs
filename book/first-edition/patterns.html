<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Patterns - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="README.html">Introduction</a></li><li><a href="getting-started.html"><strong>1.</strong> Getting Started</a></li><li><a href="guessing-game.html"><strong>2.</strong> Tutorial: Guessing Game</a></li><li><a href="syntax-and-semantics.html"><strong>3.</strong> Syntax and Semantics</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>3.1.</strong> Variable Bindings</a></li><li><a href="functions.html"><strong>3.2.</strong> Functions</a></li><li><a href="primitive-types.html"><strong>3.3.</strong> Primitive Types</a></li><li><a href="comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="if.html"><strong>3.5.</strong> if</a></li><li><a href="loops.html"><strong>3.6.</strong> Loops</a></li><li><a href="vectors.html"><strong>3.7.</strong> Vectors</a></li><li><a href="ownership.html"><strong>3.8.</strong> Ownership</a></li><li><a href="references-and-borrowing.html"><strong>3.9.</strong> References and Borrowing</a></li><li><a href="lifetimes.html"><strong>3.10.</strong> Lifetimes</a></li><li><a href="mutability.html"><strong>3.11.</strong> Mutability</a></li><li><a href="structs.html"><strong>3.12.</strong> Structs</a></li><li><a href="enums.html"><strong>3.13.</strong> Enums</a></li><li><a href="match.html"><strong>3.14.</strong> Match</a></li><li><a href="patterns.html" class="active"><strong>3.15.</strong> Patterns</a></li><li><a href="method-syntax.html"><strong>3.16.</strong> Method Syntax</a></li><li><a href="strings.html"><strong>3.17.</strong> Strings</a></li><li><a href="generics.html"><strong>3.18.</strong> Generics</a></li><li><a href="traits.html"><strong>3.19.</strong> Traits</a></li><li><a href="drop.html"><strong>3.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>3.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>3.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>3.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>3.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>3.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>3.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>3.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>3.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>3.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>3.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>3.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>3.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>3.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>3.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>3.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>3.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>4.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>4.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>4.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>4.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>4.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>4.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>4.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>4.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>4.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>4.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>4.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>4.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>4.12.</strong> Using Rust without the standard library</a></li><li><a href="procedural-macros.html"><strong>4.13.</strong> Procedural Macros (and custom derive)</a></li></ul></li><li><a href="glossary.html"><strong>5.</strong> Glossary</a></li><li><a href="syntax-index.html"><strong>6.</strong> Syntax Index</a></li><li><a href="bibliography.html"><strong>7.</strong> Bibliography</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="patterns.html#patterns" name="patterns"><h1>Patterns</h1></a>
<p>Patterns are quite common in Rust. We use them in <a href="variable-bindings.html">variable
bindings</a>, <a href="match.html">match expressions</a>, and other places, too. Let’s go
on a whirlwind tour of all of the things patterns can do!</p>
<p>A quick refresher: you can match against literals directly, and <code>_</code> acts as an
‘any’ case:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}

#}</code></pre></pre>
<p>This prints <code>one</code>.</p>
<p>It's possible to create a binding for the value in the any case:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    y =&gt; println!(&quot;x: {} y: {}&quot;, x, y),
}

#}</code></pre></pre>
<p>This prints:</p>
<pre><code class="language-text">x: 1 y: 1
</code></pre>
<p>Note it is an error to have both a catch-all <code>_</code> and a catch-all binding in the same match block:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    y =&gt; println!(&quot;x: {} y: {}&quot;, x, y),
    _ =&gt; println!(&quot;anything&quot;), // this causes an error as it is unreachable
}

#}</code></pre></pre>
<p>There’s one pitfall with patterns: like anything that introduces a new binding,
they introduce shadowing. For example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;
let c = 'c';

match c {
    x =&gt; println!(&quot;x: {} c: {}&quot;, x, c),
}

println!(&quot;x: {}&quot;, x)

#}</code></pre></pre>
<p>This prints:</p>
<pre><code class="language-text">x: c c: c
x: 1
</code></pre>
<p>In other words, <code>x =&gt;</code> matches the pattern and introduces a new binding named
<code>x</code>. This new binding is in scope for the match arm and takes on the value of
<code>c</code>. Notice that the value of <code>x</code> outside the scope of the match has no bearing
on the value of <code>x</code> within it. Because we already have a binding named <code>x</code>, this
new <code>x</code> shadows it.</p>
<a class="header" href="patterns.html#multiple-patterns" name="multiple-patterns"><h1>Multiple patterns</h1></a>
<p>You can match multiple patterns with <code>|</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}

#}</code></pre></pre>
<p>This prints <code>one or two</code>.</p>
<a class="header" href="patterns.html#destructuring" name="destructuring"><h1>Destructuring</h1></a>
<p>If you have a compound data type, like a <a href="structs.html"><code>struct</code></a>, you can destructure it
inside of a pattern:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, y } =&gt; println!(&quot;({},{})&quot;, x, y),
}

#}</code></pre></pre>
<p>We can use <code>:</code> to give a value a different name.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x1, y: y1 } =&gt; println!(&quot;({},{})&quot;, x1, y1),
}

#}</code></pre></pre>
<p>If we only care about some of the values, we don’t have to give them all names:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 2, y: 3 };

match point {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}

#}</code></pre></pre>
<p>This prints <code>x is 2</code>.</p>
<p>You can do this kind of match on any member, not only the first:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 2, y: 3 };

match point {
    Point { y, .. } =&gt; println!(&quot;y is {}&quot;, y),
}

#}</code></pre></pre>
<p>This prints <code>y is 3</code>.</p>
<p>This ‘destructuring’ behavior works on any compound data type, like
<a href="primitive-types.html#tuples">tuples</a> or <a href="enums.html">enums</a>.</p>
<a class="header" href="patterns.html#ignoring-bindings" name="ignoring-bindings"><h1>Ignoring bindings</h1></a>
<p>You can use <code>_</code> in a pattern to disregard the type and value.
For example, here’s a <code>match</code> against a <code>Result&lt;T, E&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
# let some_value: Result&lt;i32, &amp;'static str&gt; = Err(&quot;There was an error&quot;);
match some_value {
    Ok(value) =&gt; println!(&quot;got a value: {}&quot;, value),
    Err(_) =&gt; println!(&quot;an error occurred&quot;),
}

#}</code></pre></pre>
<p>In the first arm, we bind the value inside the <code>Ok</code> variant to <code>value</code>. But
in the <code>Err</code> arm, we use <code>_</code> to disregard the specific error, and print
a general error message.</p>
<p><code>_</code> is valid in any pattern that creates a binding. This can be useful to
ignore parts of a larger structure:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn coordinate() -&gt; (i32, i32, i32) {
    // Generate and return some sort of triple tuple.
# (1, 2, 3)
}

let (x, _, z) = coordinate();

#}</code></pre></pre>
<p>Here, we bind the first and last element of the tuple to <code>x</code> and <code>z</code>, but
ignore the middle element.</p>
<p>It’s worth noting that using <code>_</code> never binds the value in the first place,
which means that the value does not move:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let tuple: (u32, String) = (5, String::from(&quot;five&quot;));

// Here, tuple is moved, because the String moved:
let (x, _s) = tuple;

// The next line would give &quot;error: use of partially moved value: `tuple`&quot;.
// println!(&quot;Tuple is: {:?}&quot;, tuple);

// However,

let tuple = (5, String::from(&quot;five&quot;));

// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:
let (x, _) = tuple;

// That means this works:
println!(&quot;Tuple is: {:?}&quot;, tuple);

#}</code></pre></pre>
<p>This also means that any temporary variables will be dropped at the end of the
statement:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// Here, the String created will be dropped immediately, as it’s not bound:

let _ = String::from(&quot;  hello  &quot;).trim();

#}</code></pre></pre>
<p>You can also use <code>..</code> in a pattern to disregard multiple values:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) =&gt; println!(&quot;Got a tuple!&quot;),
    OptionalTuple::Missing =&gt; println!(&quot;No such luck.&quot;),
}

#}</code></pre></pre>
<p>This prints <code>Got a tuple!</code>.</p>
<a class="header" href="patterns.html#ref-and-ref-mut" name="ref-and-ref-mut"><h1>ref and ref mut</h1></a>
<p>If you want to get a <a href="references-and-borrowing.html">reference</a>, use the <code>ref</code> keyword:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 5;

match x {
    ref r =&gt; println!(&quot;Got a reference to {}&quot;, r),
}

#}</code></pre></pre>
<p>This prints <code>Got a reference to 5</code>.</p>
<p>Here, the <code>r</code> inside the <code>match</code> has the type <code>&amp;i32</code>. In other words, the <code>ref</code>
keyword <em>creates</em> a reference, for use in the pattern. If you need a mutable
reference, <code>ref mut</code> will work in the same way:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut x = 5;

match x {
    ref mut mr =&gt; println!(&quot;Got a mutable reference to {}&quot;, mr),
}

#}</code></pre></pre>
<a class="header" href="patterns.html#ranges" name="ranges"><h1>Ranges</h1></a>
<p>You can match a range of values with <code>...</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    1 ... 5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}

#}</code></pre></pre>
<p>This prints <code>one through five</code>.</p>
<p>Ranges are mostly used with integers and <code>char</code>s:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = '💅';

match x {
    'a' ... 'j' =&gt; println!(&quot;early letter&quot;),
    'k' ... 'z' =&gt; println!(&quot;late letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}

#}</code></pre></pre>
<p>This prints <code>something else</code>.</p>
<a class="header" href="patterns.html#bindings" name="bindings"><h1>Bindings</h1></a>
<p>You can bind values to names with <code>@</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}

#}</code></pre></pre>
<p>This prints <code>got a range element 1</code>. This is useful when you want to
do a complicated match of part of a data structure:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
#[derive(Debug)]
struct Person {
    name: Option&lt;String&gt;,
}

let name = &quot;Steve&quot;.to_string();
let x: Option&lt;Person&gt; = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) =&gt; println!(&quot;{:?}&quot;, a),
    _ =&gt; {}
}

#}</code></pre></pre>
<p>This prints <code>Some(&quot;Steve&quot;)</code>: we’ve bound the inner <code>name</code> to <code>a</code>.</p>
<p>If you use <code>@</code> with <code>|</code>, you need to make sure the name is bound in each part
of the pattern:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}

#}</code></pre></pre>
<a class="header" href="patterns.html#guards" name="guards"><h1>Guards</h1></a>
<p>You can introduce ‘match guards’ with <code>if</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i &gt; 5 =&gt; println!(&quot;Got an int bigger than five!&quot;),
    OptionalInt::Value(..) =&gt; println!(&quot;Got an int!&quot;),
    OptionalInt::Missing =&gt; println!(&quot;No such luck.&quot;),
}

#}</code></pre></pre>
<p>This prints <code>Got an int!</code>.</p>
<p>If you’re using <code>if</code> with multiple patterns, the <code>if</code> applies to both sides:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x = 4;
let y = false;

match x {
    4 | 5 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}

#}</code></pre></pre>
<p>This prints <code>no</code>, because the <code>if</code> applies to the whole of <code>4 | 5</code>, and not to
only the <code>5</code>. In other words, the precedence of <code>if</code> behaves like this:</p>
<pre><code class="language-text">(4 | 5) if y =&gt; ...
</code></pre>
<p>not this:</p>
<pre><code class="language-text">4 | (5 if y) =&gt; ...
</code></pre>
<a class="header" href="patterns.html#mix-and-match" name="mix-and-match"><h1>Mix and Match</h1></a>
<p>Whew! That’s a lot of different ways to match things, and they can all be
mixed and matched, depending on what you’re doing:</p>
<pre><code class="language-rust ignore">match x {
    Foo { x: Some(ref name), y: None } =&gt; ...
}
</code></pre>
<p>Patterns are very powerful. Make good use of them.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="match.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="method-syntax.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="match.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="method-syntax.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
