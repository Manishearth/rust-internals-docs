<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Crates and Modules</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Guessing Game</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Syntax and Semantics</a>
<ol class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Loops</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vectors</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Method Syntax</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Universal Function Call Syntax</a>
</li>
<li><a class='active' href='crates-and-modules.html'><b>4.25.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ol>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ol class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Error Handling</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Choosing your Guarantees</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Release Channels</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Using Rust without the standard library</a>
</li>
<li><a  href='procedural-macros.html'><b>5.13.</b> Procedural Macros (and custom derive)</a>
</li>
</ol>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ol class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Advanced linking</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Custom Allocators</a>
</li>
</ol>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Syntax Index</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> Bibliography</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Crates and Modules</h1>
    <p>When a project starts getting large, it’s considered good software
engineering practice to split it up into a bunch of smaller pieces, and then
fit them together. It is also important to have a well-defined interface, so
that some of your functionality is private, and some is public. To facilitate
these kinds of things, Rust has a module system.</p>

<h1 id='basic-terminology-crates-and-modules' class='section-header'><a href='#basic-terminology-crates-and-modules'>Basic terminology: Crates and Modules</a></h1>
<p>Rust has two distinct terms that relate to the module system: ‘crate’ and
‘module’. A crate is synonymous with a ‘library’ or ‘package’ in other
languages. Hence “Cargo” as the name of Rust’s package management tool: you
ship your crates to others with Cargo. Crates can produce an executable or a
library, depending on the project.</p>

<p>Each crate has an implicit <em>root module</em> that contains the code for that crate.
You can then define a tree of sub-modules under that root module. Modules allow
you to partition your code within the crate itself.</p>

<p>As an example, let’s make a <em>phrases</em> crate, which will give us various phrases
in different languages. To keep things simple, we’ll stick to ‘greetings’ and
‘farewells’ as two kinds of phrases, and use English and Japanese (日本語) as
two languages for those phrases to be in. We’ll use this module layout:</p>

<pre><code class="language-text">                                    +-----------+
                                +---| greetings |
                  +---------+   |   +-----------+
              +---| english |---+
              |   +---------+   |   +-----------+
              |                 +---| farewells |
+---------+   |                     +-----------+
| phrases |---+
+---------+   |                     +-----------+
              |                 +---| greetings |
              |   +----------+  |   +-----------+
              +---| japanese |--+
                  +----------+  |   +-----------+
                                +---| farewells |
                                    +-----------+
</code></pre>

<p>In this example, <code>phrases</code> is the name of our crate. All of the rest are
modules.  You can see that they form a tree, branching out from the crate
<em>root</em>, which is the root of the tree: <code>phrases</code> itself.</p>

<p>Now that we have a plan, let’s define these modules in code. To start,
generate a new crate with Cargo:</p>

<pre><code class="language-bash">$ cargo new phrases
$ cd phrases
</code></pre>

<p>If you remember, this generates a simple project for us:</p>

<pre><code class="language-bash">$ tree .
.
├── Cargo.toml
└── src
    └── lib.rs

1 directory, 2 files
</code></pre>

<p><code>src/lib.rs</code> is our crate root, corresponding to the <code>phrases</code> in our diagram
above.</p>

<h1 id='defining-modules' class='section-header'><a href='#defining-modules'>Defining Modules</a></h1>
<p>To define each of our modules, we use the <code>mod</code> keyword. Let’s make our
<code>src/lib.rs</code> look like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>english</span> {
    <span class='kw'>mod</span> <span class='ident'>greetings</span> {
    }

    <span class='kw'>mod</span> <span class='ident'>farewells</span> {
    }
}

<span class='kw'>mod</span> <span class='ident'>japanese</span> {
    <span class='kw'>mod</span> <span class='ident'>greetings</span> {
    }

    <span class='kw'>mod</span> <span class='ident'>farewells</span> {
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20english%20%7B%0A%20%20%20%20mod%20greetings%20%7B%0A%20%20%20%20%7D%0A%0A%20%20%20%20mod%20farewells%20%7B%0A%20%20%20%20%7D%0A%7D%0A%0Amod%20japanese%20%7B%0A%20%20%20%20mod%20greetings%20%7B%0A%20%20%20%20%7D%0A%0A%20%20%20%20mod%20farewells%20%7B%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>After the <code>mod</code> keyword, you give the name of the module. Module names follow
the conventions for other Rust identifiers: <code>lower_snake_case</code>. The contents of
each module are within curly braces (<code>{}</code>).</p>

<p>Within a given <code>mod</code>, you can declare sub-<code>mod</code>s. We can refer to sub-modules
with double-colon (<code>::</code>) notation: our four nested modules are
<code>english::greetings</code>, <code>english::farewells</code>, <code>japanese::greetings</code>, and
<code>japanese::farewells</code>. Because these sub-modules are namespaced under their
parent module, the names don’t conflict: <code>english::greetings</code> and
<code>japanese::greetings</code> are distinct, even though their names are both
<code>greetings</code>.</p>

<p>Because this crate does not have a <code>main()</code> function, and is called <code>lib.rs</code>,
Cargo will build this crate as a library:</p>

<pre><code class="language-bash">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
$ ls target/debug
build  deps  examples  libphrases-a7448e02a0468eaa.rlib  native
</code></pre>

<p><code>libphrases-&lt;hash&gt;.rlib</code> is the compiled crate. Before we see how to use this
crate from another crate, let’s break it up into multiple files.</p>

<h1 id='multiple-file-crates' class='section-header'><a href='#multiple-file-crates'>Multiple File Crates</a></h1>
<p>If each crate were just one file, these files would get very large. It’s often
easier to split up crates into multiple files, and Rust supports this in two
ways.</p>

<p>Instead of declaring a module like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>english</span> {
    <span class='comment'>// Contents of our module go here.</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20english%20%7B%0A%20%20%20%20%2F%2F%20Contents%20of%20our%20module%20go%20here.%0A%7D%0A%7D">Run</a></pre>

<p>We can instead declare our module like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>english</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20english%3B%0A%7D">Run</a></pre>

<p>If we do that, Rust will expect to find either a <code>english.rs</code> file, or a
<code>english/mod.rs</code> file with the contents of our module.</p>

<p>Note that in these files, you don’t need to re-declare the module: that’s
already been done with the initial <code>mod</code> declaration.</p>

<p>Using these two techniques, we can break up our crate into two directories and
seven files:</p>

<pre><code class="language-bash">$ tree .
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── english
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   ├── japanese
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   └── lib.rs
└── target
    └── debug
        ├── build
        ├── deps
        ├── examples
        ├── libphrases-a7448e02a0468eaa.rlib
        └── native
</code></pre>

<p><code>src/lib.rs</code> is our crate root, and looks like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>english</span>;
<span class='kw'>mod</span> <span class='ident'>japanese</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20english%3B%0Amod%20japanese%3B%0A%7D">Run</a></pre>

<p>These two declarations tell Rust to look for either <code>src/english.rs</code> and
<code>src/japanese.rs</code>, or <code>src/english/mod.rs</code> and <code>src/japanese/mod.rs</code>, depending
on our preference. In this case, because our modules have sub-modules, we’ve
chosen the second. Both <code>src/english/mod.rs</code> and <code>src/japanese/mod.rs</code> look
like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>greetings</span>;
<span class='kw'>mod</span> <span class='ident'>farewells</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20greetings%3B%0Amod%20farewells%3B%0A%7D">Run</a></pre>

<p>Again, these declarations tell Rust to look for either
<code>src/english/greetings.rs</code>, <code>src/english/farewells.rs</code>,
<code>src/japanese/greetings.rs</code> and <code>src/japanese/farewells.rs</code> or
<code>src/english/greetings/mod.rs</code>, <code>src/english/farewells/mod.rs</code>,
<code>src/japanese/greetings/mod.rs</code> and
<code>src/japanese/farewells/mod.rs</code>. Because these sub-modules don’t have
their own sub-modules, we’ve chosen to make them
<code>src/english/greetings.rs</code>, <code>src/english/farewells.rs</code>,
<code>src/japanese/greetings.rs</code> and <code>src/japanese/farewells.rs</code>. Whew!</p>

<p>The contents of <code>src/english/greetings.rs</code>,
<code>src/english/farewells.rs</code>, <code>src/japanese/greetings.rs</code> and
<code>src/japanese/farewells.rs</code> are all empty at the moment. Let’s add
some functions.</p>

<p>Put this in <code>src/english/greetings.rs</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>hello</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;Hello!&quot;</span>.<span class='ident'>to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20hello()%20-%3E%20String%20%7B%0A%20%20%20%20%22Hello!%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>Put this in <code>src/english/farewells.rs</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>goodbye</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;Goodbye.&quot;</span>.<span class='ident'>to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20goodbye()%20-%3E%20String%20%7B%0A%20%20%20%20%22Goodbye.%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>Put this in <code>src/japanese/greetings.rs</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>hello</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;こんにちは&quot;</span>.<span class='ident'>to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20hello()%20-%3E%20String%20%7B%0A%20%20%20%20%22%E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>Of course, you can copy and paste this from this web page, or type
something else. It’s not important that you actually put ‘konnichiwa’ to learn
about the module system.</p>

<p>Put this in <code>src/japanese/farewells.rs</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>goodbye</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;さようなら&quot;</span>.<span class='ident'>to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20goodbye()%20-%3E%20String%20%7B%0A%20%20%20%20%22%E3%81%95%E3%82%88%E3%81%86%E3%81%AA%E3%82%89%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>(This is ‘Sayōnara’, if you’re curious.)</p>

<p>Now that we have some functionality in our crate, let’s try to use it from
another crate.</p>

<h1 id='importing-external-crates' class='section-header'><a href='#importing-external-crates'>Importing External Crates</a></h1>
<p>We have a library crate. Let’s make an executable crate that imports and uses
our library.</p>

<p>Make a <code>src/main.rs</code> and put this in it (it won’t quite compile yet):</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>phrases</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello in English: {}&quot;</span>, <span class='ident'>phrases</span>::<span class='ident'>english</span>::<span class='ident'>greetings</span>::<span class='ident'>hello</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Goodbye in English: {}&quot;</span>, <span class='ident'>phrases</span>::<span class='ident'>english</span>::<span class='ident'>farewells</span>::<span class='ident'>goodbye</span>());

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello in Japanese: {}&quot;</span>, <span class='ident'>phrases</span>::<span class='ident'>japanese</span>::<span class='ident'>greetings</span>::<span class='ident'>hello</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Goodbye in Japanese: {}&quot;</span>, <span class='ident'>phrases</span>::<span class='ident'>japanese</span>::<span class='ident'>farewells</span>::<span class='ident'>goodbye</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20phrases%3A%3Aenglish%3A%3Agreetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20English%3A%20%7B%7D%22%2C%20phrases%3A%3Aenglish%3A%3Afarewells%3A%3Agoodbye())%3B%0A%0A%20%20%20%20println!(%22Hello%20in%20Japanese%3A%20%7B%7D%22%2C%20phrases%3A%3Ajapanese%3A%3Agreetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20Japanese%3A%20%7B%7D%22%2C%20phrases%3A%3Ajapanese%3A%3Afarewells%3A%3Agoodbye())%3B%0A%7D%0A">Run</a></pre>

<p>The <code>extern crate</code> declaration tells Rust that we need to compile and link to
the <code>phrases</code> crate. We can then use <code>phrases</code>’ modules in this one. As we
mentioned earlier, you can use double colons to refer to sub-modules and the
functions inside of them.</p>

<p>(Note: when importing a crate that has dashes in its name &quot;like-this&quot;, which is
not a valid Rust identifier, it will be converted by changing the dashes to
underscores, so you would write <code>extern crate like_this;</code>.)</p>

<p>Also, Cargo assumes that <code>src/main.rs</code> is the crate root of a binary crate,
rather than a library crate. Our package now has two crates: <code>src/lib.rs</code> and
<code>src/main.rs</code>. This pattern is quite common for executable crates: most
functionality is in a library crate, and the executable crate uses that
library. This way, other programs can also use the library crate, and it’s also
a nice separation of concerns.</p>

<p>This doesn’t quite work yet, though. We get four errors that look similar to
this:</p>

<pre><code class="language-bash">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:38: 4:72 error: function `hello` is private
src/main.rs:4     println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: in expansion of format_args!
&lt;std macros&gt;:2:25: 2:58 note: expansion site
&lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
&lt;std macros&gt;:3:1: 3:54 note: expansion site
&lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
phrases/src/main.rs:4:5: 4:76 note: expansion site
</code></pre>

<p>By default, everything is private in Rust. Let’s talk about this in some more
depth.</p>

<h1 id='exporting-a-public-interface' class='section-header'><a href='#exporting-a-public-interface'>Exporting a Public Interface</a></h1>
<p>Rust allows you to precisely control which aspects of your interface are
public, and so private is the default. To make things public, you use the <code>pub</code>
keyword. Let’s focus on the <code>english</code> module first, so let’s reduce our <code>src/main.rs</code>
to only this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>phrases</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello in English: {}&quot;</span>, <span class='ident'>phrases</span>::<span class='ident'>english</span>::<span class='ident'>greetings</span>::<span class='ident'>hello</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Goodbye in English: {}&quot;</span>, <span class='ident'>phrases</span>::<span class='ident'>english</span>::<span class='ident'>farewells</span>::<span class='ident'>goodbye</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20phrases%3A%3Aenglish%3A%3Agreetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20English%3A%20%7B%7D%22%2C%20phrases%3A%3Aenglish%3A%3Afarewells%3A%3Agoodbye())%3B%0A%7D%0A">Run</a></pre>

<p>In our <code>src/lib.rs</code>, let’s add <code>pub</code> to the <code>english</code> module declaration:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>english</span>;
<span class='kw'>mod</span> <span class='ident'>japanese</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20mod%20english%3B%0Amod%20japanese%3B%0A%7D">Run</a></pre>

<p>And in our <code>src/english/mod.rs</code>, let’s make both <code>pub</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>greetings</span>;
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>farewells</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20mod%20greetings%3B%0Apub%20mod%20farewells%3B%0A%7D">Run</a></pre>

<p>In our <code>src/english/greetings.rs</code>, let’s add <code>pub</code> to our <code>fn</code> declaration:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>hello</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;Hello!&quot;</span>.<span class='ident'>to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20hello()%20-%3E%20String%20%7B%0A%20%20%20%20%22Hello!%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>And also in <code>src/english/farewells.rs</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>goodbye</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;Goodbye.&quot;</span>.<span class='ident'>to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20goodbye()%20-%3E%20String%20%7B%0A%20%20%20%20%22Goodbye.%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>Now, our crate compiles, albeit with warnings about not using the <code>japanese</code>
functions:</p>

<pre><code class="language-bash">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/japanese/greetings.rs:1:1: 3:2 warning: function is never used: `hello`, #[warn(dead_code)] on by default
src/japanese/greetings.rs:1 fn hello() -&gt; String {
src/japanese/greetings.rs:2     &quot;こんにちは&quot;.to_string()
src/japanese/greetings.rs:3 }
src/japanese/farewells.rs:1:1: 3:2 warning: function is never used: `goodbye`, #[warn(dead_code)] on by default
src/japanese/farewells.rs:1 fn goodbye() -&gt; String {
src/japanese/farewells.rs:2     &quot;さようなら&quot;.to_string()
src/japanese/farewells.rs:3 }
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
</code></pre>

<p><code>pub</code> also applies to <code>struct</code>s and their member fields. In keeping with Rust’s
tendency toward safety, simply making a <code>struct</code> public won&#39;t automatically
make its members public: you must mark the fields individually with <code>pub</code>.</p>

<p>Now that our functions are public, we can use them. Great! However, typing out
<code>phrases::english::greetings::hello()</code> is very long and repetitive. Rust has
another keyword for importing names into the current scope, so that you can
refer to them with shorter names. Let’s talk about <code>use</code>.</p>

<h1 id='importing-modules-with-use' class='section-header'><a href='#importing-modules-with-use'>Importing Modules with <code>use</code></a></h1>
<p>Rust has a <code>use</code> keyword, which allows us to import names into our local scope.
Let’s change our <code>src/main.rs</code> to look like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>phrases</span>;

<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>english</span>::<span class='ident'>greetings</span>;
<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>english</span>::<span class='ident'>farewells</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello in English: {}&quot;</span>, <span class='ident'>greetings</span>::<span class='ident'>hello</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Goodbye in English: {}&quot;</span>, <span class='ident'>farewells</span>::<span class='ident'>goodbye</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Ause%20phrases%3A%3Aenglish%3A%3Agreetings%3B%0Ause%20phrases%3A%3Aenglish%3A%3Afarewells%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20greetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20English%3A%20%7B%7D%22%2C%20farewells%3A%3Agoodbye())%3B%0A%7D%0A">Run</a></pre>

<p>The two <code>use</code> lines import each module into the local scope, so we can refer to
the functions by a much shorter name. By convention, when importing functions, it’s
considered best practice to import the module, rather than the function directly. In
other words, you <em>can</em> do this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>phrases</span>;

<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>english</span>::<span class='ident'>greetings</span>::<span class='ident'>hello</span>;
<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>english</span>::<span class='ident'>farewells</span>::<span class='ident'>goodbye</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello in English: {}&quot;</span>, <span class='ident'>hello</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Goodbye in English: {}&quot;</span>, <span class='ident'>goodbye</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Ause%20phrases%3A%3Aenglish%3A%3Agreetings%3A%3Ahello%3B%0Ause%20phrases%3A%3Aenglish%3A%3Afarewells%3A%3Agoodbye%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20hello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20English%3A%20%7B%7D%22%2C%20goodbye())%3B%0A%7D%0A">Run</a></pre>

<p>But it is not idiomatic. This is significantly more likely to introduce a
naming conflict. In our short program, it’s not a big deal, but as it grows, it
becomes a problem. If we have conflicting names, Rust will give a compilation
error. For example, if we made the <code>japanese</code> functions public, and tried to do
this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>phrases</span>;

<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>english</span>::<span class='ident'>greetings</span>::<span class='ident'>hello</span>;
<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>japanese</span>::<span class='ident'>greetings</span>::<span class='ident'>hello</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello in English: {}&quot;</span>, <span class='ident'>hello</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello in Japanese: {}&quot;</span>, <span class='ident'>hello</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Ause%20phrases%3A%3Aenglish%3A%3Agreetings%3A%3Ahello%3B%0Ause%20phrases%3A%3Ajapanese%3A%3Agreetings%3A%3Ahello%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20hello())%3B%0A%20%20%20%20println!(%22Hello%20in%20Japanese%3A%20%7B%7D%22%2C%20hello())%3B%0A%7D%0A">Run</a></pre>

<p>Rust will give us a compile-time error:</p>

<pre><code class="language-text">   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module [E0252]
src/main.rs:4 use phrases::japanese::greetings::hello;
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `phrases`.
</code></pre>

<p>If we’re importing multiple names from the same module, we don’t have to type it out
twice. Instead of this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>english</span>::<span class='ident'>greetings</span>;
<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>english</span>::<span class='ident'>farewells</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20phrases%3A%3Aenglish%3A%3Agreetings%3B%0Ause%20phrases%3A%3Aenglish%3A%3Afarewells%3B%0A%7D">Run</a></pre>

<p>We can use this shortcut:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>english</span>::{<span class='ident'>greetings</span>, <span class='ident'>farewells</span>};<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20phrases%3A%3Aenglish%3A%3A%7Bgreetings%2C%20farewells%7D%3B%0A%7D">Run</a></pre>

<h2 id='re-exporting-with-pub-use' class='section-header'><a href='#re-exporting-with-pub-use'>Re-exporting with <code>pub use</code></a></h2>
<p>You don’t only use <code>use</code> to shorten identifiers. You can also use it inside of your crate
to re-export a function inside another module. This allows you to present an external
interface that may not directly map to your internal code organization.</p>

<p>Let’s look at an example. Modify your <code>src/main.rs</code> to read like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>phrases</span>;

<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>english</span>::{<span class='ident'>greetings</span>,<span class='ident'>farewells</span>};
<span class='kw'>use</span> <span class='ident'>phrases</span>::<span class='ident'>japanese</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello in English: {}&quot;</span>, <span class='ident'>greetings</span>::<span class='ident'>hello</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Goodbye in English: {}&quot;</span>, <span class='ident'>farewells</span>::<span class='ident'>goodbye</span>());

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello in Japanese: {}&quot;</span>, <span class='ident'>japanese</span>::<span class='ident'>hello</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Goodbye in Japanese: {}&quot;</span>, <span class='ident'>japanese</span>::<span class='ident'>goodbye</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Ause%20phrases%3A%3Aenglish%3A%3A%7Bgreetings%2Cfarewells%7D%3B%0Ause%20phrases%3A%3Ajapanese%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20greetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20English%3A%20%7B%7D%22%2C%20farewells%3A%3Agoodbye())%3B%0A%0A%20%20%20%20println!(%22Hello%20in%20Japanese%3A%20%7B%7D%22%2C%20japanese%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20Japanese%3A%20%7B%7D%22%2C%20japanese%3A%3Agoodbye())%3B%0A%7D%0A">Run</a></pre>

<p>Then, modify your <code>src/lib.rs</code> to make the <code>japanese</code> mod public:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>english</span>;
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>japanese</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20mod%20english%3B%0Apub%20mod%20japanese%3B%0A%7D">Run</a></pre>

<p>Next, make the two functions public, first in <code>src/japanese/greetings.rs</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>hello</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;こんにちは&quot;</span>.<span class='ident'>to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20hello()%20-%3E%20String%20%7B%0A%20%20%20%20%22%E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>And then in <code>src/japanese/farewells.rs</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>goodbye</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='string'>&quot;さようなら&quot;</span>.<span class='ident'>to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20goodbye()%20-%3E%20String%20%7B%0A%20%20%20%20%22%E3%81%95%E3%82%88%E3%81%86%E3%81%AA%E3%82%89%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>Finally, modify your <code>src/japanese/mod.rs</code> to read like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='self'>self</span>::<span class='ident'>greetings</span>::<span class='ident'>hello</span>;
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='self'>self</span>::<span class='ident'>farewells</span>::<span class='ident'>goodbye</span>;

<span class='kw'>mod</span> <span class='ident'>greetings</span>;
<span class='kw'>mod</span> <span class='ident'>farewells</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20use%20self%3A%3Agreetings%3A%3Ahello%3B%0Apub%20use%20self%3A%3Afarewells%3A%3Agoodbye%3B%0A%0Amod%20greetings%3B%0Amod%20farewells%3B%0A%7D">Run</a></pre>

<p>The <code>pub use</code> declaration brings the function into scope at this part of our
module hierarchy. Because we’ve <code>pub use</code>d this inside of our <code>japanese</code>
module, we now have a <code>phrases::japanese::hello()</code> function and a
<code>phrases::japanese::goodbye()</code> function, even though the code for them lives in
<code>phrases::japanese::greetings::hello()</code> and
<code>phrases::japanese::farewells::goodbye()</code>. Our internal organization doesn’t
define our external interface.</p>

<p>Here we have a <code>pub use</code> for each function we want to bring into the
<code>japanese</code> scope. We could alternatively use the wildcard syntax to include
everything from <code>greetings</code> into the current scope: <code>pub use self::greetings::*</code>.</p>

<p>What about the <code>self</code>? Well, by default, <code>use</code> declarations are absolute paths,
starting from your crate root. <code>self</code> makes that path relative to your current
place in the hierarchy instead. There’s one more special form of <code>use</code>: you can
<code>use super::</code> to reach one level up the tree from your current location. Some
people like to think of <code>self</code> as <code>.</code> and <code>super</code> as <code>..</code>, from many shells’
display for the current directory and the parent directory.</p>

<p>Outside of <code>use</code>, paths are relative: <code>foo::bar()</code> refers to a function inside
of <code>foo</code> relative to where we are. If that’s prefixed with <code>::</code>, as in
<code>::foo::bar()</code>, it refers to a different <code>foo</code>, an absolute path from your
crate root.</p>

<p>This will build and run:</p>

<pre><code class="language-bash">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
Hello in Japanese: こんにちは
Goodbye in Japanese: さようなら
</code></pre>

<h2 id='complex-imports' class='section-header'><a href='#complex-imports'>Complex imports</a></h2>
<p>Rust offers several advanced options that can add compactness and
convenience to your <code>extern crate</code> and <code>use</code> statements. Here is an example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>phrases</span> <span class='kw'>as</span> <span class='ident'>sayings</span>;

<span class='kw'>use</span> <span class='ident'>sayings</span>::<span class='ident'>japanese</span>::<span class='ident'>greetings</span> <span class='kw'>as</span> <span class='ident'>ja_greetings</span>;
<span class='kw'>use</span> <span class='ident'>sayings</span>::<span class='ident'>japanese</span>::<span class='ident'>farewells</span>::<span class='kw-2'>*</span>;
<span class='kw'>use</span> <span class='ident'>sayings</span>::<span class='ident'>english</span>::{<span class='self'>self</span>, <span class='ident'>greetings</span> <span class='kw'>as</span> <span class='ident'>en_greetings</span>, <span class='ident'>farewells</span> <span class='kw'>as</span> <span class='ident'>en_farewells</span>};

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello in English; {}&quot;</span>, <span class='ident'>en_greetings</span>::<span class='ident'>hello</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;And in Japanese: {}&quot;</span>, <span class='ident'>ja_greetings</span>::<span class='ident'>hello</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Goodbye in English: {}&quot;</span>, <span class='ident'>english</span>::<span class='ident'>farewells</span>::<span class='ident'>goodbye</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Again: {}&quot;</span>, <span class='ident'>en_farewells</span>::<span class='ident'>goodbye</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;And in Japanese: {}&quot;</span>, <span class='ident'>goodbye</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%20as%20sayings%3B%0A%0Ause%20sayings%3A%3Ajapanese%3A%3Agreetings%20as%20ja_greetings%3B%0Ause%20sayings%3A%3Ajapanese%3A%3Afarewells%3A%3A*%3B%0Ause%20sayings%3A%3Aenglish%3A%3A%7Bself%2C%20greetings%20as%20en_greetings%2C%20farewells%20as%20en_farewells%7D%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3B%20%7B%7D%22%2C%20en_greetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22And%20in%20Japanese%3A%20%7B%7D%22%2C%20ja_greetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20English%3A%20%7B%7D%22%2C%20english%3A%3Afarewells%3A%3Agoodbye())%3B%0A%20%20%20%20println!(%22Again%3A%20%7B%7D%22%2C%20en_farewells%3A%3Agoodbye())%3B%0A%20%20%20%20println!(%22And%20in%20Japanese%3A%20%7B%7D%22%2C%20goodbye())%3B%0A%7D%0A">Run</a></pre>

<p>What&#39;s going on here?</p>

<p>First, both <code>extern crate</code> and <code>use</code> allow renaming the thing that is being
imported. So the crate is still called &quot;phrases&quot;, but here we will refer
to it as &quot;sayings&quot;. Similarly, the first <code>use</code> statement pulls in the
<code>japanese::greetings</code> module from the crate, but makes it available as
<code>ja_greetings</code> as opposed to simply <code>greetings</code>. This can help to avoid
ambiguity when importing similarly-named items from different places.</p>

<p>The second <code>use</code> statement uses a star glob to bring in all public symbols from
the <code>sayings::japanese::farewells</code> module. As you can see we can later refer to
the Japanese <code>goodbye</code> function with no module qualifiers. This kind of glob
should be used sparingly. It’s worth noting that it only imports the public
symbols, even if the code doing the globbing is in the same module.</p>

<p>The third <code>use</code> statement bears more explanation. It&#39;s using &quot;brace expansion&quot;
globbing to compress three <code>use</code> statements into one (this sort of syntax
may be familiar if you&#39;ve written Linux shell scripts before). The
uncompressed form of this statement would be:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>sayings</span>::<span class='ident'>english</span>;
<span class='kw'>use</span> <span class='ident'>sayings</span>::<span class='ident'>english</span>::<span class='ident'>greetings</span> <span class='kw'>as</span> <span class='ident'>en_greetings</span>;
<span class='kw'>use</span> <span class='ident'>sayings</span>::<span class='ident'>english</span>::<span class='ident'>farewells</span> <span class='kw'>as</span> <span class='ident'>en_farewells</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20sayings%3A%3Aenglish%3B%0Ause%20sayings%3A%3Aenglish%3A%3Agreetings%20as%20en_greetings%3B%0Ause%20sayings%3A%3Aenglish%3A%3Afarewells%20as%20en_farewells%3B%0A%7D">Run</a></pre>

<p>As you can see, the curly brackets compress <code>use</code> statements for several items
under the same path, and in this context <code>self</code> refers back to that path.
Note: The curly brackets cannot be nested or mixed with star globbing.</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>