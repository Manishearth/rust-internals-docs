<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Ownership</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Guessing Game</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Syntax and Semantics</a>
<ol class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Loops</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vectors</a>
</li>
<li><a class='active' href='ownership.html'><b>4.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Method Syntax</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ol>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ol class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Error Handling</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Choosing your Guarantees</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Release Channels</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Using Rust without the standard library</a>
</li>
<li><a  href='procedural-macros.html'><b>5.13.</b> Procedural Macros (and custom derive)</a>
</li>
</ol>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ol class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Advanced linking</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Custom Allocators</a>
</li>
</ol>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Syntax Index</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> Bibliography</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Ownership</h1>
    <p>This is the first of three sections presenting Rust’s ownership system. This is one of
Rust’s most distinct and compelling features, with which Rust developers should
become quite acquainted. Ownership is how Rust achieves its largest goal,
memory safety. There are a few distinct concepts, each with its own
chapter:</p>

<ul>
<li>ownership, which you’re reading now</li>
<li><a href="references-and-borrowing.html">borrowing</a>, and their associated feature ‘references’</li>
<li><a href="lifetimes.html">lifetimes</a>, an advanced concept of borrowing</li>
</ul>

<p>These three chapters are related, and in order. You’ll need all three to fully
understand the ownership system.</p>

<h1 id='meta' class='section-header'><a href='#meta'>Meta</a></h1>
<p>Before we get to the details, two important notes about the ownership system.</p>

<p>Rust has a focus on safety and speed. It accomplishes these goals through many
‘zero-cost abstractions’, which means that in Rust, abstractions cost as little
as possible in order to make them work. The ownership system is a prime example
of a zero-cost abstraction. All of the analysis we’ll talk about in this guide
is <em>done at compile time</em>. You do not pay any run-time cost for any of these
features.</p>

<p>However, this system does have a certain cost: learning curve. Many new users
to Rust experience something we like to call ‘fighting with the borrow
checker’, where the Rust compiler refuses to compile a program that the author
thinks is valid. This often happens because the programmer’s mental model of
how ownership should work doesn’t match the actual rules that Rust implements.
You probably will experience similar things at first. There is good news,
however: more experienced Rust developers report that once they work with the
rules of the ownership system for a period of time, they fight the borrow
checker less and less.</p>

<p>With that in mind, let’s learn about ownership.</p>

<h1 id='ownership' class='section-header'><a href='#ownership'>Ownership</a></h1>
<p><a href="variable-bindings.html">Variable bindings</a> have a property in Rust: they ‘have ownership’
of what they’re bound to. This means that when a binding goes out of scope,
Rust will free the bound resources. For example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {
    <span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo()%20%7B%0A%20%20%20%20let%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%7D%0A%7D">Run</a></pre>

<p>When <code>v</code> comes into scope, a new <a href="vectors.html">vector</a> is created on <a href="the-stack-and-the-heap.html#the-stack">the stack</a>,
and it allocates space on <a href="the-stack-and-the-heap.html#the-heap">the heap</a> for its elements. When <code>v</code> goes out
of scope at the end of <code>foo()</code>, Rust will clean up everything related to the
vector, even the heap-allocated memory. This happens deterministically, at the
end of the scope.</p>

<p>We covered <a href="vectors.html">vectors</a> in the previous chapter; we use them
here as an example of a type that allocates space on the heap at runtime. They
behave like <a href="primitive-types.html#arrays">arrays</a>, except their size may change by <code>push()</code>ing more
elements onto them.</p>

<p>Vectors have a <a href="generics.html">generic type</a> <code>Vec&lt;T&gt;</code>, so in this example <code>v</code> will have type
<code>Vec&lt;i32&gt;</code>. We&#39;ll cover <a href="generics.html">generics</a> in detail in a later chapter.</p>

<h1 id='move-semantics' class='section-header'><a href='#move-semantics'>Move semantics</a></h1>
<p>There’s some more subtlety here, though: Rust ensures that there is <em>exactly
one</em> binding to any given resource. For example, if we have a vector, we can
assign it to another binding:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0Alet%20v2%20%3D%20v%3B%0A%7D">Run</a></pre>

<p>But, if we try to use <code>v</code> afterwards, we get an error:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;v[0] is: {}&quot;</span>, <span class='ident'>v</span>[<span class='number'>0</span>]);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0Alet%20v2%20%3D%20v%3B%0A%0Aprintln!(%22v%5B0%5D%20is%3A%20%7B%7D%22%2C%20v%5B0%5D)%3B%0A%7D">Run</a></pre>

<p>It looks like this:</p>

<pre><code class="language-text">error: use of moved value: `v`
println!(&quot;v[0] is: {}&quot;, v[0]);
                        ^
</code></pre>

<p>A similar thing happens if we define a function which takes ownership, and
try to use something after we’ve passed it as an argument:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>take</span>(<span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) {
    <span class='comment'>// What happens here isn’t important.</span>
}

<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='ident'>take</span>(<span class='ident'>v</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;v[0] is: {}&quot;</span>, <span class='ident'>v</span>[<span class='number'>0</span>]);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20take(v%3A%20Vec%3Ci32%3E)%20%7B%0A%20%20%20%20%2F%2F%20What%20happens%20here%20isn%E2%80%99t%20important.%0A%7D%0A%0Alet%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0Atake(v)%3B%0A%0Aprintln!(%22v%5B0%5D%20is%3A%20%7B%7D%22%2C%20v%5B0%5D)%3B%0A%7D">Run</a></pre>

<p>Same error: ‘use of moved value’. When we transfer ownership to something else,
we say that we’ve ‘moved’ the thing we refer to. You don’t need some sort of
special annotation here, it’s the default thing that Rust does.</p>

<h2 id='the-details' class='section-header'><a href='#the-details'>The details</a></h2>
<p>The reason that we cannot use a binding after we’ve moved it is subtle, but
important.</p>

<p>When we write code like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>10</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%20%3D%2010%3B%0A%7D">Run</a></pre>

<p>Rust allocates memory for an integer <a href="primitive-types.html#numeric-types">i32</a> on the <a href="the-stack-and-the-heap.html">stack</a>, copies the bit
pattern representing the value of 10 to the allocated memory and binds the
variable name x to this memory region for future reference.</p>

<p>Now consider the following code fragment:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0Alet%20mut%20v2%20%3D%20v%3B%0A%7D">Run</a></pre>

<p>The first line allocates memory for the vector object <code>v</code> on the stack like
it does for <code>x</code> above. But in addition to that it also allocates some memory
on the <a href="the-stack-and-the-heap.html">heap</a> for the actual data (<code>[1, 2, 3]</code>). Rust copies the address
of this heap allocation to an internal pointer, which is part of the vector
object placed on the stack (let&#39;s call it the data pointer).</p>

<p>It is worth pointing out (even at the risk of stating the obvious) that the
vector object and its data live in separate memory regions instead of being a
single contiguous memory allocation (due to reasons we will not go into at
this point of time). These two parts of the vector (the one on the stack and
one on the heap) must agree with each other at all times with regards to
things like the length, capacity, etc.</p>

<p>When we move <code>v</code> to <code>v2</code>, Rust actually does a bitwise copy of the vector
object <code>v</code> into the stack allocation represented by <code>v2</code>. This shallow copy
does not create a copy of the heap allocation containing the actual data.
Which means that there would be two pointers to the contents of the vector
both pointing to the same memory allocation on the heap. It would violate
Rust’s safety guarantees by introducing a data race if one could access both
<code>v</code> and <code>v2</code> at the same time.</p>

<p>For example if we truncated the vector to just two elements through <code>v2</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>v2</span>.<span class='ident'>truncate</span>(<span class='number'>2</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Alet%20mut%20v2%20%3D%20v%3B%0Av2.truncate(2)%3B%0A%7D">Run</a></pre>

<p>and <code>v</code> were still accessible we&#39;d end up with an invalid vector since <code>v</code>
would not know that the heap data has been truncated. Now, the part of the
vector <code>v</code> on the stack does not agree with the corresponding part on the
heap. <code>v</code> still thinks there are three elements in the vector and will
happily let us access the non existent element <code>v[2]</code> but as you might
already know this is a recipe for disaster. Especially because it might lead
to a segmentation fault or worse allow an unauthorized user to read from
memory to which they don&#39;t have access.</p>

<p>This is why Rust forbids using <code>v</code> after we’ve done the move.</p>

<p>It’s also important to note that optimizations may remove the actual copy of
the bytes on the stack, depending on circumstances. So it may not be as
inefficient as it initially seems.</p>

<h2 id='copy-types' class='section-header'><a href='#copy-types'><code>Copy</code> types</a></h2>
<p>We’ve established that when ownership is transferred to another binding, you
cannot use the original binding. However, there’s a <a href="traits.html">trait</a> that changes this
behavior, and it’s called <code>Copy</code>. We haven’t discussed traits yet, but for now,
you can think of them as an annotation to a particular type that adds extra
behavior. For example:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='number'>1</span>;

<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;v is: {}&quot;</span>, <span class='ident'>v</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20v%20%3D%201%3B%0A%0Alet%20v2%20%3D%20v%3B%0A%0Aprintln!(%22v%20is%3A%20%7B%7D%22%2C%20v)%3B%0A%7D">Run</a></pre>

<p>In this case, <code>v</code> is an <code>i32</code>, which implements the <code>Copy</code> trait. This means
that, just like a move, when we assign <code>v</code> to <code>v2</code>, a copy of the data is made.
But, unlike a move, we can still use <code>v</code> afterward. This is because an <code>i32</code>
has no pointers to data somewhere else, copying it is a full copy.</p>

<p>All primitive types implement the <code>Copy</code> trait and their ownership is
therefore not moved like one would assume, following the ‘ownership rules’.
To give an example, the two following snippets of code only compile because the
<code>i32</code> and <code>bool</code> types implement the <code>Copy</code> trait.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='kw'>let</span> <span class='ident'>_y</span> <span class='op'>=</span> <span class='ident'>double</span>(<span class='ident'>a</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>);
}

<span class='kw'>fn</span> <span class='ident'>double</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>2</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%205%3B%0A%0A%20%20%20%20let%20_y%20%3D%20double(a)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0A%0Afn%20double(x%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20x%20*%202%0A%7D%0A">Run</a></pre>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='bool-val'>true</span>;

    <span class='kw'>let</span> <span class='ident'>_y</span> <span class='op'>=</span> <span class='ident'>change_truth</span>(<span class='ident'>a</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>);
}

<span class='kw'>fn</span> <span class='ident'>change_truth</span>(<span class='ident'>x</span>: <span class='ident'>bool</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='op'>!</span><span class='ident'>x</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20true%3B%0A%0A%20%20%20%20let%20_y%20%3D%20change_truth(a)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0A%0Afn%20change_truth(x%3A%20bool)%20-%3E%20bool%20%7B%0A%20%20%20%20!x%0A%7D%0A">Run</a></pre>

<p>If we had used types that do not implement the <code>Copy</code> trait,
we would have gotten a compile error because we tried to use a moved value.</p>

<pre><code class="language-text">error: use of moved value: `a`
println!(&quot;{}&quot;, a);
               ^
</code></pre>

<p>We will discuss how to make your own types <code>Copy</code> in the <a href="traits.html">traits</a>
section.</p>

<h1 id='more-than-ownership' class='section-header'><a href='#more-than-ownership'>More than ownership</a></h1>
<p>Of course, if we had to hand ownership back with every function we wrote:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> {
    <span class='comment'>// Do stuff with `v`.</span>

    <span class='comment'>// Hand back ownership.</span>
    <span class='ident'>v</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo(v%3A%20Vec%3Ci32%3E)%20-%3E%20Vec%3Ci32%3E%20%7B%0A%20%20%20%20%2F%2F%20Do%20stuff%20with%20%60v%60.%0A%0A%20%20%20%20%2F%2F%20Hand%20back%20ownership.%0A%20%20%20%20v%0A%7D%0A%7D">Run</a></pre>

<p>This would get very tedious. It gets worse the more things we want to take ownership of:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>v1</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>v2</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> (<span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>i32</span>) {
    <span class='comment'>// Do stuff with `v1` and `v2`.</span>

    <span class='comment'>// Hand back ownership, and the result of our function.</span>
    (<span class='ident'>v1</span>, <span class='ident'>v2</span>, <span class='number'>42</span>)
}

<span class='kw'>let</span> <span class='ident'>v1</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> (<span class='ident'>v1</span>, <span class='ident'>v2</span>, <span class='ident'>answer</span>) <span class='op'>=</span> <span class='ident'>foo</span>(<span class='ident'>v1</span>, <span class='ident'>v2</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo(v1%3A%20Vec%3Ci32%3E%2C%20v2%3A%20Vec%3Ci32%3E)%20-%3E%20(Vec%3Ci32%3E%2C%20Vec%3Ci32%3E%2C%20i32)%20%7B%0A%20%20%20%20%2F%2F%20Do%20stuff%20with%20%60v1%60%20and%20%60v2%60.%0A%0A%20%20%20%20%2F%2F%20Hand%20back%20ownership%2C%20and%20the%20result%20of%20our%20function.%0A%20%20%20%20(v1%2C%20v2%2C%2042)%0A%7D%0A%0Alet%20v1%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Alet%20v2%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0Alet%20(v1%2C%20v2%2C%20answer)%20%3D%20foo(v1%2C%20v2)%3B%0A%7D">Run</a></pre>

<p>Ugh! The return type, return line, and calling the function gets way more
complicated.</p>

<p>Luckily, Rust offers a feature which helps us solve this problem.
It’s called borrowing and is the topic of the next section!</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>