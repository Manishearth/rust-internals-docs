<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Closures</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='./README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Installing Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Learn Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> Guessing Game</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> Dining Philosophers</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust Inside Other Languages</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Error Handling</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Release Channels</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Syntax and Semantics</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='for-loops.html'><b>5.6.</b> for loops</a>
</li>
<li><a  href='while-loops.html'><b>5.7.</b> while loops</a>
</li>
<li><a  href='ownership.html'><b>5.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>5.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>5.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>5.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>5.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>5.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>5.16.</b> Method Syntax</a>
</li>
<li><a  href='vectors.html'><b>5.17.</b> Vectors</a>
</li>
<li><a  href='strings.html'><b>5.18.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>5.19.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>5.20.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.21.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.22.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.23.</b> Trait Objects</a>
</li>
<li><a class='active' href='closures.html'><b>5.24.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.25.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.26.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>5.27.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>5.28.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>5.29.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>5.30.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>5.31.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>5.32.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.33.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>5.34.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>5.35.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.36.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>5.37.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Link args</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Academic Research</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Closures</h1>
    <p>Rust not only has named functions, but anonymous functions as well. Anonymous
functions that have an associated environment are called ‘closures’, because they
close over an environment. Rust has a really great implementation of them, as
we’ll see.</p>

<h1 id="syntax" class='section-header'><a
                           href="#syntax">Syntax</a></h1>
<p>Closures look like this:</p>
<span class='rusttest'>fn main() {
    let plus_one = |x: i32| x + 1;
    
    assert_eq!(2, plus_one(1));
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>plus_one</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>2</span>, <span class='ident'>plus_one</span>(<span class='number'>1</span>));
</pre>

<p>We create a binding, <code>plus_one</code>, and assign it to a closure. The closure’s
arguments go between the pipes (<code>|</code>), and the body is an expression, in this
case, <code>x + 1</code>. Remember that <code>{ }</code> is an expression, so we can have multi-line
closures too:</p>
<span class='rusttest'>fn main() {
    let plus_two = |x| {
        let mut result: i32 = x;
    
        result += 1;
        result += 1;
    
        result
    };
    
    assert_eq!(4, plus_two(2));
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>plus_two</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>result</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>x</span>;

    <span class='ident'>result</span> <span class='op'>+=</span> <span class='number'>1</span>;
    <span class='ident'>result</span> <span class='op'>+=</span> <span class='number'>1</span>;

    <span class='ident'>result</span>
};

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>plus_two</span>(<span class='number'>2</span>));
</pre>

<p>You’ll notice a few things about closures that are a bit different than regular
functions defined with <code>fn</code>. The first of which is that we did not need to
annotate the types of arguments the closure takes or the values it returns. We
can:</p>
<span class='rusttest'>fn main() {
    let plus_one = |x: i32| -&gt; i32 { x + 1 };
    
    assert_eq!(2, plus_one(1));
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>plus_one</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> };

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>2</span>, <span class='ident'>plus_one</span>(<span class='number'>1</span>));
</pre>

<p>But we don’t have to. Why is this? Basically, it was chosen for ergonomic reasons.
While specifying the full type for named functions is helpful with things like
documentation and type inference, the types of closures are rarely documented
since they’re anonymous, and they don’t cause the kinds of error-at-a-distance
that inferring named function types can.</p>

<p>The second is that the syntax is similar, but a bit different. I’ve added spaces
here to make them look a little closer:</p>
<span class='rusttest'>fn main() {
    fn  plus_one_v1   (x: i32) -&gt; i32 { x + 1 }
    let plus_one_v2 = |x: i32| -&gt; i32 { x + 1 };
    let plus_one_v3 = |x: i32|          x + 1  ;
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span>  <span class='ident'>plus_one_v1</span>   (<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }
<span class='kw'>let</span> <span class='ident'>plus_one_v2</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> };
<span class='kw'>let</span> <span class='ident'>plus_one_v3</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span>          <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>  ;
</pre>

<p>Small differences, but they’re similar in ways.</p>

<h1 id="closures-and-their-environment" class='section-header'><a
                           href="#closures-and-their-environment">Closures and their environment</a></h1>
<p>Closures are called such because they ‘close over their environment’. It
looks like this:</p>
<span class='rusttest'>fn main() {
    let num = 5;
    let plus_num = |x: i32| x + num;
    
    assert_eq!(10, plus_num(5));
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>plus_num</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>10</span>, <span class='ident'>plus_num</span>(<span class='number'>5</span>));
</pre>

<p>This closure, <code>plus_num</code>, refers to a <code>let</code> binding in its scope: <code>num</code>. More
specifically, it borrows the binding. If we do something that would conflict
with that binding, we get an error. Like this one:</p>
<span class='rusttest'>fn main() {
    let mut num = 5;
    let plus_num = |x: i32| x + num;
    
    let y = &amp;mut num;
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='ident'>plus_num</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>;

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>num</span>;
</pre>

<p>Which errors with:</p>

<pre><code class="language-text">error: cannot borrow `num` as mutable because it is also borrowed as immutable
    let y = &amp;mut num;
                 ^~~
note: previous borrow of `num` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `num` until the borrow
  ends
    let plus_num = |x| x + num;
                   ^~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut num = 5;
    let plus_num = |x| x + num;
    
    let y = &amp;mut num;
}
^
</code></pre>

<p>A verbose yet helpful error message! As it says, we can’t take a mutable borrow
on <code>num</code> because the closure is already borrowing it. If we let the closure go
out of scope, we can:</p>
<span class='rusttest'>fn main() {
    let mut num = 5;
    {
        let plus_num = |x: i32| x + num;
    
    } // plus_num goes out of scope, borrow of num ends
    
    let y = &amp;mut num;
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;
{
    <span class='kw'>let</span> <span class='ident'>plus_num</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>;

} <span class='comment'>// plus_num goes out of scope, borrow of num ends</span>

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>num</span>;
</pre>

<p>If your closure requires it, however, Rust will take ownership and move
the environment instead:</p>
<span class='rusttest'>fn main() {
    let nums = vec![1, 2, 3];
    
    let takes_nums = || nums;
    
    println!(&quot;{:?}&quot;, nums);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>nums</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='ident'>takes_nums</span> <span class='op'>=</span> <span class='op'>||</span> <span class='ident'>nums</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>nums</span>);
</pre>

<p>This gives us:</p>

<pre><code class="language-text">note: `nums` moved into closure environment here because it has type
  `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
let takes_nums = || nums;
                 ^~~~~~~
</code></pre>

<p><code>Vec&lt;T&gt;</code> has ownership over its contents, and therefore, when we refer to it
in our closure, we have to take ownership of <code>nums</code>. It’s the same as if we’d
passed <code>nums</code> to a function that took ownership of it.</p>

<h2 id="move-closures" class='section-header'><a
                           href="#move-closures"><code>move</code> closures</a></h2>
<p>We can force our closure to take ownership of its environment with the <code>move</code>
keyword:</p>
<span class='rusttest'>fn main() {
    let num = 5;
    
    let owns_num = move |x: i32| x + num;
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

<span class='kw'>let</span> <span class='ident'>owns_num</span> <span class='op'>=</span> <span class='kw'>move</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>;
</pre>

<p>Now, even though the keyword is <code>move</code>, the variables follow normal move semantics.
In this case, <code>5</code> implements <code>Copy</code>, and so <code>owns_num</code> takes ownership of a copy
of <code>num</code>. So what’s the difference?</p>
<span class='rusttest'>fn main() {
    let mut num = 5;
    
    { 
        let mut add_num = |x: i32| num += x;
    
        add_num(5);
    }
    
    assert_eq!(10, num);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

{ 
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>add_num</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>num</span> <span class='op'>+=</span> <span class='ident'>x</span>;

    <span class='ident'>add_num</span>(<span class='number'>5</span>);
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>10</span>, <span class='ident'>num</span>);
</pre>

<p>So in this case, our closure took a mutable reference to <code>num</code>, and then when
we called <code>add_num</code>, it mutated the underlying value, as we’d expect. We also
needed to declare <code>add_num</code> as <code>mut</code> too, because we’re mutating its
environment.</p>

<p>If we change to a <code>move</code> closure, it’s different:</p>
<span class='rusttest'>fn main() {
    let mut num = 5;
    
    { 
        let mut add_num = move |x: i32| num += x;
    
        add_num(5);
    }
    
    assert_eq!(5, num);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

{ 
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>add_num</span> <span class='op'>=</span> <span class='kw'>move</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='ident'>num</span> <span class='op'>+=</span> <span class='ident'>x</span>;

    <span class='ident'>add_num</span>(<span class='number'>5</span>);
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='ident'>num</span>);
</pre>

<p>We only get <code>5</code>. Rather than taking a mutable borrow out on our <code>num</code>, we took
ownership of a copy.</p>

<p>Another way to think about <code>move</code> closures: they give a closure its own stack
frame.  Without <code>move</code>, a closure may be tied to the stack frame that created
it, while a <code>move</code> closure is self-contained. This means that you cannot
generally return a non-<code>move</code> closure from a function, for example.</p>

<p>But before we talk about taking and returning closures, we should talk some more
about the way that closures are implemented. As a systems language, Rust gives
you tons of control over what your code does, and closures are no different.</p>

<h1 id="closure-implementation" class='section-header'><a
                           href="#closure-implementation">Closure implementation</a></h1>
<p>Rust’s implementation of closures is a bit different than other languages. They
are effectively syntax sugar for traits. You’ll want to make sure to have read
the <a href="traits.html">traits chapter</a> before this one, as well as the chapter on <a href="trait-objects.html">trait
objects</a>.</p>

<p>Got all that? Good.</p>

<p>The key to understanding how closures work under the hood is something a bit
strange: Using <code>()</code> to call a function, like <code>foo()</code>, is an overloadable
operator. From this, everything else clicks into place. In Rust, we use the
trait system to overload operators. Calling functions is no different. We have
three separate traits to overload with:</p>
<span class='rusttest'>fn main() {
    mod foo {
    pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
        extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
    }
    
    pub trait FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {
        extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
    }
    
    pub trait FnOnce&lt;Args&gt; {
        type Output;
    
        extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
    }
    }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Fn</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> : <span class='ident'>FnMut</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> {
    <span class='kw'>extern</span> <span class='string'>&quot;rust-call&quot;</span> <span class='kw'>fn</span> <span class='ident'>call</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>args</span>: <span class='ident'>Args</span>) <span class='op'>-&gt;</span> <span class='ident'>Self</span>::<span class='ident'>Output</span>;
}

<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>FnMut</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> : <span class='ident'>FnOnce</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> {
    <span class='kw'>extern</span> <span class='string'>&quot;rust-call&quot;</span> <span class='kw'>fn</span> <span class='ident'>call_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>args</span>: <span class='ident'>Args</span>) <span class='op'>-&gt;</span> <span class='ident'>Self</span>::<span class='ident'>Output</span>;
}

<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>FnOnce</span><span class='op'>&lt;</span><span class='ident'>Args</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span>;

    <span class='kw'>extern</span> <span class='string'>&quot;rust-call&quot;</span> <span class='kw'>fn</span> <span class='ident'>call_once</span>(<span class='self'>self</span>, <span class='ident'>args</span>: <span class='ident'>Args</span>) <span class='op'>-&gt;</span> <span class='ident'>Self</span>::<span class='ident'>Output</span>;
}
</pre>

<p>You’ll notice a few differences between these traits, but a big one is <code>self</code>:
<code>Fn</code> takes <code>&amp;self</code>, <code>FnMut</code> takes <code>&amp;mut self</code>, and <code>FnOnce</code> takes <code>self</code>. This
covers all three kinds of <code>self</code> via the usual method call syntax. But we’ve
split them up into three traits, rather than having a single one. This gives us
a large amount of control over what kind of closures we can take.</p>

<p>The <code>|| {}</code> syntax for closures is sugar for these three traits. Rust will
generate a struct for the environment, <code>impl</code> the appropriate trait, and then
use it.</p>

<h1 id="taking-closures-as-arguments" class='section-header'><a
                           href="#taking-closures-as-arguments">Taking closures as arguments</a></h1>
<p>Now that we know that closures are traits, we already know how to accept and
return closures: just like any other trait!</p>

<p>This also means that we can choose static vs dynamic dispatch as well. First,
let’s write a function which takes something callable, calls it, and returns
the result:</p>
<span class='rusttest'>fn main() {
    fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
        where F : Fn(i32) -&gt; i32 {
    
        some_closure(1)
    }
    
    let answer = call_with_one(|x| x + 2);
    
    assert_eq!(3, answer);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>call_with_one</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>some_closure</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>
    <span class='kw'>where</span> <span class='ident'>F</span> : <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {

    <span class='ident'>some_closure</span>(<span class='number'>1</span>)
}

<span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='ident'>call_with_one</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>2</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>3</span>, <span class='ident'>answer</span>);
</pre>

<p>We pass our closure, <code>|x| x + 2</code>, to <code>call_with_one</code>. It just does what it
suggests: it calls the closure, giving it <code>1</code> as an argument.</p>

<p>Let’s examine the signature of <code>call_with_one</code> in more depth:</p>
<span class='rusttest'>fn main() {
    fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
       where F : Fn(i32) -&gt; i32 {
       some_closure(1) }
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>call_with_one</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>some_closure</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>
</pre>

<p>We take one parameter, and it has the type <code>F</code>. We also return a <code>i32</code>. This part
isn’t interesting. The next part is:</p>
<span class='rusttest'>fn main() {
    fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
        where F : Fn(i32) -&gt; i32 {
      some_closure(1) }
    
}</span><pre id='rust-example-rendered' class='rust '>
    <span class='kw'>where</span> <span class='ident'>F</span> : <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
</pre>

<p>Because <code>Fn</code> is a trait, we can bound our generic with it. In this case, our closure
takes a <code>i32</code> as an argument and returns an <code>i32</code>, and so the generic bound we use
is <code>Fn(i32) -&gt; i32</code>.</p>

<p>There’s one other key point here: because we’re bounding a generic with a
trait, this will get monomorphized, and therefore, we’ll be doing static
dispatch into the closure. That’s pretty neat. In many languages, closures are
inherently heap allocated, and will always involve dynamic dispatch. In Rust,
we can stack allocate our closure environment, and statically dispatch the
call. This happens quite often with iterators and their adapters, which often
take closures as arguments.</p>

<p>Of course, if we want dynamic dispatch, we can get that too. A trait object
handles this case, as usual:</p>
<span class='rusttest'>fn main() {
    fn call_with_one(some_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
        some_closure(1)
    }
    
    let answer = call_with_one(&amp;|x| x + 2);
    
    assert_eq!(3, answer);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>call_with_one</span>(<span class='ident'>some_closure</span>: <span class='kw-2'>&amp;</span><span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>some_closure</span>(<span class='number'>1</span>)
}

<span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='ident'>call_with_one</span>(<span class='kw-2'>&amp;</span><span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>2</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>3</span>, <span class='ident'>answer</span>);
</pre>

<p>Now we take a trait object, a <code>&amp;Fn</code>. And we have to make a reference
to our closure when we pass it to <code>call_with_one</code>, so we use <code>&amp;||</code>.</p>

<h1 id="returning-closures" class='section-header'><a
                           href="#returning-closures">Returning closures</a></h1>
<p>It’s very common for functional-style code to return closures in various
situations. If you try to return a closure, you may run into an error. At
first, it may seem strange, but we’ll figure it out. Here’s how you’d probably
try to return a closure from a function:</p>
<span class='rusttest'>fn main() {
    fn factory() -&gt; (Fn(i32) -&gt; Vec&lt;i32&gt;) {
        let vec = vec![1, 2, 3];
    
        |n| vec.push(n)
    }
    
    let f = factory();
    
    let answer = f(4);
    assert_eq!(vec![1, 2, 3, 4], answer);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> (<span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) {
    <span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

    <span class='op'>|</span><span class='ident'>n</span><span class='op'>|</span> <span class='ident'>vec</span>.<span class='ident'>push</span>(<span class='ident'>n</span>)
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>4</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>], <span class='ident'>answer</span>);
</pre>

<p>This gives us these long, related errors:</p>

<pre><code class="language-text">error: the trait `core::marker::Sized` is not implemented for the type
`core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` [E0277]
f = factory();
^
note: `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` does not have a
constant size known at compile-time
f = factory();
^
error: the trait `core::marker::Sized` is not implemented for the type
`core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` [E0277]
factory() -&gt; (Fn(i32) -&gt; Vec&lt;i32&gt;) {
             ^~~~~~~~~~~~~~~~~~~~~
note: `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` does not have a constant size known at compile-time
factory() -&gt; (Fn(i32) -&gt; Vec&lt;i32&gt;) {
             ^~~~~~~~~~~~~~~~~~~~~

</code></pre>

<p>In order to return something from a function, Rust needs to know what
size the return type is. But since <code>Fn</code> is a trait, it could be various
things of various sizes: many different types can implement <code>Fn</code>. An easy
way to give something a size is to take a reference to it, as references
have a known size. So we’d write this:</p>
<span class='rusttest'>fn main() {
    fn factory() -&gt; &amp;(Fn(i32) -&gt; Vec&lt;i32&gt;) {
        let vec = vec![1, 2, 3];
    
        |n| vec.push(n)
    }
    
    let f = factory();
    
    let answer = f(4);
    assert_eq!(vec![1, 2, 3, 4], answer);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span>(<span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) {
    <span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

    <span class='op'>|</span><span class='ident'>n</span><span class='op'>|</span> <span class='ident'>vec</span>.<span class='ident'>push</span>(<span class='ident'>n</span>)
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>4</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>], <span class='ident'>answer</span>);
</pre>

<p>But we get another error:</p>

<pre><code class="language-text">error: missing lifetime specifier [E0106]
fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~~
</code></pre>

<p>Right. Because we have a reference, we need to give it a lifetime. But
our <code>factory()</code> function takes no arguments, so elision doesn’t kick in
here. What lifetime can we choose? <code>&#39;static</code>:</p>
<span class='rusttest'>fn main() {
    fn factory() -&gt; &amp;&#39;static (Fn(i32) -&gt; i32) {
        let num = 5;
    
        |x| x + num
    }
    
    let f = factory();
    
    let answer = f(1);
    assert_eq!(6, answer);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> (<span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>) {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>answer</span>);
</pre>

<p>But we get another error:</p>

<pre><code class="language-text">error: mismatched types:
 expected `&amp;&#39;static core::ops::Fn(i32) -&gt; i32`,
    found `[closure &lt;anon&gt;:7:9: 7:20]`
(expected &amp;-ptr,
    found closure) [E0308]
         |x| x + num
         ^~~~~~~~~~~

</code></pre>

<p>This error is letting us know that we don’t have a <code>&amp;&#39;static Fn(i32) -&gt; i32</code>,
we have a <code>[closure &lt;anon&gt;:7:9: 7:20]</code>. Wait, what?</p>

<p>Because each closure generates its own environment <code>struct</code> and implementation
of <code>Fn</code> and friends, these types are anonymous. They exist just solely for
this closure. So Rust shows them as <code>closure &lt;anon&gt;</code>, rather than some
autogenerated name.</p>

<p>But why doesn’t our closure implement <code>&amp;&#39;static Fn</code>? Well, as we discussed before,
closures borrow their environment. And in this case, our environment is based
on a stack-allocated <code>5</code>, the <code>num</code> variable binding. So the borrow has a lifetime
of the stack frame. So if we returned this closure, the function call would be
over, the stack frame would go away, and our closure is capturing an environment
of garbage memory!</p>

<p>So what to do? This <em>almost</em> works:</p>
<span class='rusttest'>fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(|x| x + num)
}
fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
}
</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>)
}
<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>answer</span>);
</pre>

<p>We use a trait object, by <code>Box</code>ing up the <code>Fn</code>. There’s just one last problem:</p>

<pre><code class="language-text">error: `num` does not live long enough
Box::new(|x| x + num)
         ^~~~~~~~~~~
</code></pre>

<p>We still have a reference to the parent stack frame. With one last fix, we can
make this work:</p>
<span class='rusttest'>fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(move |x| x + num)
}
fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
}
</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>factory</span>() <span class='op'>-&gt;</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='kw'>move</span> <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>num</span>)
}
<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>factory</span>();

<span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>6</span>, <span class='ident'>answer</span>);
</pre>

<p>By making the inner closure a <code>move Fn</code>, we create a new stack frame for our
closure. By <code>Box</code>ing it up, we’ve given it a known size, and allowing it to
escape our stack frame.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>