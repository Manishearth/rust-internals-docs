<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Strings</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='./README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
<ul class='section'>
<li><a  href='installing-rust.html'><b>2.1.</b> Installing Rust</a>
</li>
<li><a  href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a  href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
</ul>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Learn Rust</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> Guessing Game</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> Dining Philosophers</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> Rust Inside Other Languages</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>4.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>4.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>4.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>4.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>4.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>4.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>4.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>4.7.</b> Error Handling</a>
</li>
<li><a  href='ffi.html'><b>4.8.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>4.9.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>4.10.</b> Release Channels</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>5.</b> Syntax and Semantics</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>5.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>5.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>5.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>5.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>5.5.</b> if</a>
</li>
<li><a  href='for-loops.html'><b>5.6.</b> for loops</a>
</li>
<li><a  href='while-loops.html'><b>5.7.</b> while loops</a>
</li>
<li><a  href='ownership.html'><b>5.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>5.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>5.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>5.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>5.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>5.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>5.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>5.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>5.16.</b> Method Syntax</a>
</li>
<li><a  href='vectors.html'><b>5.17.</b> Vectors</a>
</li>
<li><a class='active' href='strings.html'><b>5.18.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>5.19.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>5.20.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>5.21.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>5.22.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>5.23.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>5.24.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>5.25.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>5.26.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>5.27.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>5.28.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>5.29.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>5.30.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>5.31.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>5.32.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>5.33.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>5.34.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>5.35.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>5.36.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>5.37.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='link-args.html'><b>6.6.</b> Link args</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='academic-research.html'><b>8.</b> Academic Research</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Strings</h1>
    <p>Strings are an important concept for any programmer to master. Rust’s string
handling system is a bit different from other languages, due to its systems
focus. Any time you have a data structure of variable size, things can get
tricky, and strings are a re-sizable data structure. That being said, Rust’s
strings also work differently than in some other systems languages, such as C.</p>

<p>Let’s dig into the details. A ‘string’ is a sequence of Unicode scalar values
encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid
encoding of UTF-8 sequences. Additionally, unlike some systems languages,
strings are not null-terminated and can contain null bytes.</p>

<p>Rust has two main types of strings: <code>&amp;str</code> and <code>String</code>. Let’s talk about
<code>&amp;str</code> first. These are called ‘string slices’. String literals are of the type
<code>&amp;&#39;static str</code>:</p>
<span class='rusttest'>fn main() {
    let greeting = &quot;Hello there.&quot;; // greeting: &amp;&#39;static str
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>greeting</span> <span class='op'>=</span> <span class='string'>&quot;Hello there.&quot;</span>; <span class='comment'>// greeting: &amp;&#39;static str</span>
</pre>

<p>This string is statically allocated, meaning that it’s saved inside our
compiled program, and exists for the entire duration it runs. The <code>greeting</code>
binding is a reference to this statically allocated string. String slices
have a fixed size, and cannot be mutated.</p>

<p>A <code>String</code>, on the other hand, is a heap-allocated string. This string is
growable, and is also guaranteed to be UTF-8. <code>String</code>s are commonly created by
converting from a string slice using the <code>to_string</code> method.</p>
<span class='rusttest'>fn main() {
    let mut s = &quot;Hello&quot;.to_string(); // mut s: String
    println!(&quot;{}&quot;, s);
    
    s.push_str(&quot;, world.&quot;);
    println!(&quot;{}&quot;, s);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>(); <span class='comment'>// mut s: String</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>);

<span class='ident'>s</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;, world.&quot;</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>);
</pre>

<p><code>String</code>s will coerce into <code>&amp;str</code> with an <code>&amp;</code>:</p>
<span class='rusttest'>fn takes_slice(slice: &amp;str) {
    println!(&quot;Got: {}&quot;, slice);
}

fn main() {
    let s = &quot;Hello&quot;.to_string();
    takes_slice(&amp;s);
}
</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>takes_slice</span>(<span class='ident'>slice</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Got: {}&quot;</span>, <span class='ident'>slice</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();
    <span class='ident'>takes_slice</span>(<span class='kw-2'>&amp;</span><span class='ident'>s</span>);
}
</pre>

<p>This coercion does not happen for functions that accept one of <code>&amp;str</code>’s traits
instead of <code>&amp;str</code>. For example, <a href="../std/net/struct.TcpStream.html#method.connect"><code>TcpStream::connect</code></a> has a parameter
of type <code>ToSocketAddrs</code>. A <code>&amp;str</code> is okay but a <code>String</code> must be explicitly
converted using <code>&amp;*</code>.</p>
<span class='rusttest'>fn main() {
    use std::net::TcpStream;
    
    TcpStream::connect(&quot;192.168.0.1:3000&quot;); // &amp;str parameter
    
    let addr_string = &quot;192.168.0.1:3000&quot;.to_string();
    TcpStream::connect(&amp;*addr_string); // convert addr_string to &amp;str
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>net</span>::<span class='ident'>TcpStream</span>;

<span class='ident'>TcpStream</span>::<span class='ident'>connect</span>(<span class='string'>&quot;192.168.0.1:3000&quot;</span>); <span class='comment'>// &amp;str parameter</span>

<span class='kw'>let</span> <span class='ident'>addr_string</span> <span class='op'>=</span> <span class='string'>&quot;192.168.0.1:3000&quot;</span>.<span class='ident'>to_string</span>();
<span class='ident'>TcpStream</span>::<span class='ident'>connect</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>addr_string</span>); <span class='comment'>// convert addr_string to &amp;str</span>
</pre>

<p>Viewing a <code>String</code> as a <code>&amp;str</code> is cheap, but converting the <code>&amp;str</code> to a
<code>String</code> involves allocating memory. No reason to do that unless you have to!</p>

<h2 id="indexing" class='section-header'><a
                           href="#indexing">Indexing</a></h2>
<p>Because strings are valid UTF-8, strings do not support indexing:</p>
<span class='rusttest'>fn main() {
    let s = &quot;hello&quot;;
    
    println!(&quot;The first letter of s is {}&quot;, s[0]); // ERROR!!!
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The first letter of s is {}&quot;</span>, <span class='ident'>s</span>[<span class='number'>0</span>]); <span class='comment'>// ERROR!!!</span>
</pre>

<p>Usually, access to a vector with <code>[]</code> is very fast. But, because each character
in a UTF-8 encoded string can be multiple bytes, you have to walk over the
string to find the nᵗʰ letter of a string. This is a significantly more
expensive operation, and we don’t want to be misleading. Furthermore, ‘letter’
isn’t something defined in Unicode, exactly. We can choose to look at a string as
individual bytes, or as codepoints:</p>
<span class='rusttest'>fn main() {
    let hachiko = &quot;忠犬ハチ公&quot;;
    
    for b in hachiko.as_bytes() {
        print!(&quot;{}, &quot;, b);
    }
    
    println!(&quot;&quot;);
    
    for c in hachiko.chars() {
        print!(&quot;{}, &quot;, c);
    }
    
    println!(&quot;&quot;);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>hachiko</span> <span class='op'>=</span> <span class='string'>&quot;忠犬ハチ公&quot;</span>;

<span class='kw'>for</span> <span class='ident'>b</span> <span class='kw'>in</span> <span class='ident'>hachiko</span>.<span class='ident'>as_bytes</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}, &quot;</span>, <span class='ident'>b</span>);
}

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;&quot;</span>);

<span class='kw'>for</span> <span class='ident'>c</span> <span class='kw'>in</span> <span class='ident'>hachiko</span>.<span class='ident'>chars</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}, &quot;</span>, <span class='ident'>c</span>);
}

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;&quot;</span>);
</pre>

<p>This prints:</p>

<pre><code class="language-text">229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172, 
忠, 犬, ハ, チ, 公, 
</code></pre>

<p>As you can see, there are more bytes than <code>char</code>s.</p>

<p>You can get something similar to an index like this:</p>
<span class='rusttest'>fn main() {
    let hachiko = &quot;忠犬ハチ公&quot;;
    let dog = hachiko.chars().nth(1); // kinda like hachiko[1]
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>dog</span> <span class='op'>=</span> <span class='ident'>hachiko</span>.<span class='ident'>chars</span>().<span class='ident'>nth</span>(<span class='number'>1</span>); <span class='comment'>// kinda like hachiko[1]</span>
</pre>

<p>This emphasizes that we have to go through the whole list of <code>chars</code>.</p>

<h2 id="concatenation" class='section-header'><a
                           href="#concatenation">Concatenation</a></h2>
<p>If you have a <code>String</code>, you can concatenate a <code>&amp;str</code> to the end of it:</p>
<span class='rusttest'>fn main() {
    let hello = &quot;Hello &quot;.to_string();
    let world = &quot;world!&quot;;
    
    let hello_world = hello + world;
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='string'>&quot;Hello &quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>world</span> <span class='op'>=</span> <span class='string'>&quot;world!&quot;</span>;

<span class='kw'>let</span> <span class='ident'>hello_world</span> <span class='op'>=</span> <span class='ident'>hello</span> <span class='op'>+</span> <span class='ident'>world</span>;
</pre>

<p>But if you have two <code>String</code>s, you need an <code>&amp;</code>:</p>
<span class='rusttest'>fn main() {
    let hello = &quot;Hello &quot;.to_string();
    let world = &quot;world!&quot;.to_string();
    
    let hello_world = hello + &amp;world;
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='string'>&quot;Hello &quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>world</span> <span class='op'>=</span> <span class='string'>&quot;world!&quot;</span>.<span class='ident'>to_string</span>();

<span class='kw'>let</span> <span class='ident'>hello_world</span> <span class='op'>=</span> <span class='ident'>hello</span> <span class='op'>+</span> <span class='kw-2'>&amp;</span><span class='ident'>world</span>;
</pre>

<p>This is because <code>&amp;String</code> can automatically coerce to a <code>&amp;str</code>. This is a
feature called ‘<a href="deref-coercions.html"><code>Deref</code> coercions</a>’.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>