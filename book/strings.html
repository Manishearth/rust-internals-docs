<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Strings</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Guessing Game</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Syntax and Semantics</a>
<ol class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Loops</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vectors</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Method Syntax</a>
</li>
<li><a class='active' href='strings.html'><b>4.17.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ol>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ol class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Error Handling</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Choosing your Guarantees</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Release Channels</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Using Rust without the standard library</a>
</li>
<li><a  href='procedural-macros.html'><b>5.13.</b> Procedural Macros (and custom derive)</a>
</li>
</ol>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ol class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Advanced linking</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Custom Allocators</a>
</li>
</ol>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Syntax Index</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> Bibliography</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Strings</h1>
    <p>Strings are an important concept for any programmer to master. Rust’s string
handling system is a bit different from other languages, due to its systems
focus. Any time you have a data structure of variable size, things can get
tricky, and strings are a re-sizable data structure. That being said, Rust’s
strings also work differently than in some other systems languages, such as C.</p>

<p>Let’s dig into the details. A ‘string’ is a sequence of Unicode scalar values
encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid
encoding of UTF-8 sequences. Additionally, unlike some systems languages,
strings are not NUL-terminated and can contain NUL bytes.</p>

<p>Rust has two main types of strings: <code>&amp;str</code> and <code>String</code>. Let’s talk about
<code>&amp;str</code> first. These are called ‘string slices’. A string slice has a fixed
size, and cannot be mutated. It is a reference to a sequence of UTF-8 bytes.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>greeting</span> <span class='op'>=</span> <span class='string'>&quot;Hello there.&quot;</span>; <span class='comment'>// greeting: &amp;&#39;static str</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20greeting%20%3D%20%22Hello%20there.%22%3B%20%2F%2F%20greeting%3A%20%26'static%20str%0A%7D">Run</a></pre>

<p><code>&quot;Hello there.&quot;</code> is a string literal and its type is <code>&amp;&#39;static str</code>. A string
literal is a string slice that is statically allocated, meaning that it’s saved
inside our compiled program, and exists for the entire duration it runs. The
<code>greeting</code> binding is a reference to this statically allocated string. Any
function expecting a string slice will also accept a string literal.</p>

<p>String literals can span multiple lines. There are two forms. The first will
include the newline and the leading spaces:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;foo
    bar&quot;</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;foo\n    bar&quot;</span>, <span class='ident'>s</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20s%20%3D%20%22foo%0A%20%20%20%20bar%22%3B%0A%0Aassert_eq!(%22foo%5Cn%20%20%20%20bar%22%2C%20s)%3B%0A%7D">Run</a></pre>

<p>The second, with a <code>\</code>, trims the spaces and the newline:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;foo\
    bar&quot;</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;foobar&quot;</span>, <span class='ident'>s</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20s%20%3D%20%22foo%5C%0A%20%20%20%20bar%22%3B%0A%0Aassert_eq!(%22foobar%22%2C%20s)%3B%0A%7D">Run</a></pre>

<p>Note that you normally cannot access a <code>str</code> directly, but only through a <code>&amp;str</code>
reference. This is because <code>str</code> is an unsized type which requires additional
runtime information to be usable. For more information see the chapter on
<a href="unsized-types.html">unsized types</a>.</p>

<p>Rust has more than only <code>&amp;str</code>s though. A <code>String</code> is a heap-allocated string.
This string is growable, and is also guaranteed to be UTF-8. <code>String</code>s are
commonly created by converting from a string slice using the <code>to_string</code>
method.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>(); <span class='comment'>// mut s: String</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>);

<span class='ident'>s</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;, world.&quot;</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%22Hello%22.to_string()%3B%20%2F%2F%20mut%20s%3A%20String%0Aprintln!(%22%7B%7D%22%2C%20s)%3B%0A%0As.push_str(%22%2C%20world.%22)%3B%0Aprintln!(%22%7B%7D%22%2C%20s)%3B%0A%7D">Run</a></pre>

<p><code>String</code>s will coerce into <code>&amp;str</code> with an <code>&amp;</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>takes_slice</span>(<span class='ident'>slice</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Got: {}&quot;</span>, <span class='ident'>slice</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();
    <span class='ident'>takes_slice</span>(<span class='kw-2'>&amp;</span><span class='ident'>s</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20takes_slice(slice%3A%20%26str)%20%7B%0A%20%20%20%20println!(%22Got%3A%20%7B%7D%22%2C%20slice)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20s%20%3D%20%22Hello%22.to_string()%3B%0A%20%20%20%20takes_slice(%26s)%3B%0A%7D%0A">Run</a></pre>

<p>This coercion does not happen for functions that accept one of <code>&amp;str</code>’s traits
instead of <code>&amp;str</code>. For example, <a href="../std/net/struct.TcpStream.html#method.connect"><code>TcpStream::connect</code></a> has a parameter
of type <code>ToSocketAddrs</code>. A <code>&amp;str</code> is okay but a <code>String</code> must be explicitly
converted using <code>&amp;*</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>net</span>::<span class='ident'>TcpStream</span>;

<span class='ident'>TcpStream</span>::<span class='ident'>connect</span>(<span class='string'>&quot;192.168.0.1:3000&quot;</span>); <span class='comment'>// Parameter is of type &amp;str.</span>

<span class='kw'>let</span> <span class='ident'>addr_string</span> <span class='op'>=</span> <span class='string'>&quot;192.168.0.1:3000&quot;</span>.<span class='ident'>to_string</span>();
<span class='ident'>TcpStream</span>::<span class='ident'>connect</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>*</span><span class='ident'>addr_string</span>); <span class='comment'>// Convert `addr_string` to &amp;str.</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Anet%3A%3ATcpStream%3B%0A%0ATcpStream%3A%3Aconnect(%22192.168.0.1%3A3000%22)%3B%20%2F%2F%20Parameter%20is%20of%20type%20%26str.%0A%0Alet%20addr_string%20%3D%20%22192.168.0.1%3A3000%22.to_string()%3B%0ATcpStream%3A%3Aconnect(%26*addr_string)%3B%20%2F%2F%20Convert%20%60addr_string%60%20to%20%26str.%0A%7D">Run</a></pre>

<p>Viewing a <code>String</code> as a <code>&amp;str</code> is cheap, but converting the <code>&amp;str</code> to a
<code>String</code> involves allocating memory. No reason to do that unless you have to!</p>

<h2 id='indexing' class='section-header'><a href='#indexing'>Indexing</a></h2>
<p>Because strings are valid UTF-8, they do not support indexing:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The first letter of s is {}&quot;</span>, <span class='ident'>s</span>[<span class='number'>0</span>]); <span class='comment'>// ERROR!!!</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20s%20%3D%20%22hello%22%3B%0A%0Aprintln!(%22The%20first%20letter%20of%20s%20is%20%7B%7D%22%2C%20s%5B0%5D)%3B%20%2F%2F%20ERROR!!!%0A%7D">Run</a></pre>

<p>Usually, access to a vector with <code>[]</code> is very fast. But, because each character
in a UTF-8 encoded string can be multiple bytes, you have to walk over the
string to find the nᵗʰ letter of a string. This is a significantly more
expensive operation, and we don’t want to be misleading. Furthermore, ‘letter’
isn’t something defined in Unicode, exactly. We can choose to look at a string as
individual bytes, or as codepoints:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hachiko</span> <span class='op'>=</span> <span class='string'>&quot;忠犬ハチ公&quot;</span>;

<span class='kw'>for</span> <span class='ident'>b</span> <span class='kw'>in</span> <span class='ident'>hachiko</span>.<span class='ident'>as_bytes</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}, &quot;</span>, <span class='ident'>b</span>);
}

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;&quot;</span>);

<span class='kw'>for</span> <span class='ident'>c</span> <span class='kw'>in</span> <span class='ident'>hachiko</span>.<span class='ident'>chars</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}, &quot;</span>, <span class='ident'>c</span>);
}

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;&quot;</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20hachiko%20%3D%20%22%E5%BF%A0%E7%8A%AC%E3%83%8F%E3%83%81%E5%85%AC%22%3B%0A%0Afor%20b%20in%20hachiko.as_bytes()%20%7B%0A%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20b)%3B%0A%7D%0A%0Aprintln!(%22%22)%3B%0A%0Afor%20c%20in%20hachiko.chars()%20%7B%0A%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20c)%3B%0A%7D%0A%0Aprintln!(%22%22)%3B%0A%7D">Run</a></pre>

<p>This prints:</p>

<pre><code class="language-text">229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,
忠, 犬, ハ, チ, 公,
</code></pre>

<p>As you can see, there are more bytes than <code>char</code>s.</p>

<p>You can get something similar to an index like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>dog</span> <span class='op'>=</span> <span class='ident'>hachiko</span>.<span class='ident'>chars</span>().<span class='ident'>nth</span>(<span class='number'>1</span>); <span class='comment'>// Kinda like `hachiko[1]`.</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20hachiko%20%3D%20%22%E5%BF%A0%E7%8A%AC%E3%83%8F%E3%83%81%E5%85%AC%22%3B%0Alet%20dog%20%3D%20hachiko.chars().nth(1)%3B%20%2F%2F%20Kinda%20like%20%60hachiko%5B1%5D%60.%0A%7D">Run</a></pre>

<p>This emphasizes that we have to walk from the beginning of the list of <code>chars</code>.</p>

<h2 id='slicing' class='section-header'><a href='#slicing'>Slicing</a></h2>
<p>You can get a slice of a string with slicing syntax:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>dog</span> <span class='op'>=</span> <span class='string'>&quot;hachiko&quot;</span>;
<span class='kw'>let</span> <span class='ident'>hachi</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>dog</span>[<span class='number'>0</span>..<span class='number'>5</span>];<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20dog%20%3D%20%22hachiko%22%3B%0Alet%20hachi%20%3D%20%26dog%5B0..5%5D%3B%0A%7D">Run</a></pre>

<p>But note that these are <em>byte</em> offsets, not <em>character</em> offsets. So
this will fail at runtime:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>dog</span> <span class='op'>=</span> <span class='string'>&quot;忠犬ハチ公&quot;</span>;
<span class='kw'>let</span> <span class='ident'>hachi</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>dog</span>[<span class='number'>0</span>..<span class='number'>2</span>];<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20dog%20%3D%20%22%E5%BF%A0%E7%8A%AC%E3%83%8F%E3%83%81%E5%85%AC%22%3B%0Alet%20hachi%20%3D%20%26dog%5B0..2%5D%3B%0A%7D">Run</a></pre>

<p>with this error:</p>

<pre><code class="language-text">thread &#39;main&#39; panicked at &#39;byte index 2 is not a char boundary; it is inside &#39;忠&#39;
(bytes 0..3) of `忠犬ハチ公`&#39;
</code></pre>

<h2 id='concatenation' class='section-header'><a href='#concatenation'>Concatenation</a></h2>
<p>If you have a <code>String</code>, you can concatenate a <code>&amp;str</code> to the end of it:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='string'>&quot;Hello &quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>world</span> <span class='op'>=</span> <span class='string'>&quot;world!&quot;</span>;

<span class='kw'>let</span> <span class='ident'>hello_world</span> <span class='op'>=</span> <span class='ident'>hello</span> <span class='op'>+</span> <span class='ident'>world</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20hello%20%3D%20%22Hello%20%22.to_string()%3B%0Alet%20world%20%3D%20%22world!%22%3B%0A%0Alet%20hello_world%20%3D%20hello%20%2B%20world%3B%0A%7D">Run</a></pre>

<p>But if you have two <code>String</code>s, you need an <code>&amp;</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='string'>&quot;Hello &quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>world</span> <span class='op'>=</span> <span class='string'>&quot;world!&quot;</span>.<span class='ident'>to_string</span>();

<span class='kw'>let</span> <span class='ident'>hello_world</span> <span class='op'>=</span> <span class='ident'>hello</span> <span class='op'>+</span> <span class='kw-2'>&amp;</span><span class='ident'>world</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20hello%20%3D%20%22Hello%20%22.to_string()%3B%0Alet%20world%20%3D%20%22world!%22.to_string()%3B%0A%0Alet%20hello_world%20%3D%20hello%20%2B%20%26world%3B%0A%7D">Run</a></pre>

<p>This is because <code>&amp;String</code> can automatically coerce to a <code>&amp;str</code>. This is a
feature called ‘<a href="deref-coercions.html"><code>Deref</code> coercions</a>’.</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>