<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Foreign Function Interface</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> Getting Started</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> Tutorial: Guessing Game</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> Syntax and Semantics</a>
<ol class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> Variable Bindings</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> Functions</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> Primitive Types</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> Comments</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> Loops</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> Vectors</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> Ownership</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> References and Borrowing</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> Lifetimes</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> Mutability</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> Structs</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> Enums</a>
</li>
<li><a  href='match.html'><b>4.14.</b> Match</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> Patterns</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> Method Syntax</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> Strings</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> Generics</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> Traits</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> Trait Objects</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> Closures</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> Universal Function Call Syntax</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> Crates and Modules</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` and `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> Attributes</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` aliases</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> Casting between types</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> Associated Types</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> Unsized Types</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> Operators and Overloading</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Deref coercions</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> Macros</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> Raw Pointers</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ol>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ol class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> The Stack and the Heap</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> Testing</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> Conditional Compilation</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> Documentation</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> Iterators</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> Concurrency</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> Error Handling</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> Choosing your Guarantees</a>
</li>
<li><a class='active' href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Borrow and AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> Release Channels</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> Using Rust without the standard library</a>
</li>
<li><a  href='procedural-macros.html'><b>5.13.</b> Procedural Macros (and custom derive)</a>
</li>
</ol>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ol class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> Compiler Plugins</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> Inline Assembly</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsics</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> Advanced linking</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> Benchmark Tests</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box Syntax and Patterns</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> Slice Patterns</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> Associated Constants</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> Custom Allocators</a>
</li>
</ol>
</li>
<li><a  href='glossary.html'><b>7.</b> Glossary</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> Syntax Index</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> Bibliography</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Foreign Function Interface</h1>
    
<h1 id='introduction' class='section-header'><a href='#introduction'>Introduction</a></h1>
<p>This guide will use the <a href="https://github.com/google/snappy">snappy</a>
compression/decompression library as an introduction to writing bindings for
foreign code. Rust is currently unable to call directly into a C++ library, but
snappy includes a C interface (documented in
<a href="https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>).</p>

<h2 id='a-note-about-libc' class='section-header'><a href='#a-note-about-libc'>A note about libc</a></h2>
<p>Many of these examples use <a href="https://crates.io/crates/libc">the <code>libc</code> crate</a>, which provides various
type definitions for C types, among other things. If you’re trying these
examples yourself, you’ll need to add <code>libc</code> to your <code>Cargo.toml</code>:</p>

<pre><code class="language-toml">[dependencies]
libc = &quot;0.2.0&quot;
</code></pre>

<p>and add <code>extern crate libc;</code> to your crate root.</p>

<h2 id='calling-foreign-functions' class='section-header'><a href='#calling-foreign-functions'>Calling foreign functions</a></h2>
<p>The following is a minimal example of calling a foreign function which will
compile if snappy is installed:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;
<span class='kw'>use</span> <span class='ident'>libc</span>::<span class='ident'>size_t</span>;

<span class='attribute'>#[<span class='ident'>link</span>(<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;snappy&quot;</span>)]</span>
<span class='kw'>extern</span> {
    <span class='kw'>fn</span> <span class='ident'>snappy_max_compressed_length</span>(<span class='ident'>source_length</span>: <span class='ident'>size_t</span>) <span class='op'>-&gt;</span> <span class='ident'>size_t</span>;
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='ident'>snappy_max_compressed_length</span>(<span class='number'>100</span>) };
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;max compressed length of a 100 byte buffer: {}&quot;</span>, <span class='ident'>x</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3Asize_t%3B%0A%0A%23%5Blink(name%20%3D%20%22snappy%22)%5D%0Aextern%20%7B%0A%20%20%20%20fn%20snappy_max_compressed_length(source_length%3A%20size_t)%20-%3E%20size_t%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%20unsafe%20%7B%20snappy_max_compressed_length(100)%20%7D%3B%0A%20%20%20%20println!(%22max%20compressed%20length%20of%20a%20100%20byte%20buffer%3A%20%7B%7D%22%2C%20x)%3B%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>The <code>extern</code> block is a list of function signatures in a foreign library, in
this case with the platform&#39;s C ABI. The <code>#[link(...)]</code> attribute is used to
instruct the linker to link against the snappy library so the symbols are
resolved.</p>

<p>Foreign functions are assumed to be unsafe so calls to them need to be wrapped
with <code>unsafe {}</code> as a promise to the compiler that everything contained within
truly is safe. C libraries often expose interfaces that aren&#39;t thread-safe, and
almost any function that takes a pointer argument isn&#39;t valid for all possible
inputs since the pointer could be dangling, and raw pointers fall outside of
Rust&#39;s safe memory model.</p>

<p>When declaring the argument types to a foreign function, the Rust compiler
cannot check if the declaration is correct, so specifying it correctly is part
of keeping the binding correct at runtime.</p>

<p>The <code>extern</code> block can be extended to cover the entire snappy API:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;
<span class='kw'>use</span> <span class='ident'>libc</span>::{<span class='ident'>c_int</span>, <span class='ident'>size_t</span>};

<span class='attribute'>#[<span class='ident'>link</span>(<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;snappy&quot;</span>)]</span>
<span class='kw'>extern</span> {
    <span class='kw'>fn</span> <span class='ident'>snappy_compress</span>(<span class='ident'>input</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>,
                       <span class='ident'>input_length</span>: <span class='ident'>size_t</span>,
                       <span class='ident'>compressed</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>u8</span>,
                       <span class='ident'>compressed_length</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>size_t</span>) <span class='op'>-&gt;</span> <span class='ident'>c_int</span>;
    <span class='kw'>fn</span> <span class='ident'>snappy_uncompress</span>(<span class='ident'>compressed</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>,
                         <span class='ident'>compressed_length</span>: <span class='ident'>size_t</span>,
                         <span class='ident'>uncompressed</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>u8</span>,
                         <span class='ident'>uncompressed_length</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>size_t</span>) <span class='op'>-&gt;</span> <span class='ident'>c_int</span>;
    <span class='kw'>fn</span> <span class='ident'>snappy_max_compressed_length</span>(<span class='ident'>source_length</span>: <span class='ident'>size_t</span>) <span class='op'>-&gt;</span> <span class='ident'>size_t</span>;
    <span class='kw'>fn</span> <span class='ident'>snappy_uncompressed_length</span>(<span class='ident'>compressed</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>,
                                  <span class='ident'>compressed_length</span>: <span class='ident'>size_t</span>,
                                  <span class='ident'>result</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>size_t</span>) <span class='op'>-&gt;</span> <span class='ident'>c_int</span>;
    <span class='kw'>fn</span> <span class='ident'>snappy_validate_compressed_buffer</span>(<span class='ident'>compressed</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>,
                                         <span class='ident'>compressed_length</span>: <span class='ident'>size_t</span>) <span class='op'>-&gt;</span> <span class='ident'>c_int</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3A%7Bc_int%2C%20size_t%7D%3B%0A%0A%23%5Blink(name%20%3D%20%22snappy%22)%5D%0Aextern%20%7B%0A%20%20%20%20fn%20snappy_compress(input%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20input_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed%3A%20*mut%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20*mut%20size_t)%20-%3E%20c_int%3B%0A%20%20%20%20fn%20snappy_uncompress(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20uncompressed%3A%20*mut%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20uncompressed_length%3A%20*mut%20size_t)%20-%3E%20c_int%3B%0A%20%20%20%20fn%20snappy_max_compressed_length(source_length%3A%20size_t)%20-%3E%20size_t%3B%0A%20%20%20%20fn%20snappy_uncompressed_length(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20result%3A%20*mut%20size_t)%20-%3E%20c_int%3B%0A%20%20%20%20fn%20snappy_validate_compressed_buffer(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t)%20-%3E%20c_int%3B%0A%7D%0Afn%20main()%20%7B%7D%0A&amp;version=nightly">Run</a></pre>

<h1 id='creating-a-safe-interface' class='section-header'><a href='#creating-a-safe-interface'>Creating a safe interface</a></h1>
<p>The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts
like vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe
internal details.</p>

<p>Wrapping the functions which expect buffers involves using the <code>slice::raw</code> module to manipulate Rust
vectors as pointers to memory. Rust&#39;s vectors are guaranteed to be a contiguous block of memory. The
length is the number of elements currently contained, and the capacity is the total size in elements of
the allocated memory. The length is less than or equal to the capacity.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>validate_compressed_buffer</span>(<span class='ident'>src</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='kw'>unsafe</span> {
        <span class='ident'>snappy_validate_compressed_buffer</span>(<span class='ident'>src</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>src</span>.<span class='ident'>len</span>() <span class='kw'>as</span> <span class='ident'>size_t</span>) <span class='op'>==</span> <span class='number'>0</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3A%7Bc_int%2C%20size_t%7D%3B%0Aunsafe%20fn%20snappy_validate_compressed_buffer(_%3A%20*const%20u8%2C%20_%3A%20size_t)%20-%3E%20c_int%20%7B%200%20%7D%0Afn%20main()%20%7B%7D%0Apub%20fn%20validate_compressed_buffer(src%3A%20%26%5Bu8%5D)%20-%3E%20bool%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20snappy_validate_compressed_buffer(src.as_ptr()%2C%20src.len()%20as%20size_t)%20%3D%3D%200%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>The <code>validate_compressed_buffer</code> wrapper above makes use of an <code>unsafe</code> block, but it makes the
guarantee that calling it is safe for all inputs by leaving off <code>unsafe</code> from the function
signature.</p>

<p>The <code>snappy_compress</code> and <code>snappy_uncompress</code> functions are more complex, since a buffer has to be
allocated to hold the output too.</p>

<p>The <code>snappy_max_compressed_length</code> function can be used to allocate a vector with the maximum
required capacity to hold the compressed output. The vector can then be passed to the
<code>snappy_compress</code> function as an output parameter. An output parameter is also passed to retrieve
the true length after compression for setting the length.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>compress</span>(<span class='ident'>src</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> {
    <span class='kw'>unsafe</span> {
        <span class='kw'>let</span> <span class='ident'>srclen</span> <span class='op'>=</span> <span class='ident'>src</span>.<span class='ident'>len</span>() <span class='kw'>as</span> <span class='ident'>size_t</span>;
        <span class='kw'>let</span> <span class='ident'>psrc</span> <span class='op'>=</span> <span class='ident'>src</span>.<span class='ident'>as_ptr</span>();

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>dstlen</span> <span class='op'>=</span> <span class='ident'>snappy_max_compressed_length</span>(<span class='ident'>srclen</span>);
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>dst</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>with_capacity</span>(<span class='ident'>dstlen</span> <span class='kw'>as</span> <span class='ident'>usize</span>);
        <span class='kw'>let</span> <span class='ident'>pdst</span> <span class='op'>=</span> <span class='ident'>dst</span>.<span class='ident'>as_mut_ptr</span>();

        <span class='ident'>snappy_compress</span>(<span class='ident'>psrc</span>, <span class='ident'>srclen</span>, <span class='ident'>pdst</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>dstlen</span>);
        <span class='ident'>dst</span>.<span class='ident'>set_len</span>(<span class='ident'>dstlen</span> <span class='kw'>as</span> <span class='ident'>usize</span>);
        <span class='ident'>dst</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3A%7Bsize_t%2C%20c_int%7D%3B%0Aunsafe%20fn%20snappy_compress(a%3A%20*const%20u8%2C%20b%3A%20size_t%2C%20c%3A%20*mut%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20d%3A%20*mut%20size_t)%20-%3E%20c_int%20%7B%200%20%7D%0Aunsafe%20fn%20snappy_max_compressed_length(a%3A%20size_t)%20-%3E%20size_t%20%7B%20a%20%7D%0Afn%20main()%20%7B%7D%0Apub%20fn%20compress(src%3A%20%26%5Bu8%5D)%20-%3E%20Vec%3Cu8%3E%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20let%20srclen%20%3D%20src.len()%20as%20size_t%3B%0A%20%20%20%20%20%20%20%20let%20psrc%20%3D%20src.as_ptr()%3B%0A%0A%20%20%20%20%20%20%20%20let%20mut%20dstlen%20%3D%20snappy_max_compressed_length(srclen)%3B%0A%20%20%20%20%20%20%20%20let%20mut%20dst%20%3D%20Vec%3A%3Awith_capacity(dstlen%20as%20usize)%3B%0A%20%20%20%20%20%20%20%20let%20pdst%20%3D%20dst.as_mut_ptr()%3B%0A%0A%20%20%20%20%20%20%20%20snappy_compress(psrc%2C%20srclen%2C%20pdst%2C%20%26mut%20dstlen)%3B%0A%20%20%20%20%20%20%20%20dst.set_len(dstlen%20as%20usize)%3B%0A%20%20%20%20%20%20%20%20dst%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>Decompression is similar, because snappy stores the uncompressed size as part of the compression
format and <code>snappy_uncompressed_length</code> will retrieve the exact buffer size required.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>uncompress</span>(<span class='ident'>src</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;&gt;</span> {
    <span class='kw'>unsafe</span> {
        <span class='kw'>let</span> <span class='ident'>srclen</span> <span class='op'>=</span> <span class='ident'>src</span>.<span class='ident'>len</span>() <span class='kw'>as</span> <span class='ident'>size_t</span>;
        <span class='kw'>let</span> <span class='ident'>psrc</span> <span class='op'>=</span> <span class='ident'>src</span>.<span class='ident'>as_ptr</span>();

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>dstlen</span>: <span class='ident'>size_t</span> <span class='op'>=</span> <span class='number'>0</span>;
        <span class='ident'>snappy_uncompressed_length</span>(<span class='ident'>psrc</span>, <span class='ident'>srclen</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>dstlen</span>);

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>dst</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>with_capacity</span>(<span class='ident'>dstlen</span> <span class='kw'>as</span> <span class='ident'>usize</span>);
        <span class='kw'>let</span> <span class='ident'>pdst</span> <span class='op'>=</span> <span class='ident'>dst</span>.<span class='ident'>as_mut_ptr</span>();

        <span class='kw'>if</span> <span class='ident'>snappy_uncompress</span>(<span class='ident'>psrc</span>, <span class='ident'>srclen</span>, <span class='ident'>pdst</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>dstlen</span>) <span class='op'>==</span> <span class='number'>0</span> {
            <span class='ident'>dst</span>.<span class='ident'>set_len</span>(<span class='ident'>dstlen</span> <span class='kw'>as</span> <span class='ident'>usize</span>);
            <span class='prelude-val'>Some</span>(<span class='ident'>dst</span>)
        } <span class='kw'>else</span> {
            <span class='prelude-val'>None</span> <span class='comment'>// SNAPPY_INVALID_INPUT</span>
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3A%7Bsize_t%2C%20c_int%7D%3B%0Aunsafe%20fn%20snappy_uncompress(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20uncompressed%3A%20*mut%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20uncompressed_length%3A%20*mut%20size_t)%20-%3E%20c_int%20%7B%200%20%7D%0Aunsafe%20fn%20snappy_uncompressed_length(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20result%3A%20*mut%20size_t)%20-%3E%20c_int%20%7B%200%20%7D%0Afn%20main()%20%7B%7D%0Apub%20fn%20uncompress(src%3A%20%26%5Bu8%5D)%20-%3E%20Option%3CVec%3Cu8%3E%3E%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20let%20srclen%20%3D%20src.len()%20as%20size_t%3B%0A%20%20%20%20%20%20%20%20let%20psrc%20%3D%20src.as_ptr()%3B%0A%0A%20%20%20%20%20%20%20%20let%20mut%20dstlen%3A%20size_t%20%3D%200%3B%0A%20%20%20%20%20%20%20%20snappy_uncompressed_length(psrc%2C%20srclen%2C%20%26mut%20dstlen)%3B%0A%0A%20%20%20%20%20%20%20%20let%20mut%20dst%20%3D%20Vec%3A%3Awith_capacity(dstlen%20as%20usize)%3B%0A%20%20%20%20%20%20%20%20let%20pdst%20%3D%20dst.as_mut_ptr()%3B%0A%0A%20%20%20%20%20%20%20%20if%20snappy_uncompress(psrc%2C%20srclen%2C%20pdst%2C%20%26mut%20dstlen)%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20dst.set_len(dstlen%20as%20usize)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20Some(dst)%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20None%20%2F%2F%20SNAPPY_INVALID_INPUT%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>Then, we can add some tests to show how to use them.</p>

<pre class='rust rust-example-rendered'>

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>test</span>)]</span>
<span class='kw'>mod</span> <span class='ident'>tests</span> {
    <span class='kw'>use</span> <span class='kw'>super</span>::<span class='kw-2'>*</span>;

    <span class='attribute'>#[<span class='ident'>test</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>valid</span>() {
        <span class='kw'>let</span> <span class='ident'>d</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0xde</span>, <span class='number'>0xad</span>, <span class='number'>0xd0</span>, <span class='number'>0x0d</span>];
        <span class='kw'>let</span> <span class='ident'>c</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>] <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>compress</span>(<span class='kw-2'>&amp;</span><span class='ident'>d</span>);
        <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>validate_compressed_buffer</span>(<span class='ident'>c</span>));
        <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>uncompress</span>(<span class='ident'>c</span>) <span class='op'>==</span> <span class='prelude-val'>Some</span>(<span class='ident'>d</span>));
    }

    <span class='attribute'>#[<span class='ident'>test</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>invalid</span>() {
        <span class='kw'>let</span> <span class='ident'>d</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>];
        <span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>validate_compressed_buffer</span>(<span class='kw-2'>&amp;</span><span class='ident'>d</span>));
        <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>uncompress</span>(<span class='kw-2'>&amp;</span><span class='ident'>d</span>).<span class='ident'>is_none</span>());
    }

    <span class='attribute'>#[<span class='ident'>test</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>empty</span>() {
        <span class='kw'>let</span> <span class='ident'>d</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[];
        <span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>validate_compressed_buffer</span>(<span class='kw-2'>&amp;</span><span class='ident'>d</span>));
        <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>uncompress</span>(<span class='kw-2'>&amp;</span><span class='ident'>d</span>).<span class='ident'>is_none</span>());
        <span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>compress</span>(<span class='kw-2'>&amp;</span><span class='ident'>d</span>);
        <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>validate_compressed_buffer</span>(<span class='kw-2'>&amp;</span><span class='ident'>c</span>));
        <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>uncompress</span>(<span class='kw-2'>&amp;</span><span class='ident'>c</span>) <span class='op'>==</span> <span class='prelude-val'>Some</span>(<span class='ident'>d</span>));
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3A%7Bc_int%2C%20size_t%7D%3B%0Aunsafe%20fn%20snappy_compress(input%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20input_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed%3A%20*mut%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20*mut%20size_t)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%3E%20c_int%20%7B%200%20%7D%0Aunsafe%20fn%20snappy_uncompress(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20uncompressed%3A%20*mut%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20uncompressed_length%3A%20*mut%20size_t)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%3E%20c_int%20%7B%200%20%7D%0Aunsafe%20fn%20snappy_max_compressed_length(source_length%3A%20size_t)%20-%3E%20size_t%20%7B%200%20%7D%0Aunsafe%20fn%20snappy_uncompressed_length(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20result%3A%20*mut%20size_t)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%3E%20c_int%20%7B%200%20%7D%0Aunsafe%20fn%20snappy_validate_compressed_buffer(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20-%3E%20c_int%20%7B%200%20%7D%0Afn%20main()%20%7B%20%7D%0A%0A%23%5Bcfg(test)%5D%0Amod%20tests%20%7B%0A%20%20%20%20use%20super%3A%3A*%3B%0A%0A%20%20%20%20%23%5Btest%5D%0A%20%20%20%20fn%20valid()%20%7B%0A%20%20%20%20%20%20%20%20let%20d%20%3D%20vec!%5B0xde%2C%200xad%2C%200xd0%2C%200x0d%5D%3B%0A%20%20%20%20%20%20%20%20let%20c%3A%20%26%5Bu8%5D%20%3D%20%26compress(%26d)%3B%0A%20%20%20%20%20%20%20%20assert!(validate_compressed_buffer(c))%3B%0A%20%20%20%20%20%20%20%20assert!(uncompress(c)%20%3D%3D%20Some(d))%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Btest%5D%0A%20%20%20%20fn%20invalid()%20%7B%0A%20%20%20%20%20%20%20%20let%20d%20%3D%20vec!%5B0%2C%200%2C%200%2C%200%5D%3B%0A%20%20%20%20%20%20%20%20assert!(!validate_compressed_buffer(%26d))%3B%0A%20%20%20%20%20%20%20%20assert!(uncompress(%26d).is_none())%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%5Btest%5D%0A%20%20%20%20fn%20empty()%20%7B%0A%20%20%20%20%20%20%20%20let%20d%20%3D%20vec!%5B%5D%3B%0A%20%20%20%20%20%20%20%20assert!(!validate_compressed_buffer(%26d))%3B%0A%20%20%20%20%20%20%20%20assert!(uncompress(%26d).is_none())%3B%0A%20%20%20%20%20%20%20%20let%20c%20%3D%20compress(%26d)%3B%0A%20%20%20%20%20%20%20%20assert!(validate_compressed_buffer(%26c))%3B%0A%20%20%20%20%20%20%20%20assert!(uncompress(%26c)%20%3D%3D%20Some(d))%3B%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly">Run</a></pre>

<h1 id='destructors' class='section-header'><a href='#destructors'>Destructors</a></h1>
<p>Foreign libraries often hand off ownership of resources to the calling code.
When this occurs, we must use Rust&#39;s destructors to provide safety and guarantee
the release of these resources (especially in the case of panic).</p>

<p>For more about destructors, see the <a href="../std/ops/trait.Drop.html">Drop trait</a>.</p>

<h1 id='callbacks-from-c-code-to-rust-functions' class='section-header'><a href='#callbacks-from-c-code-to-rust-functions'>Callbacks from C code to Rust functions</a></h1>
<p>Some external libraries require the usage of callbacks to report back their
current state or intermediate data to the caller.
It is possible to pass functions defined in Rust to an external library.
The requirement for this is that the callback function is marked as <code>extern</code>
with the correct calling convention to make it callable from C code.</p>

<p>The callback function can then be sent through a registration call
to the C library and afterwards be invoked from there.</p>

<p>A basic example is:</p>

<p>Rust code:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>callback</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;I&#39;m called from C with value {0}&quot;</span>, <span class='ident'>a</span>);
}

<span class='attribute'>#[<span class='ident'>link</span>(<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;extlib&quot;</span>)]</span>
<span class='kw'>extern</span> {
   <span class='kw'>fn</span> <span class='ident'>register_callback</span>(<span class='ident'>cb</span>: <span class='kw'>extern</span> <span class='kw'>fn</span>(<span class='ident'>i32</span>)) <span class='op'>-&gt;</span> <span class='ident'>i32</span>;
   <span class='kw'>fn</span> <span class='ident'>trigger_callback</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> {
        <span class='ident'>register_callback</span>(<span class='ident'>callback</span>);
        <span class='ident'>trigger_callback</span>(); <span class='comment'>// Triggers the callback.</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20fn%20callback(a%3A%20i32)%20%7B%0A%20%20%20%20println!(%22I'm%20called%20from%20C%20with%20value%20%7B0%7D%22%2C%20a)%3B%0A%7D%0A%0A%23%5Blink(name%20%3D%20%22extlib%22)%5D%0Aextern%20%7B%0A%20%20%20fn%20register_callback(cb%3A%20extern%20fn(i32))%20-%3E%20i32%3B%0A%20%20%20fn%20trigger_callback()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20register_callback(callback)%3B%0A%20%20%20%20%20%20%20%20trigger_callback()%3B%20%2F%2F%20Triggers%20the%20callback.%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>C code:</p>

<pre><code class="language-c">typedef void (*rust_callback)(int32_t);
rust_callback cb;

int32_t register_callback(rust_callback callback) {
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(7); // Will call callback(7) in Rust.
}
</code></pre>

<p>In this example Rust&#39;s <code>main()</code> will call <code>trigger_callback()</code> in C,
which would, in turn, call back to <code>callback()</code> in Rust.</p>

<h2 id='targeting-callbacks-to-rust-objects' class='section-header'><a href='#targeting-callbacks-to-rust-objects'>Targeting callbacks to Rust objects</a></h2>
<p>The former example showed how a global function can be called from C code.
However it is often desired that the callback is targeted to a special
Rust object. This could be the object that represents the wrapper for the
respective C object.</p>

<p>This can be achieved by passing a raw pointer to the object down to the
C library. The C library can then include the pointer to the Rust object in
the notification. This will allow the callback to unsafely access the
referenced Rust object.</p>

<p>Rust code:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>C</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>RustObject</span> {
    <span class='ident'>a</span>: <span class='ident'>i32</span>,
    <span class='comment'>// Other members...</span>
}

<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> <span class='kw'>fn</span> <span class='ident'>callback</span>(<span class='ident'>target</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>RustObject</span>, <span class='ident'>a</span>: <span class='ident'>i32</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;I&#39;m called from C with value {0}&quot;</span>, <span class='ident'>a</span>);
    <span class='kw'>unsafe</span> {
        <span class='comment'>// Update the value in RustObject with the value received from the callback:</span>
        (<span class='kw-2'>*</span><span class='ident'>target</span>).<span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>a</span>;
    }
}

<span class='attribute'>#[<span class='ident'>link</span>(<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;extlib&quot;</span>)]</span>
<span class='kw'>extern</span> {
   <span class='kw'>fn</span> <span class='ident'>register_callback</span>(<span class='ident'>target</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>RustObject</span>,
                        <span class='ident'>cb</span>: <span class='kw'>extern</span> <span class='kw'>fn</span>(<span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>RustObject</span>, <span class='ident'>i32</span>)) <span class='op'>-&gt;</span> <span class='ident'>i32</span>;
   <span class='kw'>fn</span> <span class='ident'>trigger_callback</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// Create the object that will be referenced in the callback:</span>
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rust_object</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>RustObject</span> { <span class='ident'>a</span>: <span class='number'>5</span> });

    <span class='kw'>unsafe</span> {
        <span class='ident'>register_callback</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='kw-2'>*</span><span class='ident'>rust_object</span>, <span class='ident'>callback</span>);
        <span class='ident'>trigger_callback</span>();
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23%5Brepr(C)%5D%0Astruct%20RustObject%20%7B%0A%20%20%20%20a%3A%20i32%2C%0A%20%20%20%20%2F%2F%20Other%20members...%0A%7D%0A%0Aextern%20%22C%22%20fn%20callback(target%3A%20*mut%20RustObject%2C%20a%3A%20i32)%20%7B%0A%20%20%20%20println!(%22I'm%20called%20from%20C%20with%20value%20%7B0%7D%22%2C%20a)%3B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Update%20the%20value%20in%20RustObject%20with%20the%20value%20received%20from%20the%20callback%3A%0A%20%20%20%20%20%20%20%20(*target).a%20%3D%20a%3B%0A%20%20%20%20%7D%0A%7D%0A%0A%23%5Blink(name%20%3D%20%22extlib%22)%5D%0Aextern%20%7B%0A%20%20%20fn%20register_callback(target%3A%20*mut%20RustObject%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20cb%3A%20extern%20fn(*mut%20RustObject%2C%20i32))%20-%3E%20i32%3B%0A%20%20%20fn%20trigger_callback()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Create%20the%20object%20that%20will%20be%20referenced%20in%20the%20callback%3A%0A%20%20%20%20let%20mut%20rust_object%20%3D%20Box%3A%3Anew(RustObject%20%7B%20a%3A%205%20%7D)%3B%0A%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20register_callback(%26mut%20*rust_object%2C%20callback)%3B%0A%20%20%20%20%20%20%20%20trigger_callback()%3B%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>C code:</p>

<pre><code class="language-c">typedef void (*rust_callback)(void*, int32_t);
void* cb_target;
rust_callback cb;

int32_t register_callback(void* callback_target, rust_callback callback) {
    cb_target = callback_target;
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(cb_target, 7); // Will call callback(&amp;rustObject, 7) in Rust.
}
</code></pre>

<h2 id='asynchronous-callbacks' class='section-header'><a href='#asynchronous-callbacks'>Asynchronous callbacks</a></h2>
<p>In the previously given examples the callbacks are invoked as a direct reaction
to a function call to the external C library.
The control over the current thread is switched from Rust to C to Rust for the
execution of the callback, but in the end the callback is executed on the
same thread that called the function which triggered the callback.</p>

<p>Things get more complicated when the external library spawns its own threads
and invokes callbacks from there.
In these cases access to Rust data structures inside the callbacks is
especially unsafe and proper synchronization mechanisms must be used.
Besides classical synchronization mechanisms like mutexes, one possibility in
Rust is to use channels (in <code>std::sync::mpsc</code>) to forward data from the C
thread that invoked the callback into a Rust thread.</p>

<p>If an asynchronous callback targets a special object in the Rust address space
it is also absolutely necessary that no more callbacks are performed by the
C library after the respective Rust object gets destroyed.
This can be achieved by unregistering the callback in the object&#39;s
destructor and designing the library in a way that guarantees that no
callback will be performed after deregistration.</p>

<h1 id='linking' class='section-header'><a href='#linking'>Linking</a></h1>
<p>The <code>link</code> attribute on <code>extern</code> blocks provides the basic building block for
instructing rustc how it will link to native libraries. There are two accepted
forms of the link attribute today:</p>

<ul>
<li><code>#[link(name = &quot;foo&quot;)]</code></li>
<li><code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code></li>
</ul>

<p>In both of these cases, <code>foo</code> is the name of the native library that we&#39;re
linking to, and in the second case <code>bar</code> is the type of native library that the
compiler is linking to. There are currently three known types of native
libraries:</p>

<ul>
<li>Dynamic - <code>#[link(name = &quot;readline&quot;)]</code></li>
<li>Static - <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></li>
<li>Frameworks - <code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code></li>
</ul>

<p>Note that frameworks are only available on OSX targets.</p>

<p>The different <code>kind</code> values are meant to differentiate how the native library
participates in linkage. From a linkage perspective, the Rust compiler creates
two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary).
Native dynamic library and framework dependencies are propagated to the final
artifact boundary, while static library dependencies are not propagated at
all, because the static libraries are integrated directly into the subsequent
artifact.</p>

<p>A few examples of how this model can be used are:</p>

<ul>
<li><p>A native build dependency. Sometimes some C/C++ glue is needed when writing
some Rust code, but distribution of the C/C++ code in a library format is
a burden. In this case, the code will be archived into <code>libfoo.a</code> and then the
Rust crate would declare a dependency via <code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code>.</p>

<p>Regardless of the flavor of output for the crate, the native static library
will be included in the output, meaning that distribution of the native static
library is not necessary.</p></li>
<li><p>A normal dynamic dependency. Common system libraries (like <code>readline</code>) are
available on a large number of systems, and often a static copy of these
libraries cannot be found. When this dependency is included in a Rust crate,
partial targets (like rlibs) will not link to the library, but when the rlib
is included in a final target (like a binary), the native library will be
linked in.</p></li>
</ul>

<p>On OSX, frameworks behave with the same semantics as a dynamic library.</p>

<h1 id='unsafe-blocks' class='section-header'><a href='#unsafe-blocks'>Unsafe blocks</a></h1>
<p>Some operations, like dereferencing raw pointers or calling functions that have been marked
unsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to
the compiler that the unsafety does not leak out of the block.</p>

<p>Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like
this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>kaboom</span>(<span class='ident'>ptr</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='kw-2'>*</span><span class='ident'>ptr</span> }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aunsafe%20fn%20kaboom(ptr%3A%20*const%20i32)%20-%3E%20i32%20%7B%20*ptr%20%7D%0A%7D">Run</a></pre>

<p>This function can only be called from an <code>unsafe</code> block or another <code>unsafe</code> function.</p>

<h1 id='accessing-foreign-globals' class='section-header'><a href='#accessing-foreign-globals'>Accessing foreign globals</a></h1>
<p>Foreign APIs often export a global variable which could do something like track
global state. In order to access these variables, you declare them in <code>extern</code>
blocks with the <code>static</code> keyword:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;

<span class='attribute'>#[<span class='ident'>link</span>(<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;readline&quot;</span>)]</span>
<span class='kw'>extern</span> {
    <span class='kw'>static</span> <span class='ident'>rl_readline_version</span>: <span class='ident'>libc</span>::<span class='ident'>c_int</span>;
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You have readline version {} installed.&quot;</span>,
             <span class='kw'>unsafe</span> { <span class='ident'>rl_readline_version</span> <span class='kw'>as</span> <span class='ident'>i32</span> });
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0A%0A%23%5Blink(name%20%3D%20%22readline%22)%5D%0Aextern%20%7B%0A%20%20%20%20static%20rl_readline_version%3A%20libc%3A%3Ac_int%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22You%20have%20readline%20version%20%7B%7D%20installed.%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20unsafe%20%7B%20rl_readline_version%20as%20i32%20%7D)%3B%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>Alternatively, you may need to alter global state provided by a foreign
interface. To do this, statics can be declared with <code>mut</code> so we can mutate
them.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ffi</span>::<span class='ident'>CString</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ptr</span>;

<span class='attribute'>#[<span class='ident'>link</span>(<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;readline&quot;</span>)]</span>
<span class='kw'>extern</span> {
    <span class='kw'>static</span> <span class='kw-2'>mut</span> <span class='ident'>rl_prompt</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>libc</span>::<span class='ident'>c_char</span>;
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>prompt</span> <span class='op'>=</span> <span class='ident'>CString</span>::<span class='ident'>new</span>(<span class='string'>&quot;[my-awesome-shell] $&quot;</span>).<span class='ident'>unwrap</span>();
    <span class='kw'>unsafe</span> {
        <span class='ident'>rl_prompt</span> <span class='op'>=</span> <span class='ident'>prompt</span>.<span class='ident'>as_ptr</span>();

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>rl_prompt</span>);

        <span class='ident'>rl_prompt</span> <span class='op'>=</span> <span class='ident'>ptr</span>::<span class='ident'>null</span>();
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0A%0Ause%20std%3A%3Affi%3A%3ACString%3B%0Ause%20std%3A%3Aptr%3B%0A%0A%23%5Blink(name%20%3D%20%22readline%22)%5D%0Aextern%20%7B%0A%20%20%20%20static%20mut%20rl_prompt%3A%20*const%20libc%3A%3Ac_char%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20prompt%20%3D%20CString%3A%3Anew(%22%5Bmy-awesome-shell%5D%20%24%22).unwrap()%3B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20rl_prompt%20%3D%20prompt.as_ptr()%3B%0A%0A%20%20%20%20%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20rl_prompt)%3B%0A%0A%20%20%20%20%20%20%20%20rl_prompt%20%3D%20ptr%3A%3Anull()%3B%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>Note that all interaction with a <code>static mut</code> is unsafe, both reading and
writing. Dealing with global mutable state requires a great deal of care.</p>

<h1 id='foreign-calling-conventions' class='section-header'><a href='#foreign-calling-conventions'>Foreign calling conventions</a></h1>
<p>Most foreign code exposes a C ABI, and Rust uses the platform&#39;s C calling convention by default when
calling foreign functions. Some foreign functions, most notably the Windows API, use other calling
conventions. Rust provides a way to tell the compiler which convention to use:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>all</span>(<span class='ident'>target_os</span> <span class='op'>=</span> <span class='string'>&quot;win32&quot;</span>, <span class='ident'>target_arch</span> <span class='op'>=</span> <span class='string'>&quot;x86&quot;</span>))]</span>
<span class='attribute'>#[<span class='ident'>link</span>(<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;kernel32&quot;</span>)]</span>
<span class='attribute'>#[<span class='ident'>allow</span>(<span class='ident'>non_snake_case</span>)]</span>
<span class='kw'>extern</span> <span class='string'>&quot;stdcall&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>SetEnvironmentVariableA</span>(<span class='ident'>n</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>, <span class='ident'>v</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>libc</span>::<span class='ident'>c_int</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0A%0A%23%5Bcfg(all(target_os%20%3D%20%22win32%22%2C%20target_arch%20%3D%20%22x86%22))%5D%0A%23%5Blink(name%20%3D%20%22kernel32%22)%5D%0A%23%5Ballow(non_snake_case)%5D%0Aextern%20%22stdcall%22%20%7B%0A%20%20%20%20fn%20SetEnvironmentVariableA(n%3A%20*const%20u8%2C%20v%3A%20*const%20u8)%20-%3E%20libc%3A%3Ac_int%3B%0A%7D%0Afn%20main()%20%7B%20%7D%0A&amp;version=nightly">Run</a></pre>

<p>This applies to the entire <code>extern</code> block. The list of supported ABI constraints
are:</p>

<ul>
<li><code>stdcall</code></li>
<li><code>aapcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>vectorcall</code>
This is currently hidden behind the <code>abi_vectorcall</code> gate and is subject to change.</li>
<li><code>Rust</code></li>
<li><code>rust-intrinsic</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
<li><code>sysv64</code></li>
</ul>

<p>Most of the abis in this list are self-explanatory, but the <code>system</code> abi may
seem a little odd. This constraint selects whatever the appropriate ABI is for
interoperating with the target&#39;s libraries. For example, on win32 with a x86
architecture, this means that the abi used would be <code>stdcall</code>. On x86_64,
however, windows uses the <code>C</code> calling convention, so <code>C</code> would be used. This
means that in our previous example, we could have used <code>extern &quot;system&quot; { ... }</code>
to define a block for all windows systems, not only x86 ones.</p>

<h1 id='interoperability-with-foreign-code' class='section-header'><a href='#interoperability-with-foreign-code'>Interoperability with foreign code</a></h1>
<p>Rust guarantees that the layout of a <code>struct</code> is compatible with the platform&#39;s
representation in C only if the <code>#[repr(C)]</code> attribute is applied to it.
<code>#[repr(C, packed)]</code> can be used to lay out struct members without padding.
<code>#[repr(C)]</code> can also be applied to an enum.</p>

<p>Rust&#39;s owned boxes (<code>Box&lt;T&gt;</code>) use non-nullable pointers as handles which point
to the contained object. However, they should not be manually created because
they are managed by internal allocators. References can safely be assumed to be
non-nullable pointers directly to the type.  However, breaking the borrow
checking or mutability rules is not guaranteed to be safe, so prefer using raw
pointers (<code>*</code>) if that&#39;s needed because the compiler can&#39;t make as many
assumptions about them.</p>

<p>Vectors and strings share the same basic memory layout, and utilities are
available in the <code>vec</code> and <code>str</code> modules for working with C APIs. However,
strings are not terminated with <code>\0</code>. If you need a NUL-terminated string for
interoperability with C, you should use the <code>CString</code> type in the <code>std::ffi</code>
module.</p>

<p>The <a href="https://crates.io/crates/libc"><code>libc</code> crate on crates.io</a> includes type aliases and function
definitions for the C standard library in the <code>libc</code> module, and Rust links
against <code>libc</code> and <code>libm</code> by default.</p>

<h1 id='variadic-functions' class='section-header'><a href='#variadic-functions'>Variadic functions</a></h1>
<p>In C, functions can be &#39;variadic&#39;, meaning they accept a variable number of arguments. This can
be achieved in Rust by specifying <code>...</code> within the argument list of a foreign function declaration:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, ...);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> {
        <span class='ident'>foo</span>(<span class='number'>10</span>, <span class='number'>20</span>, <span class='number'>30</span>, <span class='number'>40</span>, <span class='number'>50</span>);
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20%7B%0A%20%20%20%20fn%20foo(x%3A%20i32%2C%20...)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20foo(10%2C%2020%2C%2030%2C%2040%2C%2050)%3B%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>Normal Rust functions can <em>not</em> be variadic:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// This will not compile</span>

<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, ...) { }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%2F%2F%20This%20will%20not%20compile%0A%0Afn%20foo(x%3A%20i32%2C%20...)%20%7B%20%7D%0A%7D">Run</a></pre>

<h1 id='the-nullable-pointer-optimization' class='section-header'><a href='#the-nullable-pointer-optimization'>The &quot;nullable pointer optimization&quot;</a></h1>
<p>Certain Rust types are defined to never be <code>null</code>. This includes references (<code>&amp;T</code>,
<code>&amp;mut T</code>), boxes (<code>Box&lt;T&gt;</code>), and function pointers (<code>extern &quot;abi&quot; fn()</code>). When
interfacing with C, pointers that might be <code>null</code> are often used, which would seem to
require some messy <code>transmute</code>s and/or unsafe code to handle conversions to/from Rust types.
However, the language provides a workaround.</p>

<p>As a special case, an <code>enum</code> is eligible for the &quot;nullable pointer optimization&quot; if it contains
exactly two variants, one of which contains no data and the other contains a field of one of the
non-nullable types listed above.  This means no extra space is required for a discriminant; rather,
the empty variant is represented by putting a <code>null</code> value into the non-nullable field. This is
called an &quot;optimization&quot;, but unlike other optimizations it is guaranteed to apply to eligible
types.</p>

<p>The most common type that takes advantage of the nullable pointer optimization is <code>Option&lt;T&gt;</code>,
where <code>None</code> corresponds to <code>null</code>. So <code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code> is a correct way
to represent a nullable function pointer using the C ABI (corresponding to the C type
<code>int (*)(int)</code>).</p>

<p>Here is a contrived example. Let&#39;s say some C library has a facility for registering a
callback, which gets called in certain situations. The callback is passed a function pointer
and an integer and it is supposed to run the function with the integer as a parameter. So
we have function pointers flying across the FFI boundary in both directions.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;
<span class='kw'>use</span> <span class='ident'>libc</span>::<span class='ident'>c_int</span>;

<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> {
    <span class='doccomment'>/// Registers the callback.</span>
    <span class='kw'>fn</span> <span class='ident'>register</span>(<span class='ident'>cb</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> <span class='kw'>fn</span>(<span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> <span class='kw'>fn</span>(<span class='ident'>c_int</span>) <span class='op'>-&gt;</span> <span class='ident'>c_int</span><span class='op'>&gt;</span>, <span class='ident'>c_int</span>) <span class='op'>-&gt;</span> <span class='ident'>c_int</span><span class='op'>&gt;</span>);
}

<span class='doccomment'>/// This fairly useless function receives a function pointer and an integer</span>
<span class='doccomment'>/// from C, and returns the result of calling the function with the integer.</span>
<span class='doccomment'>/// In case no function is provided, it squares the integer by default.</span>
<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> <span class='kw'>fn</span> <span class='ident'>apply</span>(<span class='ident'>process</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> <span class='kw'>fn</span>(<span class='ident'>c_int</span>) <span class='op'>-&gt;</span> <span class='ident'>c_int</span><span class='op'>&gt;</span>, <span class='ident'>int</span>: <span class='ident'>c_int</span>) <span class='op'>-&gt;</span> <span class='ident'>c_int</span> {
    <span class='kw'>match</span> <span class='ident'>process</span> {
        <span class='prelude-val'>Some</span>(<span class='ident'>f</span>) <span class='op'>=&gt;</span> <span class='ident'>f</span>(<span class='ident'>int</span>),
        <span class='prelude-val'>None</span>    <span class='op'>=&gt;</span> <span class='ident'>int</span> <span class='op'>*</span> <span class='ident'>int</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> {
        <span class='ident'>register</span>(<span class='prelude-val'>Some</span>(<span class='ident'>apply</span>));
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3Ac_int%3B%0A%0A%23%5Bcfg(hidden)%5D%0Aextern%20%22C%22%20%7B%0A%20%20%20%20%2F%2F%2F%20Registers%20the%20callback.%0A%20%20%20%20fn%20register(cb%3A%20Option%3Cextern%20%22C%22%20fn(Option%3Cextern%20%22C%22%20fn(c_int)%20-%3E%20c_int%3E%2C%20c_int)%20-%3E%20c_int%3E)%3B%0A%7D%0Aunsafe%20fn%20register(_%3A%20Option%3Cextern%20%22C%22%20fn(Option%3Cextern%20%22C%22%20fn(c_int)%20-%3E%20c_int%3E%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20c_int)%20-%3E%20c_int%3E)%0A%7B%7D%0A%0A%2F%2F%2F%20This%20fairly%20useless%20function%20receives%20a%20function%20pointer%20and%20an%20integer%0A%2F%2F%2F%20from%20C%2C%20and%20returns%20the%20result%20of%20calling%20the%20function%20with%20the%20integer.%0A%2F%2F%2F%20In%20case%20no%20function%20is%20provided%2C%20it%20squares%20the%20integer%20by%20default.%0Aextern%20%22C%22%20fn%20apply(process%3A%20Option%3Cextern%20%22C%22%20fn(c_int)%20-%3E%20c_int%3E%2C%20int%3A%20c_int)%20-%3E%20c_int%20%7B%0A%20%20%20%20match%20process%20%7B%0A%20%20%20%20%20%20%20%20Some(f)%20%3D%3E%20f(int)%2C%0A%20%20%20%20%20%20%20%20None%20%20%20%20%3D%3E%20int%20*%20int%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20register(Some(apply))%3B%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>And the code on the C side looks like this:</p>

<pre><code class="language-c">void register(void (*f)(void (*)(int), int)) {
    ...
}
</code></pre>

<p>No <code>transmute</code> required!</p>

<h1 id='calling-rust-code-from-c' class='section-header'><a href='#calling-rust-code-from-c'>Calling Rust code from C</a></h1>
<p>You may wish to compile Rust code in a way so that it can be called from C. This is
fairly easy, but requires a few things:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>hello_rust</span>() <span class='op'>-&gt;</span> <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>u8</span> {
    <span class='string'>&quot;Hello, world!\0&quot;</span>.<span class='ident'>as_ptr</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23%5Bno_mangle%5D%0Apub%20extern%20fn%20hello_rust()%20-%3E%20*const%20u8%20%7B%0A%20%20%20%20%22Hello%2C%20world!%5C0%22.as_ptr()%0A%7D%0Afn%20main()%20%7B%7D%0A">Run</a></pre>

<p>The <code>extern</code> makes this function adhere to the C calling convention, as
discussed above in &quot;<a href="ffi.html#foreign-calling-conventions">Foreign Calling
Conventions</a>&quot;. The <code>no_mangle</code>
attribute turns off Rust&#39;s name mangling, so that it is easier to link to.</p>

<h1 id='ffi-and-panics' class='section-header'><a href='#ffi-and-panics'>FFI and panics</a></h1>
<p>It’s important to be mindful of <code>panic!</code>s when working with FFI. A <code>panic!</code>
across an FFI boundary is undefined behavior. If you’re writing code that may
panic, you should run it in a closure with <a href="../std/panic/fn.catch_unwind.html"><code>catch_unwind()</code></a>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>panic</span>::<span class='ident'>catch_unwind</span>;

<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>oh_no</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>let</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='ident'>catch_unwind</span>(<span class='op'>||</span> {
        <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Oops!&quot;</span>);
    });
    <span class='kw'>match</span> <span class='ident'>result</span> {
        <span class='prelude-val'>Ok</span>(_) <span class='op'>=&gt;</span> <span class='number'>0</span>,
        <span class='prelude-val'>Err</span>(_) <span class='op'>=&gt;</span> <span class='number'>1</span>,
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=use%20std%3A%3Apanic%3A%3Acatch_unwind%3B%0A%0A%23%5Bno_mangle%5D%0Apub%20extern%20fn%20oh_no()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20result%20%3D%20catch_unwind(%7C%7C%20%7B%0A%20%20%20%20%20%20%20%20panic!(%22Oops!%22)%3B%0A%20%20%20%20%7D)%3B%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(_)%20%3D%3E%200%2C%0A%20%20%20%20%20%20%20%20Err(_)%20%3D%3E%201%2C%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%7D%0A">Run</a></pre>

<p>Please note that <a href="../std/panic/fn.catch_unwind.html"><code>catch_unwind()</code></a> will only catch unwinding panics, not
those who abort the process. See the documentation of <a href="../std/panic/fn.catch_unwind.html"><code>catch_unwind()</code></a>
for more information.</p>

<h1 id='representing-opaque-structs' class='section-header'><a href='#representing-opaque-structs'>Representing opaque structs</a></h1>
<p>Sometimes, a C library wants to provide a pointer to something, but not let you
know the internal details of the thing it wants. The simplest way is to use a
<code>void *</code> argument:</p>

<pre><code class="language-c">void foo(void *arg);
void bar(void *arg);
</code></pre>

<p>We can represent this in Rust with the <code>c_void</code> type:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;

<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>arg</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>libc</span>::<span class='ident'>c_void</span>);
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>arg</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>libc</span>::<span class='ident'>c_void</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0A%0Aextern%20%22C%22%20%7B%0A%20%20%20%20pub%20fn%20foo(arg%3A%20*mut%20libc%3A%3Ac_void)%3B%0A%20%20%20%20pub%20fn%20bar(arg%3A%20*mut%20libc%3A%3Ac_void)%3B%0A%7D%0Afn%20main()%20%7B%7D%0A&amp;version=nightly">Run</a></pre>

<p>This is a perfectly valid way of handling the situation. However, we can do a bit
better. To solve this, some C libraries will instead create a <code>struct</code>, where
the details and memory layout of the struct are private. This gives some amount
of type safety. These structures are called ‘opaque’. Here’s an example, in C:</p>

<pre><code class="language-c">struct Foo; /* Foo is a structure, but its contents are not part of the public interface */
struct Bar;
void foo(struct Foo *arg);
void bar(struct Bar *arg);
</code></pre>

<p>To do this in Rust, let’s create our own opaque types with <code>enum</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>enum</span> <span class='ident'>Foo</span> {}
<span class='kw'>pub</span> <span class='kw'>enum</span> <span class='ident'>Bar</span> {}

<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>arg</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>Foo</span>);
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>arg</span>: <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>Bar</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=pub%20enum%20Foo%20%7B%7D%0Apub%20enum%20Bar%20%7B%7D%0A%0Aextern%20%22C%22%20%7B%0A%20%20%20%20pub%20fn%20foo(arg%3A%20*mut%20Foo)%3B%0A%20%20%20%20pub%20fn%20bar(arg%3A%20*mut%20Bar)%3B%0A%7D%0Afn%20main()%20%7B%7D%0A">Run</a></pre>

<p>By using an <code>enum</code> with no variants, we create an opaque type that we can’t
instantiate, as it has no variants. But because our <code>Foo</code> and <code>Bar</code> types are
different, we’ll get type safety between the two of them, so we cannot
accidentally pass a pointer to <code>Foo</code> to <code>bar()</code>.</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>