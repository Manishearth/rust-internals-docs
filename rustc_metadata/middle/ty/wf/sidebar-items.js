initSidebarItems({"enum":[["ImpliedBound","Implied bounds are region relationships that we deduce automatically.  The idea is that (e.g.) a caller must check that a function's argument types are well-formed immediately before calling that fn, and hence the *callee* can assume that its argument types are well-formed. This may imply certain relationships between generic parameters. For example:"]],"fn":[["implied_bounds","Compute the implied bounds that a callee/impl can assume based on the fact that caller/projector has ensured that `ty` is WF.  See the `ImpliedBound` type for more details."],["object_region_bounds","Given an object type like `SomeTrait+Send`, computes the lifetime bounds that must hold on the elided self type. These are derived from the declarations of `SomeTrait`, `Send`, and friends -- if they declare `trait SomeTrait : 'static`, for example, then `'static` would appear in the list. The hard work is done by `ty::required_region_bounds`, see that for more information."],["obligations","Returns the set of obligations needed to make `ty` well-formed. If `ty` contains unresolved inference variables, this may include further WF obligations. However, if `ty` IS an unresolved inference variable, returns `None`, because we are not able to make any progress at all. This is to prevent \"livelock\" where we say \"$0 is WF if $0 is WF\"."],["predicate_obligations",""],["trait_obligations","Returns the obligations that make this trait reference well-formed.  For example, if there is a trait `Set` defined like `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF if `Bar: Eq`."]]});