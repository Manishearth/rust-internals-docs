<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Operator expressions - The Rust Reference</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">
        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }

            a .hljs {
                color: #4183c4;
            }
        </style>

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="notation.html"><strong>1.</strong> Notation</a></li><li><ul class="section"><li><a href="unicode-productions.html"><strong>1.1.</strong> Unicode productions</a></li><li><a href="string-table-productions.html"><strong>1.2.</strong> String table productions</a></li></ul></li><li><a href="lexical-structure.html"><strong>2.</strong> Lexical structure</a></li><li><ul class="section"><li><a href="input-format.html"><strong>2.1.</strong> Input format</a></li><li><a href="keywords.html"><strong>2.2.</strong> Keywords</a></li><li><a href="identifiers.html"><strong>2.3.</strong> Identifiers</a></li><li><a href="comments.html"><strong>2.4.</strong> Comments</a></li><li><a href="whitespace.html"><strong>2.5.</strong> Whitespace</a></li><li><a href="tokens.html"><strong>2.6.</strong> Tokens</a></li><li><a href="paths.html"><strong>2.7.</strong> Paths</a></li></ul></li><li><a href="macros.html"><strong>3.</strong> Macros</a></li><li><ul class="section"><li><a href="macros-by-example.html"><strong>3.1.</strong> Macros By Example</a></li><li><a href="procedural-macros.html"><strong>3.2.</strong> Procedural Macros</a></li></ul></li><li><a href="crates-and-source-files.html"><strong>4.</strong> Crates and source files</a></li><li><a href="items-and-attributes.html"><strong>5.</strong> Items and attributes</a></li><li><ul class="section"><li><a href="items.html"><strong>5.1.</strong> Items</a></li><li><ul class="section"><li><a href="items/modules.html"><strong>5.1.1.</strong> Modules</a></li><li><a href="items/extern-crates.html"><strong>5.1.2.</strong> Extern crates</a></li><li><a href="items/use-declarations.html"><strong>5.1.3.</strong> Use declarations</a></li><li><a href="items/functions.html"><strong>5.1.4.</strong> Functions</a></li><li><a href="items/type-aliases.html"><strong>5.1.5.</strong> Type aliases</a></li><li><a href="items/structs.html"><strong>5.1.6.</strong> Structs</a></li><li><a href="items/enumerations.html"><strong>5.1.7.</strong> Enumerations</a></li><li><a href="items/unions.html"><strong>5.1.8.</strong> Unions</a></li><li><a href="items/constant-items.html"><strong>5.1.9.</strong> Constant items</a></li><li><a href="items/static-items.html"><strong>5.1.10.</strong> Static items</a></li><li><a href="items/traits.html"><strong>5.1.11.</strong> Traits</a></li><li><a href="items/implementations.html"><strong>5.1.12.</strong> Implementations</a></li><li><a href="items/external-blocks.html"><strong>5.1.13.</strong> External blocks</a></li></ul></li><li><a href="visibility-and-privacy.html"><strong>5.2.</strong> Visibility and Privacy</a></li><li><a href="attributes.html"><strong>5.3.</strong> Attributes</a></li></ul></li><li><a href="statements-and-expressions.html"><strong>6.</strong> Statements and expressions</a></li><li><ul class="section"><li><a href="statements.html"><strong>6.1.</strong> Statements</a></li><li><a href="expressions.html"><strong>6.2.</strong> Expressions</a></li><li><ul class="section"><li><a href="expressions/literal-expr.html"><strong>6.2.1.</strong> Literal expressions</a></li><li><a href="expressions/path-expr.html"><strong>6.2.2.</strong> Path expressions</a></li><li><a href="expressions/block-expr.html"><strong>6.2.3.</strong> Block expressions</a></li><li><a href="expressions/operator-expr.html" class="active"><strong>6.2.4.</strong> Operator expressions</a></li><li><a href="expressions/array-expr.html"><strong>6.2.5.</strong> Array and index expressions</a></li><li><a href="expressions/tuple-expr.html"><strong>6.2.6.</strong> Tuple and index expressions</a></li><li><a href="expressions/struct-expr.html"><strong>6.2.7.</strong> Struct expressions</a></li><li><a href="expressions/enum-variant-expr.html"><strong>6.2.8.</strong> Enum variant expressions</a></li><li><a href="expressions/call-expr.html"><strong>6.2.9.</strong> Call expressions</a></li><li><a href="expressions/method-call-expr.html"><strong>6.2.10.</strong> Method call expressions</a></li><li><a href="expressions/field-expr.html"><strong>6.2.11.</strong> Field access expressions</a></li><li><a href="expressions/closure-expr.html"><strong>6.2.12.</strong> Closure expressions</a></li><li><a href="expressions/loop-expr.html"><strong>6.2.13.</strong> Loop expressions</a></li><li><a href="expressions/range-expr.html"><strong>6.2.14.</strong> Range expressions</a></li><li><a href="expressions/if-expr.html"><strong>6.2.15.</strong> If and if let expressions</a></li><li><a href="expressions/match-expr.html"><strong>6.2.16.</strong> Match expressions</a></li><li><a href="expressions/return-expr.html"><strong>6.2.17.</strong> Return expressions</a></li></ul></li></ul></li><li><a href="type-system.html"><strong>7.</strong> Type system</a></li><li><ul class="section"><li><a href="types.html"><strong>7.1.</strong> Types</a></li><li><a href="dynamically-sized-types.html"><strong>7.2.</strong> Dynamically Sized Types</a></li><li><a href="interior-mutability.html"><strong>7.3.</strong> Interior mutability</a></li><li><a href="subtyping.html"><strong>7.4.</strong> Subtyping</a></li><li><a href="type-coercions.html"><strong>7.5.</strong> Type coercions</a></li></ul></li><li><a href="special-traits.html"><strong>8.</strong> Special traits</a></li><li><ul class="section"><li><a href="the-copy-trait.html"><strong>8.1.</strong> The Copy trait</a></li><li><a href="the-sized-trait.html"><strong>8.2.</strong> The Sized trait</a></li><li><a href="the-drop-trait.html"><strong>8.3.</strong> The Drop trait</a></li><li><a href="the-deref-trait.html"><strong>8.4.</strong> The Deref trait</a></li><li><a href="the-send-trait.html"><strong>8.5.</strong> The Send trait</a></li><li><a href="the-sync-trait.html"><strong>8.6.</strong> The Sync trait</a></li></ul></li><li><a href="memory-model.html"><strong>9.</strong> Memory model</a></li><li><ul class="section"><li><a href="memory-allocation-and-lifetime.html"><strong>9.1.</strong> Memory allocation and lifetime</a></li><li><a href="memory-ownership.html"><strong>9.2.</strong> Memory ownership</a></li><li><a href="variables.html"><strong>9.3.</strong> Variables</a></li></ul></li><li><a href="linkage.html"><strong>10.</strong> Linkage</a></li><li><a href="unsafety.html"><strong>11.</strong> Unsafety</a></li><li><ul class="section"><li><a href="unsafe-functions.html"><strong>11.1.</strong> Unsafe functions</a></li><li><a href="unsafe-blocks.html"><strong>11.2.</strong> Unsafe blocks</a></li><li><a href="behavior-considered-undefined.html"><strong>11.3.</strong> Behavior considered undefined</a></li><li><a href="behavior-not-considered-unsafe.html"><strong>11.4.</strong> Behavior not considered unsafe</a></li></ul></li><li><a href="influences.html">Appendix: Influences</a></li><li class="affix"><a href="undocumented.html">Appendix: As-yet-undocumented Features</a></li><li class="affix"><a href="glossory.html">Appendix: Glossory</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page" tabindex="-1">
                <header><p class="warning">
                    For now, this reference is a best-effort document. We strive for validity and completeness, but are
                    not yet there. In the future, the docs and lang teams will work together to figure out how
                    best to do this. Until then, this is a best-effort attempt. If you find something wrong or
                    missing, file an <a href="https://github.com/rust-lang-nursery/reference/issues">issue</a> or send in a
                    pull request.
                </p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="expressions/operator-expr.html#operator-expressions" id="operator-expressions"><h1>Operator expressions</h1></a>
<p>Operators are defined for built in types by the Rust language. Many of the
following operators can also be overloaded using traits in <code>std::ops</code> or
<code>std::cmp</code>.</p>
<a class="header" href="expressions/operator-expr.html#overflow" id="overflow"><h2>Overflow</h2></a>
<p>Integer operators will panic when they overflow when compiled in debug mode.
The <code>-C debug-assertions</code> and <code>-C overflow-checks</code> compiler flags can be used
to control this more directly. The following things are considered to be
overflow:</p>
<ul>
<li>When <code>+</code>, <code>*</code> or <code>-</code> create a value greater than the maximum value, or less
than the minimum value that can be stored. This includes unary <code>-</code> on the
smallest value of any signed integer type.</li>
<li>Using <code>/</code> or <code>%</code>, where the left-hand argument is the smallest integer of a
signed integer type and the right-hand argument is <code>-1</code>.</li>
<li>Using <code>&lt;&lt;</code> or <code>&gt;&gt;</code> where the right-hand argument is greater than or equal to
the number of bits in the type of the left-hand argument, or is negative.</li>
</ul>
<a class="header" href="expressions/operator-expr.html#grouped-expressions" id="grouped-expressions"><h2>Grouped expressions</h2></a>
<p>An expression enclosed in parentheses evaluates to the result of the enclosed
expression. Parentheses can be used to explicitly specify evaluation order
within an expression.</p>
<p>An example of a parenthesized expression:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: i32 = 2 + 3 * 4;
let y: i32 = (2 + 3) * 4;
assert_eq!(x, 14);
assert_eq!(y, 20);
#}</code></pre></pre>
<a class="header" href="expressions/operator-expr.html#borrow-operators" id="borrow-operators"><h2>Borrow operators</h2></a>
<p>The <code>&amp;</code> (shared borrow) and <code>&amp;mut</code> (mutable borrow) operators are unary prefix
operators. When applied to an lvalue produce a reference (pointer) to the
location that the value refers to. The lvalue is also placed into a borrowed
state for the duration of the reference. For a shared borrow (<code>&amp;</code>), this
implies that the lvalue may not be mutated, but it may be read or shared again.
For a mutable borrow (<code>&amp;mut</code>), the lvalue may not be accessed in any way until
the borrow expires. <code>&amp;mut</code> evaluates its operand in a mutable lvalue context.
If the <code>&amp;</code> or <code>&amp;mut</code> operators are applied to an rvalue, a temporary value is
created; the lifetime of this temporary value is defined by <a href="expressions.html#temporary-lifetimes">syntactic
rules</a>. These operators cannot be overloaded.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    // a temporary with value 7 is created that lasts for this scope.
    let shared_reference = &amp;7;
}
let mut array = [-2, 3, 9];
{
    // Mutably borrows `array` for this scope.
    // `array` may only be used through `mutable_reference`.
    let mutable_reference = &amp;mut array;
}
#}</code></pre></pre>
<a class="header" href="expressions/operator-expr.html#the-dereference-operator" id="the-dereference-operator"><h2>The dereference operator</h2></a>
<p>The <code>*</code> (dereference) operator is also a unary prefix operator. When applied to
a <a href="types.html#pointer-types">pointer</a> it denotes the pointed-to location. If
the expression is of type <code>&amp;mut T</code> and <code>*mut T</code>, and is either a local
variable, a (nested) field of a local variance or is a mutable lvalue, then the
resulting <a href="expressions.html#lvalues-and-rvalues">lvalue</a> can be
assigned to. Dereferencing a raw pointer requires <code>unsafe</code>.</p>
<p>On non-pointer types <code>*x</code> is equivalent to <code>*std::ops::Deref::deref(&amp;x)</code> in an
<a href="expressions.html#mutability">immutable lvalue context</a> and
<code>*std::ops::Deref::deref_mut(&amp;mut x)</code> in a mutable lvalue context.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = &amp;7;
assert_eq!(*x, 7);
let y = &amp;mut 9;
*y = 11;
assert_eq!(*y, 11);
#}</code></pre></pre>
<a class="header" href="expressions/operator-expr.html#the--operator" id="the--operator"><h2>The <code>?</code> operator.</h2></a>
<p>The <code>?</code> (&quot;question mark&quot;) operator can be applied to values of the <code>Result&lt;T, E&gt;</code> type to propagate errors. If applied to <code>Err(e)</code> it will return
<code>Err(From::from(e))</code> from the enclosing function or closure. If applied to
<code>Ok(x)</code> it will unwrap the value to return <code>x</code>. Unlike other unary operators
<code>?</code> is written in postfix notation. <code>?</code> cannot be overloaded.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::num::ParseIntError;
fn try_to_parse() -&gt; Result&lt;i32, ParseIntError&gt; {
    let x: i32 = &quot;123&quot;.parse()?; // x = 123
    let y: i32 = &quot;24a&quot;.parse()?; // returns an Err() immediately
    Ok(x + y)                    // Doesn't run.
}

let res = try_to_parse();
println!(&quot;{:?}&quot;, res);
# assert!(res.is_err())
#}</code></pre></pre>
<a class="header" href="expressions/operator-expr.html#negation-operators" id="negation-operators"><h2>Negation operators</h2></a>
<p>These are the last two unary operators. This table summarizes the behavior of
them on primitive types and which traits are used to overload these operators
for other types. Remember that signed integers are always represented using
two's complement. The operands of all of these operators are evaluated in
rvalue context so are moved or copied.</p>
<table><thead><tr><th> Symbol </th><th> Integer     </th><th> <code>bool</code>      </th><th> Floating Point </th><th> Overloading Trait  </th></tr></thead><tbody>
<tr><td> <code>-</code>    </td><td> Negation*   </td><td>             </td><td> Negation       </td><td> <code>std::ops::Neg</code>    </td></tr>
<tr><td> <code>!</code>    </td><td> Bitwise NOT </td><td> Logical NOT </td><td>                </td><td> <code>std::ops::Not</code>    </td></tr>
</tbody></table>
<p>* Only for signed integer types.</p>
<p>Here are some example of these operators</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 6;
assert_eq!(-x, -6);
assert_eq!(!x, -7);
assert_eq!(true, !false);
#}</code></pre></pre>
<a class="header" href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators" id="arithmetic-and-logical-binary-operators"><h2>Arithmetic and Logical Binary Operators</h2></a>
<p>Binary operators expressions are all written with infix notation. This table
summarizes the behavior of arithmetic and logical binary operators on
primitive types and which traits are used to overload these operators for other
types. Remember that signed integers are always represented using two's
complement. The operands of all of these operators are evaluated in rvalue
context so are moved or copied.</p>
<table><thead><tr><th> Symbol </th><th> Integer                 </th><th> <code>bool</code>      </th><th> Floating Point </th><th> Overloading Trait  </th></tr></thead><tbody>
<tr><td> <code>+</code>    </td><td> Addition                </td><td>             </td><td> Addition       </td><td> <code>std::ops::Add</code>    </td></tr>
<tr><td> <code>-</code>    </td><td> Subtraction             </td><td>             </td><td> Subtraction    </td><td> <code>std::ops::Sub</code>    </td></tr>
<tr><td> <code>*</code>    </td><td> Multiplication          </td><td>             </td><td> Multiplication </td><td> <code>std::ops::Mul</code>    </td></tr>
<tr><td> <code>/</code>    </td><td> Division                </td><td>             </td><td> Division       </td><td> <code>std::ops::Div</code>    </td></tr>
<tr><td> <code>%</code>    </td><td> Remainder               </td><td>             </td><td> Remainder      </td><td> <code>std::ops::Rem</code>    </td></tr>
<tr><td> <code>&amp;</code>    </td><td> Bitwise AND             </td><td> Logical AND </td><td>                </td><td> <code>std::ops::BitAnd</code> </td></tr>
<tr><td> <code>|</code> </td><td> Bitwise OR </td><td> Logical OR  </td><td>                </td><td> <code>std::ops::BitOr</code>  </td></tr>
<tr><td> <code>^</code>    </td><td> Bitwise XOR             </td><td> Logical XOR </td><td>                </td><td> <code>std::ops::BitXor</code> </td></tr>
<tr><td> <code>&lt;&lt;</code>   </td><td> Left Shift              </td><td>             </td><td>                </td><td> <code>std::ops::Shl</code>    </td></tr>
<tr><td> <code>&gt;&gt;</code>   </td><td> Right Shift*            </td><td>             </td><td>                </td><td> <code>std::ops::Shr</code>    </td></tr>
</tbody></table>
<p>* Arithmetic right shift on signed integer types, logical right shift on
unsigned integer types.</p>
<p>Here are examples of these operators being used.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
assert_eq!(3 + 6, 9);
assert_eq!(5.5 - 1.25, 4.25);
assert_eq!(-5 * 14, -70);
assert_eq!(14 / 3, 4);
assert_eq!(100 % 7, 2);
assert_eq!(0b1010 &amp; 0b1100, 0b1000);
assert_eq!(0b1010 | 0b1100, 0b1110);
assert_eq!(0b1010 ^ 0b1100, 0b110);
assert_eq!(13 &lt;&lt; 3, 104);
assert_eq!(-10 &gt;&gt; 2, -3);
#}</code></pre></pre>
<a class="header" href="expressions/operator-expr.html#comparison-operators" id="comparison-operators"><h2>Comparison Operators</h2></a>
<p>Comparison operators are also defined both for primitive types and many type in
the standard library. Parentheses are required when chaining comparison
operators. For example, the expression <code>a == b == c</code> is invalid and may be
written as <code>(a == b) == c</code>.</p>
<p>Unlike arithmetic and logical operators, the traits for
overloading the operators the traits for these operators are used more
generally to show how a type may be compared and will likely be assumed to
define actual comparisons by functions that use these traits as bounds. Many
functions and macros in the standard library can then use that assumption
(although not to ensure safety). Unlike the arithmetic and logical operators
above, these operators implicitly take shared borrows of their operands,
evaluating them in lvalue context:</p>
<pre><code class="language-rust ignore">a == b;
// is equivalent to
::std::cmp::PartialEq::eq(&amp;a, &amp;b);
</code></pre>
<p>This means that the operands don't have to be moved out of.</p>
<table><thead><tr><th> Symbol </th><th> Meaning                  </th><th> Overloading method         </th></tr></thead><tbody>
<tr><td> <code>==</code>   </td><td> Equal                    </td><td> <code>std::cmp::PartialEq::eq</code>  </td></tr>
<tr><td> <code>!=</code>   </td><td> Not equal                </td><td> <code>std::cmp::PartialEq::ne</code>  </td></tr>
<tr><td> <code>&gt;</code>    </td><td> Greater than             </td><td> <code>std::cmp::PartialOrd::gt</code> </td></tr>
<tr><td> <code>&lt;</code>    </td><td> Less than                </td><td> <code>std::cmp::PartialOrd::lt</code> </td></tr>
<tr><td> <code>&gt;=</code>   </td><td> Greater than or equal to </td><td> <code>std::cmp::PartialOrd::ge</code> </td></tr>
<tr><td> <code>&lt;=</code>   </td><td> Less than or equal to    </td><td> <code>std::cmp::PartialOrd::le</code> </td></tr>
</tbody></table>
<p>Here are examples of the comparison operators being used.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
assert!(123 == 123);
assert!(23 != -12);
assert!(12.5 &gt; 12.2);
assert!([1, 2, 3] &lt; [1, 3, 4]);
assert!('A' &lt;= 'B');
assert!(&quot;World&quot; &gt;= &quot;Hello&quot;);
#}</code></pre></pre>
<a class="header" href="expressions/operator-expr.html#lazy-boolean-operators" id="lazy-boolean-operators"><h2>Lazy boolean operators</h2></a>
<p>The operators <code>||</code> and <code>&amp;&amp;</code> may be applied to operands of boolean type. The
<code>||</code> operator denotes logical 'or', and the <code>&amp;&amp;</code> operator denotes logical
'and'. They differ from <code>|</code> and <code>&amp;</code> in that the right-hand operand is only
evaluated when the left-hand operand does not already determine the result of
the expression. That is, <code>||</code> only evaluates its right-hand operand when the
left-hand operand evaluates to <code>false</code>, and <code>&amp;&amp;</code> only when it evaluates to
<code>true</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = false || true; // true
let y = false &amp;&amp; panic!(); // false, doesn't evaluate `panic!()`
#}</code></pre></pre>
<a class="header" href="expressions/operator-expr.html#type-cast-expressions" id="type-cast-expressions"><h2>Type cast expressions</h2></a>
<p>A type cast expression is denoted with the binary operator <code>as</code>.</p>
<p>Executing an <code>as</code> expression casts the value on the left-hand side to the type
on the right-hand side.</p>
<p>An example of an <code>as</code> expression:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn sum(values: &amp;[f64]) -&gt; f64 { 0.0 }
# fn len(values: &amp;[f64]) -&gt; i32 { 0 }
fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}
#}</code></pre></pre>
<p><code>as</code> can be used to explicitly perform <a href="type-coercions.html">coercions</a>, as
well as the following additional casts. Here <code>*T</code> means either <code>*const T</code> or
<code>*mut T</code>.</p>
<table><thead><tr><th> Type of <code>e</code>           </th><th> <code>U</code>                   </th><th> Cast performed by <code>e as U</code>       </th></tr></thead><tbody>
<tr><td> Integer or Float type </td><td> Integer or Float type </td><td> Numeric cast                     </td></tr>
<tr><td> C-like enum           </td><td> Integer type          </td><td> Enum cast                        </td></tr>
<tr><td> <code>bool</code> or <code>char</code>      </td><td> Integer type          </td><td> Primitive to integer cast        </td></tr>
<tr><td> <code>u8</code>                  </td><td> <code>char</code>                </td><td> <code>u8</code> to <code>char</code> cast              </td></tr>
<tr><td> <code>*T</code>                  </td><td> <code>*V</code> where <code>V: Sized</code> * </td><td> Pointer to pointer cast       </td></tr>
<tr><td> <code>*T</code> where <code>T: Sized</code> </td><td> Numeric type          </td><td> Pointer to address cast          </td></tr>
<tr><td> Integer type          </td><td> <code>*V</code> where <code>V: Sized</code> </td><td> Address to pointer cast          </td></tr>
<tr><td> <code>&amp;[T; n]</code>             </td><td> <code>*const T</code>            </td><td> Array to pointer cast            </td></tr>
<tr><td> <a href="types.html#function-pointer-types">Function pointer</a> </td><td> <code>*V</code> where <code>V: Sized</code> </td><td> Function pointer to pointer cast </td></tr>
<tr><td> Function pointer      </td><td> Integer               </td><td> Function pointer to address cast </td></tr>
</tbody></table>
<p>* or <code>T</code> and <code>V</code> are compatible unsized types, e.g., both slices, both the
same trait object.</p>
<a class="header" href="expressions/operator-expr.html#semantics" id="semantics"><h3>Semantics</h3></a>
<ul>
<li>Numeric cast
<ul>
<li>Casting between two integers of the same size (e.g. i32 -&gt; u32) is a no-op</li>
<li>Casting from a larger integer to a smaller integer (e.g. u32 -&gt; u8) will
truncate</li>
<li>Casting from a smaller integer to a larger integer (e.g. u8 -&gt; u32) will
<ul>
<li>zero-extend if the source is unsigned</li>
<li>sign-extend if the source is signed</li>
</ul>
</li>
<li>Casting from a float to an integer will round the float towards zero
<ul>
<li><strong><a href="https://github.com/rust-lang/rust/issues/10184">NOTE: currently this will cause Undefined Behavior if the rounded
value cannot be represented by the target integer type</a></strong>.
This includes Inf and NaN. This is a bug and will be fixed.</li>
</ul>
</li>
<li>Casting from an integer to float will produce the floating point
representation of the integer, rounded if necessary (rounding strategy
unspecified)</li>
<li>Casting from an f32 to an f64 is perfect and lossless</li>
<li>Casting from an f64 to an f32 will produce the closest possible value
(rounding strategy unspecified)
<ul>
<li><strong><a href="https://github.com/rust-lang/rust/issues/15536">NOTE: currently this will cause Undefined Behavior if the value
is finite but larger or smaller than the largest or smallest finite
value representable by f32</a></strong>. This is a bug and will
be fixed.</li>
</ul>
</li>
</ul>
</li>
<li>Enum cast
<ul>
<li>Casts an enum to its discriminant, then uses a numeric cast if needed.</li>
</ul>
</li>
<li>Primitive to integer cast
<ul>
<li><code>false</code> casts to <code>0</code>, <code>true</code> casts to <code>1</code></li>
<li><code>char</code> casts to the value of the code point, then uses a numeric cast if needed.</li>
</ul>
</li>
<li><code>u8</code> to <code>char</code> cast
<ul>
<li>Casts to the <code>char</code> with the corresponding code point.</li>
</ul>
</li>
</ul>
<a class="header" href="expressions/operator-expr.html#assignment-expressions" id="assignment-expressions"><h2>Assignment expressions</h2></a>
<p>An <em>assignment expression</em> consists of an
<a href="expressions.html#lvalues-and-rvalues">lvalue</a> expression followed
by an equals sign (<code>=</code>) and an
<a href="expressions.html#lvalues-and-rvalues">rvalue</a> expression.</p>
<p>Evaluating an assignment expression <a href="expressions.html#moved-and-copied-types">either copies or
moves</a> its right-hand operand to its left-hand
operand. The left-hand operand must be an lvalue: using an rvalue results in a
compiler error, rather than promoting it to a temporary.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let mut x = 0;
# let y = 0;
x = y;
#}</code></pre></pre>
<a class="header" href="expressions/operator-expr.html#compound-assignment-expressions" id="compound-assignment-expressions"><h2>Compound assignment expressions</h2></a>
<p>The <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code> operators may be
composed with the <code>=</code> operator. The expression <code>lval OP= val</code> is equivalent to
<code>lval = lval OP val</code>. For example, <code>x = x + 1</code> may be written as <code>x += 1</code>.
Any such expression always has the <a href="types.html#tuple-types"><code>unit</code></a> type.
These operators can all be overloaded using the trait with the same name as for
the normal operation followed by 'Assign', for example, <code>std::ops::AddAssign</code>
is used to overload <code>+=</code>. As with <code>=</code>, <code>lval</code> must be an lvalue.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 10;
x += 4;
assert_eq!(x, 14);
#}</code></pre></pre>
<a class="header" href="expressions/operator-expr.html#operator-precedence" id="operator-precedence"><h2>Operator precedence</h2></a>
<p>The precedence of Rust operators is ordered as follows, going from strong to
weak. Binary Operators at the same precedence level are evaluated in the order
given by their associativity.</p>
<table><thead><tr><th> Operator                    </th><th> Associativity       </th></tr></thead><tbody>
<tr><td> <code>?</code>                         </td><td>                     </td></tr>
<tr><td> Unary <code>-</code> <code>*</code> <code>!</code> <code>&amp;</code> <code>&amp;mut</code> </td><td>                    </td></tr>
<tr><td> <code>as</code> <code>:</code>                    </td><td> left to right       </td></tr>
<tr><td> <code>*</code> <code>/</code> <code>%</code>                 </td><td> left to right       </td></tr>
<tr><td> <code>+</code> <code>-</code>                     </td><td> left to right       </td></tr>
<tr><td> <code>&lt;&lt;</code> <code>&gt;&gt;</code>                   </td><td> left to right       </td></tr>
<tr><td> <code>&amp;</code>                         </td><td> left to right       </td></tr>
<tr><td> <code>^</code>                         </td><td> left to right       </td></tr>
<tr><td> <code>|</code>         </td><td> left to right       </td></tr>
<tr><td> <code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> </td><td> Require parentheses </td></tr>
<tr><td> <code>&amp;&amp;</code>                        </td><td> left to right       </td></tr>
<tr><td> <code>||</code>   </td><td> left to right       </td></tr>
<tr><td> <code>..</code> <code>...</code>                  </td><td> Require parentheses </td></tr>
<tr><td> <code>&lt;-</code>                        </td><td> right to left       </td></tr>
<tr><td> <code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <br> <code>&amp;=</code> <code>|=</code> <code>^=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> </td><td> right to left </td></tr>
</tbody></table>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="expressions/block-expr.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="expressions/array-expr.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="expressions/block-expr.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="expressions/array-expr.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
