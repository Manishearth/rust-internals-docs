<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Types - The Rust Reference</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">
        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }

            a .hljs {
                color: #4183c4;
            }
        </style>

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="notation.html"><strong>1.</strong> Notation</a></li><li><ul class="section"><li><a href="unicode-productions.html"><strong>1.1.</strong> Unicode productions</a></li><li><a href="string-table-productions.html"><strong>1.2.</strong> String table productions</a></li></ul></li><li><a href="lexical-structure.html"><strong>2.</strong> Lexical structure</a></li><li><ul class="section"><li><a href="input-format.html"><strong>2.1.</strong> Input format</a></li><li><a href="keywords.html"><strong>2.2.</strong> Keywords</a></li><li><a href="identifiers.html"><strong>2.3.</strong> Identifiers</a></li><li><a href="comments.html"><strong>2.4.</strong> Comments</a></li><li><a href="whitespace.html"><strong>2.5.</strong> Whitespace</a></li><li><a href="tokens.html"><strong>2.6.</strong> Tokens</a></li><li><a href="paths.html"><strong>2.7.</strong> Paths</a></li></ul></li><li><a href="macros.html"><strong>3.</strong> Macros</a></li><li><ul class="section"><li><a href="macros-by-example.html"><strong>3.1.</strong> Macros By Example</a></li><li><a href="procedural-macros.html"><strong>3.2.</strong> Procedural Macros</a></li></ul></li><li><a href="crates-and-source-files.html"><strong>4.</strong> Crates and source files</a></li><li><a href="items-and-attributes.html"><strong>5.</strong> Items and attributes</a></li><li><ul class="section"><li><a href="items.html"><strong>5.1.</strong> Items</a></li><li><ul class="section"><li><a href="items/modules.html"><strong>5.1.1.</strong> Modules</a></li><li><a href="items/extern-crates.html"><strong>5.1.2.</strong> Extern crates</a></li><li><a href="items/use-declarations.html"><strong>5.1.3.</strong> Use declarations</a></li><li><a href="items/functions.html"><strong>5.1.4.</strong> Functions</a></li><li><a href="items/type-aliases.html"><strong>5.1.5.</strong> Type aliases</a></li><li><a href="items/structs.html"><strong>5.1.6.</strong> Structs</a></li><li><a href="items/enumerations.html"><strong>5.1.7.</strong> Enumerations</a></li><li><a href="items/unions.html"><strong>5.1.8.</strong> Unions</a></li><li><a href="items/constant-items.html"><strong>5.1.9.</strong> Constant items</a></li><li><a href="items/static-items.html"><strong>5.1.10.</strong> Static items</a></li><li><a href="items/traits.html"><strong>5.1.11.</strong> Traits</a></li><li><a href="items/implementations.html"><strong>5.1.12.</strong> Implementations</a></li><li><a href="items/external-blocks.html"><strong>5.1.13.</strong> External blocks</a></li></ul></li><li><a href="visibility-and-privacy.html"><strong>5.2.</strong> Visibility and Privacy</a></li><li><a href="attributes.html"><strong>5.3.</strong> Attributes</a></li></ul></li><li><a href="statements-and-expressions.html"><strong>6.</strong> Statements and expressions</a></li><li><ul class="section"><li><a href="statements.html"><strong>6.1.</strong> Statements</a></li><li><a href="expressions.html"><strong>6.2.</strong> Expressions</a></li><li><ul class="section"><li><a href="expressions/literal-expr.html"><strong>6.2.1.</strong> Literal expressions</a></li><li><a href="expressions/path-expr.html"><strong>6.2.2.</strong> Path expressions</a></li><li><a href="expressions/block-expr.html"><strong>6.2.3.</strong> Block expressions</a></li><li><a href="expressions/operator-expr.html"><strong>6.2.4.</strong> Operator expressions</a></li><li><a href="expressions/array-expr.html"><strong>6.2.5.</strong> Array and index expressions</a></li><li><a href="expressions/tuple-expr.html"><strong>6.2.6.</strong> Tuple and index expressions</a></li><li><a href="expressions/struct-expr.html"><strong>6.2.7.</strong> Struct expressions</a></li><li><a href="expressions/enum-variant-expr.html"><strong>6.2.8.</strong> Enum variant expressions</a></li><li><a href="expressions/call-expr.html"><strong>6.2.9.</strong> Call expressions</a></li><li><a href="expressions/method-call-expr.html"><strong>6.2.10.</strong> Method call expressions</a></li><li><a href="expressions/field-expr.html"><strong>6.2.11.</strong> Field access expressions</a></li><li><a href="expressions/closure-expr.html"><strong>6.2.12.</strong> Closure expressions</a></li><li><a href="expressions/loop-expr.html"><strong>6.2.13.</strong> Loop expressions</a></li><li><a href="expressions/range-expr.html"><strong>6.2.14.</strong> Range expressions</a></li><li><a href="expressions/if-expr.html"><strong>6.2.15.</strong> If and if let expressions</a></li><li><a href="expressions/match-expr.html"><strong>6.2.16.</strong> Match expressions</a></li><li><a href="expressions/return-expr.html"><strong>6.2.17.</strong> Return expressions</a></li></ul></li></ul></li><li><a href="type-system.html"><strong>7.</strong> Type system</a></li><li><ul class="section"><li><a href="types.html" class="active"><strong>7.1.</strong> Types</a></li><li><a href="dynamically-sized-types.html"><strong>7.2.</strong> Dynamically Sized Types</a></li><li><a href="interior-mutability.html"><strong>7.3.</strong> Interior mutability</a></li><li><a href="subtyping.html"><strong>7.4.</strong> Subtyping</a></li><li><a href="type-coercions.html"><strong>7.5.</strong> Type coercions</a></li></ul></li><li><a href="special-traits.html"><strong>8.</strong> Special traits</a></li><li><ul class="section"><li><a href="the-copy-trait.html"><strong>8.1.</strong> The Copy trait</a></li><li><a href="the-sized-trait.html"><strong>8.2.</strong> The Sized trait</a></li><li><a href="the-drop-trait.html"><strong>8.3.</strong> The Drop trait</a></li><li><a href="the-deref-trait.html"><strong>8.4.</strong> The Deref trait</a></li><li><a href="the-send-trait.html"><strong>8.5.</strong> The Send trait</a></li><li><a href="the-sync-trait.html"><strong>8.6.</strong> The Sync trait</a></li></ul></li><li><a href="memory-model.html"><strong>9.</strong> Memory model</a></li><li><ul class="section"><li><a href="memory-allocation-and-lifetime.html"><strong>9.1.</strong> Memory allocation and lifetime</a></li><li><a href="memory-ownership.html"><strong>9.2.</strong> Memory ownership</a></li><li><a href="variables.html"><strong>9.3.</strong> Variables</a></li></ul></li><li><a href="linkage.html"><strong>10.</strong> Linkage</a></li><li><a href="unsafety.html"><strong>11.</strong> Unsafety</a></li><li><ul class="section"><li><a href="unsafe-functions.html"><strong>11.1.</strong> Unsafe functions</a></li><li><a href="unsafe-blocks.html"><strong>11.2.</strong> Unsafe blocks</a></li><li><a href="behavior-considered-undefined.html"><strong>11.3.</strong> Behavior considered undefined</a></li><li><a href="behavior-not-considered-unsafe.html"><strong>11.4.</strong> Behavior not considered unsafe</a></li></ul></li><li><a href="influences.html">Appendix: Influences</a></li><li class="affix"><a href="undocumented.html">Appendix: As-yet-undocumented Features</a></li><li class="affix"><a href="glossory.html">Appendix: Glossory</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page" tabindex="-1">
                <header><p class="warning">
                    For now, this reference is a best-effort document. We strive for validity and completeness, but are
                    not yet there. In the future, the docs and lang teams will work together to figure out how
                    best to do this. Until then, this is a best-effort attempt. If you find something wrong or
                    missing, file an <a href="https://github.com/rust-lang-nursery/reference/issues">issue</a> or send in a
                    pull request.
                </p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="types.html#types" id="types"><h1>Types</h1></a>
<p>Every variable, item and value in a Rust program has a type. The <em>type</em> of a
<em>value</em> defines the interpretation of the memory holding it.</p>
<p>Built-in types are tightly integrated into the language, in nontrivial ways
that are not possible to emulate in user-defined types. User-defined types have
limited capabilities.</p>
<a class="header" href="types.html#primitive-types" id="primitive-types"><h2>Primitive types</h2></a>
<p>Some types are defined by the language, rather than as part of the standard
library, these are called <em>primitive types</em>. Some of these are individual
types:</p>
<ul>
<li>The boolean type <code>bool</code> with values <code>true</code> and <code>false</code>.</li>
<li>The <a href="types.html#machine-types">machine types</a> (integer and floating-point).</li>
<li>The <a href="types.html#machine-dependent-integer-types">machine-dependent integer types</a>.</li>
<li>The <a href="types.html#textual-types">textual types</a> <code>char</code> and <code>str</code>.</li>
</ul>
<p>There are also some primitive constructs for generic types built in to the
language:</p>
<ul>
<li><a href="types.html#tuple-types">Tuples</a></li>
<li><a href="types.html#array-and-slice-types">Arrays</a></li>
<li><a href="types.html#array-and-slice-types">Slices</a></li>
<li><a href="types.html#function-pointer-types">Function pointers</a></li>
<li><a href="types.html#pointer-types">References</a></li>
<li><a href="types.html#raw-pointers-const-and-mut">Pointers</a></li>
</ul>
<a class="header" href="types.html#numeric-types" id="numeric-types"><h2>Numeric types</h2></a>
<a class="header" href="types.html#machine-types" id="machine-types"><h3>Machine types</h3></a>
<p>The machine types are the following:</p>
<ul>
<li>
<p>The unsigned word types <code>u8</code>, <code>u16</code>, <code>u32</code> and <code>u64</code>, with values drawn from
the integer intervals [0, 2^8 - 1], [0, 2^16 - 1], [0, 2^32 - 1] and
[0, 2^64 - 1] respectively.</p>
</li>
<li>
<p>The signed two's complement word types <code>i8</code>, <code>i16</code>, <code>i32</code> and <code>i64</code>, with
values drawn from the integer intervals [-(2^(7)), 2^7 - 1],
[-(2^(15)), 2^15 - 1], [-(2^(31)), 2^31 - 1], [-(2^(63)), 2^63 - 1]
respectively.</p>
</li>
<li>
<p>The IEEE 754-2008 <code>binary32</code> and <code>binary64</code> floating-point types: <code>f32</code> and
<code>f64</code>, respectively.</p>
</li>
</ul>
<a class="header" href="types.html#machine-dependent-integer-types" id="machine-dependent-integer-types"><h3>Machine-dependent integer types</h3></a>
<p>The <code>usize</code> type is an unsigned integer type with the same number of bits as the
platform's pointer type. It can represent every memory address in the process.</p>
<p>The <code>isize</code> type is a signed integer type with the same number of bits as the
platform's pointer type. The theoretical upper bound on object and array size
is the maximum <code>isize</code> value. This ensures that <code>isize</code> can be used to calculate
differences between pointers into an object or array and can address every byte
within an object along with one byte past the end.</p>
<a class="header" href="types.html#textual-types" id="textual-types"><h2>Textual types</h2></a>
<p>The types <code>char</code> and <code>str</code> hold textual data.</p>
<p>A value of type <code>char</code> is a <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a> (i.e. a code point that
is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to
0xD7FF or 0xE000 to 0x10FFFF range. A <code>[char]</code> is effectively a UCS-4 / UTF-32
string.</p>
<p>A value of type <code>str</code> is a Unicode string, represented as an array of 8-bit
unsigned bytes holding a sequence of UTF-8 code points. Since <code>str</code> is a
<a href="dynamically-sized-types.html">dynamically sized type</a>, it is not a <em>first-class</em> type, but can only be
instantiated through a pointer type, such as <code>&amp;str</code>.</p>
<a class="header" href="types.html#tuple-types" id="tuple-types"><h2>Tuple types</h2></a>
<p>A tuple <em>type</em> is a heterogeneous product of other types, called the <em>elements</em>
of the tuple. It has no nominal name and is instead structurally typed.</p>
<p>Tuple types and values are denoted by listing the types or values of their
elements, respectively, in a parenthesized, comma-separated list.</p>
<p>Because tuple elements don't have a name, they can only be accessed by
pattern-matching or by using <code>N</code> directly as a field to access the <code>N</code>th
element.</p>
<p>An example of a tuple type and its use:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Pair&lt;'a&gt; = (i32, &amp;'a str);
let p: Pair&lt;'static&gt; = (10, &quot;ten&quot;);
let (a, b) = p;

assert_eq!(a, 10);
assert_eq!(b, &quot;ten&quot;);
assert_eq!(p.0, 10);
assert_eq!(p.1, &quot;ten&quot;);
#}</code></pre></pre>
<p>For historical reasons and convenience, the tuple type with no elements (<code>()</code>)
is often called ‘unit’ or ‘the unit type’.</p>
<a class="header" href="types.html#array-and-slice-types" id="array-and-slice-types"><h2>Array, and Slice types</h2></a>
<p>Rust has two different types for a list of items:</p>
<ul>
<li><code>[T; N]</code>, an 'array'</li>
<li><code>[T]</code>, a 'slice'</li>
</ul>
<p>An array has a fixed size, and can be allocated on either the stack or the
heap.</p>
<p>A slice is a <a href="dynamically-sized-types.html">dynamically sized type</a> representing a 'view' into an array. To
use a slice type it generally has to be used behind a pointer for example as</p>
<ul>
<li><code>&amp;[T]</code>, a 'shared slice', often just called a 'slice', it doesn't own the
data it points to, it borrows it.</li>
<li><code>&amp;mut [T]</code>, a 'mutable slice', mutably borrows the data it points to.</li>
<li><code>Box&lt;[T]&gt;</code>, a 'boxed slice'</li>
</ul>
<p>Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// A stack-allocated array
let array: [i32; 3] = [1, 2, 3];

// A heap-allocated array, coerced to a slice
let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);

// A (shared) slice into an array
let slice: &amp;[i32] = &amp;boxed_array[..];
#}</code></pre></pre>
<p>All elements of arrays and slices are always initialized, and access to an
array or slice is always bounds-checked in safe methods and operators.</p>
<p>The <a href="../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> standard library type provides a heap allocated resizable array
type.</p>
<a class="header" href="types.html#struct-types" id="struct-types"><h2>Struct types</h2></a>
<p>A <code>struct</code> <em>type</em> is a heterogeneous product of other types, called the
<em>fields</em> of the type.<sup class="footnote-reference"><a href="types.html#structtype">1</a></sup></p>
<p>New instances of a <code>struct</code> can be constructed with a <a href="expressions/struct-expr.html">struct
expression</a>.</p>
<p>The memory layout of a <code>struct</code> is undefined by default to allow for compiler
optimizations like field reordering, but it can be fixed with the
<code>#[repr(...)]</code> attribute. In either case, fields may be given in any order in a
corresponding struct <em>expression</em>; the resulting <code>struct</code> value will always
have the same memory layout.</p>
<p>The fields of a <code>struct</code> may be qualified by <a href="visibility-and-privacy.html">visibility
modifiers</a>, to allow access to data in a struct
outside a module.</p>
<p>A <em>tuple struct</em> type is just like a struct type, except that the fields are
anonymous.</p>
<p>A <em>unit-like struct</em> type is like a struct type, except that it has no fields.
The one value constructed by the associated <a href="expressions/struct-expr.html">struct
expression</a> is the only value that
inhabits such a type.</p>
<div class="footnote-definition" id="structtype"><sup class="footnote-definition-label">1</sup>
<p><code>struct</code> types are analogous to <code>struct</code> types in C, the
<em>record</em> types of the ML family, or the <em>struct</em> types of the Lisp family.</p>
</div>
<a class="header" href="types.html#enumerated-types" id="enumerated-types"><h2>Enumerated types</h2></a>
<p>An <em>enumerated type</em> is a nominal, heterogeneous disjoint union type, denoted
by the name of an <a href="items/enumerations.html"><code>enum</code> item</a>. <sup class="footnote-reference"><a href="types.html#enumtype">2</a></sup></p>
<p>An <a href="items/enumerations.html"><code>enum</code> item</a> declares both the type and a number
of <em>variants</em>, each of which is independently named and has the syntax of a
struct, tuple struct or unit-like struct.</p>
<p>New instances of an <code>enum</code> can be constructed in an <a href="expressions/enum-variant-expr.html">enumeration variant
expression</a>.</p>
<p>Any <code>enum</code> value consumes as much memory as the largest variant for its
corresponding <code>enum</code> type, as well as the size needed to store a discriminant.</p>
<p>Enum types cannot be denoted <em>structurally</em> as types, but must be denoted by
named reference to an <a href="items/enumerations.html"><code>enum</code> item</a>.</p>
<div class="footnote-definition" id="enumtype"><sup class="footnote-definition-label">2</sup>
<p>The <code>enum</code> type is analogous to a <code>data</code> constructor declaration in
ML, or a <em>pick ADT</em> in Limbo.</p>
</div>
<a class="header" href="types.html#union-types" id="union-types"><h2>Union types</h2></a>
<p>A <em>union type</em> is a nominal, heterogeneous C-like union, denoted by the name of
a <a href="items/unions.html"><code>union</code> item</a>.</p>
<p>A union contains the value of any one of its fields. Since the accessing the
wrong field can cause unexpected or undefined behaviour, <code>unsafe</code> is required
to read from a union field or to write to a field that doesn't implement
<a href="the-copy-trait.html"><code>Copy</code></a>.</p>
<p>The memory layout of a <code>union</code> is undefined by default, but the <code>#[repr(...)]</code>
attribute can be used to fix a layout.</p>
<a class="header" href="types.html#recursive-types" id="recursive-types"><h2>Recursive types</h2></a>
<p>Nominal types — <a href="types.html#struct-types">structs</a>,
<a href="types.html#enumerated-types">enumerations</a> and <a href="types.html#union-types">unions</a> — may be
recursive. That is, each <code>enum</code> variant or <code>struct</code> or <code>union</code> field may refer,
directly or indirectly, to the enclosing <code>enum</code> or <code>struct</code> type itself. Such
recursion has restrictions:</p>
<ul>
<li>Recursive types must include a nominal type in the recursion (not mere <a href="../grammar.html#type-definitions">type
definitions</a>, or other structural types
such as <a href="types.html#array-and-slice-types">arrays</a> or <a href="types.html#tuple-types">tuples</a>). So
<code>type Rec = &amp;'static [Rec]</code> is not allowed.</li>
<li>The size of a recursive type must be finite; in other words the recursive
fields of the type must be <a href="types.html#pointer-types">pointer types</a>.</li>
<li>Recursive type definitions can cross module boundaries, but not module
<em>visibility</em> boundaries, or crate boundaries (in order to simplify the module
system and type checker).</li>
</ul>
<p>An example of a <em>recursive</em> type and its use:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum List&lt;T&gt; {
    Nil,
    Cons(T, Box&lt;List&lt;T&gt;&gt;)
}

let a: List&lt;i32&gt; = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));
#}</code></pre></pre>
<a class="header" href="types.html#pointer-types" id="pointer-types"><h2>Pointer types</h2></a>
<p>All pointers in Rust are explicit first-class values. They can be moved or
copied, stored into data structs, and returned from functions.</p>
<a class="header" href="types.html#shared-references-" id="shared-references-"><h3>Shared references (<code>&amp;</code>)</h3></a>
<p>These point to memory <em>owned by some other value</em>. When a shared reference to a
value is created it prevents direct mutation of the value. <a href="interior-mutability.html">Interior
mutability</a> provides an exception for this in certain
circumstances. As the name suggests, any number of shared references to a value
may exit. A shared reference type is written <code>&amp;type</code>, or <code>&amp;'a type</code> when you
need to specify an explicit lifetime. Copying a reference is a &quot;shallow&quot;
operation: it involves only copying the pointer itself, that is, pointers are
<code>Copy</code>. Releasing a reference has no effect on the value it points to, but
referencing of a <a href="expressions.html#temporary-lifetimes">temporary value</a> will
keep it alive during the scope of the reference itself.</p>
<a class="header" href="types.html#mutable-references-mut" id="mutable-references-mut"><h3>Mutable references (<code>&amp;mut</code>)</h3></a>
<p>These also point to memory owned by some other value. A mutable reference type
is written <code>&amp;mut type</code> or <code>&amp;'a mut type</code>. A mutable reference (that hasn't been
borrowed) is the only way to access the value it points to, so is not <code>Copy</code>.</p>
<a class="header" href="types.html#raw-pointers-const-and-mut" id="raw-pointers-const-and-mut"><h3>Raw pointers (<code>*const</code> and <code>*mut</code>)</h3></a>
<p>Raw pointers are pointers without safety or liveness guarantees. Raw pointers
are written as <code>*const T</code> or <code>*mut T</code>, for example <code>*const i32</code> means a raw
pointer to a 32-bit integer. Copying or dropping a raw pointer has no effect on
the lifecycle of any other value. Dereferencing a raw pointer is an <a href="unsafe-functions.html"><code>unsafe</code>
operation</a>, this can also be used to convert a raw
pointer to a reference by reborrowing it (<code>&amp;*</code> or <code>&amp;mut *</code>). Raw pointers are
generally discouraged in Rust code; they exist to support interoperability with
foreign code, and writing performance-critical or low-level functions.</p>
<p>When comparing pointers they are compared by their address, rather than by what
they point to. When comparing pointers to <a href="dynamically-sized-types.html">dynamically sized
types</a> they also have their addition data
compared.</p>
<a class="header" href="types.html#smart-pointers" id="smart-pointers"><h3>Smart Pointers</h3></a>
<p>The standard library contains additional 'smart pointer' types beyond references
and raw pointers.</p>
<a class="header" href="types.html#function-item-types" id="function-item-types"><h2>Function item types</h2></a>
<p>When referred to, a function item, or the constructor of a tuple-like struct or
enum variant, yields a zero-sized value of its <em>function item type</em>. That type
explicitly identifies the function - its name, its type arguments, and its
early-bound lifetime arguments (but not its late-bound lifetime arguments,
which are only assigned when the function is called) - so the value does not
need to contain an actual function pointer, and no indirection is needed when
the function is called.</p>
<p>There is currently no syntax that directly refers to a function item type, but
the compiler will display the type as something like <code>fn() {foo::&lt;u32&gt;}</code> in
error messages.</p>
<p>Because the function item type explicitly identifies the function, the item
types of different functions - different items, or the same item with different
generics - are distinct, and mixing them will create a type error:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail E0308">
# #![allow(unused_variables)]
#fn main() {
fn foo&lt;T&gt;() { }
let x = &amp;mut foo::&lt;i32&gt;;
*x = foo::&lt;u32&gt;; //~ ERROR mismatched types
#}</code></pre></pre>
<p>However, there is a <a href="type-coercions.html">coercion</a> from function items to <a href="types.html#function-pointer-types">function
pointers</a> with the same signature, which is triggered
not only when a function item is used when a function pointer is directly
expected, but also when different function item types with the same signature
meet in different arms of the same <code>if</code> or <code>match</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let want_i32 = false;
# fn foo&lt;T&gt;() { }

// `foo_ptr_1` has function pointer type `fn()` here
let foo_ptr_1: fn() = foo::&lt;i32&gt;;

// ... and so does `foo_ptr_2` - this type-checks.
let foo_ptr_2 = if want_i32 {
    foo::&lt;i32&gt;
} else {
    foo::&lt;u32&gt;
};
#}</code></pre></pre>
<a class="header" href="types.html#function-pointer-types" id="function-pointer-types"><h2>Function pointer types</h2></a>
<p>Function pointer types, written using the <code>fn</code> keyword, refer to a function
whose identity is not necessarily known at compile-time. They can be created
via a coercion from both <a href="types.html#function-item-types">function items</a> and
non-capturing <a href="types.html#closure-types">closures</a>.</p>
<p>A function pointer type consists of a possibly-empty set of function-type
modifiers (such as <code>unsafe</code> or <code>extern</code>), a sequence of input types and an
output type.</p>
<p>An example where <code>Binop</code> is defined as a function pointer type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
#}</code></pre></pre>
<a class="header" href="types.html#closure-types" id="closure-types"><h2>Closure types</h2></a>
<p>A <a href="expressions/closure-expr.html">closure expression</a> produces a closure
value with a unique, anonymous type that cannot be written out.</p>
<p>Depending on the requirements of the closure, its type implements one or
more of the closure traits:</p>
<ul>
<li>
<p><code>FnOnce</code>
: The closure can be called once. A closure called as <code>FnOnce</code> can move out
of its captured values.</p>
</li>
<li>
<p><code>FnMut</code>
: The closure can be called multiple times as mutable. A closure called as
<code>FnMut</code> can mutate values from its environment. <code>FnMut</code> inherits from
<code>FnOnce</code> (i.e. anything implementing <code>FnMut</code> also implements <code>FnOnce</code>).</p>
</li>
<li>
<p><code>Fn</code> : The closure can be called multiple times through a shared reference. A
closure called as <code>Fn</code> can neither move out from nor mutate captured
variables, but read-only access to such values is allowed. Using <code>move</code> to
capture variables by value is allowed so long as they aren't mutated or
moved in the body of the closure. <code>Fn</code> inherits from <code>FnMut</code>, which itself
inherits from <code>FnOnce</code>.</p>
</li>
</ul>
<p>Closures that don't use anything from their environment (&quot;non capturing
closures&quot;) can be coerced to function pointers (<code>fn</code>) with the matching
signature. To adopt the example from the section above:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let add = |x, y| x + y;

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
#}</code></pre></pre>
<a class="header" href="types.html#trait-objects" id="trait-objects"><h2>Trait objects</h2></a>
<p>In Rust, trait names also refer to <a href="dynamically-sized-types.html">dynamically sized types</a> called <em>trait
objects</em>. Like all <abbr title="dynamically sized types">DSTs</abbr>, trait
objects are used behind some kind of pointer: <code>&amp;SomeTrait</code> or <code>Box&lt;SomeTrait&gt;</code>.
Each instance of a pointer to a trait object includes:</p>
<ul>
<li>a pointer to an instance of a type <code>T</code> that implements <code>SomeTrait</code></li>
<li>a <em>virtual method table</em>, often just called a <em>vtable</em>, which contains, for
each method of <code>SomeTrait</code> that <code>T</code> implements, a pointer to <code>T</code>'s
implementation (i.e. a function pointer).</li>
</ul>
<p>The purpose of trait objects is to permit &quot;late binding&quot; of methods. Calling a
method on a trait object results in virtual dispatch at runtime: that is, a
function pointer is loaded from the trait object vtable and invoked indirectly.
The actual implementation for each vtable entry can vary on an object-by-object
basis.</p>
<p>Note that trait object types only exist for <em>object-safe</em> traits (<a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">RFC 255</a>):</p>
<ul>
<li>It must not require <code>Self: Sized</code></li>
<li>All associated functions must either have a <code>where Self: Sized</code> bound or
<ul>
<li>Not have any type parameters (lifetime parameters are allowed)</li>
<li>Must be a method: its first parameter must be called self, with type
<code>Self</code>, <code>&amp;Self</code>, <code>&amp;mut Self</code>, <code>Box&lt;Self&gt;</code>.</li>
<li><code>Self</code> may only be used in the type of the receiver.</li>
</ul>
</li>
<li>It must not have any associated constants.</li>
</ul>
<p>Given a pointer-typed expression <code>E</code> of type <code>&amp;T</code> or <code>Box&lt;T&gt;</code>, where <code>T</code>
implements trait <code>R</code>, casting <code>E</code> to the corresponding pointer type <code>&amp;R</code> or
<code>Box&lt;R&gt;</code> results in a value of the <em>trait object</em> <code>R</code>. This result is
represented as a pair of pointers: the vtable pointer for the <code>T</code>
implementation of <code>R</code>, and the pointer value of <code>E</code>.</p>
<p>An example of a trait object:</p>
<pre><pre class="playpen"><code class="language-rust">trait Printable {
    fn stringify(&amp;self) -&gt; String;
}

impl Printable for i32 {
    fn stringify(&amp;self) -&gt; String { self.to_string() }
}

fn print(a: Box&lt;Printable&gt;) {
    println!(&quot;{}&quot;, a.stringify());
}

fn main() {
    print(Box::new(10) as Box&lt;Printable&gt;);
}
</code></pre></pre>
<p>In this example, the trait <code>Printable</code> occurs as a trait object in both the
type signature of <code>print</code>, and the cast expression in <code>main</code>.</p>
<p>Since a trait object can contain references, the lifetimes of those references
need to be expressed as part of the trait object. The assumed lifetime of
references held by a trait object is called its <em>default object lifetime bound</em>.
These were defined in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md">RFC 599</a> and amended in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a>.</p>
<p>For traits that themselves have no lifetime parameters:</p>
<ul>
<li>If there is a unique bound from the containing type then that is the default</li>
<li>If there is more than one bound from the containing type then an explicit bound must
be specified</li>
<li>Otherwise the default bound is <code>'static</code></li>
</ul>
<pre><code class="language-rust ignore">// For the following trait...
trait Foo { }

// These two are the same as Box&lt;T&gt; has no lifetime bound on T
Box&lt;Foo&gt;
Box&lt;Foo + 'static&gt;

// ...and so are these:
impl Foo {}
impl Foo + 'static {}

// ...so are these, because &amp;'a T requires T: 'a
&amp;'a Foo
&amp;'a (Foo + 'a)

// std::cell::Ref&lt;'a, T&gt; also requires T: 'a, so these are the same
std::cell::Ref&lt;'a, Foo&gt;
std::cell::Ref&lt;'a, Foo + 'a&gt;

// This is an error:
struct TwoBounds&lt;'a, 'b, T: ?Sized + 'a + 'b&gt;
TwoBounds&lt;'a, 'b, Foo&gt; // Error: the lifetime bound for this object type cannot
                       // be deduced from context

</code></pre>
<p>The <code>+ 'static</code> and <code>+ 'a</code> refer to the default bounds of those kinds of trait
objects, and also to how you can directly override them. Note that the innermost
object sets the bound, so <code>&amp;'a Box&lt;Foo&gt;</code> is still <code>&amp;'a Box&lt;Foo + 'static&gt;</code>.</p>
<p>For traits that have a single lifetime <em>bound</em> of their own then, instead of
infering 'static as the default bound, the bound on the trait is used instead</p>
<pre><code class="language-rust ignore">// For the following trait...
trait Bar&lt;'a&gt;: 'a { }

// ...these two are the same:
Box&lt;Bar&lt;'a&gt;&gt;
Box&lt;Bar&lt;'a&gt; + 'a&gt;

// ...and so are these:
impl&lt;'a&gt; Foo&lt;'a&gt; {}
impl&lt;'a&gt; Foo&lt;'a&gt; + 'a {}

// This is still an error:
struct TwoBounds&lt;'a, 'b, T: ?Sized + 'a + 'b&gt;
TwoBounds&lt;'a, 'b, Foo&lt;'c&gt;&gt;
</code></pre>
<a class="header" href="types.html#type-parameters" id="type-parameters"><h2>Type parameters</h2></a>
<p>Within the body of an item that has type parameter declarations, the names of
its type parameters are types:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn to_vec&lt;A: Clone&gt;(xs: &amp;[A]) -&gt; Vec&lt;A&gt; {
    if xs.is_empty() {
        return vec![];
    }
    let first: A = xs[0].clone();
    let mut rest: Vec&lt;A&gt; = to_vec(&amp;xs[1..]);
    rest.insert(0, first);
    rest
}
#}</code></pre></pre>
<p>Here, <code>first</code> has type <code>A</code>, referring to <code>to_vec</code>'s <code>A</code> type parameter; and
<code>rest</code> has type <code>Vec&lt;A&gt;</code>, a vector with element type <code>A</code>.</p>
<a class="header" href="types.html#self-types" id="self-types"><h2>Self types</h2></a>
<p>The special type <code>Self</code> has a meaning within traits and impls: it refers to
the implementing type. For example, in:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}

impl From&lt;i32&gt; for String {
    fn from(x: i32) -&gt; Self {
        x.to_string()
    }
}
#}</code></pre></pre>
<p>The notation <code>Self</code> in the impl refers to the implementing type: <code>String</code>. In
another example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Printable {
    fn make_string(&amp;self) -&gt; String;
}

impl Printable for String {
    fn make_string(&amp;self) -&gt; String {
        (*self).clone()
    }
}
#}</code></pre></pre>
<p>The notation <code>&amp;self</code> is a shorthand for <code>self: &amp;Self</code>.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="type-system.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="dynamically-sized-types.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="type-system.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="dynamically-sized-types.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
