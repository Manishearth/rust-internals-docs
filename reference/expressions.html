<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Expressions - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="notation.html"><strong>1.</strong> Notation</a></li><li><ul class="section"><li><a href="unicode-productions.html"><strong>1.1.</strong> Unicode productions</a></li><li><a href="string-table-productions.html"><strong>1.2.</strong> String table productions</a></li></ul></li><li><a href="lexical-structure.html"><strong>2.</strong> Lexical structure</a></li><li><ul class="section"><li><a href="input-format.html"><strong>2.1.</strong> Input format</a></li><li><a href="identifiers.html"><strong>2.2.</strong> Identifiers</a></li><li><a href="comments.html"><strong>2.3.</strong> Comments</a></li><li><a href="whitespace.html"><strong>2.4.</strong> Whitespace</a></li><li><a href="tokens.html"><strong>2.5.</strong> Tokens</a></li><li><a href="paths.html"><strong>2.6.</strong> Paths</a></li></ul></li><li><a href="macros.html"><strong>3.</strong> Macros</a></li><li><ul class="section"><li><a href="macros-by-example.html"><strong>3.1.</strong> Macros By Example</a></li><li><a href="procedural-macros.html"><strong>3.2.</strong> Procedrual Macros</a></li></ul></li><li><a href="crates-and-source-files.html"><strong>4.</strong> Crates and source files</a></li><li><a href="items-and-attributes.html"><strong>5.</strong> Items and attributes</a></li><li><ul class="section"><li><a href="items.html"><strong>5.1.</strong> Items</a></li><li><a href="visibility-and-privacy.html"><strong>5.2.</strong> Visibility and Privacy</a></li><li><a href="attributes.html"><strong>5.3.</strong> Attributes</a></li></ul></li><li><a href="statements-and-expressions.html"><strong>6.</strong> Statements and expressions</a></li><li><ul class="section"><li><a href="statements.html"><strong>6.1.</strong> Statements</a></li><li><a href="expressions.html" class="active"><strong>6.2.</strong> Expressions</a></li></ul></li><li><a href="type-system.html"><strong>7.</strong> Type system</a></li><li><ul class="section"><li><a href="types.html"><strong>7.1.</strong> Types</a></li><li><a href="subtyping.html"><strong>7.2.</strong> Subtyping</a></li><li><a href="type-coercions.html"><strong>7.3.</strong> Type coercions</a></li></ul></li><li><a href="special-traits.html"><strong>8.</strong> Special traits</a></li><li><ul class="section"><li><a href="the-copy-trait.html"><strong>8.1.</strong> The Copy trait</a></li><li><a href="the-sized-trait.html"><strong>8.2.</strong> The Sized trait</a></li><li><a href="the-drop-trait.html"><strong>8.3.</strong> The Drop trait</a></li><li><a href="the-deref-trait.html"><strong>8.4.</strong> The Deref trait</a></li><li><a href="the-send-trait.html"><strong>8.5.</strong> The Send trait</a></li><li><a href="the-sync-trait.html"><strong>8.6.</strong> The Sync trait</a></li></ul></li><li><a href="memory-model.html"><strong>9.</strong> Memory model</a></li><li><ul class="section"><li><a href="memory-allocation-and-lifetime.html"><strong>9.1.</strong> Memory allocation and lifetime</a></li><li><a href="memory-ownership.html"><strong>9.2.</strong> Memory ownership</a></li><li><a href="variables.html"><strong>9.3.</strong> Variables</a></li></ul></li><li><a href="linkage.html"><strong>10.</strong> Linkage</a></li><li><a href="unsafety.html"><strong>11.</strong> Unsafety</a></li><li><ul class="section"><li><a href="unsafe-functions.html"><strong>11.1.</strong> Unsafe functions</a></li><li><a href="unsafe-blocks.html"><strong>11.2.</strong> Unsafe blocks</a></li><li><a href="behavior-considered-undefined.html"><strong>11.3.</strong> Behavior considered undefined</a></li><li><a href="behavior-not-considered-unsafe.html"><strong>11.4.</strong> Behavior not considered unsafe</a></li></ul></li><li><a href="influences.html">Appendix: Influences</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="#expressions" name="expressions"><h1>Expressions</h1></a>
<p>An expression may have two roles: it always produces a <em>value</em>, and it may have
<em>effects</em> (otherwise known as &quot;side effects&quot;). An expression <em>evaluates to</em> a
value, and has effects during <em>evaluation</em>. Many expressions contain
sub-expressions (operands). The meaning of each kind of expression dictates
several things:</p>
<ul>
<li>Whether or not to evaluate the sub-expressions when evaluating the expression</li>
<li>The order in which to evaluate the sub-expressions</li>
<li>How to combine the sub-expressions' values to obtain the value of the expression</li>
</ul>
<p>In this way, the structure of expressions dictates the structure of execution.
Blocks are just another kind of expression, so blocks, statements, expressions,
and blocks again can recursively nest inside each other to an arbitrary depth.</p>
<a class="header" href="#lvalues-rvalues-and-temporaries" name="lvalues-rvalues-and-temporaries"><h3>Lvalues, rvalues and temporaries</h3></a>
<p>Expressions are divided into two main categories: <em>lvalues</em> and <em>rvalues</em>.
Likewise within each expression, sub-expressions may occur in <em>lvalue context</em>
or <em>rvalue context</em>. The evaluation of an expression depends both on its own
category and the context it occurs within.</p>
<p>An lvalue is an expression that represents a memory location. These expressions
are <a href="#path-expressions">paths</a> (which refer to local variables, function and
method arguments, or static variables), dereferences (<code>*expr</code>), <a href="#index-expressions">indexing
expressions</a> (<code>expr[expr]</code>), and <a href="#field-expressions">field
references</a> (<code>expr.f</code>). All other expressions are rvalues.</p>
<p>The left operand of an <a href="#assignment-expressions">assignment</a> or
<a href="#compound-assignment-expressions">compound-assignment</a> expression is
an lvalue context, as is the single operand of a unary
<a href="#unary-operator-expressions">borrow</a>. The discriminant or subject of
a <a href="#match-expressions">match expression</a> may be an lvalue context, if
ref bindings are made, but is otherwise an rvalue context. All other
expression contexts are rvalue contexts.</p>
<p>When an lvalue is evaluated in an <em>lvalue context</em>, it denotes a memory
location; when evaluated in an <em>rvalue context</em>, it denotes the value held <em>in</em>
that memory location.</p>
<a class="header" href="#temporary-lifetimes" name="temporary-lifetimes"><h4>Temporary lifetimes</h4></a>
<p>When an rvalue is used in an lvalue context, a temporary un-named
lvalue is created and used instead. The lifetime of temporary values
is typically the innermost enclosing statement; the tail expression of
a block is considered part of the statement that encloses the block.</p>
<p>When a temporary rvalue is being created that is assigned into a <code>let</code>
declaration, however, the temporary is created with the lifetime of
the enclosing block instead, as using the enclosing statement (the
<code>let</code> declaration) would be a guaranteed error (since a pointer to the
temporary would be stored into a variable, but the temporary would be
freed before the variable could be used). The compiler uses simple
syntactic rules to decide which values are being assigned into a <code>let</code>
binding, and therefore deserve a longer temporary lifetime.</p>
<p>Here are some examples:</p>
<ul>
<li><code>let x = foo(&amp;temp())</code>. The expression <code>temp()</code> is an rvalue. As it
is being borrowed, a temporary is created which will be freed after
the innermost enclosing statement (the <code>let</code> declaration, in this case).</li>
<li><code>let x = temp().foo()</code>. This is the same as the previous example,
except that the value of <code>temp()</code> is being borrowed via autoref on a
method-call. Here we are assuming that <code>foo()</code> is an <code>&amp;self</code> method
defined in some trait, say <code>Foo</code>. In other words, the expression
<code>temp().foo()</code> is equivalent to <code>Foo::foo(&amp;temp())</code>.</li>
<li><code>let x = &amp;temp()</code>. Here, the same temporary is being assigned into
<code>x</code>, rather than being passed as a parameter, and hence the
temporary's lifetime is considered to be the enclosing block.</li>
<li><code>let x = SomeStruct { foo: &amp;temp() }</code>. As in the previous case, the
temporary is assigned into a struct which is then assigned into a
binding, and hence it is given the lifetime of the enclosing block.</li>
<li><code>let x = [ &amp;temp() ]</code>. As in the previous case, the
temporary is assigned into an array which is then assigned into a
binding, and hence it is given the lifetime of the enclosing block.</li>
<li><code>let ref x = temp()</code>. In this case, the temporary is created using a ref binding,
but the result is the same: the lifetime is extended to the enclosing block.</li>
</ul>
<a class="header" href="#moved-and-copied-types" name="moved-and-copied-types"><h3>Moved and copied types</h3></a>
<p>When a <a href="variables.html">local variable</a> is used as an
<a href="expressions.html#lvalues-rvalues-and-temporaries">rvalue</a>, the variable will
be copied if its type implements <code>Copy</code>. All others are moved.</p>
<a class="header" href="#literal-expressions" name="literal-expressions"><h2>Literal expressions</h2></a>
<p>A <em>literal expression</em> consists of one of the <a href="tokens.html#literals">literal</a> forms
described earlier. It directly describes a number, character, string, boolean
value, or the unit value.</p>
<pre><code class="language-text">();        // unit type
&quot;hello&quot;;   // string type
'5';       // character type
5;         // integer type
</code></pre>
<a class="header" href="#path-expressions" name="path-expressions"><h2>Path expressions</h2></a>
<p>A <a href="paths.html">path</a> used as an expression context denotes either a local
variable or an item. Path expressions are
<a href="expressions.html#lvalues-rvalues-and-temporaries">lvalues</a>.</p>
<a class="header" href="#tuple-expressions" name="tuple-expressions"><h2>Tuple expressions</h2></a>
<p>Tuples are written by enclosing zero or more comma-separated expressions in
parentheses. They are used to create <a href="types.html#tuple-types">tuple-typed</a>
values.</p>
<pre><code class="language-{.tuple}">(0.0, 4.5);
(&quot;a&quot;, 4usize, true);
</code></pre>
<p>You can disambiguate a single-element tuple from a value in parentheses with a
comma:</p>
<pre><code>(0,); // single-element tuple
(0); // zero in parentheses
</code></pre>
<a class="header" href="#struct-expressions" name="struct-expressions"><h2>Struct expressions</h2></a>
<p>There are several forms of struct expressions. A <em>struct expression</em>
consists of the <a href="paths.html">path</a> of a <a href="items.html#structs">struct item</a>, followed
by a brace-enclosed list of zero or more comma-separated name-value pairs,
providing the field values of a new instance of the struct. A field name can be
any identifier, and is separated from its value expression by a colon.  The
location denoted by a struct field is mutable if and only if the enclosing
struct is mutable.</p>
<p>A <em>tuple struct expression</em> consists of the <a href="paths.html">path</a> of a <a href="items.html#structs">struct
item</a>, followed by a parenthesized list of one or more
comma-separated expressions (in other words, the path of a struct item followed
by a tuple expression). The struct item must be a tuple struct item.</p>
<p>A <em>unit-like struct expression</em> consists only of the <a href="paths.html">path</a> of a
<a href="items.html#structs">struct item</a>.</p>
<p>The following are examples of struct expressions:</p>
<pre><code># struct Point { x: f64, y: f64 }
# struct NothingInMe { }
# struct TuplePoint(f64, f64);
# mod game { pub struct User&lt;'a&gt; { pub name: &amp;'a str, pub age: u32, pub score: usize } }
# struct Cookie; fn some_fn&lt;T&gt;(t: T) {}
Point {x: 10.0, y: 20.0};
NothingInMe {};
TuplePoint(10.0, 20.0);
let u = game::User {name: &quot;Joe&quot;, age: 35, score: 100_000};
some_fn::&lt;Cookie&gt;(Cookie);
</code></pre>
<p>A struct expression forms a new value of the named struct type. Note
that for a given <em>unit-like</em> struct type, this will always be the same
value.</p>
<p>A struct expression can terminate with the syntax <code>..</code> followed by an
expression to denote a functional update. The expression following <code>..</code> (the
base) must have the same struct type as the new struct type being formed.
The entire expression denotes the result of constructing a new struct (with
the same type as the base expression) with the given values for the fields that
were explicitly specified and the values in the base expression for all other
fields.</p>
<pre><code># struct Point3d { x: i32, y: i32, z: i32 }
let base = Point3d {x: 1, y: 2, z: 3};
Point3d {y: 0, z: 10, .. base};
</code></pre>
<a class="header" href="#struct-field-init-shorthand" name="struct-field-init-shorthand"><h4>Struct field init shorthand</h4></a>
<p>When initializing a data structure (struct, enum, union) with named fields,
it is allowed to write <code>fieldname</code> as a shorthand for <code>fieldname: fieldname</code>.
This allows a compact syntax with less duplication.</p>
<p>Example:</p>
<pre><code># struct Point3d { x: i32, y: i32, z: i32 }
# let x = 0;
# let y_value = 0;
# let z = 0;
Point3d { x: x, y: y_value, z: z };
Point3d { x, y: y_value, z };
</code></pre>
<a class="header" href="#block-expressions" name="block-expressions"><h2>Block expressions</h2></a>
<p>A <em>block expression</em> is similar to a module in terms of the declarations that
are possible. Each block conceptually introduces a new namespace scope. Use
items can bring new names into scopes and declared items are in scope for only
the block itself.</p>
<p>A block will execute each statement sequentially, and then execute the
expression (if given). If the block ends in a statement, its value is <code>()</code>:</p>
<pre><code>let x: () = { println!(&quot;Hello.&quot;); };
</code></pre>
<p>If it ends in an expression, its value and type are that of the expression:</p>
<pre><code>let x: i32 = { println!(&quot;Hello.&quot;); 5 };

assert_eq!(5, x);
</code></pre>
<a class="header" href="#method-call-expressions" name="method-call-expressions"><h2>Method-call expressions</h2></a>
<p>A <em>method call</em> consists of an expression followed by a single dot, an
identifier, and a parenthesized expression-list. Method calls are resolved to
methods on specific traits, either statically dispatching to a method if the
exact <code>self</code>-type of the left-hand-side is known, or dynamically dispatching if
the left-hand-side expression is an indirect <a href="types.html#trait-objects">trait
object</a>.</p>
<a class="header" href="#field-expressions" name="field-expressions"><h2>Field expressions</h2></a>
<p>A <em>field expression</em> consists of an expression followed by a single dot and an
identifier, when not immediately followed by a parenthesized expression-list
(the latter is a <a href="#method-call-expressions">method call expression</a>). A field
expression denotes a field of a <a href="types.html#struct-types">struct</a>.</p>
<pre><code class="language-{.ignore">mystruct.myfield;
foo().x;
(Struct {a: 10, b: 20}).a;
</code></pre>
<p>A field access is an <a href="expressions.html#lvalues-rvalues-and-temporaries">lvalue</a>
referring to the value of that field. When the type providing the field
inherits mutability, it can be <a href="#assignment-expressions">assigned</a> to.</p>
<p>Also, if the type of the expression to the left of the dot is a
pointer, it is automatically dereferenced as many times as necessary
to make the field access possible. In cases of ambiguity, we prefer
fewer autoderefs to more.</p>
<a class="header" href="#array-expressions" name="array-expressions"><h2>Array expressions</h2></a>
<p>An <a href="types.html#array-and-slice-types">array</a> <em>expression</em> is written by
enclosing zero or more comma-separated expressions of uniform type in square
brackets.</p>
<p>In the <code>[expr ';' expr]</code> form, the expression after the <code>';'</code> must be a
constant expression that can be evaluated at compile time, such as a
<a href="tokens.html#literals">literal</a> or a <a href="items.html#static-items">static item</a>.</p>
<pre><code>[1, 2, 3, 4];
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];
[0; 128];              // array with 128 zeros
[0u8, 0u8, 0u8, 0u8];
</code></pre>
<a class="header" href="#index-expressions" name="index-expressions"><h2>Index expressions</h2></a>
<p><a href="types.html#array-and-slice-types">Array</a>-typed expressions can be indexed by
writing a square-bracket-enclosed expression (the index) after them. When the
array is mutable, the resulting
<a href="expressions.html#lvalues-rvalues-and-temporaries">lvalue</a> can be assigned to.</p>
<p>Indices are zero-based, and may be of any integral type. Vector access is
bounds-checked at compile-time for constant arrays being accessed with a
constant index value.  Otherwise a check will be performed at run-time that
will put the thread in a <em>panicked state</em> if it fails.</p>
<pre><code class="language-{should-fail}">([1, 2, 3, 4])[0];

let x = ([&quot;a&quot;, &quot;b&quot;])[10]; // compiler error: const index-expr is out of bounds

let n = 10;
let y = ([&quot;a&quot;, &quot;b&quot;])[n]; // panics

let arr = [&quot;a&quot;, &quot;b&quot;];
arr[10]; // panics
</code></pre>
<p>Also, if the type of the expression to the left of the brackets is a
pointer, it is automatically dereferenced as many times as necessary
to make the indexing possible. In cases of ambiguity, we prefer fewer
autoderefs to more.</p>
<a class="header" href="#range-expressions" name="range-expressions"><h2>Range expressions</h2></a>
<p>The <code>..</code> operator will construct an object of one of the <code>std::ops::Range</code> variants.</p>
<pre><code>1..2;   // std::ops::Range
3..;    // std::ops::RangeFrom
..4;    // std::ops::RangeTo
..;     // std::ops::RangeFull
</code></pre>
<p>The following expressions are equivalent.</p>
<pre><code>let x = std::ops::Range {start: 0, end: 10};
let y = 0..10;

assert_eq!(x, y);
</code></pre>
<p>Similarly, the <code>...</code> operator will construct an object of one of the
<code>std::ops::RangeInclusive</code> variants.</p>
<pre><code># #![feature(inclusive_range_syntax)]
1...2;   // std::ops::RangeInclusive
...4;    // std::ops::RangeToInclusive
</code></pre>
<p>The following expressions are equivalent.</p>
<pre><code># #![feature(inclusive_range_syntax, inclusive_range)]
let x = std::ops::RangeInclusive::NonEmpty {start: 0, end: 10};
let y = 0...10;

assert_eq!(x, y);
</code></pre>
<a class="header" href="#unary-operator-expressions" name="unary-operator-expressions"><h2>Unary operator expressions</h2></a>
<p>Rust defines the following unary operators. With the exception of <code>?</code>, they are
all written as prefix operators, before the expression they apply to.</p>
<ul>
<li><code>-</code>
: Negation. Signed integer types and floating-point types support negation. It
is an error to apply negation to unsigned types; for example, the compiler
rejects <code>-1u32</code>.</li>
<li><code>*</code>
: Dereference. When applied to a <a href="types.html#pointer-types">pointer</a> it
denotes the pointed-to location. For pointers to mutable locations, the
resulting <a href="expressions.html#lvalues-rvalues-and-temporaries">lvalue</a> can be
assigned to.  On non-pointer types, it calls the <code>deref</code> method of the
<code>std::ops::Deref</code> trait, or the <code>deref_mut</code> method of the
<code>std::ops::DerefMut</code> trait (if implemented by the type and required for an
outer expression that will or could mutate the dereference), and produces
the result of dereferencing the <code>&amp;</code> or <code>&amp;mut</code> borrowed pointer returned
from the overload method.</li>
<li><code>!</code>
: Logical negation. On the boolean type, this flips between <code>true</code> and
<code>false</code>. On integer types, this inverts the individual bits in the
two's complement representation of the value.</li>
<li><code>&amp;</code> and <code>&amp;mut</code>
: Borrowing. When applied to an lvalue, these operators produce a
reference (pointer) to the lvalue. The lvalue is also placed into
a borrowed state for the duration of the reference. For a shared
borrow (<code>&amp;</code>), this implies that the lvalue may not be mutated, but
it may be read or shared again. For a mutable borrow (<code>&amp;mut</code>), the
lvalue may not be accessed in any way until the borrow expires.
If the <code>&amp;</code> or <code>&amp;mut</code> operators are applied to an rvalue, a
temporary value is created; the lifetime of this temporary value
is defined by <a href="#temporary-lifetimes">syntactic rules</a>.</li>
<li><code>?</code>
: Propagating errors if applied to <code>Err(_)</code> and unwrapping if
applied to <code>Ok(_)</code>. Only works on the <code>Result&lt;T, E&gt;</code> type,
and written in postfix notation.</li>
</ul>
<a class="header" href="#binary-operator-expressions" name="binary-operator-expressions"><h2>Binary operator expressions</h2></a>
<p>Binary operators expressions are given in terms of <a href="#operator-precedence">operator
precedence</a>.</p>
<a class="header" href="#arithmetic-operators" name="arithmetic-operators"><h3>Arithmetic operators</h3></a>
<p>Binary arithmetic expressions are syntactic sugar for calls to built-in traits,
defined in the <code>std::ops</code> module of the <code>std</code> library. This means that
arithmetic operators can be overridden for user-defined types. The default
meaning of the operators on standard types is given here.</p>
<ul>
<li><code>+</code>
: Addition and array/string concatenation.
Calls the <code>add</code> method on the <code>std::ops::Add</code> trait.</li>
<li><code>-</code>
: Subtraction.
Calls the <code>sub</code> method on the <code>std::ops::Sub</code> trait.</li>
<li><code>*</code>
: Multiplication.
Calls the <code>mul</code> method on the <code>std::ops::Mul</code> trait.</li>
<li><code>/</code>
: Quotient.
Calls the <code>div</code> method on the <code>std::ops::Div</code> trait.</li>
<li><code>%</code>
: Remainder.
Calls the <code>rem</code> method on the <code>std::ops::Rem</code> trait.</li>
</ul>
<a class="header" href="#bitwise-operators" name="bitwise-operators"><h3>Bitwise operators</h3></a>
<p>Like the <a href="#arithmetic-operators">arithmetic operators</a>, bitwise operators are
syntactic sugar for calls to methods of built-in traits. This means that
bitwise operators can be overridden for user-defined types. The default
meaning of the operators on standard types is given here. Bitwise <code>&amp;</code>, <code>|</code> and
<code>^</code> applied to boolean arguments are equivalent to logical <code>&amp;&amp;</code>, <code>||</code> and <code>!=</code>
evaluated in non-lazy fashion.</p>
<ul>
<li><code>&amp;</code>
: Bitwise AND.
Calls the <code>bitand</code> method of the <code>std::ops::BitAnd</code> trait.</li>
<li><code>|</code>
: Bitwise inclusive OR.
Calls the <code>bitor</code> method of the <code>std::ops::BitOr</code> trait.</li>
<li><code>^</code>
: Bitwise exclusive OR.
Calls the <code>bitxor</code> method of the <code>std::ops::BitXor</code> trait.</li>
<li><code>&lt;&lt;</code>
: Left shift.
Calls the <code>shl</code> method of the <code>std::ops::Shl</code> trait.</li>
<li><code>&gt;&gt;</code>
: Right shift (arithmetic).
Calls the <code>shr</code> method of the <code>std::ops::Shr</code> trait.</li>
</ul>
<a class="header" href="#lazy-boolean-operators" name="lazy-boolean-operators"><h3>Lazy boolean operators</h3></a>
<p>The operators <code>||</code> and <code>&amp;&amp;</code> may be applied to operands of boolean type. The
<code>||</code> operator denotes logical 'or', and the <code>&amp;&amp;</code> operator denotes logical
'and'. They differ from <code>|</code> and <code>&amp;</code> in that the right-hand operand is only
evaluated when the left-hand operand does not already determine the result of
the expression. That is, <code>||</code> only evaluates its right-hand operand when the
left-hand operand evaluates to <code>false</code>, and <code>&amp;&amp;</code> only when it evaluates to
<code>true</code>.</p>
<a class="header" href="#comparison-operators" name="comparison-operators"><h3>Comparison operators</h3></a>
<p>Comparison operators are, like the <a href="#arithmetic-operators">arithmetic
operators</a>, and <a href="#bitwise-operators">bitwise operators</a>,
syntactic sugar for calls to built-in traits. This means that comparison
operators can be overridden for user-defined types. The default meaning of the
operators on standard types is given here.</p>
<ul>
<li><code>==</code>
: Equal to.
Calls the <code>eq</code> method on the <code>std::cmp::PartialEq</code> trait.</li>
<li><code>!=</code>
: Unequal to.
Calls the <code>ne</code> method on the <code>std::cmp::PartialEq</code> trait.</li>
<li><code>&lt;</code>
: Less than.
Calls the <code>lt</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
<li><code>&gt;</code>
: Greater than.
Calls the <code>gt</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
<li><code>&lt;=</code>
: Less than or equal.
Calls the <code>le</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
<li><code>&gt;=</code>
: Greater than or equal.
Calls the <code>ge</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
</ul>
<a class="header" href="#type-cast-expressions" name="type-cast-expressions"><h3>Type cast expressions</h3></a>
<p>A type cast expression is denoted with the binary operator <code>as</code>.</p>
<p>Executing an <code>as</code> expression casts the value on the left-hand side to the type
on the right-hand side.</p>
<p>An example of an <code>as</code> expression:</p>
<pre><code># fn sum(values: &amp;[f64]) -&gt; f64 { 0.0 }
# fn len(values: &amp;[f64]) -&gt; i32 { 0 }

fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}
</code></pre>
<p>Some of the conversions which can be done through the <code>as</code> operator
can also be done implicitly at various points in the program, such as
argument passing and assignment to a <code>let</code> binding with an explicit
type. Implicit conversions are limited to &quot;harmless&quot; conversions that
do not lose information and which have minimal or no risk of
surprising side-effects on the dynamic execution semantics.</p>
<a class="header" href="#assignment-expressions" name="assignment-expressions"><h3>Assignment expressions</h3></a>
<p>An <em>assignment expression</em> consists of an
<a href="expressions.html#lvalues-rvalues-and-temporaries">lvalue</a> expression followed
by an equals sign (<code>=</code>) and an
<a href="expressions.html#lvalues-rvalues-and-temporaries">rvalue</a> expression.</p>
<p>Evaluating an assignment expression <a href="#moved-and-copied-types">either copies or
moves</a> its right-hand operand to its left-hand
operand.</p>
<pre><code># let mut x = 0;
# let y = 0;
x = y;
</code></pre>
<a class="header" href="#compound-assignment-expressions" name="compound-assignment-expressions"><h3>Compound assignment expressions</h3></a>
<p>The <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code> operators may be
composed with the <code>=</code> operator. The expression <code>lval OP= val</code> is equivalent to
<code>lval = lval OP val</code>. For example, <code>x = x + 1</code> may be written as <code>x += 1</code>.</p>
<p>Any such expression always has the <a href="types.html#tuple-types"><code>unit</code></a> type.</p>
<a class="header" href="#operator-precedence" name="operator-precedence"><h3>Operator precedence</h3></a>
<p>The precedence of Rust binary operators is ordered as follows, going from
strong to weak:</p>
<pre><code class="language-{.text">as :
* / %
+ -
&lt;&lt; &gt;&gt;
&amp;
^
|
== != &lt; &gt; &lt;= &gt;=
&amp;&amp;
||
.. ...
&lt;-
=
</code></pre>
<p>Operators at the same precedence level are evaluated left-to-right. <a href="#unary-operator-expressions">Unary
operators</a> have the same precedence level and are
stronger than any of the binary operators.</p>
<a class="header" href="#grouped-expressions" name="grouped-expressions"><h2>Grouped expressions</h2></a>
<p>An expression enclosed in parentheses evaluates to the result of the enclosed
expression. Parentheses can be used to explicitly specify evaluation order
within an expression.</p>
<p>An example of a parenthesized expression:</p>
<pre><code>let x: i32 = (2 + 3) * 4;
</code></pre>
<a class="header" href="#call-expressions" name="call-expressions"><h2>Call expressions</h2></a>
<p>A <em>call expression</em> invokes a function, providing zero or more input variables
and an optional location to move the function's output into. If the function
eventually returns, then the expression completes.</p>
<p>Some examples of call expressions:</p>
<pre><code># fn add(x: i32, y: i32) -&gt; i32 { 0 }

let x: i32 = add(1i32, 2i32);
let pi: Result&lt;f32, _&gt; = &quot;3.14&quot;.parse();
</code></pre>
<a class="header" href="#lambda-expressions" name="lambda-expressions"><h2>Lambda expressions</h2></a>
<p>A <em>lambda expression</em> (sometimes called an &quot;anonymous function expression&quot;)
defines a function and denotes it as a value, in a single expression. A lambda
expression is a pipe-symbol-delimited (<code>|</code>) list of identifiers followed by an
expression.</p>
<p>A lambda expression denotes a function that maps a list of parameters
(<code>ident_list</code>) onto the expression that follows the <code>ident_list</code>. The
identifiers in the <code>ident_list</code> are the parameters to the function. These
parameters' types need not be specified, as the compiler infers them from
context.</p>
<p>Lambda expressions are most useful when passing functions as arguments to other
functions, as an abbreviation for defining and capturing a separate function.</p>
<p>Significantly, lambda expressions <em>capture their environment</em>, which regular
<a href="items.html#functions">function definitions</a> do not. The exact type of capture
depends on the <a href="types.html#function-types">function type</a> inferred for the
lambda expression. In the simplest and least-expensive form (analogous to a
<code>|| { }</code> expression), the lambda expression captures its environment by
reference, effectively borrowing pointers to all outer variables mentioned
inside the function.  Alternately, the compiler may infer that a lambda
expression should copy or move values (depending on their type) from the
environment into the lambda expression's captured environment. A lambda can be
forced to capture its environment by moving values by prefixing it with the
<code>move</code> keyword.</p>
<p>In this example, we define a function <code>ten_times</code> that takes a higher-order
function argument, and we then call it with a lambda expression as an argument,
followed by a lambda expression that moves values from its environment.</p>
<pre><code>fn ten_times&lt;F&gt;(f: F) where F: Fn(i32) {
    for index in 0..10 {
        f(index);
    }
}

ten_times(|j| println!(&quot;hello, {}&quot;, j));

let word = &quot;konnichiwa&quot;.to_owned();
ten_times(move |j| println!(&quot;{}, {}&quot;, word, j));
</code></pre>
<a class="header" href="#infinite-loops" name="infinite-loops"><h2>Infinite loops</h2></a>
<p>A <code>loop</code> expression denotes an infinite loop.</p>
<p>A <code>loop</code> expression may optionally have a <em>label</em>. The label is written as
a lifetime preceding the loop expression, as in <code>'foo: loop{ }</code>. If a
label is present, then labeled <code>break</code> and <code>continue</code> expressions nested
within this loop may exit out of this loop or return control to its head.
See <a href="#break-expressions">break expressions</a> and <a href="#continue-expressions">continue
expressions</a>.</p>
<a class="header" href="#break-expressions" name="break-expressions"><h2><code>break</code> expressions</h2></a>
<p>A <code>break</code> expression has an optional <em>label</em>. If the label is absent, then
executing a <code>break</code> expression immediately terminates the innermost loop
enclosing it. It is only permitted in the body of a loop. If the label is
present, then <code>break 'foo</code> terminates the loop with label <code>'foo</code>, which need not
be the innermost label enclosing the <code>break</code> expression, but must enclose it.</p>
<a class="header" href="#continue-expressions" name="continue-expressions"><h2><code>continue</code> expressions</h2></a>
<p>A <code>continue</code> expression has an optional <em>label</em>. If the label is absent, then
executing a <code>continue</code> expression immediately terminates the current iteration
of the innermost loop enclosing it, returning control to the loop <em>head</em>. In
the case of a <code>while</code> loop, the head is the conditional expression controlling
the loop. In the case of a <code>for</code> loop, the head is the call-expression
controlling the loop. If the label is present, then <code>continue 'foo</code> returns
control to the head of the loop with label <code>'foo</code>, which need not be the
innermost label enclosing the <code>continue</code> expression, but must enclose it.</p>
<p>A <code>continue</code> expression is only permitted in the body of a loop.</p>
<a class="header" href="#while-loops" name="while-loops"><h2><code>while</code> loops</h2></a>
<p>A <code>while</code> loop begins by evaluating the boolean loop conditional expression.
If the loop conditional expression evaluates to <code>true</code>, the loop body block
executes and control returns to the loop conditional expression. If the loop
conditional expression evaluates to <code>false</code>, the <code>while</code> expression completes.</p>
<p>An example:</p>
<pre><code>let mut i = 0;

while i &lt; 10 {
    println!(&quot;hello&quot;);
    i = i + 1;
}
</code></pre>
<p>Like <code>loop</code> expressions, <code>while</code> loops can be controlled with <code>break</code> or
<code>continue</code>, and may optionally have a <em>label</em>. See <a href="#infinite-loops">infinite
loops</a>, <a href="#break-expressions">break expressions</a>, and
<a href="#continue-expressions">continue expressions</a> for more information.</p>
<a class="header" href="#for-expressions" name="for-expressions"><h2><code>for</code> expressions</h2></a>
<p>A <code>for</code> expression is a syntactic construct for looping over elements provided
by an implementation of <code>std::iter::IntoIterator</code>.</p>
<p>An example of a <code>for</code> loop over the contents of an array:</p>
<pre><code># type Foo = i32;
# fn bar(f: &amp;Foo) { }
# let a = 0;
# let b = 0;
# let c = 0;

let v: &amp;[Foo] = &amp;[a, b, c];

for e in v {
    bar(e);
}
</code></pre>
<p>An example of a for loop over a series of integers:</p>
<pre><code># fn bar(b:usize) { }
for i in 0..256 {
    bar(i);
}
</code></pre>
<p>Like <code>loop</code> expressions, <code>for</code> loops can be controlled with <code>break</code> or
<code>continue</code>, and may optionally have a <em>label</em>. See <a href="#infinite-loops">infinite
loops</a>, <a href="#break-expressions">break expressions</a>, and
<a href="#continue-expressions">continue expressions</a> for more information.</p>
<a class="header" href="#if-expressions" name="if-expressions"><h2><code>if</code> expressions</h2></a>
<p>An <code>if</code> expression is a conditional branch in program control. The form of an
<code>if</code> expression is a condition expression, followed by a consequent block, any
number of <code>else if</code> conditions and blocks, and an optional trailing <code>else</code>
block. The condition expressions must have type <code>bool</code>. If a condition
expression evaluates to <code>true</code>, the consequent block is executed and any
subsequent <code>else if</code> or <code>else</code> block is skipped. If a condition expression
evaluates to <code>false</code>, the consequent block is skipped and any subsequent <code>else if</code> condition is evaluated. If all <code>if</code> and <code>else if</code> conditions evaluate to
<code>false</code> then any <code>else</code> block is executed.</p>
<a class="header" href="#match-expressions" name="match-expressions"><h2><code>match</code> expressions</h2></a>
<p>A <code>match</code> expression branches on a <em>pattern</em>. The exact form of matching that
occurs depends on the pattern. Patterns consist of some combination of
literals, destructured arrays or enum constructors, structs and tuples,
variable binding specifications, wildcards (<code>..</code>), and placeholders (<code>_</code>). A
<code>match</code> expression has a <em>head expression</em>, which is the value to compare to
the patterns. The type of the patterns must equal the type of the head
expression.</p>
<p>In a pattern whose head expression has an <code>enum</code> type, a placeholder (<code>_</code>)
stands for a <em>single</em> data field, whereas a wildcard <code>..</code> stands for <em>all</em> the
fields of a particular variant.</p>
<p>A <code>match</code> behaves differently depending on whether or not the head expression
is an <a href="expressions.html#lvalues-rvalues-and-temporaries">lvalue or an rvalue</a>.
If the head expression is an rvalue, it is first evaluated into a temporary
location, and the resulting value is sequentially compared to the patterns in
the arms until a match is found. The first arm with a matching pattern is
chosen as the branch target of the <code>match</code>, any variables bound by the pattern
are assigned to local variables in the arm's block, and control enters the
block.</p>
<p>When the head expression is an lvalue, the match does not allocate a temporary
location (however, a by-value binding may copy or move from the lvalue). When
possible, it is preferable to match on lvalues, as the lifetime of these
matches inherits the lifetime of the lvalue, rather than being restricted to
the inside of the match.</p>
<p>An example of a <code>match</code> expression:</p>
<pre><code>let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    4 =&gt; println!(&quot;four&quot;),
    5 =&gt; println!(&quot;five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
</code></pre>
<p>Patterns that bind variables default to binding to a copy or move of the
matched value (depending on the matched value's type). This can be changed to
bind to a reference by using the <code>ref</code> keyword, or to a mutable reference using
<code>ref mut</code>.</p>
<p>Subpatterns can also be bound to variables by the use of the syntax <code>variable @ subpattern</code>. For example:</p>
<pre><code>let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>Patterns can also dereference pointers by using the <code>&amp;</code>, <code>&amp;mut</code> and <code>box</code>
symbols, as appropriate. For example, these two matches on <code>x: &amp;i32</code> are
equivalent:</p>
<pre><code># let x = &amp;3;
let y = match *x { 0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };
let z = match x { &amp;0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };

assert_eq!(y, z);
</code></pre>
<p>Multiple match patterns may be joined with the <code>|</code> operator. A range of values
may be specified with <code>...</code>. For example:</p>
<pre><code># let x = 2;

let message = match x {
    0 | 1  =&gt; &quot;not many&quot;,
    2 ... 9 =&gt; &quot;a few&quot;,
    _      =&gt; &quot;lots&quot;
};
</code></pre>
<p>Range patterns only work on scalar types (like integers and characters; not
like arrays and structs, which have sub-components). A range pattern may not
be a sub-range of another range pattern inside the same <code>match</code>.</p>
<p>Finally, match patterns can accept <em>pattern guards</em> to further refine the
criteria for matching a case. Pattern guards appear after the pattern and
consist of a bool-typed expression following the <code>if</code> keyword. A pattern guard
may refer to the variables bound within the pattern they follow.</p>
<pre><code># let maybe_digit = Some(0);
# fn process_digit(i: i32) { }
# fn process_other(i: i32) { }

let message = match maybe_digit {
    Some(x) if x &lt; 10 =&gt; process_digit(x),
    Some(x) =&gt; process_other(x),
    None =&gt; panic!(),
};
</code></pre>
<a class="header" href="#if-let-expressions" name="if-let-expressions"><h2><code>if let</code> expressions</h2></a>
<p>An <code>if let</code> expression is semantically identical to an <code>if</code> expression but in
place of a condition expression it expects a <code>let</code> statement with a refutable
pattern. If the value of the expression on the right hand side of the <code>let</code>
statement matches the pattern, the corresponding block will execute, otherwise
flow proceeds to the first <code>else</code> block that follows.</p>
<pre><code>let dish = (&quot;Ham&quot;, &quot;Eggs&quot;);

// this body will be skipped because the pattern is refuted
if let (&quot;Bacon&quot;, b) = dish {
    println!(&quot;Bacon is served with {}&quot;, b);
}

// this body will execute
if let (&quot;Ham&quot;, b) = dish {
    println!(&quot;Ham is served with {}&quot;, b);
}
</code></pre>
<a class="header" href="#while-let-loops" name="while-let-loops"><h2><code>while let</code> loops</h2></a>
<p>A <code>while let</code> loop is semantically identical to a <code>while</code> loop but in place of
a condition expression it expects <code>let</code> statement with a refutable pattern. If
the value of the expression on the right hand side of the <code>let</code> statement
matches the pattern, the loop body block executes and control returns to the
pattern matching statement. Otherwise, the while expression completes.</p>
<a class="header" href="#return-expressions" name="return-expressions"><h2><code>return</code> expressions</h2></a>
<p>Return expressions are denoted with the keyword <code>return</code>. Evaluating a <code>return</code>
expression moves its argument into the designated output location for the
current function call, destroys the current function activation frame, and
transfers control to the caller frame.</p>
<p>An example of a <code>return</code> expression:</p>
<pre><code>fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        return a;
    }
    return b;
}
</code></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="statements.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="type-system.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="statements.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="type-system.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
