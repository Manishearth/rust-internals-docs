initSidebarItems({"enum":[["AtRuleType","The return value for `AtRuleParser::parse_prelude`. Indicates whether the at-rule is expected to have a `{ /* ... */ }` block or end with a `;` semicolon."],["Color","A  value."],["Token","One of the pieces the CSS input is broken into."]],"fn":[["parse_color_keyword","Return the named color with the given name."],["parse_important","Parse `!important`."],["parse_nth","Parse the An+B notation, as found in the `:nth-child()` selector. The input is typically the arguments of a function, in which case the caller needs to check if the arguments’ parser is exhausted. Return `Ok((A, B))`, or `Err(())` for a syntax error."],["parse_one_declaration","Parse a single declaration, such as an `( /* ... */ )` parenthesis in an `@supports` prelude."],["parse_one_rule","Parse a single rule, such as for CSSOM’s `CSSStyleSheet.insertRule`."],["serialize_identifier","Write a CSS identifier, escaping characters as necessary."],["serialize_string","Write a double-quoted CSS string token, escaping content as necessary."],["stylesheet_encoding","Determine the character encoding of a CSS stylesheet."]],"macro":[["ascii_case_insensitive_phf_map","Define a function `$name(&str) -> Option<&'static $ValueType>`"],["match_ignore_ascii_case","Expands to a `match` expression with string patterns, matching case-insensitively in the ASCII range."]],"mod":[["Delimiter","`Delimiters` constants."]],"struct":[["CssStringWriter","A `fmt::Write` adapter that escapes text for writing as a double-quoted CSS string. Quotes are not included."],["DeclarationListParser","Provides an iterator for declaration list parsing."],["Delimiters","A set of characters, to be used with the `Parser::parse_until*` methods."],["NumericValue","The numeric value of `Number` and `Dimension` tokens."],["Parser","A CSS parser that borrows its `&str` input, yields `Token`s, and keeps track of nested blocks and functions."],["PercentageValue","The numeric value of `Percentage` tokens."],["RGBA","A color with red, green, blue, and alpha components, in a byte each."],["RuleListParser","Provides an iterator for rule list parsing."],["SourceLocation","The line and column number for a given position within the input."],["SourcePosition","A capture of the internal state of a `Parser` (including the position within the input), obtained from the `Parser::position` method."],["TokenSerializationType","A category of token. See the `needs_separator_when_before` method."],["UnicodeRange","One contiguous range of code points."]],"trait":[["AtRuleParser","A trait to provide various parsing of at-rules."],["DeclarationParser","A trait to provide various parsing of declaration values."],["EncodingSupport","Abstraction for avoiding a dependency from cssparser to an encoding library"],["QualifiedRuleParser","A trait to provide various parsing of qualified rules."],["ToCss","Trait for things the can serialize themselves in CSS syntax."]]});