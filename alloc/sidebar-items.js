initSidebarItems({"mod":[["arc","Threadsafe reference-counted boxes (the `Arc<T>` type).The `Arc<T>` type provides shared ownership of an immutable value. Destruction is deterministic, and will occur as soon as the last owner is gone. It is marked as `Send` because it uses atomic reference counting.If you do not need thread-safety, and just need shared ownership, consider the `Rc<T>` type. It is the same as `Arc<T>`, but does not use atomics, making it both thread-unsafe as well as significantly faster when updating the reference count.The `downgrade` method can be used to create a non-owning `Weak<T>` pointer to the box. A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but will return `None` if the value has already been dropped.For example, a tree with parent pointers can be represented by putting the nodes behind strong `Arc<T>` pointers, and then storing the parent pointers as `Weak<T>` pointers.ExamplesSharing some immutable data between threads:Sharing mutable data safely between threads with a `Mutex`:"],["boxed","A pointer type for heap allocation.`Box<T>`, casually referred to as a 'box', provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope.ExamplesCreating a box:Creating a recursive data structure:This will print `Cons(1, Cons(2, Nil))`.Recursive structures must be boxed, because if the definition of `Cons` looked like this:It wouldn't work. This is because the size of a `List` depends on how many elements are in the list, and so we don't know how much memory to allocate for a `Cons`. By introducing a `Box`, which has a defined size, we know how big `Cons` needs to be."],["heap",""],["oom",""],["raw_vec",""],["rc","Thread-local reference-counted boxes (the `Rc<T>` type).The `Rc<T>` type provides shared ownership of an immutable value. Destruction is deterministic, and will occur as soon as the last owner is gone. It is marked as non-sendable because it avoids the overhead of atomic reference counting.The `downgrade` method can be used to create a non-owning `Weak<T>` pointer to the box. A `Weak<T>` pointer can be upgraded to an `Rc<T>` pointer, but will return `None` if the value has already been dropped.For example, a tree with parent pointers can be represented by putting the nodes behind strong `Rc<T>` pointers, and then storing the parent pointers as `Weak<T>` pointers.ExamplesConsider a scenario where a set of `Gadget`s are owned by a given `Owner`. We want to have our `Gadget`s point to their `Owner`. We can't do this with unique ownership, because more than one gadget may belong to the same `Owner`. `Rc<T>` allows us to share an `Owner` between multiple `Gadget`s, and have the `Owner` remain allocated as long as any `Gadget` points at it.If our requirements change, and we also need to be able to traverse from Owner → Gadget, we will run into problems: an `Rc<T>` pointer from Owner → Gadget introduces a cycle between the objects. This means that their reference counts can never reach 0, and the objects will remain allocated: a memory leak. In order to get around this, we can use `Weak<T>` pointers. These pointers don't contribute to the total count.Rust actually makes it somewhat difficult to produce this loop in the first place: in order to end up with two objects that point at each other, one of them needs to be mutable. This is problematic because `Rc<T>` enforces memory safety by only giving out shared references to the object it wraps, and these don't allow direct mutation. We need to wrap the part of the object we wish to mutate in a `RefCell`, which provides *interior mutability*: a method to achieve mutability through a shared reference. `RefCell` enforces Rust's borrowing rules at runtime.  Read the `Cell` documentation for more details on interior mutability."]]});