initSidebarItems({"struct":[["RawVec","A low-level utility for more ergonomically allocating, reallocating, and deallocating a a buffer of memory on the heap without having to worry about all the corner cases involved. This type is excellent for building your own data structures like Vec and VecDeque. In particular:Produces heap::EMPTY on zero-sized types Produces heap::EMPTY on zero-length allocations Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics) Guards against 32-bit systems allocating more than isize::MAX bytes Guards against overflowing your length Aborts on OOM Avoids freeing heap::EMPTY Contains a ptr::Unique and thus endows the user with all related benefits This type does not in anyway inspect the memory that it manages. When dropped it *will* free its memory, but it *won't* try to Drop its contents. It is up to the user of RawVec to handle the actual things *stored* inside of a RawVec.Note that a RawVec always forces its capacity to be usize::MAX for zero-sized types. This enables you to use capacity growing logic catch the overflows in your length that might occur with zero-sized types.However this means that you need to be careful when roundtripping this type with a `Box<[T]>`: `cap()` won't yield the len. However `with_capacity`, `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity field. This allows zero-sized types to not be special-cased by consumers of this type."]]});