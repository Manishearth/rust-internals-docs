initSidebarItems({"fn":[["register_all",""]],"mod":[["bounds",""],["clone",""],["debug",""],["decodable","The compiler code necessary for `#[derive(Decodable)]`. See encodable.rs for more."],["default",""],["encodable","The compiler code necessary to implement the `#[derive(Encodable)]` (and `Decodable`, in decodable.rs) extension.  The idea here is that type-defining items may be tagged with `#[derive(Encodable, Decodable)]`.For example, a type like:would generate two implementations like:Other interesting scenarios are when the item has type parameters or references other non-built-in types.  A type definition like:would yield functions like:"],["eq",""],["generic","Some code that abstracts away much of the boilerplate of writing `derive` instances for traits. Among other things it manages getting access to the fields of the 4 different sorts of structs and enum variants, as well as creating the method and impl ast instances.Supported features (fairly exhaustive):Methods taking any number of parameters of any type, and returning any type, other than vectors, bottom and closures. Generating `impl`s for types with type parameters and lifetimes (e.g. `Option<T>`), the parameters are automatically given the current trait as a bound. (This includes separate type parameters and lifetimes for methods.) Additional bounds on the type parameters (`TraitDef.additional_bounds`) The most important thing for implementers is the `Substructure` and `SubstructureFields` objects. The latter groups 5 possibilities of the arguments:`Struct`, when `Self` is a struct (including tuple structs, e.g `struct T(i32, char)`). `EnumMatching`, when `Self` is an enum and all the arguments are the same variant of the enum (e.g. `Some(1)`, `Some(3)` and `Some(4)`) `EnumNonMatchingCollapsed` when `Self` is an enum and the arguments are not the same variant (e.g. `None`, `Some(1)` and `None`). `StaticEnum` and `StaticStruct` for static methods, where the type being derived upon is either an enum or struct respectively. (Any argument with type Self is just grouped among the non-self arguments.) In the first two cases, the values from the corresponding fields in all the arguments are grouped together. For `EnumNonMatchingCollapsed` this isn't possible (different variants have different fields), so the fields are inaccessible. (Previous versions of the deriving infrastructure had a way to expand into code that could access them, at the cost of generating exponential amounts of code; see issue #15375). There are no fields with values in the static cases, so these are treated entirely differently.The non-static cases have `Option<ident>` in several places associated with field `expr`s. This represents the name of the field it is associated with. It is only not `None` when the associated field has an identifier in the source code. For example, the `x`s in the following snippetThe `i32`s in `B` and `C0` don't have an identifier, so the `Option<ident>`s would be `None` for them.In the static cases, the structure is summarised, either into the just spans of the fields or a list of spans and the field idents (for tuple structs and record structs, respectively), or a list of these, for enums (one for each variant). For empty struct and empty enum variants, it is represented as a count of 0.\"`cs`\" functionsThe `cs_...` functions (\"combine substructure) are designed to make life easier by providing some pre-made recipes for common threads; mostly calling the function being derived on all the arguments and then combining them back together in some way (or letting the user chose that). They are not meant to be the only way to handle the structures that this code creates.ExamplesThe following simplified `PartialEq` is used for in-code examples:Some examples of the values of `SubstructureFields` follow, using the above `PartialEq`, `A`, `B` and `C`.StructsWhen generating the `expr` for the `A` impl, the `SubstructureFields` isFor the `B` impl, called with `B(a)` and `B(b)`,EnumsWhen generating the `expr` for a call with `self == C0(a)` and `other == C0(b)`, the SubstructureFields isFor `C1 {x}` and `C1 {x}`,For `C0(a)` and `C1 {x}` ,It is the same for when the arguments are flipped to `C1 {x}` and `C0(a)`; the only difference is what the values of the identifiers <ident for self index value> and <ident of __arg_1 index value> will be in the generated code.`EnumNonMatchingCollapsed` deliberately provides far less information than is generally available for a given pair of variants; see #15375 for discussion.StaticA static method on the types above would result in,"],["hash",""],["ord",""],["partial_eq",""],["partial_ord",""]]});