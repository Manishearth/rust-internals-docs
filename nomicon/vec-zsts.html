<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Handling Zero-Sized Types</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='meet-safe-and-unsafe.html'><b>2.</b> Meet Safe and Unsafe</a>
<ol class='section'>
<li><a  href='safe-unsafe-meaning.html'><b>2.1.</b> How Safe and Unsafe Interact</a>
</li>
<li><a  href='working-with-unsafe.html'><b>2.2.</b> Working with Unsafe</a>
</li>
</ol>
</li>
<li><a  href='data.html'><b>3.</b> Data Layout</a>
<ol class='section'>
<li><a  href='repr-rust.html'><b>3.1.</b> repr(Rust)</a>
</li>
<li><a  href='exotic-sizes.html'><b>3.2.</b> Exotically Sized Types</a>
</li>
<li><a  href='other-reprs.html'><b>3.3.</b> Other reprs</a>
</li>
</ol>
</li>
<li><a  href='ownership.html'><b>4.</b> Ownership</a>
<ol class='section'>
<li><a  href='references.html'><b>4.1.</b> References</a>
</li>
<li><a  href='lifetimes.html'><b>4.2.</b> Lifetimes</a>
</li>
<li><a  href='lifetime-mismatch.html'><b>4.3.</b> Limits of Lifetimes</a>
</li>
<li><a  href='lifetime-elision.html'><b>4.4.</b> Lifetime Elision</a>
</li>
<li><a  href='unbounded-lifetimes.html'><b>4.5.</b> Unbounded Lifetimes</a>
</li>
<li><a  href='hrtb.html'><b>4.6.</b> Higher-Rank Trait Bounds</a>
</li>
<li><a  href='subtyping.html'><b>4.7.</b> Subtyping and Variance</a>
</li>
<li><a  href='dropck.html'><b>4.8.</b> Drop Check</a>
</li>
<li><a  href='phantom-data.html'><b>4.9.</b> PhantomData</a>
</li>
<li><a  href='borrow-splitting.html'><b>4.10.</b> Splitting Borrows</a>
</li>
</ol>
</li>
<li><a  href='conversions.html'><b>5.</b> Type Conversions</a>
<ol class='section'>
<li><a  href='coercions.html'><b>5.1.</b> Coercions</a>
</li>
<li><a  href='dot-operator.html'><b>5.2.</b> The Dot Operator</a>
</li>
<li><a  href='casts.html'><b>5.3.</b> Casts</a>
</li>
<li><a  href='transmutes.html'><b>5.4.</b> Transmutes</a>
</li>
</ol>
</li>
<li><a  href='uninitialized.html'><b>6.</b> Uninitialized Memory</a>
<ol class='section'>
<li><a  href='checked-uninit.html'><b>6.1.</b> Checked</a>
</li>
<li><a  href='drop-flags.html'><b>6.2.</b> Drop Flags</a>
</li>
<li><a  href='unchecked-uninit.html'><b>6.3.</b> Unchecked</a>
</li>
</ol>
</li>
<li><a  href='obrm.html'><b>7.</b> Ownership Based Resource Management</a>
<ol class='section'>
<li><a  href='constructors.html'><b>7.1.</b> Constructors</a>
</li>
<li><a  href='destructors.html'><b>7.2.</b> Destructors</a>
</li>
<li><a  href='leaking.html'><b>7.3.</b> Leaking</a>
</li>
</ol>
</li>
<li><a  href='unwinding.html'><b>8.</b> Unwinding</a>
<ol class='section'>
<li><a  href='exception-safety.html'><b>8.1.</b> Exception Safety</a>
</li>
<li><a  href='poisoning.html'><b>8.2.</b> Poisoning</a>
</li>
</ol>
</li>
<li><a  href='concurrency.html'><b>9.</b> Concurrency</a>
<ol class='section'>
<li><a  href='races.html'><b>9.1.</b> Races</a>
</li>
<li><a  href='send-and-sync.html'><b>9.2.</b> Send and Sync</a>
</li>
<li><a  href='atomics.html'><b>9.3.</b> Atomics</a>
</li>
</ol>
</li>
<li><a  href='vec.html'><b>10.</b> Implementing Vec</a>
<ol class='section'>
<li><a  href='vec-layout.html'><b>10.1.</b> Layout</a>
</li>
<li><a  href='vec-alloc.html'><b>10.2.</b> Allocating</a>
</li>
<li><a  href='vec-push-pop.html'><b>10.3.</b> Push and Pop</a>
</li>
<li><a  href='vec-dealloc.html'><b>10.4.</b> Deallocating</a>
</li>
<li><a  href='vec-deref.html'><b>10.5.</b> Deref</a>
</li>
<li><a  href='vec-insert-remove.html'><b>10.6.</b> Insert and Remove</a>
</li>
<li><a  href='vec-into-iter.html'><b>10.7.</b> IntoIter</a>
</li>
<li><a  href='vec-raw.html'><b>10.8.</b> RawVec</a>
</li>
<li><a  href='vec-drain.html'><b>10.9.</b> Drain</a>
</li>
<li><a class='active' href='vec-zsts.html'><b>10.10.</b> Handling Zero-Sized Types</a>
</li>
<li><a  href='vec-final.html'><b>10.11.</b> Final Code</a>
</li>
</ol>
</li>
<li><a  href='arc-and-mutex.html'><b>11.</b> Implementing Arc and Mutex</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Handling Zero-Sized Types</h1>
    <p>It&#39;s time. We&#39;re going to fight the specter that is zero-sized types. Safe Rust
<em>never</em> needs to care about this, but Vec is very intensive on raw pointers and
raw allocations, which are exactly the two things that care about
zero-sized types. We need to be careful of two things:</p>

<ul>
<li>The raw allocator API has undefined behavior if you pass in 0 for an
allocation size.</li>
<li>raw pointer offsets are no-ops for zero-sized types, which will break our
C-style pointer iterator.</li>
</ul>

<p>Thankfully we abstracted out pointer-iterators and allocating handling into
RawValIter and RawVec respectively. How mysteriously convenient.</p>

<h2 id='allocating-zero-sized-types' class='section-header'><a href='#allocating-zero-sized-types'>Allocating Zero-Sized Types</a></h2>
<p>So if the allocator API doesn&#39;t support zero-sized allocations, what on earth
do we store as our allocation? Why, <code>heap::EMPTY</code> of course! Almost every operation
with a ZST is a no-op since ZSTs have exactly one value, and therefore no state needs
to be considered to store or load them. This actually extends to <code>ptr::read</code> and
<code>ptr::write</code>: they won&#39;t actually look at the pointer at all. As such we never need
to change the pointer.</p>

<p>Note however that our previous reliance on running out of memory before overflow is
no longer valid with zero-sized types. We must explicitly guard against capacity
overflow for zero-sized types.</p>

<p>Due to our current architecture, all this means is writing 3 guards, one in each
method of RawVec.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>RawVec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>() <span class='op'>-&gt;</span> <span class='self'>Self</span> {
        <span class='kw'>unsafe</span> {
            <span class='comment'>// !0 is usize::MAX. This branch should be stripped at compile time.</span>
            <span class='kw'>let</span> <span class='ident'>cap</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() <span class='op'>==</span> <span class='number'>0</span> { <span class='op'>!</span><span class='number'>0</span> } <span class='kw'>else</span> { <span class='number'>0</span> };

            <span class='comment'>// heap::EMPTY doubles as &quot;unallocated&quot; and &quot;zero-sized allocation&quot;</span>
            <span class='ident'>RawVec</span> { <span class='ident'>ptr</span>: <span class='ident'>Unique</span>::<span class='ident'>new</span>(<span class='ident'>heap</span>::<span class='ident'>EMPTY</span> <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> <span class='ident'>T</span>), <span class='ident'>cap</span>: <span class='ident'>cap</span> }
        }
    }

    <span class='kw'>fn</span> <span class='ident'>grow</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='kw'>unsafe</span> {
            <span class='kw'>let</span> <span class='ident'>elem_size</span> <span class='op'>=</span> <span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>();

            <span class='comment'>// since we set the capacity to usize::MAX when elem_size is</span>
            <span class='comment'>// 0, getting to here necessarily means the Vec is overfull.</span>
            <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>elem_size</span> <span class='op'>!=</span> <span class='number'>0</span>, <span class='string'>&quot;capacity overflow&quot;</span>);

            <span class='kw'>let</span> <span class='ident'>align</span> <span class='op'>=</span> <span class='ident'>mem</span>::<span class='ident'>align_of</span>::<span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>();

            <span class='kw'>let</span> (<span class='ident'>new_cap</span>, <span class='ident'>ptr</span>) <span class='op'>=</span> <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>cap</span> <span class='op'>==</span> <span class='number'>0</span> {
                <span class='kw'>let</span> <span class='ident'>ptr</span> <span class='op'>=</span> <span class='ident'>heap</span>::<span class='ident'>allocate</span>(<span class='ident'>elem_size</span>, <span class='ident'>align</span>);
                (<span class='number'>1</span>, <span class='ident'>ptr</span>)
            } <span class='kw'>else</span> {
                <span class='kw'>let</span> <span class='ident'>new_cap</span> <span class='op'>=</span> <span class='number'>2</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>cap</span>;
                <span class='kw'>let</span> <span class='ident'>ptr</span> <span class='op'>=</span> <span class='ident'>heap</span>::<span class='ident'>reallocate</span>(<span class='kw-2'>*</span><span class='self'>self</span>.<span class='ident'>ptr</span> <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> _,
                                            <span class='self'>self</span>.<span class='ident'>cap</span> <span class='op'>*</span> <span class='ident'>elem_size</span>,
                                            <span class='ident'>new_cap</span> <span class='op'>*</span> <span class='ident'>elem_size</span>,
                                            <span class='ident'>align</span>);
                (<span class='ident'>new_cap</span>, <span class='ident'>ptr</span>)
            };

            <span class='comment'>// If allocate or reallocate fail, we&#39;ll get `null` back</span>
            <span class='kw'>if</span> <span class='ident'>ptr</span>.<span class='ident'>is_null</span>() { <span class='ident'>oom</span>() }

            <span class='self'>self</span>.<span class='ident'>ptr</span> <span class='op'>=</span> <span class='ident'>Unique</span>::<span class='ident'>new</span>(<span class='ident'>ptr</span> <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> _);
            <span class='self'>self</span>.<span class='ident'>cap</span> <span class='op'>=</span> <span class='ident'>new_cap</span>;
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>RawVec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='kw'>let</span> <span class='ident'>elem_size</span> <span class='op'>=</span> <span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>();

        <span class='comment'>// don&#39;t free zero-sized allocations, as they were never allocated.</span>
        <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>cap</span> <span class='op'>!=</span> <span class='number'>0</span> <span class='op'>&amp;&amp;</span> <span class='ident'>elem_size</span> <span class='op'>!=</span> <span class='number'>0</span> {
            <span class='kw'>let</span> <span class='ident'>align</span> <span class='op'>=</span> <span class='ident'>mem</span>::<span class='ident'>align_of</span>::<span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>();

            <span class='kw'>let</span> <span class='ident'>num_bytes</span> <span class='op'>=</span> <span class='ident'>elem_size</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>cap</span>;
            <span class='kw'>unsafe</span> {
                <span class='ident'>heap</span>::<span class='ident'>deallocate</span>(<span class='kw-2'>*</span><span class='self'>self</span>.<span class='ident'>ptr</span> <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw-2'>mut</span> _, <span class='ident'>num_bytes</span>, <span class='ident'>align</span>);
            }
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CT%3E%20RawVec%3CT%3E%20%7B%0A%20%20%20%20fn%20new()%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20!0%20is%20usize%3A%3AMAX.%20This%20branch%20should%20be%20stripped%20at%20compile%20time.%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20cap%20%3D%20if%20mem%3A%3Asize_of%3A%3A%3CT%3E()%20%3D%3D%200%20%7B%20!0%20%7D%20else%20%7B%200%20%7D%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20heap%3A%3AEMPTY%20doubles%20as%20%22unallocated%22%20and%20%22zero-sized%20allocation%22%0A%20%20%20%20%20%20%20%20%20%20%20%20RawVec%20%7B%20ptr%3A%20Unique%3A%3Anew(heap%3A%3AEMPTY%20as%20*mut%20T)%2C%20cap%3A%20cap%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20grow(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20elem_size%20%3D%20mem%3A%3Asize_of%3A%3A%3CT%3E()%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20since%20we%20set%20the%20capacity%20to%20usize%3A%3AMAX%20when%20elem_size%20is%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%200%2C%20getting%20to%20here%20necessarily%20means%20the%20Vec%20is%20overfull.%0A%20%20%20%20%20%20%20%20%20%20%20%20assert!(elem_size%20!%3D%200%2C%20%22capacity%20overflow%22)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20align%20%3D%20mem%3A%3Aalign_of%3A%3A%3CT%3E()%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20(new_cap%2C%20ptr)%20%3D%20if%20self.cap%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20ptr%20%3D%20heap%3A%3Aallocate(elem_size%2C%20align)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(1%2C%20ptr)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20new_cap%20%3D%202%20*%20self.cap%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20ptr%20%3D%20heap%3A%3Areallocate(*self.ptr%20as%20*mut%20_%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.cap%20*%20elem_size%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20new_cap%20*%20elem_size%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20align)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(new_cap%2C%20ptr)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20If%20allocate%20or%20reallocate%20fail%2C%20we'll%20get%20%60null%60%20back%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20ptr.is_null()%20%7B%20oom()%20%7D%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20self.ptr%20%3D%20Unique%3A%3Anew(ptr%20as%20*mut%20_)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20self.cap%20%3D%20new_cap%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3CT%3E%20Drop%20for%20RawVec%3CT%3E%20%7B%0A%20%20%20%20fn%20drop(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20let%20elem_size%20%3D%20mem%3A%3Asize_of%3A%3A%3CT%3E()%3B%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20don't%20free%20zero-sized%20allocations%2C%20as%20they%20were%20never%20allocated.%0A%20%20%20%20%20%20%20%20if%20self.cap%20!%3D%200%20%26%26%20elem_size%20!%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20align%20%3D%20mem%3A%3Aalign_of%3A%3A%3CT%3E()%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20num_bytes%20%3D%20elem_size%20*%20self.cap%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20heap%3A%3Adeallocate(*self.ptr%20as%20*mut%20_%2C%20num_bytes%2C%20align)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>That&#39;s it. We support pushing and popping zero-sized types now. Our iterators
(that aren&#39;t provided by slice Deref) are still busted, though.</p>

<h2 id='iterating-zero-sized-types' class='section-header'><a href='#iterating-zero-sized-types'>Iterating Zero-Sized Types</a></h2>
<p>Zero-sized offsets are no-ops. This means that our current design will always
initialize <code>start</code> and <code>end</code> as the same value, and our iterators will yield
nothing. The current solution to this is to cast the pointers to integers,
increment, and then cast them back:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>RawValIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>slice</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>]) <span class='op'>-&gt;</span> <span class='self'>Self</span> {
        <span class='ident'>RawValIter</span> {
            <span class='ident'>start</span>: <span class='ident'>slice</span>.<span class='ident'>as_ptr</span>(),
            <span class='ident'>end</span>: <span class='kw'>if</span> <span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() <span class='op'>==</span> <span class='number'>0</span> {
                ((<span class='ident'>slice</span>.<span class='ident'>as_ptr</span>() <span class='kw'>as</span> <span class='ident'>usize</span>) <span class='op'>+</span> <span class='ident'>slice</span>.<span class='ident'>len</span>()) <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw'>const</span> _
            } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>slice</span>.<span class='ident'>len</span>() <span class='op'>==</span> <span class='number'>0</span> {
                <span class='ident'>slice</span>.<span class='ident'>as_ptr</span>()
            } <span class='kw'>else</span> {
                <span class='ident'>slice</span>.<span class='ident'>as_ptr</span>().<span class='ident'>offset</span>(<span class='ident'>slice</span>.<span class='ident'>len</span>() <span class='kw'>as</span> <span class='ident'>isize</span>)
            }
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CT%3E%20RawValIter%3CT%3E%20%7B%0A%20%20%20%20unsafe%20fn%20new(slice%3A%20%26%5BT%5D)%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20RawValIter%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20start%3A%20slice.as_ptr()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20end%3A%20if%20mem%3A%3Asize_of%3A%3A%3CT%3E()%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20((slice.as_ptr()%20as%20usize)%20%2B%20slice.len())%20as%20*const%20_%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20if%20slice.len()%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20slice.as_ptr()%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20slice.as_ptr().offset(slice.len()%20as%20isize)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Now we have a different bug. Instead of our iterators not running at all, our
iterators now run <em>forever</em>. We need to do the same trick in our iterator impls.
Also, our size_hint computation code will divide by 0 for ZSTs. Since we&#39;ll
basically be treating the two pointers as if they point to bytes, we&#39;ll just
map size 0 to divide by 1.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>RawValIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='ident'>T</span>;
    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>start</span> <span class='op'>==</span> <span class='self'>self</span>.<span class='ident'>end</span> {
            <span class='prelude-val'>None</span>
        } <span class='kw'>else</span> {
            <span class='kw'>unsafe</span> {
                <span class='kw'>let</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='ident'>ptr</span>::<span class='ident'>read</span>(<span class='self'>self</span>.<span class='ident'>start</span>);
                <span class='self'>self</span>.<span class='ident'>start</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() <span class='op'>==</span> <span class='number'>0</span> {
                    (<span class='self'>self</span>.<span class='ident'>start</span> <span class='kw'>as</span> <span class='ident'>usize</span> <span class='op'>+</span> <span class='number'>1</span>) <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw'>const</span> _
                } <span class='kw'>else</span> {
                    <span class='self'>self</span>.<span class='ident'>start</span>.<span class='ident'>offset</span>(<span class='number'>1</span>)
                };
                <span class='prelude-val'>Some</span>(<span class='ident'>result</span>)
            }
        }
    }

    <span class='kw'>fn</span> <span class='ident'>size_hint</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> (<span class='ident'>usize</span>, <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span>) {
        <span class='kw'>let</span> <span class='ident'>elem_size</span> <span class='op'>=</span> <span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>();
        <span class='kw'>let</span> <span class='ident'>len</span> <span class='op'>=</span> (<span class='self'>self</span>.<span class='ident'>end</span> <span class='kw'>as</span> <span class='ident'>usize</span> <span class='op'>-</span> <span class='self'>self</span>.<span class='ident'>start</span> <span class='kw'>as</span> <span class='ident'>usize</span>)
                  <span class='op'>/</span> <span class='kw'>if</span> <span class='ident'>elem_size</span> <span class='op'>==</span> <span class='number'>0</span> { <span class='number'>1</span> } <span class='kw'>else</span> { <span class='ident'>elem_size</span> };
        (<span class='ident'>len</span>, <span class='prelude-val'>Some</span>(<span class='ident'>len</span>))
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>DoubleEndedIterator</span> <span class='kw'>for</span> <span class='ident'>RawValIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>next_back</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>start</span> <span class='op'>==</span> <span class='self'>self</span>.<span class='ident'>end</span> {
            <span class='prelude-val'>None</span>
        } <span class='kw'>else</span> {
            <span class='kw'>unsafe</span> {
                <span class='self'>self</span>.<span class='ident'>end</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() <span class='op'>==</span> <span class='number'>0</span> {
                    (<span class='self'>self</span>.<span class='ident'>end</span> <span class='kw'>as</span> <span class='ident'>usize</span> <span class='op'>-</span> <span class='number'>1</span>) <span class='kw'>as</span> <span class='kw-2'>*</span><span class='kw'>const</span> _
                } <span class='kw'>else</span> {
                    <span class='self'>self</span>.<span class='ident'>end</span>.<span class='ident'>offset</span>(<span class='op'>-</span><span class='number'>1</span>)
                };
                <span class='prelude-val'>Some</span>(<span class='ident'>ptr</span>::<span class='ident'>read</span>(<span class='self'>self</span>.<span class='ident'>end</span>))
            }
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aimpl%3CT%3E%20Iterator%20for%20RawValIter%3CT%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20T%3B%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20self.start%20%3D%3D%20self.end%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20None%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20result%20%3D%20ptr%3A%3Aread(self.start)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.start%20%3D%20if%20mem%3A%3Asize_of%3A%3A%3CT%3E()%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(self.start%20as%20usize%20%2B%201)%20as%20*const%20_%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.start.offset(1)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(result)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20size_hint(%26self)%20-%3E%20(usize%2C%20Option%3Cusize%3E)%20%7B%0A%20%20%20%20%20%20%20%20let%20elem_size%20%3D%20mem%3A%3Asize_of%3A%3A%3CT%3E()%3B%0A%20%20%20%20%20%20%20%20let%20len%20%3D%20(self.end%20as%20usize%20-%20self.start%20as%20usize)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20if%20elem_size%20%3D%3D%200%20%7B%201%20%7D%20else%20%7B%20elem_size%20%7D%3B%0A%20%20%20%20%20%20%20%20(len%2C%20Some(len))%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3CT%3E%20DoubleEndedIterator%20for%20RawValIter%3CT%3E%20%7B%0A%20%20%20%20fn%20next_back(%26mut%20self)%20-%3E%20Option%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20self.start%20%3D%3D%20self.end%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20None%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.end%20%3D%20if%20mem%3A%3Asize_of%3A%3A%3CT%3E()%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(self.end%20as%20usize%20-%201)%20as%20*const%20_%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20self.end.offset(-1)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(ptr%3A%3Aread(self.end))%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>And that&#39;s it. Iteration works!</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>