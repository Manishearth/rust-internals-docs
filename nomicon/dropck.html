<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Drop Check</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='meet-safe-and-unsafe.html'><b>2.</b> Meet Safe and Unsafe</a>
<ul class='section'>
<li><a  href='safe-unsafe-meaning.html'><b>2.1.</b> How Safe and Unsafe Interact</a>
</li>
<li><a  href='working-with-unsafe.html'><b>2.2.</b> Working with Unsafe</a>
</li>
</ul>
</li>
<li><a  href='data.html'><b>3.</b> Data Layout</a>
<ul class='section'>
<li><a  href='repr-rust.html'><b>3.1.</b> repr(Rust)</a>
</li>
<li><a  href='exotic-sizes.html'><b>3.2.</b> Exotically Sized Types</a>
</li>
<li><a  href='other-reprs.html'><b>3.3.</b> Other reprs</a>
</li>
</ul>
</li>
<li><a  href='ownership.html'><b>4.</b> Ownership</a>
<ul class='section'>
<li><a  href='references.html'><b>4.1.</b> References</a>
</li>
<li><a  href='lifetimes.html'><b>4.2.</b> Lifetimes</a>
</li>
<li><a  href='lifetime-mismatch.html'><b>4.3.</b> Limits of Lifetimes</a>
</li>
<li><a  href='lifetime-elision.html'><b>4.4.</b> Lifetime Elision</a>
</li>
<li><a  href='unbounded-lifetimes.html'><b>4.5.</b> Unbounded Lifetimes</a>
</li>
<li><a  href='hrtb.html'><b>4.6.</b> Higher-Rank Trait Bounds</a>
</li>
<li><a  href='subtyping.html'><b>4.7.</b> Subtyping and Variance</a>
</li>
<li><a class='active' href='dropck.html'><b>4.8.</b> Drop Check</a>
</li>
<li><a  href='phantom-data.html'><b>4.9.</b> PhantomData</a>
</li>
<li><a  href='borrow-splitting.html'><b>4.10.</b> Splitting Borrows</a>
</li>
</ul>
</li>
<li><a  href='conversions.html'><b>5.</b> Type Conversions</a>
<ul class='section'>
<li><a  href='coercions.html'><b>5.1.</b> Coercions</a>
</li>
<li><a  href='dot-operator.html'><b>5.2.</b> The Dot Operator</a>
</li>
<li><a  href='casts.html'><b>5.3.</b> Casts</a>
</li>
<li><a  href='transmutes.html'><b>5.4.</b> Transmutes</a>
</li>
</ul>
</li>
<li><a  href='uninitialized.html'><b>6.</b> Uninitialized Memory</a>
<ul class='section'>
<li><a  href='checked-uninit.html'><b>6.1.</b> Checked</a>
</li>
<li><a  href='drop-flags.html'><b>6.2.</b> Drop Flags</a>
</li>
<li><a  href='unchecked-uninit.html'><b>6.3.</b> Unchecked</a>
</li>
</ul>
</li>
<li><a  href='obrm.html'><b>7.</b> Ownership Based Resource Management</a>
<ul class='section'>
<li><a  href='constructors.html'><b>7.1.</b> Constructors</a>
</li>
<li><a  href='destructors.html'><b>7.2.</b> Destructors</a>
</li>
<li><a  href='leaking.html'><b>7.3.</b> Leaking</a>
</li>
</ul>
</li>
<li><a  href='unwinding.html'><b>8.</b> Unwinding</a>
<ul class='section'>
<li><a  href='exception-safety.html'><b>8.1.</b> Exception Safety</a>
</li>
<li><a  href='poisoning.html'><b>8.2.</b> Poisoning</a>
</li>
</ul>
</li>
<li><a  href='concurrency.html'><b>9.</b> Concurrency</a>
<ul class='section'>
<li><a  href='races.html'><b>9.1.</b> Races</a>
</li>
<li><a  href='send-and-sync.html'><b>9.2.</b> Send and Sync</a>
</li>
<li><a  href='atomics.html'><b>9.3.</b> Atomics</a>
</li>
</ul>
</li>
<li><a  href='vec.html'><b>10.</b> Implementing Vec</a>
<ul class='section'>
<li><a  href='vec-layout.html'><b>10.1.</b> Layout</a>
</li>
<li><a  href='vec-alloc.html'><b>10.2.</b> Allocating</a>
</li>
<li><a  href='vec-push-pop.html'><b>10.3.</b> Push and Pop</a>
</li>
<li><a  href='vec-dealloc.html'><b>10.4.</b> Deallocating</a>
</li>
<li><a  href='vec-deref.html'><b>10.5.</b> Deref</a>
</li>
<li><a  href='vec-insert-remove.html'><b>10.6.</b> Insert and Remove</a>
</li>
<li><a  href='vec-into-iter.html'><b>10.7.</b> IntoIter</a>
</li>
<li><a  href='vec-raw.html'><b>10.8.</b> RawVec</a>
</li>
<li><a  href='vec-drain.html'><b>10.9.</b> Drain</a>
</li>
<li><a  href='vec-zsts.html'><b>10.10.</b> Handling Zero-Sized Types</a>
</li>
<li><a  href='vec-final.html'><b>10.11.</b> Final Code</a>
</li>
</ul>
</li>
<li><a  href='arc-and-mutex.html'><b>11.</b> Implementing Arc and Mutex</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Drop Check</h1>
    <p>We have seen how lifetimes provide us some fairly simple rules for ensuring
that we never read dangling references. However up to this point we have only ever
interacted with the <em>outlives</em> relationship in an inclusive manner. That is,
when we talked about <code>&#39;a: &#39;b</code>, it was ok for <code>&#39;a</code> to live <em>exactly</em> as long as
<code>&#39;b</code>. At first glance, this seems to be a meaningless distinction. Nothing ever
gets dropped at the same time as another, right? This is why we used the
following desugarring of <code>let</code> statements:</p>
<span class='rusttest'>fn main() {
    let x;
    let y;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>;
<span class='kw'>let</span> <span class='ident'>y</span>;</pre>
<span class='rusttest'>fn main() {
    {
        let x;
        {
            let y;
        }
    }
    
}</span><pre class='rust rust-example-rendered'>
{
    <span class='kw'>let</span> <span class='ident'>x</span>;
    {
        <span class='kw'>let</span> <span class='ident'>y</span>;
    }
}</pre>

<p>Each creates its own scope, clearly establishing that one drops before the
other. However, what if we do the following?</p>
<span class='rusttest'>fn main() {
    let (x, y) = (vec![], vec![]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>) <span class='op'>=</span> (<span class='macro'>vec</span><span class='macro'>!</span>[], <span class='macro'>vec</span><span class='macro'>!</span>[]);</pre>

<p>Does either value strictly outlive the other? The answer is in fact <em>no</em>,
neither value strictly outlives the other. Of course, one of x or y will be
dropped before the other, but the actual order is not specified. Tuples aren&#39;t
special in this regard; composite structures just don&#39;t guarantee their
destruction order as of Rust 1.0.</p>

<p>We <em>could</em> specify this for the fields of built-in composites like tuples and
structs. However, what about something like Vec? Vec has to manually drop its
elements via pure-library code. In general, anything that implements Drop has
a chance to fiddle with its innards during its final death knell. Therefore
the compiler can&#39;t sufficiently reason about the actual destruction order
of the contents of any type that implements Drop.</p>

<p>So why do we care? We care because if the type system isn&#39;t careful, it could
accidentally make dangling pointers. Consider the following simple program:</p>
<span class='rusttest'>struct Inspector&lt;&#39;a&gt;(&amp;&#39;a u8);

fn main() {
    let (inspector, days);
    days = Box::new(1);
    inspector = Inspector(&amp;days);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Inspector</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>u8</span>);

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> (<span class='ident'>inspector</span>, <span class='ident'>days</span>);
    <span class='ident'>days</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>1</span>);
    <span class='ident'>inspector</span> <span class='op'>=</span> <span class='ident'>Inspector</span>(<span class='kw-2'>&amp;</span><span class='ident'>days</span>);
}</pre>

<p>This program is totally sound and compiles today. The fact that <code>days</code> does
not <em>strictly</em> outlive <code>inspector</code> doesn&#39;t matter. As long as the <code>inspector</code>
is alive, so is days.</p>

<p>However if we add a destructor, the program will no longer compile!</p>
<span class='rusttest'>struct Inspector&lt;&#39;a&gt;(&amp;&#39;a u8);

impl&lt;&#39;a&gt; Drop for Inspector&lt;&#39;a&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;I was only {} days from retirement!&quot;, self.0);
    }
}

fn main() {
    let (inspector, days);
    days = Box::new(1);
    inspector = Inspector(&amp;days);
    // Let&#39;s say `days` happens to get dropped first.
    // Then when Inspector is dropped, it will try to read free&#39;d memory!
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Inspector</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>u8</span>);

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>Inspector</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;I was only {} days from retirement!&quot;</span>, <span class='self'>self</span>.<span class='number'>0</span>);
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> (<span class='ident'>inspector</span>, <span class='ident'>days</span>);
    <span class='ident'>days</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>1</span>);
    <span class='ident'>inspector</span> <span class='op'>=</span> <span class='ident'>Inspector</span>(<span class='kw-2'>&amp;</span><span class='ident'>days</span>);
    <span class='comment'>// Let&#39;s say `days` happens to get dropped first.</span>
    <span class='comment'>// Then when Inspector is dropped, it will try to read free&#39;d memory!</span>
}</pre>

<pre><code class="language-text">&lt;anon&gt;:12:28: 12:32 error: `days` does not live long enough
&lt;anon&gt;:12     inspector = Inspector(&amp;days);
                                     ^~~~
&lt;anon&gt;:9:11: 15:2 note: reference must be valid for the block at 9:10...
&lt;anon&gt;:9 fn main() {
&lt;anon&gt;:10     let (inspector, days);
&lt;anon&gt;:11     days = Box::new(1);
&lt;anon&gt;:12     inspector = Inspector(&amp;days);
&lt;anon&gt;:13     // Let&#39;s say `days` happens to get dropped first.
&lt;anon&gt;:14     // Then when Inspector is dropped, it will try to read free&#39;d memory!
          ...
&lt;anon&gt;:10:27: 15:2 note: ...but borrowed value is only valid for the block suffix following statement 0 at 10:26
&lt;anon&gt;:10     let (inspector, days);
&lt;anon&gt;:11     days = Box::new(1);
&lt;anon&gt;:12     inspector = Inspector(&amp;days);
&lt;anon&gt;:13     // Let&#39;s say `days` happens to get dropped first.
&lt;anon&gt;:14     // Then when Inspector is dropped, it will try to read free&#39;d memory!
&lt;anon&gt;:15 }
</code></pre>

<p>Implementing Drop lets the Inspector execute some arbitrary code during its
death. This means it can potentially observe that types that are supposed to
live as long as it does actually were destroyed first.</p>

<p>Interestingly, only generic types need to worry about this. If they aren&#39;t
generic, then the only lifetimes they can harbor are <code>&#39;static</code>, which will truly
live <em>forever</em>. This is why this problem is referred to as <em>sound generic drop</em>.
Sound generic drop is enforced by the <em>drop checker</em>. As of this writing, some
of the finer details of how the drop checker validates types is totally up in
the air. However The Big Rule is the subtlety that we have focused on this whole
section:</p>

<p><strong>For a generic type to soundly implement drop, its generics arguments must
strictly outlive it.</strong></p>

<p>This rule is sufficient but not necessary to satisfy the drop checker. That is,
if your type obeys this rule then it&#39;s definitely sound to drop. However
there are special cases where you can fail to satisfy this, but still
successfully pass the borrow checker. These are the precise rules that are
currently up in the air.</p>

<p>It turns out that when writing unsafe code, we generally don&#39;t need to
worry at all about doing the right thing for the drop checker. However there
is one special case that you need to worry about, which we will look at in
the next section.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    
<script type="text/javascript" src="rust-book.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>