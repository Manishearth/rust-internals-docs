<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Splitting Borrows</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='meet-safe-and-unsafe.html'><b>2.</b> Meet Safe and Unsafe</a>
<ol class='section'>
<li><a  href='safe-unsafe-meaning.html'><b>2.1.</b> How Safe and Unsafe Interact</a>
</li>
<li><a  href='working-with-unsafe.html'><b>2.2.</b> Working with Unsafe</a>
</li>
</ol>
</li>
<li><a  href='data.html'><b>3.</b> Data Layout</a>
<ol class='section'>
<li><a  href='repr-rust.html'><b>3.1.</b> repr(Rust)</a>
</li>
<li><a  href='exotic-sizes.html'><b>3.2.</b> Exotically Sized Types</a>
</li>
<li><a  href='other-reprs.html'><b>3.3.</b> Other reprs</a>
</li>
</ol>
</li>
<li><a  href='ownership.html'><b>4.</b> Ownership</a>
<ol class='section'>
<li><a  href='references.html'><b>4.1.</b> References</a>
</li>
<li><a  href='lifetimes.html'><b>4.2.</b> Lifetimes</a>
</li>
<li><a  href='lifetime-mismatch.html'><b>4.3.</b> Limits of Lifetimes</a>
</li>
<li><a  href='lifetime-elision.html'><b>4.4.</b> Lifetime Elision</a>
</li>
<li><a  href='unbounded-lifetimes.html'><b>4.5.</b> Unbounded Lifetimes</a>
</li>
<li><a  href='hrtb.html'><b>4.6.</b> Higher-Rank Trait Bounds</a>
</li>
<li><a  href='subtyping.html'><b>4.7.</b> Subtyping and Variance</a>
</li>
<li><a  href='dropck.html'><b>4.8.</b> Drop Check</a>
</li>
<li><a  href='phantom-data.html'><b>4.9.</b> PhantomData</a>
</li>
<li><a class='active' href='borrow-splitting.html'><b>4.10.</b> Splitting Borrows</a>
</li>
</ol>
</li>
<li><a  href='conversions.html'><b>5.</b> Type Conversions</a>
<ol class='section'>
<li><a  href='coercions.html'><b>5.1.</b> Coercions</a>
</li>
<li><a  href='dot-operator.html'><b>5.2.</b> The Dot Operator</a>
</li>
<li><a  href='casts.html'><b>5.3.</b> Casts</a>
</li>
<li><a  href='transmutes.html'><b>5.4.</b> Transmutes</a>
</li>
</ol>
</li>
<li><a  href='uninitialized.html'><b>6.</b> Uninitialized Memory</a>
<ol class='section'>
<li><a  href='checked-uninit.html'><b>6.1.</b> Checked</a>
</li>
<li><a  href='drop-flags.html'><b>6.2.</b> Drop Flags</a>
</li>
<li><a  href='unchecked-uninit.html'><b>6.3.</b> Unchecked</a>
</li>
</ol>
</li>
<li><a  href='obrm.html'><b>7.</b> Ownership Based Resource Management</a>
<ol class='section'>
<li><a  href='constructors.html'><b>7.1.</b> Constructors</a>
</li>
<li><a  href='destructors.html'><b>7.2.</b> Destructors</a>
</li>
<li><a  href='leaking.html'><b>7.3.</b> Leaking</a>
</li>
</ol>
</li>
<li><a  href='unwinding.html'><b>8.</b> Unwinding</a>
<ol class='section'>
<li><a  href='exception-safety.html'><b>8.1.</b> Exception Safety</a>
</li>
<li><a  href='poisoning.html'><b>8.2.</b> Poisoning</a>
</li>
</ol>
</li>
<li><a  href='concurrency.html'><b>9.</b> Concurrency</a>
<ol class='section'>
<li><a  href='races.html'><b>9.1.</b> Races</a>
</li>
<li><a  href='send-and-sync.html'><b>9.2.</b> Send and Sync</a>
</li>
<li><a  href='atomics.html'><b>9.3.</b> Atomics</a>
</li>
</ol>
</li>
<li><a  href='vec.html'><b>10.</b> Implementing Vec</a>
<ol class='section'>
<li><a  href='vec-layout.html'><b>10.1.</b> Layout</a>
</li>
<li><a  href='vec-alloc.html'><b>10.2.</b> Allocating</a>
</li>
<li><a  href='vec-push-pop.html'><b>10.3.</b> Push and Pop</a>
</li>
<li><a  href='vec-dealloc.html'><b>10.4.</b> Deallocating</a>
</li>
<li><a  href='vec-deref.html'><b>10.5.</b> Deref</a>
</li>
<li><a  href='vec-insert-remove.html'><b>10.6.</b> Insert and Remove</a>
</li>
<li><a  href='vec-into-iter.html'><b>10.7.</b> IntoIter</a>
</li>
<li><a  href='vec-raw.html'><b>10.8.</b> RawVec</a>
</li>
<li><a  href='vec-drain.html'><b>10.9.</b> Drain</a>
</li>
<li><a  href='vec-zsts.html'><b>10.10.</b> Handling Zero-Sized Types</a>
</li>
<li><a  href='vec-final.html'><b>10.11.</b> Final Code</a>
</li>
</ol>
</li>
<li><a  href='arc-and-mutex.html'><b>11.</b> Implementing Arc and Mutex</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Splitting Borrows</h1>
    <p>The mutual exclusion property of mutable references can be very limiting when
working with a composite structure. The borrow checker understands some basic
stuff, but will fall over pretty easily. It does understand structs
sufficiently to know that it&#39;s possible to borrow disjoint fields of a struct
simultaneously. So this works today:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>a</span>: <span class='ident'>i32</span>,
    <span class='ident'>b</span>: <span class='ident'>i32</span>,
    <span class='ident'>c</span>: <span class='ident'>i32</span>,
}

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> {<span class='ident'>a</span>: <span class='number'>0</span>, <span class='ident'>b</span>: <span class='number'>0</span>, <span class='ident'>c</span>: <span class='number'>0</span>};
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>.<span class='ident'>a</span>;
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>.<span class='ident'>b</span>;
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>.<span class='ident'>c</span>;
<span class='kw-2'>*</span><span class='ident'>b</span> <span class='op'>+=</span> <span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>c2</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>.<span class='ident'>c</span>;
<span class='kw-2'>*</span><span class='ident'>a</span> <span class='op'>+=</span> <span class='number'>10</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} {} {} {}&quot;</span>, <span class='ident'>a</span>, <span class='ident'>b</span>, <span class='ident'>c</span>, <span class='ident'>c2</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Foo%20%7B%0A%20%20%20%20a%3A%20i32%2C%0A%20%20%20%20b%3A%20i32%2C%0A%20%20%20%20c%3A%20i32%2C%0A%7D%0A%0Alet%20mut%20x%20%3D%20Foo%20%7Ba%3A%200%2C%20b%3A%200%2C%20c%3A%200%7D%3B%0Alet%20a%20%3D%20%26mut%20x.a%3B%0Alet%20b%20%3D%20%26mut%20x.b%3B%0Alet%20c%20%3D%20%26x.c%3B%0A*b%20%2B%3D%201%3B%0Alet%20c2%20%3D%20%26x.c%3B%0A*a%20%2B%3D%2010%3B%0Aprintln!(%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%20a%2C%20b%2C%20c%2C%20c2)%3B%0A%7D">Run</a></pre>

<p>However borrowck doesn&#39;t understand arrays or slices in any way, so this doesn&#39;t
work:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>[<span class='number'>0</span>];
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>[<span class='number'>1</span>];
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} {}&quot;</span>, <span class='ident'>a</span>, <span class='ident'>b</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20x%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20a%20%3D%20%26mut%20x%5B0%5D%3B%0Alet%20b%20%3D%20%26mut%20x%5B1%5D%3B%0Aprintln!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D">Run</a></pre>

<pre><code class="language-text">&lt;anon&gt;:4:14: 4:18 error: cannot borrow `x[..]` as mutable more than once at a time
&lt;anon&gt;:4 let b = &amp;mut x[1];
                      ^~~~
&lt;anon&gt;:3:14: 3:18 note: previous borrow of `x[..]` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x[..]` until the borrow ends
&lt;anon&gt;:3 let a = &amp;mut x[0];
                      ^~~~
&lt;anon&gt;:6:2: 6:2 note: previous borrow ends here
&lt;anon&gt;:1 fn main() {
&lt;anon&gt;:2 let mut x = [1, 2, 3];
&lt;anon&gt;:3 let a = &amp;mut x[0];
&lt;anon&gt;:4 let b = &amp;mut x[1];
&lt;anon&gt;:5 println!(&quot;{} {}&quot;, a, b);
&lt;anon&gt;:6 }
         ^
error: aborting due to 2 previous errors
</code></pre>

<p>While it was plausible that borrowck could understand this simple case, it&#39;s
pretty clearly hopeless for borrowck to understand disjointness in general
container types like a tree, especially if distinct keys actually <em>do</em> map
to the same value.</p>

<p>In order to &quot;teach&quot; borrowck that what we&#39;re doing is ok, we need to drop down
to unsafe code. For instance, mutable slices expose a <code>split_at_mut</code> function
that consumes the slice and returns two mutable slices. One for everything to
the left of the index, and one for everything to the right. Intuitively we know
this is safe because the slices don&#39;t overlap, and therefore alias. However
the implementation requires some unsafety:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>split_at_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>mid</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> (<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>T</span>], <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>T</span>]) {
    <span class='kw'>let</span> <span class='ident'>len</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>len</span>();
    <span class='kw'>let</span> <span class='ident'>ptr</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>as_mut_ptr</span>();
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>mid</span> <span class='op'>&lt;=</span> <span class='ident'>len</span>);
    <span class='kw'>unsafe</span> {
        (<span class='ident'>from_raw_parts_mut</span>(<span class='ident'>ptr</span>, <span class='ident'>mid</span>),
         <span class='ident'>from_raw_parts_mut</span>(<span class='ident'>ptr</span>.<span class='ident'>offset</span>(<span class='ident'>mid</span> <span class='kw'>as</span> <span class='ident'>isize</span>), <span class='ident'>len</span> <span class='op'>-</span> <span class='ident'>mid</span>))
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20split_at_mut(%26mut%20self%2C%20mid%3A%20usize)%20-%3E%20(%26mut%20%5BT%5D%2C%20%26mut%20%5BT%5D)%20%7B%0A%20%20%20%20let%20len%20%3D%20self.len()%3B%0A%20%20%20%20let%20ptr%20%3D%20self.as_mut_ptr()%3B%0A%20%20%20%20assert!(mid%20%3C%3D%20len)%3B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20(from_raw_parts_mut(ptr%2C%20mid)%2C%0A%20%20%20%20%20%20%20%20%20from_raw_parts_mut(ptr.offset(mid%20as%20isize)%2C%20len%20-%20mid))%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>This is actually a bit subtle. So as to avoid ever making two <code>&amp;mut</code>&#39;s to the
same value, we explicitly construct brand-new slices through raw pointers.</p>

<p>However more subtle is how iterators that yield mutable references work.
The iterator trait is defined as follows:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Iterator</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span>;

    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Iterator%20%7B%0A%20%20%20%20type%20Item%3B%0A%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CSelf%3A%3AItem%3E%3B%0A%7D%0A%7D">Run</a></pre>

<p>Given this definition, Self::Item has <em>no</em> connection to <code>self</code>. This means that
we can call <code>next</code> several times in a row, and hold onto all the results
<em>concurrently</em>. This is perfectly fine for by-value iterators, which have
exactly these semantics. It&#39;s also actually fine for shared references, as they
admit arbitrarily many references to the same thing (although the iterator needs
to be a separate object from the thing being shared).</p>

<p>But mutable references make this a mess. At first glance, they might seem
completely incompatible with this API, as it would produce multiple mutable
references to the same object!</p>

<p>However it actually <em>does</em> work, exactly because iterators are one-shot objects.
Everything an IterMut yields will be yielded at most once, so we don&#39;t
actually ever yield multiple mutable references to the same piece of data.</p>

<p>Perhaps surprisingly, mutable iterators don&#39;t require unsafe code to be
implemented for many types!</p>

<p>For instance here&#39;s a singly linked list:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span><span class='op'>&gt;</span>;

<span class='kw'>struct</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>elem</span>: <span class='ident'>T</span>,
    <span class='ident'>next</span>: <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>LinkedList</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>head</span>: <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>);

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>LinkedList</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>iter_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='ident'>IterMut</span>(<span class='self'>self</span>.<span class='ident'>head</span>.<span class='ident'>as_mut</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>node</span><span class='op'>|</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='kw-2'>*</span><span class='kw-2'>*</span><span class='ident'>node</span>))
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span>;

    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>take</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>node</span><span class='op'>|</span> {
            <span class='self'>self</span>.<span class='number'>0</span> <span class='op'>=</span> <span class='ident'>node</span>.<span class='ident'>next</span>.<span class='ident'>as_mut</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>node</span><span class='op'>|</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='kw-2'>*</span><span class='kw-2'>*</span><span class='ident'>node</span>);
            <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>node</span>.<span class='ident'>elem</span>
        })
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%7D%0Atype%20Link%3CT%3E%20%3D%20Option%3CBox%3CNode%3CT%3E%3E%3E%3B%0A%0Astruct%20Node%3CT%3E%20%7B%0A%20%20%20%20elem%3A%20T%2C%0A%20%20%20%20next%3A%20Link%3CT%3E%2C%0A%7D%0A%0Apub%20struct%20LinkedList%3CT%3E%20%7B%0A%20%20%20%20head%3A%20Link%3CT%3E%2C%0A%7D%0A%0Apub%20struct%20IterMut%3C'a%2C%20T%3A%20'a%3E(Option%3C%26'a%20mut%20Node%3CT%3E%3E)%3B%0A%0Aimpl%3CT%3E%20LinkedList%3CT%3E%20%7B%0A%20%20%20%20fn%20iter_mut(%26mut%20self)%20-%3E%20IterMut%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20IterMut(self.head.as_mut().map(%7Cnode%7C%20%26mut%20**node))%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3C'a%2C%20T%3E%20Iterator%20for%20IterMut%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20%26'a%20mut%20T%3B%0A%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CSelf%3A%3AItem%3E%20%7B%0A%20%20%20%20%20%20%20%20self.0.take().map(%7Cnode%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20self.0%20%3D%20node.next.as_mut().map(%7Cnode%7C%20%26mut%20**node)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%26mut%20node.elem%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>Here&#39;s a mutable slice:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>mem</span>;

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span>[<span class='ident'>T</span>]);

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span>;

    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>slice</span> <span class='op'>=</span> <span class='ident'>mem</span>::<span class='ident'>replace</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='number'>0</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> []);
        <span class='kw'>if</span> <span class='ident'>slice</span>.<span class='ident'>is_empty</span>() { <span class='kw'>return</span> <span class='prelude-val'>None</span>; }

        <span class='kw'>let</span> (<span class='ident'>l</span>, <span class='ident'>r</span>) <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>split_at_mut</span>(<span class='number'>1</span>);
        <span class='self'>self</span>.<span class='number'>0</span> <span class='op'>=</span> <span class='ident'>r</span>;
        <span class='ident'>l</span>.<span class='ident'>get_mut</span>(<span class='number'>0</span>)
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>DoubleEndedIterator</span> <span class='kw'>for</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>next_back</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>slice</span> <span class='op'>=</span> <span class='ident'>mem</span>::<span class='ident'>replace</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='number'>0</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> []);
        <span class='kw'>if</span> <span class='ident'>slice</span>.<span class='ident'>is_empty</span>() { <span class='kw'>return</span> <span class='prelude-val'>None</span>; }

        <span class='kw'>let</span> <span class='ident'>new_len</span> <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>len</span>() <span class='op'>-</span> <span class='number'>1</span>;
        <span class='kw'>let</span> (<span class='ident'>l</span>, <span class='ident'>r</span>) <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>split_at_mut</span>(<span class='ident'>new_len</span>);
        <span class='self'>self</span>.<span class='number'>0</span> <span class='op'>=</span> <span class='ident'>l</span>;
        <span class='ident'>r</span>.<span class='ident'>get_mut</span>(<span class='number'>0</span>)
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%7D%0Ause%20std%3A%3Amem%3B%0A%0Apub%20struct%20IterMut%3C'a%2C%20T%3A%20'a%3E(%26'a%20mut%5BT%5D)%3B%0A%0Aimpl%3C'a%2C%20T%3E%20Iterator%20for%20IterMut%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20%26'a%20mut%20T%3B%0A%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CSelf%3A%3AItem%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20slice%20%3D%20mem%3A%3Areplace(%26mut%20self.0%2C%20%26mut%20%5B%5D)%3B%0A%20%20%20%20%20%20%20%20if%20slice.is_empty()%20%7B%20return%20None%3B%20%7D%0A%0A%20%20%20%20%20%20%20%20let%20(l%2C%20r)%20%3D%20slice.split_at_mut(1)%3B%0A%20%20%20%20%20%20%20%20self.0%20%3D%20r%3B%0A%20%20%20%20%20%20%20%20l.get_mut(0)%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3C'a%2C%20T%3E%20DoubleEndedIterator%20for%20IterMut%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20fn%20next_back(%26mut%20self)%20-%3E%20Option%3CSelf%3A%3AItem%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20slice%20%3D%20mem%3A%3Areplace(%26mut%20self.0%2C%20%26mut%20%5B%5D)%3B%0A%20%20%20%20%20%20%20%20if%20slice.is_empty()%20%7B%20return%20None%3B%20%7D%0A%0A%20%20%20%20%20%20%20%20let%20new_len%20%3D%20slice.len()%20-%201%3B%0A%20%20%20%20%20%20%20%20let%20(l%2C%20r)%20%3D%20slice.split_at_mut(new_len)%3B%0A%20%20%20%20%20%20%20%20self.0%20%3D%20l%3B%0A%20%20%20%20%20%20%20%20r.get_mut(0)%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>And here&#39;s a binary tree:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>VecDeque</span>;

<span class='kw'>type</span> <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span><span class='op'>&gt;</span>;

<span class='kw'>struct</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>elem</span>: <span class='ident'>T</span>,
    <span class='ident'>left</span>: <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
    <span class='ident'>right</span>: <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Tree</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>root</span>: <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>struct</span> <span class='ident'>NodeIterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>elem</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span><span class='op'>&gt;</span>,
    <span class='ident'>left</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>,
    <span class='ident'>right</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>,
}

<span class='kw'>enum</span> <span class='ident'>State</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>Elem</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span>),
    <span class='ident'>Node</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>),
}

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>VecDeque</span><span class='op'>&lt;</span><span class='ident'>NodeIterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;&gt;</span>);

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Tree</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>iter_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>deque</span> <span class='op'>=</span> <span class='ident'>VecDeque</span>::<span class='ident'>new</span>();
        <span class='self'>self</span>.<span class='ident'>root</span>.<span class='ident'>as_mut</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>root</span><span class='op'>|</span> <span class='ident'>deque</span>.<span class='ident'>push_front</span>(<span class='ident'>root</span>.<span class='ident'>iter_mut</span>()));
        <span class='ident'>IterMut</span>(<span class='ident'>deque</span>)
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>iter_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>NodeIterMut</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='ident'>NodeIterMut</span> {
            <span class='ident'>elem</span>: <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='ident'>elem</span>),
            <span class='ident'>left</span>: <span class='self'>self</span>.<span class='ident'>left</span>.<span class='ident'>as_mut</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>node</span><span class='op'>|</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='kw-2'>*</span><span class='kw-2'>*</span><span class='ident'>node</span>),
            <span class='ident'>right</span>: <span class='self'>self</span>.<span class='ident'>right</span>.<span class='ident'>as_mut</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>node</span><span class='op'>|</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='kw-2'>*</span><span class='kw-2'>*</span><span class='ident'>node</span>),
        }
    }
}


<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>NodeIterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='ident'>State</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span>;

    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>left</span>.<span class='ident'>take</span>() {
            <span class='prelude-val'>Some</span>(<span class='ident'>node</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)),
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>elem</span>.<span class='ident'>take</span>() {
                <span class='prelude-val'>Some</span>(<span class='ident'>elem</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Elem</span>(<span class='ident'>elem</span>)),
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>right</span>.<span class='ident'>take</span>() {
                    <span class='prelude-val'>Some</span>(<span class='ident'>node</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)),
                    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
                }
            }
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>DoubleEndedIterator</span> <span class='kw'>for</span> <span class='ident'>NodeIterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>next_back</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>right</span>.<span class='ident'>take</span>() {
            <span class='prelude-val'>Some</span>(<span class='ident'>node</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)),
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>elem</span>.<span class='ident'>take</span>() {
                <span class='prelude-val'>Some</span>(<span class='ident'>elem</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Elem</span>(<span class='ident'>elem</span>)),
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>left</span>.<span class='ident'>take</span>() {
                    <span class='prelude-val'>Some</span>(<span class='ident'>node</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)),
                    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
                }
            }
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span>;
    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>loop</span> {
            <span class='kw'>match</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>front_mut</span>().<span class='ident'>and_then</span>(<span class='op'>|</span><span class='ident'>node_it</span><span class='op'>|</span> <span class='ident'>node_it</span>.<span class='ident'>next</span>()) {
                <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Elem</span>(<span class='ident'>elem</span>)) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Some</span>(<span class='ident'>elem</span>),
                <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)) <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>push_front</span>(<span class='ident'>node</span>.<span class='ident'>iter_mut</span>()),
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>None</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>pop_front</span>() { <span class='kw'>return</span> <span class='prelude-val'>None</span> },
            }
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>DoubleEndedIterator</span> <span class='kw'>for</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>next_back</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>loop</span> {
            <span class='kw'>match</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>back_mut</span>().<span class='ident'>and_then</span>(<span class='op'>|</span><span class='ident'>node_it</span><span class='op'>|</span> <span class='ident'>node_it</span>.<span class='ident'>next_back</span>()) {
                <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Elem</span>(<span class='ident'>elem</span>)) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Some</span>(<span class='ident'>elem</span>),
                <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)) <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>push_back</span>(<span class='ident'>node</span>.<span class='ident'>iter_mut</span>()),
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>None</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>pop_back</span>() { <span class='kw'>return</span> <span class='prelude-val'>None</span> },
            }
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%7D%0Ause%20std%3A%3Acollections%3A%3AVecDeque%3B%0A%0Atype%20Link%3CT%3E%20%3D%20Option%3CBox%3CNode%3CT%3E%3E%3E%3B%0A%0Astruct%20Node%3CT%3E%20%7B%0A%20%20%20%20elem%3A%20T%2C%0A%20%20%20%20left%3A%20Link%3CT%3E%2C%0A%20%20%20%20right%3A%20Link%3CT%3E%2C%0A%7D%0A%0Apub%20struct%20Tree%3CT%3E%20%7B%0A%20%20%20%20root%3A%20Link%3CT%3E%2C%0A%7D%0A%0Astruct%20NodeIterMut%3C'a%2C%20T%3A%20'a%3E%20%7B%0A%20%20%20%20elem%3A%20Option%3C%26'a%20mut%20T%3E%2C%0A%20%20%20%20left%3A%20Option%3C%26'a%20mut%20Node%3CT%3E%3E%2C%0A%20%20%20%20right%3A%20Option%3C%26'a%20mut%20Node%3CT%3E%3E%2C%0A%7D%0A%0Aenum%20State%3C'a%2C%20T%3A%20'a%3E%20%7B%0A%20%20%20%20Elem(%26'a%20mut%20T)%2C%0A%20%20%20%20Node(%26'a%20mut%20Node%3CT%3E)%2C%0A%7D%0A%0Apub%20struct%20IterMut%3C'a%2C%20T%3A%20'a%3E(VecDeque%3CNodeIterMut%3C'a%2C%20T%3E%3E)%3B%0A%0Aimpl%3CT%3E%20Tree%3CT%3E%20%7B%0A%20%20%20%20pub%20fn%20iter_mut(%26mut%20self)%20-%3E%20IterMut%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20mut%20deque%20%3D%20VecDeque%3A%3Anew()%3B%0A%20%20%20%20%20%20%20%20self.root.as_mut().map(%7Croot%7C%20deque.push_front(root.iter_mut()))%3B%0A%20%20%20%20%20%20%20%20IterMut(deque)%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3CT%3E%20Node%3CT%3E%20%7B%0A%20%20%20%20pub%20fn%20iter_mut(%26mut%20self)%20-%3E%20NodeIterMut%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20NodeIterMut%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20elem%3A%20Some(%26mut%20self.elem)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20left%3A%20self.left.as_mut().map(%7Cnode%7C%20%26mut%20**node)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20right%3A%20self.right.as_mut().map(%7Cnode%7C%20%26mut%20**node)%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0A%0Aimpl%3C'a%2C%20T%3E%20Iterator%20for%20NodeIterMut%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20State%3C'a%2C%20T%3E%3B%0A%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CSelf%3A%3AItem%3E%20%7B%0A%20%20%20%20%20%20%20%20match%20self.left.take()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Some(node)%20%3D%3E%20Some(State%3A%3ANode(node))%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20match%20self.elem.take()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(elem)%20%3D%3E%20Some(State%3A%3AElem(elem))%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20match%20self.right.take()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(node)%20%3D%3E%20Some(State%3A%3ANode(node))%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20None%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3C'a%2C%20T%3E%20DoubleEndedIterator%20for%20NodeIterMut%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20fn%20next_back(%26mut%20self)%20-%3E%20Option%3CSelf%3A%3AItem%3E%20%7B%0A%20%20%20%20%20%20%20%20match%20self.right.take()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Some(node)%20%3D%3E%20Some(State%3A%3ANode(node))%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20match%20self.elem.take()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(elem)%20%3D%3E%20Some(State%3A%3AElem(elem))%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20match%20self.left.take()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(node)%20%3D%3E%20Some(State%3A%3ANode(node))%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20None%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3C'a%2C%20T%3E%20Iterator%20for%20IterMut%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20%26'a%20mut%20T%3B%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CSelf%3A%3AItem%3E%20%7B%0A%20%20%20%20%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20self.0.front_mut().and_then(%7Cnode_it%7C%20node_it.next())%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(State%3A%3AElem(elem))%20%3D%3E%20return%20Some(elem)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(State%3A%3ANode(node))%20%3D%3E%20self.0.push_front(node.iter_mut())%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20if%20let%20None%20%3D%20self.0.pop_front()%20%7B%20return%20None%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3C'a%2C%20T%3E%20DoubleEndedIterator%20for%20IterMut%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20fn%20next_back(%26mut%20self)%20-%3E%20Option%3CSelf%3A%3AItem%3E%20%7B%0A%20%20%20%20%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20self.0.back_mut().and_then(%7Cnode_it%7C%20node_it.next_back())%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(State%3A%3AElem(elem))%20%3D%3E%20return%20Some(elem)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(State%3A%3ANode(node))%20%3D%3E%20self.0.push_back(node.iter_mut())%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20if%20let%20None%20%3D%20self.0.pop_back()%20%7B%20return%20None%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>All of these are completely safe and work on stable Rust! This ultimately
falls out of the simple struct case we saw before: Rust understands that you
can safely split a mutable reference into subfields. We can then encode
permanently consuming a reference via Options (or in the case of slices,
replacing with an empty slice).</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>