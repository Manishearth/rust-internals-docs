<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Drain</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='meet-safe-and-unsafe.html'><b>2.</b> Meet Safe and Unsafe</a>
<ol class='section'>
<li><a  href='safe-unsafe-meaning.html'><b>2.1.</b> How Safe and Unsafe Interact</a>
</li>
<li><a  href='working-with-unsafe.html'><b>2.2.</b> Working with Unsafe</a>
</li>
</ol>
</li>
<li><a  href='data.html'><b>3.</b> Data Layout</a>
<ol class='section'>
<li><a  href='repr-rust.html'><b>3.1.</b> repr(Rust)</a>
</li>
<li><a  href='exotic-sizes.html'><b>3.2.</b> Exotically Sized Types</a>
</li>
<li><a  href='other-reprs.html'><b>3.3.</b> Other reprs</a>
</li>
</ol>
</li>
<li><a  href='ownership.html'><b>4.</b> Ownership</a>
<ol class='section'>
<li><a  href='references.html'><b>4.1.</b> References</a>
</li>
<li><a  href='lifetimes.html'><b>4.2.</b> Lifetimes</a>
</li>
<li><a  href='lifetime-mismatch.html'><b>4.3.</b> Limits of Lifetimes</a>
</li>
<li><a  href='lifetime-elision.html'><b>4.4.</b> Lifetime Elision</a>
</li>
<li><a  href='unbounded-lifetimes.html'><b>4.5.</b> Unbounded Lifetimes</a>
</li>
<li><a  href='hrtb.html'><b>4.6.</b> Higher-Rank Trait Bounds</a>
</li>
<li><a  href='subtyping.html'><b>4.7.</b> Subtyping and Variance</a>
</li>
<li><a  href='dropck.html'><b>4.8.</b> Drop Check</a>
</li>
<li><a  href='phantom-data.html'><b>4.9.</b> PhantomData</a>
</li>
<li><a  href='borrow-splitting.html'><b>4.10.</b> Splitting Borrows</a>
</li>
</ol>
</li>
<li><a  href='conversions.html'><b>5.</b> Type Conversions</a>
<ol class='section'>
<li><a  href='coercions.html'><b>5.1.</b> Coercions</a>
</li>
<li><a  href='dot-operator.html'><b>5.2.</b> The Dot Operator</a>
</li>
<li><a  href='casts.html'><b>5.3.</b> Casts</a>
</li>
<li><a  href='transmutes.html'><b>5.4.</b> Transmutes</a>
</li>
</ol>
</li>
<li><a  href='uninitialized.html'><b>6.</b> Uninitialized Memory</a>
<ol class='section'>
<li><a  href='checked-uninit.html'><b>6.1.</b> Checked</a>
</li>
<li><a  href='drop-flags.html'><b>6.2.</b> Drop Flags</a>
</li>
<li><a  href='unchecked-uninit.html'><b>6.3.</b> Unchecked</a>
</li>
</ol>
</li>
<li><a  href='obrm.html'><b>7.</b> Ownership Based Resource Management</a>
<ol class='section'>
<li><a  href='constructors.html'><b>7.1.</b> Constructors</a>
</li>
<li><a  href='destructors.html'><b>7.2.</b> Destructors</a>
</li>
<li><a  href='leaking.html'><b>7.3.</b> Leaking</a>
</li>
</ol>
</li>
<li><a  href='unwinding.html'><b>8.</b> Unwinding</a>
<ol class='section'>
<li><a  href='exception-safety.html'><b>8.1.</b> Exception Safety</a>
</li>
<li><a  href='poisoning.html'><b>8.2.</b> Poisoning</a>
</li>
</ol>
</li>
<li><a  href='concurrency.html'><b>9.</b> Concurrency</a>
<ol class='section'>
<li><a  href='races.html'><b>9.1.</b> Races</a>
</li>
<li><a  href='send-and-sync.html'><b>9.2.</b> Send and Sync</a>
</li>
<li><a  href='atomics.html'><b>9.3.</b> Atomics</a>
</li>
</ol>
</li>
<li><a  href='vec.html'><b>10.</b> Implementing Vec</a>
<ol class='section'>
<li><a  href='vec-layout.html'><b>10.1.</b> Layout</a>
</li>
<li><a  href='vec-alloc.html'><b>10.2.</b> Allocating</a>
</li>
<li><a  href='vec-push-pop.html'><b>10.3.</b> Push and Pop</a>
</li>
<li><a  href='vec-dealloc.html'><b>10.4.</b> Deallocating</a>
</li>
<li><a  href='vec-deref.html'><b>10.5.</b> Deref</a>
</li>
<li><a  href='vec-insert-remove.html'><b>10.6.</b> Insert and Remove</a>
</li>
<li><a  href='vec-into-iter.html'><b>10.7.</b> IntoIter</a>
</li>
<li><a  href='vec-raw.html'><b>10.8.</b> RawVec</a>
</li>
<li><a class='active' href='vec-drain.html'><b>10.9.</b> Drain</a>
</li>
<li><a  href='vec-zsts.html'><b>10.10.</b> Handling Zero-Sized Types</a>
</li>
<li><a  href='vec-final.html'><b>10.11.</b> Final Code</a>
</li>
</ol>
</li>
<li><a  href='arc-and-mutex.html'><b>11.</b> Implementing Arc and Mutex</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Drain</h1>
    <p>Let&#39;s move on to Drain. Drain is largely the same as IntoIter, except that
instead of consuming the Vec, it borrows the Vec and leaves its allocation
untouched. For now we&#39;ll only implement the &quot;basic&quot; full-range version.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>marker</span>::<span class='ident'>PhantomData</span>;

<span class='kw'>struct</span> <span class='ident'>Drain</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='comment'>// Need to bound the lifetime here, so we do it with `&amp;&#39;a mut Vec&lt;T&gt;`</span>
    <span class='comment'>// because that&#39;s semantically what we contain. We&#39;re &quot;just&quot; calling</span>
    <span class='comment'>// `pop()` and `remove(0)`.</span>
    <span class='ident'>vec</span>: <span class='ident'>PhantomData</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>
    <span class='ident'>start</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>T</span>,
    <span class='ident'>end</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>T</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>Drain</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='ident'>T</span>;
    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>start</span> <span class='op'>==</span> <span class='self'>self</span>.<span class='ident'>end</span> {
            <span class='prelude-val'>None</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Amarker%3A%3APhantomData%3B%0A%0Astruct%20Drain%3C'a%2C%20T%3A%20'a%3E%20%7B%0A%20%20%20%20%2F%2F%20Need%20to%20bound%20the%20lifetime%20here%2C%20so%20we%20do%20it%20with%20%60%26'a%20mut%20Vec%3CT%3E%60%0A%20%20%20%20%2F%2F%20because%20that's%20semantically%20what%20we%20contain.%20We're%20%22just%22%20calling%0A%20%20%20%20%2F%2F%20%60pop()%60%20and%20%60remove(0)%60.%0A%20%20%20%20vec%3A%20PhantomData%3C%26'a%20mut%20Vec%3CT%3E%3E%0A%20%20%20%20start%3A%20*const%20T%2C%0A%20%20%20%20end%3A%20*const%20T%2C%0A%7D%0A%0Aimpl%3C'a%2C%20T%3E%20Iterator%20for%20Drain%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20T%3B%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20self.start%20%3D%3D%20self.end%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20None%0A%7D">Run</a></pre>

<p>-- wait, this is seeming familiar. Let&#39;s do some more compression. Both
IntoIter and Drain have the exact same structure, let&#39;s just factor it out.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>RawValIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>start</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>T</span>,
    <span class='ident'>end</span>: <span class='kw-2'>*</span><span class='kw'>const</span> <span class='ident'>T</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>RawValIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='comment'>// unsafe to construct because it has no associated lifetimes.</span>
    <span class='comment'>// This is necessary to store a RawValIter in the same struct as</span>
    <span class='comment'>// its actual allocation. OK since it&#39;s a private implementation</span>
    <span class='comment'>// detail.</span>
    <span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>slice</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>]) <span class='op'>-&gt;</span> <span class='self'>Self</span> {
        <span class='ident'>RawValIter</span> {
            <span class='ident'>start</span>: <span class='ident'>slice</span>.<span class='ident'>as_ptr</span>(),
            <span class='ident'>end</span>: <span class='kw'>if</span> <span class='ident'>slice</span>.<span class='ident'>len</span>() <span class='op'>==</span> <span class='number'>0</span> {
                <span class='comment'>// if `len = 0`, then this is not actually allocated memory.</span>
                <span class='comment'>// Need to avoid offsetting because that will give wrong</span>
                <span class='comment'>// information to LLVM via GEP.</span>
                <span class='ident'>slice</span>.<span class='ident'>as_ptr</span>()
            } <span class='kw'>else</span> {
                <span class='ident'>slice</span>.<span class='ident'>as_ptr</span>().<span class='ident'>offset</span>(<span class='ident'>slice</span>.<span class='ident'>len</span>() <span class='kw'>as</span> <span class='ident'>isize</span>)
            }
        }
    }
}

<span class='comment'>// Iterator and DoubleEndedIterator impls identical to IntoIter.</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20RawValIter%3CT%3E%20%7B%0A%20%20%20%20start%3A%20*const%20T%2C%0A%20%20%20%20end%3A%20*const%20T%2C%0A%7D%0A%0Aimpl%3CT%3E%20RawValIter%3CT%3E%20%7B%0A%20%20%20%20%2F%2F%20unsafe%20to%20construct%20because%20it%20has%20no%20associated%20lifetimes.%0A%20%20%20%20%2F%2F%20This%20is%20necessary%20to%20store%20a%20RawValIter%20in%20the%20same%20struct%20as%0A%20%20%20%20%2F%2F%20its%20actual%20allocation.%20OK%20since%20it's%20a%20private%20implementation%0A%20%20%20%20%2F%2F%20detail.%0A%20%20%20%20unsafe%20fn%20new(slice%3A%20%26%5BT%5D)%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20RawValIter%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20start%3A%20slice.as_ptr()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20end%3A%20if%20slice.len()%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20if%20%60len%20%3D%200%60%2C%20then%20this%20is%20not%20actually%20allocated%20memory.%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20Need%20to%20avoid%20offsetting%20because%20that%20will%20give%20wrong%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20information%20to%20LLVM%20via%20GEP.%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20slice.as_ptr()%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20slice.as_ptr().offset(slice.len()%20as%20isize)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20Iterator%20and%20DoubleEndedIterator%20impls%20identical%20to%20IntoIter.%0A%7D">Run</a></pre>

<p>And IntoIter becomes the following:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>IntoIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>_buf</span>: <span class='ident'>RawVec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='comment'>// we don&#39;t actually care about this. Just need it to live.</span>
    <span class='ident'>iter</span>: <span class='ident'>RawValIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>IntoIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='ident'>T</span>;
    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='self'>self</span>.<span class='ident'>iter</span>.<span class='ident'>next</span>() }
    <span class='kw'>fn</span> <span class='ident'>size_hint</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> (<span class='ident'>usize</span>, <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span>) { <span class='self'>self</span>.<span class='ident'>iter</span>.<span class='ident'>size_hint</span>() }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>DoubleEndedIterator</span> <span class='kw'>for</span> <span class='ident'>IntoIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>next_back</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='self'>self</span>.<span class='ident'>iter</span>.<span class='ident'>next_back</span>() }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>IntoIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='ident'>iter</span> {}
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>into_iter</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>IntoIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='kw'>unsafe</span> {
            <span class='kw'>let</span> <span class='ident'>iter</span> <span class='op'>=</span> <span class='ident'>RawValIter</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);

            <span class='kw'>let</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='ident'>ptr</span>::<span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>buf</span>);
            <span class='ident'>mem</span>::<span class='ident'>forget</span>(<span class='self'>self</span>);

            <span class='ident'>IntoIter</span> {
                <span class='ident'>iter</span>: <span class='ident'>iter</span>,
                <span class='ident'>_buf</span>: <span class='ident'>buf</span>,
            }
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20struct%20IntoIter%3CT%3E%20%7B%0A%20%20%20%20_buf%3A%20RawVec%3CT%3E%2C%20%2F%2F%20we%20don't%20actually%20care%20about%20this.%20Just%20need%20it%20to%20live.%0A%20%20%20%20iter%3A%20RawValIter%3CT%3E%2C%0A%7D%0A%0Aimpl%3CT%3E%20Iterator%20for%20IntoIter%3CT%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20T%3B%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CT%3E%20%7B%20self.iter.next()%20%7D%0A%20%20%20%20fn%20size_hint(%26self)%20-%3E%20(usize%2C%20Option%3Cusize%3E)%20%7B%20self.iter.size_hint()%20%7D%0A%7D%0A%0Aimpl%3CT%3E%20DoubleEndedIterator%20for%20IntoIter%3CT%3E%20%7B%0A%20%20%20%20fn%20next_back(%26mut%20self)%20-%3E%20Option%3CT%3E%20%7B%20self.iter.next_back()%20%7D%0A%7D%0A%0Aimpl%3CT%3E%20Drop%20for%20IntoIter%3CT%3E%20%7B%0A%20%20%20%20fn%20drop(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20for%20_%20in%20%26mut%20self.iter%20%7B%7D%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3CT%3E%20Vec%3CT%3E%20%7B%0A%20%20%20%20pub%20fn%20into_iter(self)%20-%3E%20IntoIter%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20iter%20%3D%20RawValIter%3A%3Anew(%26self)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20buf%20%3D%20ptr%3A%3Aread(%26self.buf)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20mem%3A%3Aforget(self)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20IntoIter%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20iter%3A%20iter%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_buf%3A%20buf%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Note that I&#39;ve left a few quirks in this design to make upgrading Drain to work
with arbitrary subranges a bit easier. In particular we <em>could</em> have RawValIter
drain itself on drop, but that won&#39;t work right for a more complex Drain.
We also take a slice to simplify Drain initialization.</p>

<p>Alright, now Drain is really easy:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>marker</span>::<span class='ident'>PhantomData</span>;

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Drain</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>vec</span>: <span class='ident'>PhantomData</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>,
    <span class='ident'>iter</span>: <span class='ident'>RawValIter</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>Drain</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='ident'>T</span>;
    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='self'>self</span>.<span class='ident'>iter</span>.<span class='ident'>next</span>() }
    <span class='kw'>fn</span> <span class='ident'>size_hint</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> (<span class='ident'>usize</span>, <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span>) { <span class='self'>self</span>.<span class='ident'>iter</span>.<span class='ident'>size_hint</span>() }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>DoubleEndedIterator</span> <span class='kw'>for</span> <span class='ident'>Drain</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>next_back</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='self'>self</span>.<span class='ident'>iter</span>.<span class='ident'>next_back</span>() }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>Drain</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='ident'>iter</span> {}
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>drain</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Drain</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='kw'>unsafe</span> {
            <span class='kw'>let</span> <span class='ident'>iter</span> <span class='op'>=</span> <span class='ident'>RawValIter</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);

            <span class='comment'>// this is a mem::forget safety thing. If Drain is forgotten, we just</span>
            <span class='comment'>// leak the whole Vec&#39;s contents. Also we need to do this *eventually*</span>
            <span class='comment'>// anyway, so why not do it now?</span>
            <span class='self'>self</span>.<span class='ident'>len</span> <span class='op'>=</span> <span class='number'>0</span>;

            <span class='ident'>Drain</span> {
                <span class='ident'>iter</span>: <span class='ident'>iter</span>,
                <span class='ident'>vec</span>: <span class='ident'>PhantomData</span>,
            }
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Amarker%3A%3APhantomData%3B%0A%0Apub%20struct%20Drain%3C'a%2C%20T%3A%20'a%3E%20%7B%0A%20%20%20%20vec%3A%20PhantomData%3C%26'a%20mut%20Vec%3CT%3E%3E%2C%0A%20%20%20%20iter%3A%20RawValIter%3CT%3E%2C%0A%7D%0A%0Aimpl%3C'a%2C%20T%3E%20Iterator%20for%20Drain%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20T%3B%0A%20%20%20%20fn%20next(%26mut%20self)%20-%3E%20Option%3CT%3E%20%7B%20self.iter.next()%20%7D%0A%20%20%20%20fn%20size_hint(%26self)%20-%3E%20(usize%2C%20Option%3Cusize%3E)%20%7B%20self.iter.size_hint()%20%7D%0A%7D%0A%0Aimpl%3C'a%2C%20T%3E%20DoubleEndedIterator%20for%20Drain%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20fn%20next_back(%26mut%20self)%20-%3E%20Option%3CT%3E%20%7B%20self.iter.next_back()%20%7D%0A%7D%0A%0Aimpl%3C'a%2C%20T%3E%20Drop%20for%20Drain%3C'a%2C%20T%3E%20%7B%0A%20%20%20%20fn%20drop(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20for%20_%20in%20%26mut%20self.iter%20%7B%7D%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3CT%3E%20Vec%3CT%3E%20%7B%0A%20%20%20%20pub%20fn%20drain(%26mut%20self)%20-%3E%20Drain%3CT%3E%20%7B%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20iter%20%3D%20RawValIter%3A%3Anew(%26self)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20this%20is%20a%20mem%3A%3Aforget%20safety%20thing.%20If%20Drain%20is%20forgotten%2C%20we%20just%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20leak%20the%20whole%20Vec's%20contents.%20Also%20we%20need%20to%20do%20this%20*eventually*%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20anyway%2C%20so%20why%20not%20do%20it%20now%3F%0A%20%20%20%20%20%20%20%20%20%20%20%20self.len%20%3D%200%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20Drain%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20iter%3A%20iter%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20vec%3A%20PhantomData%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>For more details on the <code>mem::forget</code> problem, see the
<a href="leaking.html">section on leaks</a>.</p>

    <script src='rustbook.js'></script>
</div></div>


</body>
</html>