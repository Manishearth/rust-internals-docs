<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `DIAGNOSTICS` constant in crate `rustc_typeck`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, DIAGNOSTICS">

    <title>rustc_typeck::DIAGNOSTICS - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc constant">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../rustc_typeck/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='logo' width='100'></a>
        <p class='location'><a href='index.html'>rustc_typeck</a></p><script>window.sidebarCurrent = {name: 'DIAGNOSTICS', ty: 'constant', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Constant <a href='index.html'>rustc_typeck</a>::<wbr><a class="constant" href=''>DIAGNOSTICS</a></span><span class='out-of-band'><span class='since' title='Stable since Rust version '></span><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/rustc_typeck/lib.rs.html#352' title='goto source code'>[src]</a></span></h1>
<pre class='rust const'>pub const DIAGNOSTICS: <a class="primitive" href="../std/primitive.array.html">[</a><a class="primitive" href="../std/primitive.tuple.html">(</a>&amp;'static <a class="primitive" href="../std/primitive.str.html">str</a>, &amp;'static <a class="primitive" href="../std/primitive.str.html">str</a><a class="primitive" href="../std/primitive.tuple.html">)</a><a class="primitive" href="../std/primitive.array.html">; 143]</a><code> = </code><code>[(&quot;E0045&quot;,
  &quot;\nRust only supports variadic parameters for interoperability with C code in its\nFFI. As such, variadic parameters can only be used with functions which are\nusing the C ABI. Examples of erroneous code:\n\n```compile_fail\n#![feature(unboxed_closures)]\n\nextern \&quot;rust-call\&quot; { fn foo(x: u8, ...); }\n\n// or\n\nfn foo(x: u8, ...) {}\n```\n\nTo fix such code, put them in an extern \&quot;C\&quot; block:\n\n```\nextern \&quot;C\&quot; {\n    fn foo (x: u8, ...);\n}\n```\n&quot;),
 (&quot;E0131&quot;,
  &quot;\nIt is not possible to define `main` with type parameters, or even with function\nparameters. When `main` is present, it must take no arguments and return `()`.\nErroneous code example:\n\n```compile_fail,E0131\nfn main&lt;T&gt;() { // error: main function is not allowed to have type parameters\n}\n```\n&quot;),
 (&quot;E0132&quot;,
  &quot;\nA function with the `start` attribute was declared with type parameters.\n\nErroneous code example:\n\n```compile_fail,E0132\n#![feature(start)]\n\n#[start]\nfn f&lt;T&gt;() {}\n```\n\nIt is not possible to declare type parameters on a function that has the `start`\nattribute. Such a function must have the following type signature (for more\ninformation: http://doc.rust-lang.org/stable/book/first-edition/no-stdlib.html):\n\n```\n# let _:\nfn(isize, *const *const u8) -&gt; isize;\n```\n\nExample:\n\n```\n#![feature(start)]\n\n#[start]\nfn my_start(argc: isize, argv: *const *const u8) -&gt; isize {\n    0\n}\n```\n&quot;),
 (&quot;E0023&quot;,
  &quot;\nA pattern used to match against an enum variant must provide a sub-pattern for\neach field of the enum variant. This error indicates that a pattern attempted to\nextract an incorrect number of fields from a variant.\n\n```\nenum Fruit {\n    Apple(String, String),\n    Pear(u32),\n}\n```\n\nHere the `Apple` variant has two fields, and should be matched against like so:\n\n```\nenum Fruit {\n    Apple(String, String),\n    Pear(u32),\n}\n\nlet x = Fruit::Apple(String::new(), String::new());\n\n// Correct.\nmatch x {\n    Fruit::Apple(a, b) =&gt; {},\n    _ =&gt; {}\n}\n```\n\nMatching with the wrong number of fields has no sensible interpretation:\n\n```compile_fail,E0023\nenum Fruit {\n    Apple(String, String),\n    Pear(u32),\n}\n\nlet x = Fruit::Apple(String::new(), String::new());\n\n// Incorrect.\nmatch x {\n    Fruit::Apple(a) =&gt; {},\n    Fruit::Apple(a, b, c) =&gt; {},\n}\n```\n\nCheck how many fields the enum was declared with and ensure that your pattern\nuses the same number.\n&quot;),
 (&quot;E0025&quot;,
  &quot;\nEach field of a struct can only be bound once in a pattern. Erroneous code\nexample:\n\n```compile_fail,E0025\nstruct Foo {\n    a: u8,\n    b: u8,\n}\n\nfn main(){\n    let x = Foo { a:1, b:2 };\n\n    let Foo { a: x, a: y } = x;\n    // error: field `a` bound multiple times in the pattern\n}\n```\n\nEach occurrence of a field name binds the value of that field, so to fix this\nerror you will have to remove or alter the duplicate uses of the field name.\nPerhaps you misspelled another field name? Example:\n\n```\nstruct Foo {\n    a: u8,\n    b: u8,\n}\n\nfn main(){\n    let x = Foo { a:1, b:2 };\n\n    let Foo { a: x, b: y } = x; // ok!\n}\n```\n&quot;),
 (&quot;E0026&quot;,
  &quot;\nThis error indicates that a struct pattern attempted to extract a non-existent\nfield from a struct. Struct fields are identified by the name used before the\ncolon `:` so struct patterns should resemble the declaration of the struct type\nbeing matched.\n\n```\n// Correct matching.\nstruct Thing {\n    x: u32,\n    y: u32\n}\n\nlet thing = Thing { x: 1, y: 2 };\n\nmatch thing {\n    Thing { x: xfield, y: yfield } =&gt; {}\n}\n```\n\nIf you are using shorthand field patterns but want to refer to the struct field\nby a different name, you should rename it explicitly.\n\nChange this:\n\n```compile_fail,E0026\nstruct Thing {\n    x: u32,\n    y: u32\n}\n\nlet thing = Thing { x: 0, y: 0 };\n\nmatch thing {\n    Thing { x, z } =&gt; {}\n}\n```\n\nTo this:\n\n```\nstruct Thing {\n    x: u32,\n    y: u32\n}\n\nlet thing = Thing { x: 0, y: 0 };\n\nmatch thing {\n    Thing { x, y: z } =&gt; {}\n}\n```\n&quot;),
 (&quot;E0027&quot;,
  &quot;\nThis error indicates that a pattern for a struct fails to specify a sub-pattern\nfor every one of the struct\&#39;s fields. Ensure that each field from the struct\&#39;s\ndefinition is mentioned in the pattern, or use `..` to ignore unwanted fields.\n\nFor example:\n\n```compile_fail,E0027\nstruct Dog {\n    name: String,\n    age: u32,\n}\n\nlet d = Dog { name: \&quot;Rusty\&quot;.to_string(), age: 8 };\n\n// This is incorrect.\nmatch d {\n    Dog { age: x } =&gt; {}\n}\n```\n\nThis is correct (explicit):\n\n```\nstruct Dog {\n    name: String,\n    age: u32,\n}\n\nlet d = Dog { name: \&quot;Rusty\&quot;.to_string(), age: 8 };\n\nmatch d {\n    Dog { name: ref n, age: x } =&gt; {}\n}\n\n// This is also correct (ignore unused fields).\nmatch d {\n    Dog { age: x, .. } =&gt; {}\n}\n```\n&quot;),
 (&quot;E0029&quot;,
  &quot;\nIn a match expression, only numbers and characters can be matched against a\nrange. This is because the compiler checks that the range is non-empty at\ncompile-time, and is unable to evaluate arbitrary comparison functions. If you\nwant to capture values of an orderable type between two end-points, you can use\na guard.\n\n```compile_fail,E0029\nlet string = \&quot;salutations !\&quot;;\n\n// The ordering relation for strings can\&#39;t be evaluated at compile time,\n// so this doesn\&#39;t work:\nmatch string {\n    \&quot;hello\&quot; ... \&quot;world\&quot; =&gt; {}\n    _ =&gt; {}\n}\n\n// This is a more general version, using a guard:\nmatch string {\n    s if s &gt;= \&quot;hello\&quot; &amp;&amp; s &lt;= \&quot;world\&quot; =&gt; {}\n    _ =&gt; {}\n}\n```\n&quot;),
 (&quot;E0033&quot;,
  &quot;\nThis error indicates that a pointer to a trait type cannot be implicitly\ndereferenced by a pattern. Every trait defines a type, but because the\nsize of trait implementors isn\&#39;t fixed, this type has no compile-time size.\nTherefore, all accesses to trait types must be through pointers. If you\nencounter this error you should try to avoid dereferencing the pointer.\n\n```compile_fail,E0033\n# trait SomeTrait { fn method_one(&amp;self){} fn method_two(&amp;self){} }\n# impl&lt;T&gt; SomeTrait for T {}\nlet trait_obj: &amp;SomeTrait = &amp;\&quot;some_value\&quot;;\n\n// This tries to implicitly dereference to create an unsized local variable.\nlet &amp;invalid = trait_obj;\n\n// You can call methods without binding to the value being pointed at.\ntrait_obj.method_one();\ntrait_obj.method_two();\n```\n\nYou can read more about trait objects in the [Trait Objects] section of the\nReference.\n\n[Trait Objects]: https://doc.rust-lang.org/reference/types.html#trait-objects\n&quot;),
 (&quot;E0034&quot;,
  &quot;\nThe compiler doesn\&#39;t know what method to call because more than one method\nhas the same prototype. Erroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let\&#39;s take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that\&#39;s good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    &lt;Test as Trait1&gt;::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&amp;self);\n}\n\ntrait G {\n    fn m(&amp;self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&amp;self) { println!(\&quot;I am F\&quot;); } }\nimpl G for X { fn m(&amp;self) { println!(\&quot;I am G\&quot;); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&amp;f); // it displays \&quot;I am F\&quot;\n    G::m(&amp;f); // it displays \&quot;I am G\&quot;\n}\n```\n&quot;),
 (&quot;E0040&quot;,
  &quot;\nIt is not allowed to manually call destructors in Rust. It is also not\nnecessary to do this since `drop` is called automatically whenever a value goes\nout of scope.\n\nHere\&#39;s an example of this error:\n\n```compile_fail,E0040\nstruct Foo {\n    x: i32,\n}\n\nimpl Drop for Foo {\n    fn drop(&amp;mut self) {\n        println!(\&quot;kaboom\&quot;);\n    }\n}\n\nfn main() {\n    let mut x = Foo { x: -7 };\n    x.drop(); // error: explicit use of destructor method\n}\n```\n&quot;),
 (&quot;E0044&quot;,
  &quot;\nYou can\&#39;t use type parameters on foreign items. Example of erroneous code:\n\n```compile_fail,E0044\nextern { fn some_func&lt;T&gt;(x: T); }\n```\n\nTo fix this, replace the type parameter with the specializations that you\nneed:\n\n```\nextern { fn some_func_i32(x: i32); }\nextern { fn some_func_i64(x: i64); }\n```\n&quot;),
 (&quot;E0046&quot;,
  &quot;\nItems are missing in a trait implementation. Erroneous code example:\n\n```compile_fail,E0046\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {}\n// error: not all trait items implemented, missing: `foo`\n```\n\nWhen trying to make some type implement a trait `Foo`, you must, at minimum,\nprovide implementations for all of `Foo`\&#39;s required methods (meaning the\nmethods that do not have default implementations), as well as any required\ntrait items like associated types or constants. Example:\n\n```\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn foo() {} // ok!\n}\n```\n&quot;),
 (&quot;E0049&quot;,
  &quot;\nThis error indicates that an attempted implementation of a trait method\nhas the wrong number of type parameters.\n\nFor example, the trait below has a method `foo` with a type parameter `T`,\nbut the implementation of `foo` for the type `Bar` is missing this parameter:\n\n```compile_fail,E0049\ntrait Foo {\n    fn foo&lt;T: Default&gt;(x: T) -&gt; Self;\n}\n\nstruct Bar;\n\n// error: method `foo` has 0 type parameters but its trait declaration has 1\n// type parameter\nimpl Foo for Bar {\n    fn foo(x: bool) -&gt; Self { Bar }\n}\n```\n&quot;),
 (&quot;E0050&quot;,
  &quot;\nThis error indicates that an attempted implementation of a trait method\nhas the wrong number of function parameters.\n\nFor example, the trait below has a method `foo` with two function parameters\n(`&amp;self` and `u8`), but the implementation of `foo` for the type `Bar` omits\nthe `u8` parameter:\n\n```compile_fail,E0050\ntrait Foo {\n    fn foo(&amp;self, x: u8) -&gt; bool;\n}\n\nstruct Bar;\n\n// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`\n// has 2\nimpl Foo for Bar {\n    fn foo(&amp;self) -&gt; bool { true }\n}\n```\n&quot;),
 (&quot;E0053&quot;,
  &quot;\nThe parameters of any trait method must match between a trait implementation\nand the trait definition.\n\nHere are a couple examples of this error:\n\n```compile_fail,E0053\ntrait Foo {\n    fn foo(x: u16);\n    fn bar(&amp;self);\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    // error, expected u16, found i16\n    fn foo(x: i16) { }\n\n    // error, types differ in mutability\n    fn bar(&amp;mut self) { }\n}\n```\n&quot;),
 (&quot;E0054&quot;,
  &quot;\nIt is not allowed to cast to a bool. If you are trying to cast a numeric type\nto a bool, you can compare it with zero instead:\n\n```compile_fail,E0054\nlet x = 5;\n\n// Not allowed, won\&#39;t compile\nlet x_is_nonzero = x as bool;\n```\n\n```\nlet x = 5;\n\n// Ok\nlet x_is_nonzero = x != 0;\n```\n&quot;),
 (&quot;E0055&quot;,
  &quot;\nDuring a method call, a value is automatically dereferenced as many times as\nneeded to make the value\&#39;s type match the method\&#39;s receiver. The catch is that\nthe compiler will only attempt to dereference a number of times up to the\nrecursion limit (which can be set via the `recursion_limit` attribute).\n\nFor a somewhat artificial example:\n\n```compile_fail,E0055\n#![recursion_limit=\&quot;2\&quot;]\n\nstruct Foo;\n\nimpl Foo {\n    fn foo(&amp;self) {}\n}\n\nfn main() {\n    let foo = Foo;\n    let ref_foo = &amp;&amp;Foo;\n\n    // error, reached the recursion limit while auto-dereferencing &amp;&amp;Foo\n    ref_foo.foo();\n}\n```\n\nOne fix may be to increase the recursion limit. Note that it is possible to\ncreate an infinite recursion of dereferencing, in which case the only fix is to\nsomehow break the recursion.\n&quot;),
 (&quot;E0057&quot;,
  &quot;\nWhen invoking closures or other implementations of the function traits `Fn`,\n`FnMut` or `FnOnce` using call notation, the number of parameters passed to the\nfunction must match its definition.\n\nAn example using a closure:\n\n```compile_fail,E0057\nlet f = |x| x * 3;\nlet a = f();        // invalid, too few parameters\nlet b = f(4);       // this works!\nlet c = f(2, 3);    // invalid, too many parameters\n```\n\nA generic function must be treated similarly:\n\n```\nfn foo&lt;F: Fn()&gt;(f: F) {\n    f(); // this is valid, but f(3) would not work\n}\n```\n&quot;),
 (&quot;E0059&quot;,
  &quot;\nThe built-in function traits are generic over a tuple of the function arguments.\nIf one uses angle-bracket notation (`Fn&lt;(T,), Output=U&gt;`) instead of parentheses\n(`Fn(T) -&gt; U`) to denote the function trait, the type parameter should be a\ntuple. Otherwise function call notation cannot be used and the trait will not be\nimplemented by closures.\n\nThe most likely source of this error is using angle-bracket notation without\nwrapping the function argument type into a tuple, for example:\n\n```compile_fail,E0059\n#![feature(unboxed_closures)]\n\nfn foo&lt;F: Fn&lt;i32&gt;&gt;(f: F) -&gt; F::Output { f(3) }\n```\n\nIt can be fixed by adjusting the trait bound like this:\n\n```\n#![feature(unboxed_closures)]\n\nfn foo&lt;F: Fn&lt;(i32,)&gt;&gt;(f: F) -&gt; F::Output { f(3) }\n```\n\nNote that `(T,)` always denotes the type of a 1-tuple containing an element of\ntype `T`. The comma is necessary for syntactic disambiguation.\n&quot;),
 (&quot;E0060&quot;,
  &quot;\nExternal C functions are allowed to be variadic. However, a variadic function\ntakes a minimum number of arguments. For example, consider C\&#39;s variadic `printf`\nfunction:\n\n```\nuse std::os::raw::{c_char, c_int};\n\nextern \&quot;C\&quot; {\n    fn printf(_: *const c_char, ...) -&gt; c_int;\n}\n```\n\nUsing this declaration, it must be called with at least one argument, so\nsimply calling `printf()` is invalid. But the following uses are allowed:\n\n```\n# #![feature(static_nobundle)]\n# use std::os::raw::{c_char, c_int};\n# #[cfg_attr(all(windows, target_env = \&quot;msvc\&quot;),\n#            link(name = \&quot;legacy_stdio_definitions\&quot;, kind = \&quot;static-nobundle\&quot;))]\n# extern \&quot;C\&quot; { fn printf(_: *const c_char, ...) -&gt; c_int; }\n# fn main() {\nunsafe {\n    use std::ffi::CString;\n\n    let fmt = CString::new(\&quot;test\\n\&quot;).unwrap();\n    printf(fmt.as_ptr());\n\n    let fmt = CString::new(\&quot;number = %d\\n\&quot;).unwrap();\n    printf(fmt.as_ptr(), 3);\n\n    let fmt = CString::new(\&quot;%d, %d\\n\&quot;).unwrap();\n    printf(fmt.as_ptr(), 10, 5);\n}\n# }\n```\n&quot;),
 (&quot;E0061&quot;,
  &quot;\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &amp;str) {}\n```\n\nMust always be called with exactly two arguments, e.g. `f(2, \&quot;test\&quot;)`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n&quot;),
 (&quot;E0062&quot;,
  &quot;\nThis error indicates that during an attempt to build a struct or struct-like\nenum variant, one of the fields was specified more than once. Erroneous code\nexample:\n\n```compile_fail,E0062\nstruct Foo {\n    x: i32,\n}\n\nfn main() {\n    let x = Foo {\n                x: 0,\n                x: 0, // error: field `x` specified more than once\n            };\n}\n```\n\nEach field should be specified exactly one time. Example:\n\n```\nstruct Foo {\n    x: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0 }; // ok!\n}\n```\n&quot;),
 (&quot;E0063&quot;,
  &quot;\nThis error indicates that during an attempt to build a struct or struct-like\nenum variant, one of the fields was not provided. Erroneous code example:\n\n```compile_fail,E0063\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0 }; // error: missing field: `y`\n}\n```\n\nEach field should be specified exactly once. Example:\n\n```\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0, y: 0 }; // ok!\n}\n```\n&quot;),
 (&quot;E0066&quot;,
  &quot;\nBox placement expressions (like C++\&#39;s \&quot;placement new\&quot;) do not yet support any\nplace expression except the exchange heap (i.e. `std::boxed::HEAP`).\nFurthermore, the syntax is changing to use `in` instead of `box`. See [RFC 470]\nand [RFC 809] for more details.\n\n[RFC 470]: https://github.com/rust-lang/rfcs/pull/470\n[RFC 809]: https://github.com/rust-lang/rfcs/blob/master/text/0809-box-and-in-for-stdlib.md\n&quot;),
 (&quot;E0067&quot;,
  &quot;\nThe left-hand side of a compound assignment expression must be an lvalue\nexpression. An lvalue expression represents a memory location and includes\nitem paths (ie, namespaced variables), dereferences, indexing expressions,\nand field references.\n\nLet\&#39;s start with some erroneous code examples:\n\n```compile_fail,E0067\nuse std::collections::LinkedList;\n\n// Bad: assignment to non-lvalue expression\nLinkedList::new() += 1;\n\n// ...\n\nfn some_func(i: &amp;mut i32) {\n    i += 12; // Error : \&#39;+=\&#39; operation cannot be applied on a reference !\n}\n```\n\nAnd now some working examples:\n\n```\nlet mut i : i32 = 0;\n\ni += 12; // Good !\n\n// ...\n\nfn some_func(i: &amp;mut i32) {\n    *i += 12; // Good !\n}\n```\n&quot;),
 (&quot;E0069&quot;,
  &quot;\nThe compiler found a function whose body contains a `return;` statement but\nwhose return type is not `()`. An example of this is:\n\n```compile_fail,E0069\n// error\nfn foo() -&gt; u8 {\n    return;\n}\n```\n\nSince `return;` is just like `return ();`, there is a mismatch between the\nfunction\&#39;s return type and the value being returned.\n&quot;),
 (&quot;E0070&quot;,
  &quot;\nThe left-hand side of an assignment operator must be an lvalue expression. An\nlvalue expression represents a memory location and can be a variable (with\noptional namespacing), a dereference, an indexing expression or a field\nreference.\n\nMore details can be found in the [Expressions] section of the Reference.\n\n[Expressions]: https://doc.rust-lang.org/reference/expressions.html#lvalues-rvalues-and-temporaries\n\nNow, we can go further. Here are some erroneous code examples:\n\n```compile_fail,E0070\nstruct SomeStruct {\n    x: i32,\n    y: i32\n}\n\nconst SOME_CONST : i32 = 12;\n\nfn some_other_func() {}\n\nfn some_function() {\n    SOME_CONST = 14; // error : a constant value cannot be changed!\n    1 = 3; // error : 1 isn\&#39;t a valid lvalue!\n    some_other_func() = 4; // error : we can\&#39;t assign value to a function!\n    SomeStruct.x = 12; // error : SomeStruct a structure name but it is used\n                       // like a variable!\n}\n```\n\nAnd now let\&#39;s give working examples:\n\n```\nstruct SomeStruct {\n    x: i32,\n    y: i32\n}\nlet mut s = SomeStruct {x: 0, y: 0};\n\ns.x = 3; // that\&#39;s good !\n\n// ...\n\nfn some_func(x: &amp;mut i32) {\n    *x = 12; // that\&#39;s good !\n}\n```\n&quot;),
 (&quot;E0071&quot;,
  &quot;\nYou tried to use structure-literal syntax to create an item that is\nnot a structure or enum variant.\n\nExample of erroneous code:\n\n```compile_fail,E0071\ntype U32 = u32;\nlet t = U32 { value: 4 }; // error: expected struct, variant or union type,\n                          // found builtin type `u32`\n```\n\nTo fix this, ensure that the name was correctly spelled, and that\nthe correct form of initializer was used.\n\nFor example, the code above can be fixed to:\n\n```\nenum Foo {\n    FirstValue(i32)\n}\n\nfn main() {\n    let u = Foo::FirstValue(0i32);\n\n    let t = 4;\n}\n```\n&quot;),
 (&quot;E0073&quot;,
  &quot;\n#### Note: this error code is no longer emitted by the compiler.\n\nYou cannot define a struct (or enum) `Foo` that requires an instance of `Foo`\nin order to make a new `Foo` value. This is because there would be no way a\nfirst instance of `Foo` could be made to initialize another instance!\n\nHere\&#39;s an example of a struct that has this problem:\n\n```\nstruct Foo { x: Box&lt;Foo&gt; } // error\n```\n\nOne fix is to use `Option`, like so:\n\n```\nstruct Foo { x: Option&lt;Box&lt;Foo&gt;&gt; }\n```\n\nNow it\&#39;s possible to create at least one instance of `Foo`: `Foo { x: None }`.\n&quot;),
 (&quot;E0074&quot;,
  &quot;\n#### Note: this error code is no longer emitted by the compiler.\n\nWhen using the `#[simd]` attribute on a tuple struct, the components of the\ntuple struct must all be of a concrete, nongeneric type so the compiler can\nreason about how to use SIMD with them. This error will occur if the types\nare generic.\n\nThis will cause an error:\n\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Bad&lt;T&gt;(T, T, T);\n```\n\nThis will not:\n\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Good(u32, u32, u32);\n```\n&quot;),
 (&quot;E0075&quot;,
  &quot;\nThe `#[simd]` attribute can only be applied to non empty tuple structs, because\nit doesn\&#39;t make sense to try to use SIMD operations when there are no values to\noperate on.\n\nThis will cause an error:\n\n```compile_fail,E0075\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Bad;\n```\n\nThis will not:\n\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Good(u32);\n```\n&quot;),
 (&quot;E0076&quot;,
  &quot;\nWhen using the `#[simd]` attribute to automatically use SIMD operations in tuple\nstruct, the types in the struct must all be of the same type, or the compiler\nwill trigger this error.\n\nThis will cause an error:\n\n```compile_fail,E0076\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Bad(u16, u32, u32);\n```\n\nThis will not:\n\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Good(u32, u32, u32);\n```\n&quot;),
 (&quot;E0077&quot;,
  &quot;\nWhen using the `#[simd]` attribute on a tuple struct, the elements in the tuple\nmust be machine types so SIMD operations can be applied to them.\n\nThis will cause an error:\n\n```compile_fail,E0077\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Bad(String);\n```\n\nThis will not:\n\n```\n#![feature(repr_simd)]\n\n#[repr(simd)]\nstruct Good(u32, u32, u32);\n```\n&quot;),
 (&quot;E0081&quot;,
  &quot;\nEnum discriminants are used to differentiate enum variants stored in memory.\nThis error indicates that the same value was used for two or more variants,\nmaking them impossible to tell apart.\n\n```compile_fail,E0081\n// Bad.\nenum Enum {\n    P = 3,\n    X = 3,\n    Y = 5,\n}\n```\n\n```\n// Good.\nenum Enum {\n    P,\n    X = 3,\n    Y = 5,\n}\n```\n\nNote that variants without a manually specified discriminant are numbered from\ntop to bottom starting from 0, so clashes can occur with seemingly unrelated\nvariants.\n\n```compile_fail,E0081\nenum Bad {\n    X,\n    Y = 0\n}\n```\n\nHere `X` will have already been specified the discriminant 0 by the time `Y` is\nencountered, so a conflict occurs.\n&quot;),
 (&quot;E0082&quot;,
  &quot;\n#### Note: this error code is no longer emitted by the compiler.\n\nWhen you specify enum discriminants with `=`, the compiler expects `isize`\nvalues by default. Or you can add the `repr` attibute to the enum declaration\nfor an explicit choice of the discriminant type. In either cases, the\ndiscriminant values must fall within a valid range for the expected type;\notherwise this error is raised. For example:\n\n```compile_fail\n# #![deny(overflowing_literals)]\n#[repr(u8)]\nenum Thing {\n    A = 1024,\n    B = 5,\n}\n```\n\nHere, 1024 lies outside the valid range for `u8`, so the discriminant for `A` is\ninvalid. Here is another, more subtle example which depends on target word size:\n\n```compile_fail,E0080\n# #[repr(i32)]\nenum DependsOnPointerSize {\n    A = 1 &lt;&lt; 32,\n}\n```\n\nHere, `1 &lt;&lt; 32` is interpreted as an `isize` value. So it is invalid for 32 bit\ntarget (`target_pointer_width = \&quot;32\&quot;`) but valid for 64 bit target.\n\nYou may want to change representation types to fix this, or else change invalid\ndiscriminant values so that they fit within the existing type.\n&quot;),
 (&quot;E0084&quot;,
  &quot;\nAn unsupported representation was attempted on a zero-variant enum.\n\nErroneous code example:\n\n```compile_fail,E0084\n#[repr(i32)]\nenum NightsWatch {} // error: unsupported representation for zero-variant enum\n```\n\nIt is impossible to define an integer type to be used to represent zero-variant\nenum values because there are no zero-variant enum values. There is no way to\nconstruct an instance of the following type using only safe code. So you have\ntwo solutions. Either you add variants in your enum:\n\n```\n#[repr(i32)]\nenum NightsWatch {\n    JonSnow,\n    Commander,\n}\n```\n\nor you remove the integer represention of your enum:\n\n```\nenum NightsWatch {}\n```\n&quot;),
 (&quot;E0087&quot;,
  &quot;\nToo many type parameters were supplied for a function. For example:\n\n```compile_fail,E0087\nfn foo&lt;T&gt;() {}\n\nfn main() {\n    foo::&lt;f64, bool&gt;(); // error, expected 1 parameter, found 2 parameters\n}\n```\n\nThe number of supplied parameters must exactly match the number of defined type\nparameters.\n&quot;),
 (&quot;E0088&quot;,
  &quot;\nYou gave too many lifetime parameters. Erroneous code example:\n\n```compile_fail,E0088\nfn f() {}\n\nfn main() {\n    f::&lt;\&#39;static&gt;() // error: too many lifetime parameters provided\n}\n```\n\nPlease check you give the right number of lifetime parameters. Example:\n\n```\nfn f() {}\n\nfn main() {\n    f() // ok!\n}\n```\n\nIt\&#39;s also important to note that the Rust compiler can generally\ndetermine the lifetime by itself. Example:\n\n```\nstruct Foo {\n    value: String\n}\n\nimpl Foo {\n    // it can be written like this\n    fn get_value&lt;\&#39;a&gt;(&amp;\&#39;a self) -&gt; &amp;\&#39;a str { &amp;self.value }\n    // but the compiler works fine with this too:\n    fn without_lifetime(&amp;self) -&gt; &amp;str { &amp;self.value }\n}\n\nfn main() {\n    let f = Foo { value: \&quot;hello\&quot;.to_owned() };\n\n    println!(\&quot;{}\&quot;, f.get_value());\n    println!(\&quot;{}\&quot;, f.without_lifetime());\n}\n```\n&quot;),
 (&quot;E0089&quot;,
  &quot;\nNot enough type parameters were supplied for a function. For example:\n\n```compile_fail,E0089\nfn foo&lt;T, U&gt;() {}\n\nfn main() {\n    foo::&lt;f64&gt;(); // error, expected 2 parameters, found 1 parameter\n}\n```\n\nNote that if a function takes multiple type parameters but you want the compiler\nto infer some of them, you can use type placeholders:\n\n```compile_fail,E0089\nfn foo&lt;T, U&gt;(x: T) {}\n\nfn main() {\n    let x: bool = true;\n    foo::&lt;f64&gt;(x);    // error, expected 2 parameters, found 1 parameter\n    foo::&lt;_, f64&gt;(x); // same as `foo::&lt;bool, f64&gt;(x)`\n}\n```\n&quot;),
 (&quot;E0090&quot;,
  &quot;\nYou gave too few lifetime parameters. Example:\n\n```compile_fail,E0090\nfn foo&lt;\&#39;a: \&#39;b, \&#39;b: \&#39;a&gt;() {}\n\nfn main() {\n    foo::&lt;\&#39;static&gt;(); // error, expected 2 lifetime parameters\n}\n```\n\nPlease check you give the right number of lifetime parameters. Example:\n\n```\nfn foo&lt;\&#39;a: \&#39;b, \&#39;b: \&#39;a&gt;() {}\n\nfn main() {\n    foo::&lt;\&#39;static, \&#39;static&gt;();\n}\n```\n&quot;),
 (&quot;E0091&quot;,
  &quot;\nYou gave an unnecessary type parameter in a type alias. Erroneous code\nexample:\n\n```compile_fail,E0091\ntype Foo&lt;T&gt; = u32; // error: type parameter `T` is unused\n// or:\ntype Foo&lt;A,B&gt; = Box&lt;A&gt;; // error: type parameter `B` is unused\n```\n\nPlease check you didn\&#39;t write too many type parameters. Example:\n\n```\ntype Foo = u32; // ok!\ntype Foo2&lt;A&gt; = Box&lt;A&gt;; // ok!\n```\n&quot;),
 (&quot;E0092&quot;,
  &quot;\nYou tried to declare an undefined atomic operation function.\nErroneous code example:\n\n```compile_fail,E0092\n#![feature(intrinsics)]\n\nextern \&quot;rust-intrinsic\&quot; {\n    fn atomic_foo(); // error: unrecognized atomic operation\n                     //        function\n}\n```\n\nPlease check you didn\&#39;t make a mistake in the function\&#39;s name. All intrinsic\nfunctions are defined in librustc_trans/trans/intrinsic.rs and in\nlibcore/intrinsics.rs in the Rust source code. Example:\n\n```\n#![feature(intrinsics)]\n\nextern \&quot;rust-intrinsic\&quot; {\n    fn atomic_fence(); // ok!\n}\n```\n&quot;),
 (&quot;E0093&quot;,
  &quot;\nYou declared an unknown intrinsic function. Erroneous code example:\n\n```compile_fail,E0093\n#![feature(intrinsics)]\n\nextern \&quot;rust-intrinsic\&quot; {\n    fn foo(); // error: unrecognized intrinsic function: `foo`\n}\n\nfn main() {\n    unsafe {\n        foo();\n    }\n}\n```\n\nPlease check you didn\&#39;t make a mistake in the function\&#39;s name. All intrinsic\nfunctions are defined in librustc_trans/trans/intrinsic.rs and in\nlibcore/intrinsics.rs in the Rust source code. Example:\n\n```\n#![feature(intrinsics)]\n\nextern \&quot;rust-intrinsic\&quot; {\n    fn atomic_fence(); // ok!\n}\n\nfn main() {\n    unsafe {\n        atomic_fence();\n    }\n}\n```\n&quot;),
 (&quot;E0094&quot;,
  &quot;\nYou gave an invalid number of type parameters to an intrinsic function.\nErroneous code example:\n\n```compile_fail,E0094\n#![feature(intrinsics)]\n\nextern \&quot;rust-intrinsic\&quot; {\n    fn size_of&lt;T, U&gt;() -&gt; usize; // error: intrinsic has wrong number\n                                 //        of type parameters\n}\n```\n\nPlease check that you provided the right number of type parameters\nand verify with the function declaration in the Rust source code.\nExample:\n\n```\n#![feature(intrinsics)]\n\nextern \&quot;rust-intrinsic\&quot; {\n    fn size_of&lt;T&gt;() -&gt; usize; // ok!\n}\n```\n&quot;),
 (&quot;E0107&quot;,
  &quot;\nThis error means that an incorrect number of lifetime parameters were provided\nfor a type (like a struct or enum) or trait:\n\n```compile_fail,E0107\nstruct Foo&lt;\&#39;a, \&#39;b&gt;(&amp;\&#39;a str, &amp;\&#39;b str);\nenum Bar { A, B, C }\n\nstruct Baz&lt;\&#39;a&gt; {\n    foo: Foo&lt;\&#39;a&gt;, // error: expected 2, found 1\n    bar: Bar&lt;\&#39;a&gt;, // error: expected 0, found 1\n}\n```\n&quot;),
 (&quot;E0109&quot;,
  &quot;\nYou tried to give a type parameter to a type which doesn\&#39;t need it. Erroneous\ncode example:\n\n```compile_fail,E0109\ntype X = u32&lt;i32&gt;; // error: type parameters are not allowed on this type\n```\n\nPlease check that you used the correct type and recheck its definition. Perhaps\nit doesn\&#39;t need the type parameter.\n\nExample:\n\n```\ntype X = u32; // this compiles\n```\n\nNote that type parameters for enum-variant constructors go after the variant,\nnot after the enum (`Option::None::&lt;u32&gt;`, not `Option::&lt;u32&gt;::None`).\n&quot;),
 (&quot;E0110&quot;,
  &quot;\nYou tried to give a lifetime parameter to a type which doesn\&#39;t need it.\nErroneous code example:\n\n```compile_fail,E0110\ntype X = u32&lt;\&#39;static&gt;; // error: lifetime parameters are not allowed on\n                       //        this type\n```\n\nPlease check that the correct type was used and recheck its definition; perhaps\nit doesn\&#39;t need the lifetime parameter. Example:\n\n```\ntype X = u32; // ok!\n```\n&quot;),
 (&quot;E0116&quot;,
  &quot;\nYou can only define an inherent implementation for a type in the same crate\nwhere the type was defined. For example, an `impl` block as below is not allowed\nsince `Vec` is defined in the standard library:\n\n```compile_fail,E0116\nimpl Vec&lt;u8&gt; { } // error\n```\n\nTo fix this problem, you can do either of these things:\n\n - define a trait that has the desired associated functions/types/constants and\n   implement the trait for the type in question\n - define a new type wrapping the type and define an implementation on the new\n   type\n\nNote that using the `type` keyword does not work here because `type` only\nintroduces a type alias:\n\n```compile_fail,E0116\ntype Bytes = Vec&lt;u8&gt;;\n\nimpl Bytes { } // error, same as above\n```\n&quot;),
 (&quot;E0117&quot;,
  &quot;\nThis error indicates a violation of one of Rust\&#39;s orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nHere\&#39;s one example of this error:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&amp;mut self) { }\n}\n\nimpl From&lt;Foo&gt; for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -&gt; i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&amp;self) -&gt; usize;\n}\n\nimpl Bar for u32 {\n    fn get(&amp;self) -&gt; usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n&quot;),
 (&quot;E0118&quot;,
  &quot;\nYou\&#39;re trying to write an inherent implementation for something which isn\&#39;t a\nstruct nor an enum. Erroneous code example:\n\n```compile_fail,E0118\nimpl (u8, u8) { // error: no base type found for inherent implementation\n    fn get_state(&amp;self) -&gt; String {\n        // ...\n    }\n}\n```\n\nTo fix this error, please implement a trait on the type or wrap it in a struct.\nExample:\n\n```\n// we create a trait here\ntrait LiveLongAndProsper {\n    fn get_state(&amp;self) -&gt; String;\n}\n\n// and now you can implement it on (u8, u8)\nimpl LiveLongAndProsper for (u8, u8) {\n    fn get_state(&amp;self) -&gt; String {\n        \&quot;He\&#39;s dead, Jim!\&quot;.to_owned()\n    }\n}\n```\n\nAlternatively, you can create a newtype. A newtype is a wrapping tuple-struct.\nFor example, `NewType` is a newtype over `Foo` in `struct NewType(Foo)`.\nExample:\n\n```\nstruct TypeWrapper((u8, u8));\n\nimpl TypeWrapper {\n    fn get_state(&amp;self) -&gt; String {\n        \&quot;Fascinating!\&quot;.to_owned()\n    }\n}\n```\n&quot;),
 (&quot;E0120&quot;,
  &quot;\nAn attempt was made to implement Drop on a trait, which is not allowed: only\nstructs and enums can implement Drop. An example causing this error:\n\n```compile_fail,E0120\ntrait MyTrait {}\n\nimpl Drop for MyTrait {\n    fn drop(&amp;mut self) {}\n}\n```\n\nA workaround for this problem is to wrap the trait up in a struct, and implement\nDrop on that. An example is shown below:\n\n```\ntrait MyTrait {}\nstruct MyWrapper&lt;T: MyTrait&gt; { foo: T }\n\nimpl &lt;T: MyTrait&gt; Drop for MyWrapper&lt;T&gt; {\n    fn drop(&amp;mut self) {}\n}\n\n```\n\nAlternatively, wrapping trait objects requires something like the following:\n\n```\ntrait MyTrait {}\n\n//or Box&lt;MyTrait&gt;, if you wanted an owned trait object\nstruct MyWrapper&lt;\&#39;a&gt; { foo: &amp;\&#39;a MyTrait }\n\nimpl &lt;\&#39;a&gt; Drop for MyWrapper&lt;\&#39;a&gt; {\n    fn drop(&amp;mut self) {}\n}\n```\n&quot;),
 (&quot;E0121&quot;,
  &quot;\nIn order to be consistent with Rust\&#39;s lack of global type inference, type\nplaceholders are disallowed by design in item signatures.\n\nExamples of this error include:\n\n```compile_fail,E0121\nfn foo() -&gt; _ { 5 } // error, explicitly write out the return type instead\n\nstatic BAR: _ = \&quot;test\&quot;; // error, explicitly write out the type instead\n```\n&quot;),
 (&quot;E0122&quot;,
  &quot;\nAn attempt was made to add a generic constraint to a type alias. This constraint\nis entirely ignored. For backwards compatibility, Rust still allows this with a\nwarning. Consider the example below:\n\n```\ntrait Foo{}\n\ntype MyType&lt;R: Foo&gt; = (R, ());\n\nfn main() {\n    let t: MyType&lt;u32&gt;;\n}\n```\n\nWe\&#39;re able to declare a variable of type `MyType&lt;u32&gt;`, despite the fact that\n`u32` does not implement `Foo`. As a result, one should avoid using generic\nconstraints in concert with type aliases.\n&quot;),
 (&quot;E0124&quot;,
  &quot;\nYou declared two fields of a struct with the same name. Erroneous code\nexample:\n\n```compile_fail,E0124\nstruct Foo {\n    field1: i32,\n    field1: i32, // error: field is already declared\n}\n```\n\nPlease verify that the field names have been correctly spelled. Example:\n\n```\nstruct Foo {\n    field1: i32,\n    field2: i32, // ok!\n}\n```\n&quot;),
 (&quot;E0164&quot;,
  &quot;\nThis error means that an attempt was made to match a struct type enum\nvariant as a non-struct type:\n\n```compile_fail,E0164\nenum Foo { B { i: u32 } }\n\nfn bar(foo: Foo) -&gt; u32 {\n    match foo {\n        Foo::B(i) =&gt; i, // error E0164\n    }\n}\n```\n\nTry using `{}` instead:\n\n```\nenum Foo { B { i: u32 } }\n\nfn bar(foo: Foo) -&gt; u32 {\n    match foo {\n        Foo::B{i} =&gt; i,\n    }\n}\n```\n&quot;),
 (&quot;E0184&quot;,
  &quot;\nExplicitly implementing both Drop and Copy for a type is currently disallowed.\nThis feature can make some sense in theory, but the current implementation is\nincorrect and can lead to memory unsafety (see [issue #20126][iss20126]), so\nit has been disabled for now.\n\n[iss20126]: https://github.com/rust-lang/rust/issues/20126\n&quot;),
 (&quot;E0185&quot;,
  &quot;\nAn associated function for a trait was defined to be static, but an\nimplementation of the trait declared the same function to be a method (i.e. to\ntake a `self` parameter).\n\nHere\&#39;s an example of this error:\n\n```compile_fail,E0185\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    // error, method `foo` has a `&amp;self` declaration in the impl, but not in\n    // the trait\n    fn foo(&amp;self) {}\n}\n```\n&quot;),
 (&quot;E0186&quot;,
  &quot;\nAn associated function for a trait was defined to be a method (i.e. to take a\n`self` parameter), but an implementation of the trait declared the same function\nto be static.\n\nHere\&#39;s an example of this error:\n\n```compile_fail,E0186\ntrait Foo {\n    fn foo(&amp;self);\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    // error, method `foo` has a `&amp;self` declaration in the trait, but not in\n    // the impl\n    fn foo() {}\n}\n```\n&quot;),
 (&quot;E0191&quot;,
  &quot;\nTrait objects need to have all associated types specified. Erroneous code\nexample:\n\n```compile_fail,E0191\ntrait Trait {\n    type Bar;\n}\n\ntype Foo = Trait; // error: the value of the associated type `Bar` (from\n                  //        the trait `Trait`) must be specified\n```\n\nPlease verify you specified all associated types of the trait and that you\nused the right trait. Example:\n\n```\ntrait Trait {\n    type Bar;\n}\n\ntype Foo = Trait&lt;Bar=i32&gt;; // ok!\n```\n&quot;),
 (&quot;E0192&quot;,
  &quot;\nNegative impls are only allowed for traits with default impls. For more\ninformation see the [opt-in builtin traits RFC][RFC 19].\n\n[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md\n&quot;),
 (&quot;E0193&quot;,
  &quot;\n#### Note: this error code is no longer emitted by the compiler.\n\n`where` clauses must use generic type parameters: it does not make sense to use\nthem otherwise. An example causing this error:\n\n```\ntrait Foo {\n    fn bar(&amp;self);\n}\n\n#[derive(Copy,Clone)]\nstruct Wrapper&lt;T&gt; {\n    Wrapped: T\n}\n\nimpl Foo for Wrapper&lt;u32&gt; where Wrapper&lt;u32&gt;: Clone {\n    fn bar(&amp;self) { }\n}\n```\n\nThis use of a `where` clause is strange - a more common usage would look\nsomething like the following:\n\n```\ntrait Foo {\n    fn bar(&amp;self);\n}\n\n#[derive(Copy,Clone)]\nstruct Wrapper&lt;T&gt; {\n    Wrapped: T\n}\nimpl &lt;T&gt; Foo for Wrapper&lt;T&gt; where Wrapper&lt;T&gt;: Clone {\n    fn bar(&amp;self) { }\n}\n```\n\nHere, we\&#39;re saying that the implementation exists on Wrapper only when the\nwrapped type `T` implements `Clone`. The `where` clause is important because\nsome types will not implement `Clone`, and thus will not get this method.\n\nIn our erroneous example, however, we\&#39;re referencing a single concrete type.\nSince we know for certain that `Wrapper&lt;u32&gt;` implements `Clone`, there\&#39;s no\nreason to also specify it in a `where` clause.\n&quot;),
 (&quot;E0194&quot;,
  &quot;\nA type parameter was declared which shadows an existing one. An example of this\nerror:\n\n```compile_fail,E0194\ntrait Foo&lt;T&gt; {\n    fn do_something(&amp;self) -&gt; T;\n    fn do_something_else&lt;T: Clone&gt;(&amp;self, bar: T);\n}\n```\n\nIn this example, the trait `Foo` and the trait method `do_something_else` both\ndefine a type parameter `T`. This is not allowed: if the method wishes to\ndefine a type parameter, it must use a different name for it.\n&quot;),
 (&quot;E0195&quot;,
  &quot;\nYour method\&#39;s lifetime parameters do not match the trait declaration.\nErroneous code example:\n\n```compile_fail,E0195\ntrait Trait {\n    fn bar&lt;\&#39;a,\&#39;b:\&#39;a&gt;(x: &amp;\&#39;a str, y: &amp;\&#39;b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn bar&lt;\&#39;a,\&#39;b&gt;(x: &amp;\&#39;a str, y: &amp;\&#39;b str) {\n    // error: lifetime parameters or bounds on method `bar`\n    // do not match the trait declaration\n    }\n}\n```\n\nThe lifetime constraint `\&#39;b` for bar() implementation does not match the\ntrait declaration. Ensure lifetime declarations match exactly in both trait\ndeclaration and implementation. Example:\n\n```\ntrait Trait {\n    fn t&lt;\&#39;a,\&#39;b:\&#39;a&gt;(x: &amp;\&#39;a str, y: &amp;\&#39;b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn t&lt;\&#39;a,\&#39;b:\&#39;a&gt;(x: &amp;\&#39;a str, y: &amp;\&#39;b str) { // ok!\n    }\n}\n```\n&quot;),
 (&quot;E0197&quot;,
  &quot;\nInherent implementations (one that do not implement a trait but provide\nmethods associated with a type) are always safe because they are not\nimplementing an unsafe trait. Removing the `unsafe` keyword from the inherent\nimplementation will resolve this error.\n\n```compile_fail,E0197\nstruct Foo;\n\n// this will cause this error\nunsafe impl Foo { }\n// converting it to this will fix it\nimpl Foo { }\n```\n&quot;),
 (&quot;E0198&quot;,
  &quot;\nA negative implementation is one that excludes a type from implementing a\nparticular trait. Not being able to use a trait is always a safe operation,\nso negative implementations are always safe and never need to be marked as\nunsafe.\n\n```compile_fail\n#![feature(optin_builtin_traits)]\n\nstruct Foo;\n\n// unsafe is unnecessary\nunsafe impl !Clone for Foo { }\n```\n\nThis will compile:\n\n```\n#![feature(optin_builtin_traits)]\n\nstruct Foo;\n\ntrait Enterprise {}\n\nimpl Enterprise for .. { }\n\nimpl !Enterprise for Foo { }\n```\n\nPlease note that negative impls are only allowed for traits with default impls.\n&quot;),
 (&quot;E0199&quot;,
  &quot;\nSafe traits should not have unsafe implementations, therefore marking an\nimplementation for a safe trait unsafe will cause a compiler error. Removing\nthe unsafe marker on the trait noted in the error will resolve this problem.\n\n```compile_fail,E0199\nstruct Foo;\n\ntrait Bar { }\n\n// this won\&#39;t compile because Bar is safe\nunsafe impl Bar for Foo { }\n// this will compile\nimpl Bar for Foo { }\n```\n&quot;),
 (&quot;E0200&quot;,
  &quot;\nUnsafe traits must have unsafe implementations. This error occurs when an\nimplementation for an unsafe trait isn\&#39;t marked as unsafe. This may be resolved\nby marking the unsafe implementation as unsafe.\n\n```compile_fail,E0200\nstruct Foo;\n\nunsafe trait Bar { }\n\n// this won\&#39;t compile because Bar is unsafe and impl isn\&#39;t unsafe\nimpl Bar for Foo { }\n// this will compile\nunsafe impl Bar for Foo { }\n```\n&quot;),
 (&quot;E0201&quot;,
  &quot;\nIt is an error to define two associated items (like methods, associated types,\nassociated functions, etc.) with the same identifier.\n\nFor example:\n\n```compile_fail,E0201\nstruct Foo(u8);\n\nimpl Foo {\n    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }\n    fn bar() {} // error: duplicate associated function\n}\n\ntrait Baz {\n    type Quux;\n    fn baz(&amp;self) -&gt; bool;\n}\n\nimpl Baz for Foo {\n    type Quux = u32;\n\n    fn baz(&amp;self) -&gt; bool { true }\n\n    // error: duplicate method\n    fn baz(&amp;self) -&gt; bool { self.0 &gt; 5 }\n\n    // error: duplicate associated type\n    type Quux = u32;\n}\n```\n\nNote, however, that items with the same name are allowed for inherent `impl`\nblocks that don\&#39;t overlap:\n\n```\nstruct Foo&lt;T&gt;(T);\n\nimpl Foo&lt;u8&gt; {\n    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }\n}\n\nimpl Foo&lt;bool&gt; {\n    fn bar(&amp;self) -&gt; bool { self.0 }\n}\n```\n&quot;),
 (&quot;E0202&quot;,
  &quot;\nInherent associated types were part of [RFC 195] but are not yet implemented.\nSee [the tracking issue][iss8995] for the status of this implementation.\n\n[RFC 195]: https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md\n[iss8995]: https://github.com/rust-lang/rust/issues/8995\n&quot;),
 (&quot;E0204&quot;,
  &quot;\nAn attempt to implement the `Copy` trait for a struct failed because one of the\nfields does not implement `Copy`. To fix this, you must implement `Copy` for the\nmentioned field. Note that this may not be possible, as in the example of\n\n```compile_fail,E0204\nstruct Foo {\n    foo : Vec&lt;u32&gt;,\n}\n\nimpl Copy for Foo { }\n```\n\nThis fails because `Vec&lt;T&gt;` does not implement `Copy` for any `T`.\n\nHere\&#39;s another example that will fail:\n\n```compile_fail,E0204\n#[derive(Copy)]\nstruct Foo&lt;\&#39;a&gt; {\n    ty: &amp;\&#39;a mut bool,\n}\n```\n\nThis fails because `&amp;mut T` is not `Copy`, even when `T` is `Copy` (this\ndiffers from the behavior for `&amp;T`, which is always `Copy`).\n&quot;),
 (&quot;E0206&quot;,
  &quot;\nYou can only implement `Copy` for a struct or enum. Both of the following\nexamples will fail, because neither `i32` (primitive type) nor `&amp;\&#39;static Bar`\n(reference to `Bar`) is a struct or enum:\n\n```compile_fail,E0206\ntype Foo = i32;\nimpl Copy for Foo { } // error\n\n#[derive(Copy, Clone)]\nstruct Bar;\nimpl Copy for &amp;\&#39;static Bar { } // error\n```\n&quot;),
 (&quot;E0207&quot;,
  &quot;\nAny type parameter or lifetime parameter of an `impl` must meet at least one of\nthe following criteria:\n\n - it appears in the self type of the impl\n - for a trait impl, it appears in the trait reference\n - it is bound as an associated type\n\n### Error example 1\n\nSuppose we have a struct `Foo` and we would like to define some methods for it.\nThe following definition leads to a compiler error:\n\n```compile_fail,E0207\nstruct Foo;\n\nimpl&lt;T: Default&gt; Foo {\n// error: the type parameter `T` is not constrained by the impl trait, self\n// type, or predicates [E0207]\n    fn get(&amp;self) -&gt; T {\n        &lt;T as Default&gt;::default()\n    }\n}\n```\n\nThe problem is that the parameter `T` does not appear in the self type (`Foo`)\nof the impl. In this case, we can fix the error by moving the type parameter\nfrom the `impl` to the method `get`:\n\n\n```\nstruct Foo;\n\n// Move the type parameter from the impl to the method\nimpl Foo {\n    fn get&lt;T: Default&gt;(&amp;self) -&gt; T {\n        &lt;T as Default&gt;::default()\n    }\n}\n```\n\n### Error example 2\n\nAs another example, suppose we have a `Maker` trait and want to establish a\ntype `FooMaker` that makes `Foo`s:\n\n```compile_fail,E0207\ntrait Maker {\n    type Item;\n    fn make(&amp;mut self) -&gt; Self::Item;\n}\n\nstruct Foo&lt;T&gt; {\n    foo: T\n}\n\nstruct FooMaker;\n\nimpl&lt;T: Default&gt; Maker for FooMaker {\n// error: the type parameter `T` is not constrained by the impl trait, self\n// type, or predicates [E0207]\n    type Item = Foo&lt;T&gt;;\n\n    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {\n        Foo { foo: &lt;T as Default&gt;::default() }\n    }\n}\n```\n\nThis fails to compile because `T` does not appear in the trait or in the\nimplementing type.\n\nOne way to work around this is to introduce a phantom type parameter into\n`FooMaker`, like so:\n\n```\nuse std::marker::PhantomData;\n\ntrait Maker {\n    type Item;\n    fn make(&amp;mut self) -&gt; Self::Item;\n}\n\nstruct Foo&lt;T&gt; {\n    foo: T\n}\n\n// Add a type parameter to `FooMaker`\nstruct FooMaker&lt;T&gt; {\n    phantom: PhantomData&lt;T&gt;,\n}\n\nimpl&lt;T: Default&gt; Maker for FooMaker&lt;T&gt; {\n    type Item = Foo&lt;T&gt;;\n\n    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {\n        Foo {\n            foo: &lt;T as Default&gt;::default(),\n        }\n    }\n}\n```\n\nAnother way is to do away with the associated type in `Maker` and use an input\ntype parameter instead:\n\n```\n// Use a type parameter instead of an associated type here\ntrait Maker&lt;Item&gt; {\n    fn make(&amp;mut self) -&gt; Item;\n}\n\nstruct Foo&lt;T&gt; {\n    foo: T\n}\n\nstruct FooMaker;\n\nimpl&lt;T: Default&gt; Maker&lt;Foo&lt;T&gt;&gt; for FooMaker {\n    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {\n        Foo { foo: &lt;T as Default&gt;::default() }\n    }\n}\n```\n\n### Additional information\n\nFor more information, please see [RFC 447].\n\n[RFC 447]: https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md\n&quot;),
 (&quot;E0210&quot;,
  &quot;\nThis error indicates a violation of one of Rust\&#39;s orphan rules for trait\nimplementations. The rule concerns the use of type parameters in an\nimplementation of a foreign trait (a trait defined in another crate), and\nstates that type parameters must be \&quot;covered\&quot; by a local type. To understand\nwhat this means, it is perhaps easiest to consider a few examples.\n\nIf `ForeignTrait` is a trait defined in some external crate `foo`, then the\nfollowing trait `impl` is an error:\n\n```compile_fail,E0210\n# #[cfg(for_demonstration_only)]\nextern crate foo;\n# #[cfg(for_demonstration_only)]\nuse foo::ForeignTrait;\n# use std::panic::UnwindSafe as ForeignTrait;\n\nimpl&lt;T&gt; ForeignTrait for T { } // error\n# fn main() {}\n```\n\nTo work around this, it can be covered with a local type, `MyType`:\n\n```\n# use std::panic::UnwindSafe as ForeignTrait;\nstruct MyType&lt;T&gt;(T);\nimpl&lt;T&gt; ForeignTrait for MyType&lt;T&gt; { } // Ok\n```\n\nPlease note that a type alias is not sufficient.\n\nFor another example of an error, suppose there\&#39;s another trait defined in `foo`\nnamed `ForeignTrait2` that takes two type parameters. Then this `impl` results\nin the same rule violation:\n\n```ignore (cannot-doctest-multicrate-project)\nstruct MyType2;\nimpl&lt;T&gt; ForeignTrait2&lt;T, MyType&lt;T&gt;&gt; for MyType2 { } // error\n```\n\nThe reason for this is that there are two appearances of type parameter `T` in\nthe `impl` header, both as parameters for `ForeignTrait2`. The first appearance\nis uncovered, and so runs afoul of the orphan rule.\n\nConsider one more example:\n\n```ignore (cannot-doctest-multicrate-project)\nimpl&lt;T&gt; ForeignTrait2&lt;MyType&lt;T&gt;, T&gt; for MyType2 { } // Ok\n```\n\nThis only differs from the previous `impl` in that the parameters `T` and\n`MyType&lt;T&gt;` for `ForeignTrait2` have been swapped. This example does *not*\nviolate the orphan rule; it is permitted.\n\nTo see why that last example was allowed, you need to understand the general\nrule. Unfortunately this rule is a bit tricky to state. Consider an `impl`:\n\n```ignore (only-for-syntax-highlight)\nimpl&lt;P1, ..., Pm&gt; ForeignTrait&lt;T1, ..., Tn&gt; for T0 { ... }\n```\n\nwhere `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\nare types. One of the types `T0, ..., Tn` must be a local type (this is another\norphan rule, see the explanation for E0117). Let `i` be the smallest integer\nsuch that `Ti` is a local type. Then no type parameter can appear in any of the\n`Tj` for `j &lt; i`.\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n&quot;),
 (&quot;E0220&quot;,
  &quot;\nYou used an associated type which isn\&#39;t defined in the trait.\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1&lt;F=i32&gt;; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&amp;self, _: &amp;Self::Bar, _: &amp;Self::Baz) -&gt; bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn\&#39;t misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1&lt;Bar=i32&gt;; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&amp;self, _: &amp;Self::Bar, _: &amp;Self::Baz) -&gt; bool;\n}\n```\n&quot;),
 (&quot;E0221&quot;,
  &quot;\nAn attempt was made to retrieve an associated type, but the type was ambiguous.\nFor example:\n\n```compile_fail,E0221\ntrait T1 {}\ntrait T2 {}\n\ntrait Foo {\n    type A: T1;\n}\n\ntrait Bar : Foo {\n    type A: T2;\n    fn do_something() {\n        let _: Self::A;\n    }\n}\n```\n\nIn this example, `Foo` defines an associated type `A`. `Bar` inherits that type\nfrom `Foo`, and defines another associated type of the same name. As a result,\nwhen we attempt to use `Self::A`, it\&#39;s ambiguous whether we mean the `A` defined\nby `Foo` or the one defined by `Bar`.\n\nThere are two options to work around this issue. The first is simply to rename\none of the types. Alternatively, one can specify the intended type using the\nfollowing syntax:\n\n```\ntrait T1 {}\ntrait T2 {}\n\ntrait Foo {\n    type A: T1;\n}\n\ntrait Bar : Foo {\n    type A: T2;\n    fn do_something() {\n        let _: &lt;Self as Bar&gt;::A;\n    }\n}\n```\n&quot;),
 (&quot;E0223&quot;,
  &quot;\nAn attempt was made to retrieve an associated type, but the type was ambiguous.\nFor example:\n\n```compile_fail,E0223\ntrait MyTrait {type X; }\n\nfn main() {\n    let foo: MyTrait::X;\n}\n```\n\nThe problem here is that we\&#39;re attempting to take the type of X from MyTrait.\nUnfortunately, the type of X is not defined, because it\&#39;s only made concrete in\nimplementations of the trait. A working version of this code might look like:\n\n```\ntrait MyTrait {type X; }\nstruct MyStruct;\n\nimpl MyTrait for MyStruct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: &lt;MyStruct as MyTrait&gt;::X;\n}\n```\n\nThis syntax specifies that we want the X type from MyTrait, as made concrete in\nMyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\nmight implement two different traits with identically-named associated types.\nThis syntax allows disambiguation between the two.\n&quot;),
 (&quot;E0225&quot;,
  &quot;\nYou attempted to use multiple types as bounds for a closure or trait object.\nRust does not currently support this. A simple example that causes this error:\n\n```compile_fail,E0225\nfn main() {\n    let _: Box&lt;std::io::Read + std::io::Write&gt;;\n}\n```\n\nSend and Sync are an exception to this rule: it\&#39;s possible to have bounds of\none non-builtin trait, plus either or both of Send and Sync. For example, the\nfollowing compiles correctly:\n\n```\nfn main() {\n    let _: Box&lt;std::io::Read + Send + Sync&gt;;\n}\n```\n&quot;),
 (&quot;E0229&quot;,
  &quot;\nAn associated type binding was done outside of the type parameter declaration\nand `where` clause. Erroneous code example:\n\n```compile_fail,E0229\npub trait Foo {\n    type A;\n    fn boo(&amp;self) -&gt; &lt;Self as Foo&gt;::A;\n}\n\nstruct Bar;\n\nimpl Foo for isize {\n    type A = usize;\n    fn boo(&amp;self) -&gt; usize { 42 }\n}\n\nfn baz&lt;I&gt;(x: &amp;&lt;I as Foo&lt;A=Bar&gt;&gt;::A) {}\n// error: associated type bindings are not allowed here\n```\n\nTo solve this error, please move the type bindings in the type parameter\ndeclaration:\n\n```\n# struct Bar;\n# trait Foo { type A; }\nfn baz&lt;I: Foo&lt;A=Bar&gt;&gt;(x: &amp;&lt;I as Foo&gt;::A) {} // ok!\n```\n\nOr in the `where` clause:\n\n```\n# struct Bar;\n# trait Foo { type A; }\nfn baz&lt;I&gt;(x: &amp;&lt;I as Foo&gt;::A) where I: Foo&lt;A=Bar&gt; {}\n```\n&quot;),
 (&quot;E0243&quot;,
  &quot;\nThis error indicates that not enough type parameters were found in a type or\ntrait.\n\nFor example, the `Foo` struct below is defined to be generic in `T`, but the\ntype parameter is missing in the definition of `Bar`:\n\n```compile_fail,E0243\nstruct Foo&lt;T&gt; { x: T }\n\nstruct Bar { x: Foo }\n```\n&quot;),
 (&quot;E0244&quot;,
  &quot;\nThis error indicates that too many type parameters were found in a type or\ntrait.\n\nFor example, the `Foo` struct below has no type parameters, but is supplied\nwith two in the definition of `Bar`:\n\n```compile_fail,E0244\nstruct Foo { x: bool }\n\nstruct Bar&lt;S, T&gt; { x: Foo&lt;S, T&gt; }\n```\n&quot;),
 (&quot;E0318&quot;,
  &quot;\nDefault impls for a trait must be located in the same crate where the trait was\ndefined. For more information see the [opt-in builtin traits RFC][RFC 19].\n\n[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md\n&quot;),
 (&quot;E0321&quot;,
  &quot;\nA cross-crate opt-out trait was implemented on something which wasn\&#39;t a struct\nor enum type. Erroneous code example:\n\n```compile_fail,E0321\n#![feature(optin_builtin_traits)]\n\nstruct Foo;\n\nimpl !Sync for Foo {}\n\nunsafe impl Send for &amp;\&#39;static Foo {}\n// error: cross-crate traits with a default impl, like `core::marker::Send`,\n//        can only be implemented for a struct/enum type, not\n//        `&amp;\&#39;static Foo`\n```\n\nOnly structs and enums are permitted to impl Send, Sync, and other opt-out\ntrait, and the struct or enum must be local to the current crate. So, for\nexample, `unsafe impl Send for Rc&lt;Foo&gt;` is not allowed.\n&quot;),
 (&quot;E0322&quot;,
  &quot;\nThe `Sized` trait is a special trait built-in to the compiler for types with a\nconstant size known at compile-time. This trait is automatically implemented\nfor types as needed by the compiler, and it is currently disallowed to\nexplicitly implement it for a type.\n&quot;),
 (&quot;E0323&quot;,
  &quot;\nAn associated const was implemented when another trait item was expected.\nErroneous code example:\n\n```compile_fail,E0323\ntrait Foo {\n    type N;\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    const N : u32 = 0;\n    // error: item `N` is an associated const, which doesn\&#39;t match its\n    //        trait `&lt;Bar as Foo&gt;`\n}\n```\n\nPlease verify that the associated const wasn\&#39;t misspelled and the correct trait\nwas implemented. Example:\n\n```\nstruct Bar;\n\ntrait Foo {\n    type N;\n}\n\nimpl Foo for Bar {\n    type N = u32; // ok!\n}\n```\n\nOr:\n\n```\nstruct Bar;\n\ntrait Foo {\n    const N : u32;\n}\n\nimpl Foo for Bar {\n    const N : u32 = 0; // ok!\n}\n```\n&quot;),
 (&quot;E0324&quot;,
  &quot;\nA method was implemented when another trait item was expected. Erroneous\ncode example:\n\n```compile_fail,E0324\nstruct Bar;\n\ntrait Foo {\n    const N : u32;\n\n    fn M();\n}\n\nimpl Foo for Bar {\n    fn N() {}\n    // error: item `N` is an associated method, which doesn\&#39;t match its\n    //        trait `&lt;Bar as Foo&gt;`\n}\n```\n\nTo fix this error, please verify that the method name wasn\&#39;t misspelled and\nverify that you are indeed implementing the correct trait items. Example:\n\n```\nstruct Bar;\n\ntrait Foo {\n    const N : u32;\n\n    fn M();\n}\n\nimpl Foo for Bar {\n    const N : u32 = 0;\n\n    fn M() {} // ok!\n}\n```\n&quot;),
 (&quot;E0325&quot;,
  &quot;\nAn associated type was implemented when another trait item was expected.\nErroneous code example:\n\n```compile_fail,E0325\nstruct Bar;\n\ntrait Foo {\n    const N : u32;\n}\n\nimpl Foo for Bar {\n    type N = u32;\n    // error: item `N` is an associated type, which doesn\&#39;t match its\n    //        trait `&lt;Bar as Foo&gt;`\n}\n```\n\nPlease verify that the associated type name wasn\&#39;t misspelled and your\nimplementation corresponds to the trait definition. Example:\n\n```\nstruct Bar;\n\ntrait Foo {\n    type N;\n}\n\nimpl Foo for Bar {\n    type N = u32; // ok!\n}\n```\n\nOr:\n\n```\nstruct Bar;\n\ntrait Foo {\n    const N : u32;\n}\n\nimpl Foo for Bar {\n    const N : u32 = 0; // ok!\n}\n```\n&quot;),
 (&quot;E0326&quot;,
  &quot;\nThe types of any associated constants in a trait implementation must match the\ntypes in the trait definition. This error indicates that there was a mismatch.\n\nHere\&#39;s an example of this error:\n\n```compile_fail,E0326\ntrait Foo {\n    const BAR: bool;\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    const BAR: u32 = 5; // error, expected bool, found u32\n}\n```\n&quot;),
 (&quot;E0328&quot;,
  &quot;\nThe Unsize trait should not be implemented directly. All implementations of\nUnsize are provided automatically by the compiler.\n\nErroneous code example:\n\n```compile_fail,E0328\n#![feature(unsize)]\n\nuse std::marker::Unsize;\n\npub struct MyType;\n\nimpl&lt;T&gt; Unsize&lt;T&gt; for MyType {}\n```\n\nIf you are defining your own smart pointer type and would like to enable\nconversion from a sized to an unsized type with the\n[DST coercion system][RFC 982], use [`CoerceUnsized`] instead.\n\n```\n#![feature(coerce_unsized)]\n\nuse std::ops::CoerceUnsized;\n\npub struct MyType&lt;T: ?Sized&gt; {\n    field_with_unsized_type: T,\n}\n\nimpl&lt;T, U&gt; CoerceUnsized&lt;MyType&lt;U&gt;&gt; for MyType&lt;T&gt;\n    where T: CoerceUnsized&lt;U&gt; {}\n```\n\n[RFC 982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n[`CoerceUnsized`]: https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html\n&quot;),
 (&quot;E0366&quot;,
  &quot;\nAn attempt was made to implement `Drop` on a concrete specialization of a\ngeneric type. An example is shown below:\n\n```compile_fail,E0366\nstruct Foo&lt;T&gt; {\n    t: T\n}\n\nimpl Drop for Foo&lt;u32&gt; {\n    fn drop(&amp;mut self) {}\n}\n```\n\nThis code is not legal: it is not possible to specialize `Drop` to a subset of\nimplementations of a generic type. One workaround for this is to wrap the\ngeneric type, as shown below:\n\n```\nstruct Foo&lt;T&gt; {\n    t: T\n}\n\nstruct Bar {\n    t: Foo&lt;u32&gt;\n}\n\nimpl Drop for Bar {\n    fn drop(&amp;mut self) {}\n}\n```\n&quot;),
 (&quot;E0367&quot;,
  &quot;\nAn attempt was made to implement `Drop` on a specialization of a generic type.\nAn example is shown below:\n\n```compile_fail,E0367\ntrait Foo{}\n\nstruct MyStruct&lt;T&gt; {\n    t: T\n}\n\nimpl&lt;T: Foo&gt; Drop for MyStruct&lt;T&gt; {\n    fn drop(&amp;mut self) {}\n}\n```\n\nThis code is not legal: it is not possible to specialize `Drop` to a subset of\nimplementations of a generic type. In order for this code to work, `MyStruct`\nmust also require that `T` implements `Foo`. Alternatively, another option is\nto wrap the generic type in another that specializes appropriately:\n\n```\ntrait Foo{}\n\nstruct MyStruct&lt;T&gt; {\n    t: T\n}\n\nstruct MyStructWrapper&lt;T: Foo&gt; {\n    t: MyStruct&lt;T&gt;\n}\n\nimpl &lt;T: Foo&gt; Drop for MyStructWrapper&lt;T&gt; {\n    fn drop(&amp;mut self) {}\n}\n```\n&quot;),
 (&quot;E0368&quot;,
  &quot;\nThis error indicates that a binary assignment operator like `+=` or `^=` was\napplied to a type that doesn\&#39;t support it. For example:\n\n```compile_fail,E0368\nlet mut x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to\n                   //        type `f32`\n\nx &lt;&lt;= 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait\n\nx &lt;&lt;= 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing the `[OP]Assign` traits from `std::ops`.\n\nAnother problem you might be facing is this: suppose you\&#39;ve overloaded the `+`\noperator for some type `Foo` by implementing the `std::ops::Add` trait for\n`Foo`, but you find that using `+=` does not work, as in this example:\n\n```compile_fail,E0368\nuse std::ops::Add;\n\nstruct Foo(u32);\n\nimpl Add for Foo {\n    type Output = Foo;\n\n    fn add(self, rhs: Foo) -&gt; Foo {\n        Foo(self.0 + rhs.0)\n    }\n}\n\nfn main() {\n    let mut x: Foo = Foo(5);\n    x += Foo(7); // error, `+= cannot be applied to the type `Foo`\n}\n```\n\nThis is because `AddAssign` is not automatically implemented, so you need to\nmanually implement it for your type.\n&quot;),
 (&quot;E0369&quot;,
  &quot;\nA binary operation was attempted on a type which doesn\&#39;t support it.\nErroneous code example:\n\n```compile_fail,E0369\nlet x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to\n               //        type `f32`\n\nx &lt;&lt; 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx &lt;&lt; 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing traits from `std::ops`.\n\nString concatenation appends the string on the right to the string on the\nleft and may require reallocation. This requires ownership of the string\non the left. If something should be added to a string literal, move the\nliteral to the heap by allocating it with `to_owned()` like in\n`\&quot;Your text\&quot;.to_owned()`.\n\n&quot;),
 (&quot;E0370&quot;,
  &quot;\nThe maximum value of an enum was reached, so it cannot be automatically\nset in the next enum value. Erroneous code example:\n\n```compile_fail\n#[deny(overflowing_literals)]\nenum Foo {\n    X = 0x7fffffffffffffff,\n    Y, // error: enum discriminant overflowed on value after\n       //        9223372036854775807: i64; set explicitly via\n       //        Y = -9223372036854775808 if that is desired outcome\n}\n```\n\nTo fix this, please set manually the next enum value or put the enum variant\nwith the maximum value at the end of the enum. Examples:\n\n```\nenum Foo {\n    X = 0x7fffffffffffffff,\n    Y = 0, // ok!\n}\n```\n\nOr:\n\n```\nenum Foo {\n    Y = 0, // ok!\n    X = 0x7fffffffffffffff,\n}\n```\n&quot;),
 (&quot;E0371&quot;,
  &quot;\nWhen `Trait2` is a subtrait of `Trait1` (for example, when `Trait2` has a\ndefinition like `trait Trait2: Trait1 { ... }`), it is not allowed to implement\n`Trait1` for `Trait2`. This is because `Trait2` already implements `Trait1` by\ndefinition, so it is not useful to do this.\n\nExample:\n\n```compile_fail,E0371\ntrait Foo { fn foo(&amp;self) { } }\ntrait Bar: Foo { }\ntrait Baz: Bar { }\n\nimpl Bar for Baz { } // error, `Baz` implements `Bar` by definition\nimpl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`\nimpl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`\nimpl Baz for Bar { } // Note: This is OK\n```\n&quot;),
 (&quot;E0374&quot;,
  &quot;\nA struct without a field containing an unsized type cannot implement\n`CoerceUnsized`. An\n[unsized type](https://doc.rust-lang.org/book/first-edition/unsized-types.html)\nis any type that the compiler doesn\&#39;t know the length or alignment of at\ncompile time. Any struct containing an unsized type is also unsized.\n\nExample of erroneous code:\n\n```compile_fail,E0374\n#![feature(coerce_unsized)]\nuse std::ops::CoerceUnsized;\n\nstruct Foo&lt;T: ?Sized&gt; {\n    a: i32,\n}\n\n// error: Struct `Foo` has no unsized fields that need `CoerceUnsized`.\nimpl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt;\n    where T: CoerceUnsized&lt;U&gt; {}\n```\n\n`CoerceUnsized` is used to coerce one struct containing an unsized type\ninto another struct containing a different unsized type. If the struct\ndoesn\&#39;t have any fields of unsized types then you don\&#39;t need explicit\ncoercion to get the types you want. To fix this you can either\nnot try to implement `CoerceUnsized` or you can add a field that is\nunsized to the struct.\n\nExample:\n\n```\n#![feature(coerce_unsized)]\nuse std::ops::CoerceUnsized;\n\n// We don\&#39;t need to impl `CoerceUnsized` here.\nstruct Foo {\n    a: i32,\n}\n\n// We add the unsized type field to the struct.\nstruct Bar&lt;T: ?Sized&gt; {\n    a: i32,\n    b: T,\n}\n\n// The struct has an unsized field so we can implement\n// `CoerceUnsized` for it.\nimpl&lt;T, U&gt; CoerceUnsized&lt;Bar&lt;U&gt;&gt; for Bar&lt;T&gt;\n    where T: CoerceUnsized&lt;U&gt; {}\n```\n\nNote that `CoerceUnsized` is mainly used by smart pointers like `Box`, `Rc`\nand `Arc` to be able to mark that they can coerce unsized types that they\nare pointing at.\n&quot;),
 (&quot;E0375&quot;,
  &quot;\nA struct with more than one field containing an unsized type cannot implement\n`CoerceUnsized`. This only occurs when you are trying to coerce one of the\ntypes in your struct to another type in the struct. In this case we try to\nimpl `CoerceUnsized` from `T` to `U` which are both types that the struct\ntakes. An [unsized type] is any type that the compiler doesn\&#39;t know the length\nor alignment of at compile time. Any struct containing an unsized type is also\nunsized.\n\nExample of erroneous code:\n\n```compile_fail,E0375\n#![feature(coerce_unsized)]\nuse std::ops::CoerceUnsized;\n\nstruct Foo&lt;T: ?Sized, U: ?Sized&gt; {\n    a: i32,\n    b: T,\n    c: U,\n}\n\n// error: Struct `Foo` has more than one unsized field.\nimpl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U, T&gt;&gt; for Foo&lt;T, U&gt; {}\n```\n\n`CoerceUnsized` only allows for coercion from a structure with a single\nunsized type field to another struct with a single unsized type field.\nIn fact Rust only allows for a struct to have one unsized type in a struct\nand that unsized type must be the last field in the struct. So having two\nunsized types in a single struct is not allowed by the compiler. To fix this\nuse only one field containing an unsized type in the struct and then use\nmultiple structs to manage each unsized type field you need.\n\nExample:\n\n```\n#![feature(coerce_unsized)]\nuse std::ops::CoerceUnsized;\n\nstruct Foo&lt;T: ?Sized&gt; {\n    a: i32,\n    b: T,\n}\n\nimpl &lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt;\n    where T: CoerceUnsized&lt;U&gt; {}\n\nfn coerce_foo&lt;T: CoerceUnsized&lt;U&gt;, U&gt;(t: T) -&gt; Foo&lt;U&gt; {\n    Foo { a: 12i32, b: t } // we use coercion to get the `Foo&lt;U&gt;` type we need\n}\n```\n\n[unsized type]: https://doc.rust-lang.org/book/first-edition/unsized-types.html\n&quot;),
 (&quot;E0376&quot;,
  &quot;\nThe type you are trying to impl `CoerceUnsized` for is not a struct.\n`CoerceUnsized` can only be implemented for a struct. Unsized types are\nalready able to be coerced without an implementation of `CoerceUnsized`\nwhereas a struct containing an unsized type needs to know the unsized type\nfield it\&#39;s containing is able to be coerced. An\n[unsized type](https://doc.rust-lang.org/book/first-edition/unsized-types.html)\nis any type that the compiler doesn\&#39;t know the length or alignment of at\ncompile time. Any struct containing an unsized type is also unsized.\n\nExample of erroneous code:\n\n```compile_fail,E0376\n#![feature(coerce_unsized)]\nuse std::ops::CoerceUnsized;\n\nstruct Foo&lt;T: ?Sized&gt; {\n    a: T,\n}\n\n// error: The type `U` is not a struct\nimpl&lt;T, U&gt; CoerceUnsized&lt;U&gt; for Foo&lt;T&gt; {}\n```\n\nThe `CoerceUnsized` trait takes a struct type. Make sure the type you are\nproviding to `CoerceUnsized` is a struct with only the last field containing an\nunsized type.\n\nExample:\n\n```\n#![feature(coerce_unsized)]\nuse std::ops::CoerceUnsized;\n\nstruct Foo&lt;T&gt; {\n    a: T,\n}\n\n// The `Foo&lt;U&gt;` is a struct so `CoerceUnsized` can be implemented\nimpl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt; where T: CoerceUnsized&lt;U&gt; {}\n```\n\nNote that in Rust, structs can only contain an unsized type if the field\ncontaining the unsized type is the last and only unsized type field in the\nstruct.\n&quot;),
 (&quot;E0380&quot;,
  &quot;\nDefault impls are only allowed for traits with no methods or associated items.\nFor more information see the [opt-in builtin traits RFC][RFC 19].\n\n[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md\n&quot;),
 (&quot;E0390&quot;,
  &quot;\nYou tried to implement methods for a primitive type. Erroneous code example:\n\n```compile_fail,E0390\nstruct Foo {\n    x: i32\n}\n\nimpl *mut Foo {}\n// error: only a single inherent implementation marked with\n//        `#[lang = \&quot;mut_ptr\&quot;]` is allowed for the `*mut T` primitive\n```\n\nThis isn\&#39;t allowed, but using a trait to implement a method is a good solution.\nExample:\n\n```\nstruct Foo {\n    x: i32\n}\n\ntrait Bar {\n    fn bar();\n}\n\nimpl Bar for *mut Foo {\n    fn bar() {} // ok!\n}\n```\n&quot;),
 (&quot;E0392&quot;,
  &quot;\nThis error indicates that a type or lifetime parameter has been declared\nbut not actually used. Here is an example that demonstrates the error:\n\n```compile_fail,E0392\nenum Foo&lt;T&gt; {\n    Bar,\n}\n```\n\nIf the type parameter was included by mistake, this error can be fixed\nby simply removing the type parameter, as shown below:\n\n```\nenum Foo {\n    Bar,\n}\n```\n\nAlternatively, if the type parameter was intentionally inserted, it must be\nused. A simple fix is shown below:\n\n```\nenum Foo&lt;T&gt; {\n    Bar(T),\n}\n```\n\nThis error may also commonly be found when working with unsafe code. For\nexample, when using raw pointers one may wish to specify the lifetime for\nwhich the pointed-at data is valid. An initial attempt (below) causes this\nerror:\n\n```compile_fail,E0392\nstruct Foo&lt;\&#39;a, T&gt; {\n    x: *const T,\n}\n```\n\nWe want to express the constraint that Foo should not outlive `\&#39;a`, because\nthe data pointed to by `T` is only valid for that lifetime. The problem is\nthat there are no actual uses of `\&#39;a`. It\&#39;s possible to work around this\nby adding a PhantomData type to the struct, using it to tell the compiler\nto act as if the struct contained a borrowed reference `&amp;\&#39;a T`:\n\n```\nuse std::marker::PhantomData;\n\nstruct Foo&lt;\&#39;a, T: \&#39;a&gt; {\n    x: *const T,\n    phantom: PhantomData&lt;&amp;\&#39;a T&gt;\n}\n```\n\n[PhantomData] can also be used to express information about unused type\nparameters.\n\n[PhantomData]: https://doc.rust-lang.org/std/marker/struct.PhantomData.html\n&quot;),
 (&quot;E0393&quot;,
  &quot;\nA type parameter which references `Self` in its default value was not specified.\nExample of erroneous code:\n\n```compile_fail,E0393\ntrait A&lt;T=Self&gt; {}\n\nfn together_we_will_rule_the_galaxy(son: &amp;A) {}\n// error: the type parameter `T` must be explicitly specified in an\n//        object type because its default value `Self` references the\n//        type `Self`\n```\n\nA trait object is defined over a single, fully-defined trait. With a regular\ndefault parameter, this parameter can just be substituted in. However, if the\ndefault parameter is `Self`, the trait changes for each concrete type; i.e.\n`i32` will be expected to implement `A&lt;i32&gt;`, `bool` will be expected to\nimplement `A&lt;bool&gt;`, etc... These types will not share an implementation of a\nfully-defined trait; instead they share implementations of a trait with\ndifferent parameters substituted in for each implementation. This is\nirreconcilable with what we need to make a trait object work, and is thus\ndisallowed. Making the trait concrete by explicitly specifying the value of the\ndefaulted parameter will fix this issue. Fixed example:\n\n```\ntrait A&lt;T=Self&gt; {}\n\nfn together_we_will_rule_the_galaxy(son: &amp;A&lt;i32&gt;) {} // Ok!\n```\n&quot;),
 (&quot;E0399&quot;,
  &quot;\nYou implemented a trait, overriding one or more of its associated types but did\nnot reimplement its default methods.\n\nExample of erroneous code:\n\n```compile_fail,E0399\n#![feature(associated_type_defaults)]\n\npub trait Foo {\n    type Assoc = u8;\n    fn bar(&amp;self) {}\n}\n\nimpl Foo for i32 {\n    // error - the following trait items need to be reimplemented as\n    //         `Assoc` was overridden: `bar`\n    type Assoc = i32;\n}\n```\n\nTo fix this, add an implementation for each default method from the trait:\n\n```\n#![feature(associated_type_defaults)]\n\npub trait Foo {\n    type Assoc = u8;\n    fn bar(&amp;self) {}\n}\n\nimpl Foo for i32 {\n    type Assoc = i32;\n    fn bar(&amp;self) {} // ok!\n}\n```\n&quot;),
 (&quot;E0436&quot;,
  &quot;\nThe functional record update syntax is only allowed for structs. (Struct-like\nenum variants don\&#39;t qualify, for example.)\n\nErroneous code example:\n\n```compile_fail,E0436\nenum PublicationFrequency {\n    Weekly,\n    SemiMonthly { days: (u8, u8), annual_special: bool },\n}\n\nfn one_up_competitor(competitor_frequency: PublicationFrequency)\n                     -&gt; PublicationFrequency {\n    match competitor_frequency {\n        PublicationFrequency::Weekly =&gt; PublicationFrequency::SemiMonthly {\n            days: (1, 15), annual_special: false\n        },\n        c @ PublicationFrequency::SemiMonthly{ .. } =&gt;\n            PublicationFrequency::SemiMonthly {\n                annual_special: true, ..c // error: functional record update\n                                          //        syntax requires a struct\n        }\n    }\n}\n```\n\nRewrite the expression without functional record update syntax:\n\n```\nenum PublicationFrequency {\n    Weekly,\n    SemiMonthly { days: (u8, u8), annual_special: bool },\n}\n\nfn one_up_competitor(competitor_frequency: PublicationFrequency)\n                     -&gt; PublicationFrequency {\n    match competitor_frequency {\n        PublicationFrequency::Weekly =&gt; PublicationFrequency::SemiMonthly {\n            days: (1, 15), annual_special: false\n        },\n        PublicationFrequency::SemiMonthly{ days, .. } =&gt;\n            PublicationFrequency::SemiMonthly {\n                days, annual_special: true // ok!\n        }\n    }\n}\n```\n&quot;),
 (&quot;E0439&quot;,
  &quot;\nThe length of the platform-intrinsic function `simd_shuffle`\nwasn\&#39;t specified. Erroneous code example:\n\n```compile_fail,E0439\n#![feature(platform_intrinsics)]\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn simd_shuffle&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;\n    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`\n}\n```\n\nThe `simd_shuffle` function needs the length of the array passed as\nlast parameter in its name. Example:\n\n```\n#![feature(platform_intrinsics)]\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn simd_shuffle8&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;\n}\n```\n&quot;),
 (&quot;E0440&quot;,
  &quot;\nA platform-specific intrinsic function has the wrong number of type\nparameters. Erroneous code example:\n\n```compile_fail,E0440\n#![feature(repr_simd)]\n#![feature(platform_intrinsics)]\n\n#[repr(simd)]\nstruct f64x2(f64, f64);\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn x86_mm_movemask_pd&lt;T&gt;(x: f64x2) -&gt; i32;\n    // error: platform-specific intrinsic has wrong number of type\n    //        parameters\n}\n```\n\nPlease refer to the function declaration to see if it corresponds\nwith yours. Example:\n\n```\n#![feature(repr_simd)]\n#![feature(platform_intrinsics)]\n\n#[repr(simd)]\nstruct f64x2(f64, f64);\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn x86_mm_movemask_pd(x: f64x2) -&gt; i32;\n}\n```\n&quot;),
 (&quot;E0441&quot;,
  &quot;\nAn unknown platform-specific intrinsic function was used. Erroneous\ncode example:\n\n```compile_fail,E0441\n#![feature(repr_simd)]\n#![feature(platform_intrinsics)]\n\n#[repr(simd)]\nstruct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn x86_mm_adds_ep16(x: i16x8, y: i16x8) -&gt; i16x8;\n    // error: unrecognized platform-specific intrinsic function\n}\n```\n\nPlease verify that the function name wasn\&#39;t misspelled, and ensure\nthat it is declared in the rust source code (in the file\nsrc/librustc_platform_intrinsics/x86.rs). Example:\n\n```\n#![feature(repr_simd)]\n#![feature(platform_intrinsics)]\n\n#[repr(simd)]\nstruct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -&gt; i16x8; // ok!\n}\n```\n&quot;),
 (&quot;E0442&quot;,
  &quot;\nIntrinsic argument(s) and/or return value have the wrong type.\nErroneous code example:\n\n```compile_fail,E0442\n#![feature(repr_simd)]\n#![feature(platform_intrinsics)]\n\n#[repr(simd)]\nstruct i8x16(i8, i8, i8, i8, i8, i8, i8, i8,\n             i8, i8, i8, i8, i8, i8, i8, i8);\n#[repr(simd)]\nstruct i32x4(i32, i32, i32, i32);\n#[repr(simd)]\nstruct i64x2(i64, i64);\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn x86_mm_adds_epi16(x: i8x16, y: i32x4) -&gt; i64x2;\n    // error: intrinsic arguments/return value have wrong type\n}\n```\n\nTo fix this error, please refer to the function declaration to give\nit the awaited types. Example:\n\n```\n#![feature(repr_simd)]\n#![feature(platform_intrinsics)]\n\n#[repr(simd)]\nstruct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -&gt; i16x8; // ok!\n}\n```\n&quot;),
 (&quot;E0443&quot;,
  &quot;\nIntrinsic argument(s) and/or return value have the wrong type.\nErroneous code example:\n\n```compile_fail,E0443\n#![feature(repr_simd)]\n#![feature(platform_intrinsics)]\n\n#[repr(simd)]\nstruct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n#[repr(simd)]\nstruct i64x8(i64, i64, i64, i64, i64, i64, i64, i64);\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -&gt; i64x8;\n    // error: intrinsic argument/return value has wrong type\n}\n```\n\nTo fix this error, please refer to the function declaration to give\nit the awaited types. Example:\n\n```\n#![feature(repr_simd)]\n#![feature(platform_intrinsics)]\n\n#[repr(simd)]\nstruct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -&gt; i16x8; // ok!\n}\n```\n&quot;),
 (&quot;E0444&quot;,
  &quot;\nA platform-specific intrinsic function has wrong number of arguments.\nErroneous code example:\n\n```compile_fail,E0444\n#![feature(repr_simd)]\n#![feature(platform_intrinsics)]\n\n#[repr(simd)]\nstruct f64x2(f64, f64);\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn x86_mm_movemask_pd(x: f64x2, y: f64x2, z: f64x2) -&gt; i32;\n    // error: platform-specific intrinsic has invalid number of arguments\n}\n```\n\nPlease refer to the function declaration to see if it corresponds\nwith yours. Example:\n\n```\n#![feature(repr_simd)]\n#![feature(platform_intrinsics)]\n\n#[repr(simd)]\nstruct f64x2(f64, f64);\n\nextern \&quot;platform-intrinsic\&quot; {\n    fn x86_mm_movemask_pd(x: f64x2) -&gt; i32; // ok!\n}\n```\n&quot;),
 (&quot;E0516&quot;,
  &quot;\nThe `typeof` keyword is currently reserved but unimplemented.\nErroneous code example:\n\n```compile_fail,E0516\nfn main() {\n    let x: typeof(92) = 92;\n}\n```\n\nTry using type inference instead. Example:\n\n```\nfn main() {\n    let x = 92;\n}\n```\n&quot;),
 (&quot;E0520&quot;,
  &quot;\nA non-default implementation was already made on this type so it cannot be\nspecialized further. Erroneous code example:\n\n```compile_fail,E0520\n#![feature(specialization)]\n\ntrait SpaceLlama {\n    fn fly(&amp;self);\n}\n\n// applies to all T\nimpl&lt;T&gt; SpaceLlama for T {\n    default fn fly(&amp;self) {}\n}\n\n// non-default impl\n// applies to all `Clone` T and overrides the previous impl\nimpl&lt;T: Clone&gt; SpaceLlama for T {\n    fn fly(&amp;self) {}\n}\n\n// since `i32` is clone, this conflicts with the previous implementation\nimpl SpaceLlama for i32 {\n    default fn fly(&amp;self) {}\n    // error: item `fly` is provided by an `impl` that specializes\n    //        another, but the item in the parent `impl` is not marked\n    //        `default` and so it cannot be specialized.\n}\n```\n\nSpecialization only allows you to override `default` functions in\nimplementations.\n\nTo fix this error, you need to mark all the parent implementations as default.\nExample:\n\n```\n#![feature(specialization)]\n\ntrait SpaceLlama {\n    fn fly(&amp;self);\n}\n\n// applies to all T\nimpl&lt;T&gt; SpaceLlama for T {\n    default fn fly(&amp;self) {} // This is a parent implementation.\n}\n\n// applies to all `Clone` T; overrides the previous impl\nimpl&lt;T: Clone&gt; SpaceLlama for T {\n    default fn fly(&amp;self) {} // This is a parent implementation but was\n                             // previously not a default one, causing the error\n}\n\n// applies to i32, overrides the previous two impls\nimpl SpaceLlama for i32 {\n    fn fly(&amp;self) {} // And now that\&#39;s ok!\n}\n```\n&quot;),
 (&quot;E0527&quot;,
  &quot;\nThe number of elements in an array or slice pattern differed from the number of\nelements in the array being matched.\n\nExample of erroneous code:\n\n```compile_fail,E0527\n#![feature(slice_patterns)]\n\nlet r = &amp;[1, 2, 3, 4];\nmatch r {\n    &amp;[a, b] =&gt; { // error: pattern requires 2 elements but array\n                 //        has 4\n        println!(\&quot;a={}, b={}\&quot;, a, b);\n    }\n}\n```\n\nEnsure that the pattern is consistent with the size of the matched\narray. Additional elements can be matched with `..`:\n\n```\n#![feature(slice_patterns)]\n\nlet r = &amp;[1, 2, 3, 4];\nmatch r {\n    &amp;[a, b, ..] =&gt; { // ok!\n        println!(\&quot;a={}, b={}\&quot;, a, b);\n    }\n}\n```\n&quot;),
 (&quot;E0528&quot;,
  &quot;\nAn array or slice pattern required more elements than were present in the\nmatched array.\n\nExample of erroneous code:\n\n```compile_fail,E0528\n#![feature(slice_patterns)]\n\nlet r = &amp;[1, 2];\nmatch r {\n    &amp;[a, b, c, rest..] =&gt; { // error: pattern requires at least 3\n                            //        elements but array has 2\n        println!(\&quot;a={}, b={}, c={} rest={:?}\&quot;, a, b, c, rest);\n    }\n}\n```\n\nEnsure that the matched array has at least as many elements as the pattern\nrequires. You can match an arbitrary number of remaining elements with `..`:\n\n```\n#![feature(slice_patterns)]\n\nlet r = &amp;[1, 2, 3, 4, 5];\nmatch r {\n    &amp;[a, b, c, rest..] =&gt; { // ok!\n        // prints `a=1, b=2, c=3 rest=[4, 5]`\n        println!(\&quot;a={}, b={}, c={} rest={:?}\&quot;, a, b, c, rest);\n    }\n}\n```\n&quot;),
 (&quot;E0529&quot;,
  &quot;\nAn array or slice pattern was matched against some other type.\n\nExample of erroneous code:\n\n```compile_fail,E0529\n#![feature(slice_patterns)]\n\nlet r: f32 = 1.0;\nmatch r {\n    [a, b] =&gt; { // error: expected an array or slice, found `f32`\n        println!(\&quot;a={}, b={}\&quot;, a, b);\n    }\n}\n```\n\nEnsure that the pattern and the expression being matched on are of consistent\ntypes:\n\n```\n#![feature(slice_patterns)]\n\nlet r = [1.0, 2.0];\nmatch r {\n    [a, b] =&gt; { // ok!\n        println!(\&quot;a={}, b={}\&quot;, a, b);\n    }\n}\n```\n&quot;),
 (&quot;E0559&quot;,
  &quot;\nAn unknown field was specified into an enum\&#39;s structure variant.\n\nErroneous code example:\n\n```compile_fail,E0559\nenum Field {\n    Fool { x: u32 },\n}\n\nlet s = Field::Fool { joke: 0 };\n// error: struct variant `Field::Fool` has no field named `joke`\n```\n\nVerify you didn\&#39;t misspell the field\&#39;s name or that the field exists. Example:\n\n```\nenum Field {\n    Fool { joke: u32 },\n}\n\nlet s = Field::Fool { joke: 0 }; // ok!\n```\n&quot;),
 (&quot;E0560&quot;,
  &quot;\nAn unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn\&#39;t misspell the field\&#39;s name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n&quot;),
 (&quot;E0562&quot;,
  &quot;\nAbstract return types (written `impl Trait` for some trait `Trait`) are only\nallowed as function return types.\n\nErroneous code example:\n\n```compile_fail,E0562\n#![feature(conservative_impl_trait)]\n\nfn main() {\n    let count_to_ten: impl Iterator&lt;Item=usize&gt; = 0..10;\n    // error: `impl Trait` not allowed outside of function and inherent method\n    //        return types\n    for i in count_to_ten {\n        println!(\&quot;{}\&quot;, i);\n    }\n}\n```\n\nMake sure `impl Trait` only appears in return-type position.\n\n```\n#![feature(conservative_impl_trait)]\n\nfn count_to_n(n: usize) -&gt; impl Iterator&lt;Item=usize&gt; {\n    0..n\n}\n\nfn main() {\n    for i in count_to_n(10) {  // ok!\n        println!(\&quot;{}\&quot;, i);\n    }\n}\n```\n\nSee [RFC 1522] for more details.\n\n[RFC 1522]: https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md\n&quot;),
 (&quot;E0569&quot;,
  &quot;\nIf an impl has a generic parameter with the `#[may_dangle]` attribute, then\nthat impl must be declared as an `unsafe impl.\n\nErroneous code example:\n\n```compile_fail,E0569\n#![feature(generic_param_attrs)]\n#![feature(dropck_eyepatch)]\n\nstruct Foo&lt;X&gt;(X);\nimpl&lt;#[may_dangle] X&gt; Drop for Foo&lt;X&gt; {\n    fn drop(&amp;mut self) { }\n}\n```\n\nIn this example, we are asserting that the destructor for `Foo` will not\naccess any data of type `X`, and require this assertion to be true for\noverall safety in our program. The compiler does not currently attempt to\nverify this assertion; therefore we must tag this `impl` as unsafe.\n&quot;),
 (&quot;E0570&quot;,
  &quot;\nThe requested ABI is unsupported by the current target.\n\nThe rust compiler maintains for each target a blacklist of ABIs unsupported on\nthat target. If an ABI is present in such a list this usually means that the\ntarget / ABI combination is currently unsupported by llvm.\n\nIf necessary, you can circumvent this check using custom target specifications.\n&quot;),
 (&quot;E0572&quot;,
  &quot;\nA return statement was found outside of a function body.\n\nErroneous code example:\n\n```compile_fail,E0572\nconst FOO: u32 = return 0; // error: return statement outside of function body\n\nfn main() {}\n```\n\nTo fix this issue, just remove the return keyword or move the expression into a\nfunction. Example:\n\n```\nconst FOO: u32 = 0;\n\nfn some_fn() -&gt; u32 {\n    return FOO;\n}\n\nfn main() {\n    some_fn();\n}\n```\n&quot;),
 (&quot;E0581&quot;,
  &quot;\nIn a `fn` type, a lifetime appears only in the return type,\nand not in the arguments types.\n\nErroneous code example:\n\n```compile_fail,E0581\nfn main() {\n    // Here, `\&#39;a` appears only in the return type:\n    let x: for&lt;\&#39;a&gt; fn() -&gt; &amp;\&#39;a i32;\n}\n```\n\nTo fix this issue, either use the lifetime in the arguments, or use\n`\&#39;static`. Example:\n\n```\nfn main() {\n    // Here, `\&#39;a` appears only in the return type:\n    let x: for&lt;\&#39;a&gt; fn(&amp;\&#39;a i32) -&gt; &amp;\&#39;a i32;\n    let y: fn() -&gt; &amp;\&#39;static i32;\n}\n```\n\nNote: The examples above used to be (erroneously) accepted by the\ncompiler, but this was since corrected. See [issue #33685] for more\ndetails.\n\n[issue #33685]: https://github.com/rust-lang/rust/issues/33685\n&quot;),
 (&quot;E0582&quot;,
  &quot;\nA lifetime appears only in an associated-type binding,\nand not in the input types to the trait.\n\nErroneous code example:\n\n```compile_fail,E0582\nfn bar&lt;F&gt;(t: F)\n    // No type can satisfy this requirement, since `\&#39;a` does not\n    // appear in any of the input types (here, `i32`):\n    where F: for&lt;\&#39;a&gt; Fn(i32) -&gt; Option&lt;&amp;\&#39;a i32&gt;\n{\n}\n\nfn main() { }\n```\n\nTo fix this issue, either use the lifetime in the inputs, or use\n`\&#39;static`. Example:\n\n```\nfn bar&lt;F, G&gt;(t: F, u: G)\n    where F: for&lt;\&#39;a&gt; Fn(&amp;\&#39;a i32) -&gt; Option&lt;&amp;\&#39;a i32&gt;,\n          G: Fn(i32) -&gt; Option&lt;&amp;\&#39;static i32&gt;,\n{\n}\n\nfn main() { }\n```\n\nNote: The examples above used to be (erroneously) accepted by the\ncompiler, but this was since corrected. See [issue #33685] for more\ndetails.\n\n[issue #33685]: https://github.com/rust-lang/rust/issues/33685\n&quot;),
 (&quot;E0599&quot;,
  &quot;\nThis error occurs when a method is used on a type which doesn\&#39;t implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n&quot;),
 (&quot;E0600&quot;,
  &quot;\nAn unary operator was used on a type which doesn\&#39;t implement it.\n\nExample of erroneous code:\n\n```compile_fail,E0600\nenum Question {\n    Yes,\n    No,\n}\n\n!Question::Yes; // error: cannot apply unary operator `!` to type `Question`\n```\n\nIn this case, `Question` would need to implement the `std::ops::Not` trait in\norder to be able to use `!` on it. Let\&#39;s implement it:\n\n```\nuse std::ops::Not;\n\nenum Question {\n    Yes,\n    No,\n}\n\n// We implement the `Not` trait on the enum.\nimpl Not for Question {\n    type Output = bool;\n\n    fn not(self) -&gt; bool {\n        match self {\n            Question::Yes =&gt; false, // If the `Answer` is `Yes`, then it\n                                    // returns false.\n            Question::No =&gt; true, // And here we do the opposite.\n        }\n    }\n}\n\nassert_eq!(!Question::Yes, false);\nassert_eq!(!Question::No, true);\n```\n&quot;),
 (&quot;E0608&quot;,
  &quot;\nAn attempt to index into a type which doesn\&#39;t implement the `std::ops::Index`\ntrait was performed.\n\nErroneous code example:\n\n```compile_fail,E0608\n0u8[2]; // error: cannot index into a value of type `u8`\n```\n\nTo be able to index into a type it needs to implement the `std::ops::Index`\ntrait. Example:\n\n```\nlet v: Vec&lt;u8&gt; = vec![0, 1, 2, 3];\n\n// The `Vec` type implements the `Index` trait so you can do:\nprintln!(\&quot;{}\&quot;, v[2]);\n```\n&quot;),
 (&quot;E0604&quot;,
  &quot;\nA cast to `char` was attempted on a type other than `u8`.\n\nErroneous code example:\n\n```compile_fail,E0604\n0u32 as char; // error: only `u8` can be cast as `char`, not `u32`\n```\n\nAs the error message indicates, only `u8` can be cast into `char`. Example:\n\n```\nlet c = 86u8 as char; // ok!\nassert_eq!(c, \&#39;V\&#39;);\n```\n\nFor more information about casts, take a look at The Book:\nhttps://doc.rust-lang.org/book/first-edition/casting-between-types.html\n&quot;),
 (&quot;E0605&quot;,
  &quot;\nAn invalid cast was attempted.\n\nErroneous code examples:\n\n```compile_fail,E0605\nlet x = 0u8;\nx as Vec&lt;u8&gt;; // error: non-primitive cast: `u8` as `std::vec::Vec&lt;u8&gt;`\n\n// Another example\n\nlet v = 0 as *const u8; // So here, `v` is a `*const u8`.\nv as &amp;u8; // error: non-primitive cast: `*const u8` as `&amp;u8`\n```\n\nOnly primitive types can be cast into each other. Examples:\n\n```\nlet x = 0u8;\nx as u32; // ok!\n\nlet v = 0 as *const u8;\nv as *const i8; // ok!\n```\n\nFor more information about casts, take a look at The Book:\nhttps://doc.rust-lang.org/book/first-edition/casting-between-types.html\n&quot;),
 (&quot;E0606&quot;,
  &quot;\nAn incompatible cast was attempted.\n\nErroneous code example:\n\n```compile_fail,E0606\nlet x = &amp;0u8; // Here, `x` is a `&amp;u8`.\nlet y: u32 = x as u32; // error: casting `&amp;u8` as `u32` is invalid\n```\n\nWhen casting, keep in mind that only primitive types can be cast into each\nother. Example:\n\n```\nlet x = &amp;0u8;\nlet y: u32 = *x as u32; // We dereference it first and then cast it.\n```\n\nFor more information about casts, take a look at The Book:\nhttps://doc.rust-lang.org/book/first-edition/casting-between-types.html\n&quot;),
 (&quot;E0607&quot;,
  &quot;\nA cast between a thin and a fat pointer was attempted.\n\nErroneous code example:\n\n```compile_fail,E0607\nlet v = 0 as *const u8;\nv as *const [u8];\n```\n\nFirst: what are thin and fat pointers?\n\nThin pointers are \&quot;simple\&quot; pointers: they are purely a reference to a memory\naddress.\n\nFat pointers are pointers referencing Dynamically Sized Types (also called DST).\nDST don\&#39;t have a statically known size, therefore they can only exist behind\nsome kind of pointers that contain additional information. Slices and trait\nobjects are DSTs. In the case of slices, the additional information the fat\npointer holds is their size.\n\nTo fix this error, don\&#39;t try to cast directly between thin and fat pointers.\n\nFor more information about casts, take a look at The Book:\nhttps://doc.rust-lang.org/book/first-edition/casting-between-types.html\n&quot;),
 (&quot;E0609&quot;,
  &quot;\nAttempted to access a non-existent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\&quot;{}\&quot;, s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn\&#39;t misspell the field\&#39;s name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\&quot;{}\&quot;, s.x); // ok!\n```\n&quot;),
 (&quot;E0610&quot;,
  &quot;\nAttempted to access a field on a primitive type.\n\nErroneous code example:\n\n```compile_fail,E0610\nlet x: u32 = 0;\nprintln!(\&quot;{}\&quot;, x.foo); // error: `{integer}` is a primitive type, therefore\n                       //        doesn\&#39;t have fields\n```\n\nPrimitive types are the most basic types available in Rust and don\&#39;t have\nfields. To access data via named fields, struct types are used. Example:\n\n```\n// We declare struct called `Foo` containing two fields:\nstruct Foo {\n    x: u32,\n    y: i64,\n}\n\n// We create an instance of this struct:\nlet variable = Foo { x: 0, y: -12 };\n// And we can now access its fields:\nprintln!(\&quot;x: {}, y: {}\&quot;, variable.x, variable.y);\n```\n\nFor more information about primitives and structs, take a look at The Book:\nhttps://doc.rust-lang.org/book/first-edition/primitive-types.html\nhttps://doc.rust-lang.org/book/first-edition/structs.html\n&quot;),
 (&quot;E0611&quot;,
  &quot;\nAttempted to access a private field on a tuple-struct.\n\nErroneous code example:\n\n```compile_fail,E0611\nmod some_module {\n    pub struct Foo(u32);\n\n    impl Foo {\n        pub fn new() -&gt; Foo { Foo(0) }\n    }\n}\n\nlet y = some_module::Foo::new();\nprintln!(\&quot;{}\&quot;, y.0); // error: field `0` of tuple-struct `some_module::Foo`\n                     //        is private\n```\n\nSince the field is private, you have two solutions:\n\n1) Make the field public:\n\n```\nmod some_module {\n    pub struct Foo(pub u32); // The field is now public.\n\n    impl Foo {\n        pub fn new() -&gt; Foo { Foo(0) }\n    }\n}\n\nlet y = some_module::Foo::new();\nprintln!(\&quot;{}\&quot;, y.0); // So we can access it directly.\n```\n\n2) Add a getter function to keep the field private but allow for accessing its\nvalue:\n\n```\nmod some_module {\n    pub struct Foo(u32);\n\n    impl Foo {\n        pub fn new() -&gt; Foo { Foo(0) }\n\n        // We add the getter function.\n        pub fn get(&amp;self) -&gt; &amp;u32 { &amp;self.0 }\n    }\n}\n\nlet y = some_module::Foo::new();\nprintln!(\&quot;{}\&quot;, y.get()); // So we can get the value through the function.\n```\n&quot;),
 (&quot;E0612&quot;,
  &quot;\nAttempted out-of-bounds tuple index.\n\nErroneous code example:\n\n```compile_fail,E0612\nstruct Foo(u32);\n\nlet y = Foo(0);\nprintln!(\&quot;{}\&quot;, y.1); // error: attempted out-of-bounds tuple index `1`\n                     //        on type `Foo`\n```\n\nIf a tuple/tuple-struct type has n fields, you can only try to access these n\nfields from 0 to (n - 1). So in this case, you can only index `0`. Example:\n\n```\nstruct Foo(u32);\n\nlet y = Foo(0);\nprintln!(\&quot;{}\&quot;, y.0); // ok!\n```\n&quot;),
 (&quot;E0614&quot;,
  &quot;\nAttempted to dereference a variable which cannot be dereferenced.\n\nErroneous code example:\n\n```compile_fail,E0614\nlet y = 0u32;\n*y; // error: type `u32` cannot be dereferenced\n```\n\nOnly types implementing `std::ops::Deref` can be dereferenced (such as `&amp;T`).\nExample:\n\n```\nlet y = 0u32;\nlet x = &amp;y;\n// So here, `x` is a `&amp;u32`, so we can dereference it:\n*x; // ok!\n```\n&quot;),
 (&quot;E0615&quot;,
  &quot;\nAttempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&amp;self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&amp;self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&amp;self) {} }\n# let f = Foo { x: 0 };\nprintln!(\&quot;{}\&quot;, f.x);\n```\n&quot;),
 (&quot;E0616&quot;,
  &quot;\nAttempted to access a private field on a struct.\n\nErroneous code example:\n\n```compile_fail,E0616\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is private in here.\n    }\n\n    impl Foo {\n        pub fn new() -&gt; Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\&quot;{}\&quot;, f.x); // error: field `x` of struct `some_module::Foo` is private\n```\n\nIf you want to access this field, you have two options:\n\n1) Set the field public:\n\n```\nmod some_module {\n    pub struct Foo {\n        pub x: u32, // `x` is now public.\n    }\n\n    impl Foo {\n        pub fn new() -&gt; Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\&quot;{}\&quot;, f.x); // ok!\n```\n\n2) Add a getter function:\n\n```\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is still private in here.\n    }\n\n    impl Foo {\n        pub fn new() -&gt; Foo { Foo { x: 0 } }\n\n        // We create the getter function here:\n        pub fn get_x(&amp;self) -&gt; &amp;u32 { &amp;self.x }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\&quot;{}\&quot;, f.get_x()); // ok!\n```\n&quot;),
 (&quot;E0617&quot;,
  &quot;\nAttempted to pass an invalid type of variable into a variadic function.\n\nErroneous code example:\n\n```compile_fail,E0617\nextern {\n    fn printf(c: *const i8, ...);\n}\n\nunsafe {\n    printf(::std::ptr::null(), 0f32);\n    // error: can\&#39;t pass an `f32` to variadic function, cast to `c_double`\n}\n```\n\nCertain Rust types must be cast before passing them to a variadic function,\nbecause of arcane ABI rules dictated by the C standard. To fix the error,\ncast the value to the type specified by the error message (which you may need\nto import from `std::os::raw`).\n&quot;),
 (&quot;E0618&quot;,
  &quot;\nAttempted to call something which isn\&#39;t a function nor a method.\n\nErroneous code examples:\n\n```compile_fail,E0618\nenum X {\n    Entry,\n}\n\nX::Entry(); // error: expected function, found `X::Entry`\n\n// Or even simpler:\nlet x = 0i32;\nx(); // error: expected function, found `i32`\n```\n\nOnly functions and methods can be called using `()`. Example:\n\n```\n// We declare a function:\nfn i_am_a_function() {}\n\n// And we call it:\ni_am_a_function();\n```\n&quot;),
 (&quot;E0619&quot;,
  &quot;\nThe type-checker needed to know the type of an expression, but that type had not\nyet been inferred.\n\nErroneous code example:\n\n```compile_fail,E0619\nlet mut x = vec![];\nmatch x.pop() {\n    Some(v) =&gt; {\n        // Here, the type of `v` is not (yet) known, so we\n        // cannot resolve this method call:\n        v.to_uppercase(); // error: the type of this value must be known in\n                          //        this context\n    }\n    None =&gt; {}\n}\n```\n\nType inference typically proceeds from the top of the function to the bottom,\nfiguring out types as it goes. In some cases -- notably method calls and\noverloadable operators like `*` -- the type checker may not have enough\ninformation *yet* to make progress. This can be true even if the rest of the\nfunction provides enough context (because the type-checker hasn\&#39;t looked that\nfar ahead yet). In this case, type annotations can be used to help it along.\n\nTo fix this error, just specify the type of the variable. Example:\n\n```\nlet mut x: Vec&lt;String&gt; = vec![]; // We precise the type of the vec elements.\nmatch x.pop() {\n    Some(v) =&gt; {\n        v.to_uppercase(); // Since rustc now knows the type of the vec elements,\n                          // we can use `v`\&#39;s methods.\n    }\n    None =&gt; {}\n}\n```\n&quot;),
 (&quot;E0620&quot;,
  &quot;\nA cast to an unsized type was attempted.\n\nErroneous code example:\n\n```compile_fail,E0620\nlet x = &amp;[1_usize, 2] as [usize]; // error: cast to unsized type: `&amp;[usize; 2]`\n                                  //        as `[usize]`\n```\n\nIn Rust, some types don\&#39;t have a known size at compile-time. For example, in a\nslice type like `[u32]`, the number of elements is not known at compile-time and\nhence the overall size cannot be computed. As a result, such types can only be\nmanipulated through a reference (e.g., `&amp;T` or `&amp;mut T`) or other pointer-type\n(e.g., `Box` or `Rc`). Try casting to a reference instead:\n\n```\nlet x = &amp;[1_usize, 2] as &amp;[usize]; // ok!\n```\n&quot;),
 (&quot;E0622&quot;,
  &quot;\nAn intrinsic was declared without being a function.\n\nErroneous code example:\n\n```compile_fail,E0622\n#![feature(intrinsics)]\nextern \&quot;rust-intrinsic\&quot; {\n    pub static breakpoint : unsafe extern \&quot;rust-intrinsic\&quot; fn();\n    // error: intrinsic must be a function\n}\n\nfn main() { unsafe { breakpoint(); } }\n```\n\nAn intrinsic is a function available for use in a given programming language\nwhose implementation is handled specially by the compiler. In order to fix this\nerror, just declare a function.\n&quot;),
 (&quot;E0624&quot;,
  &quot;\nA private item was used outside of its scope.\n\nErroneous code example:\n\n```compile_fail,E0624\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        fn method(&amp;self) {}\n    }\n}\n\nlet foo = inner::Foo;\nfoo.method(); // error: method `method` is private\n```\n\nTwo possibilities are available to solve this issue:\n\n1. Only use the item in the scope it has been defined:\n\n```\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        fn method(&amp;self) {}\n    }\n\n    pub fn call_method(foo: &amp;Foo) { // We create a public function.\n        foo.method(); // Which calls the item.\n    }\n}\n\nlet foo = inner::Foo;\ninner::call_method(&amp;foo); // And since the function is public, we can call the\n                          // method through it.\n```\n\n2. Make the item public:\n\n```\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        pub fn method(&amp;self) {} // It\&#39;s now public.\n    }\n}\n\nlet foo = inner::Foo;\nfoo.method(); // Ok!\n```\n&quot;)]</code></pre><div class='stability'><div class='stab unstable'><details><summary><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>rustc_private</code>)</summary><p>this crate is being loaded from the sysroot, an unstable location; did you mean to load this crate from crates.io via <code>Cargo.toml</code> instead?</p>
</details></div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>↑</dt>
                    <dd>Move up in search results</dd>
                    <dt>↓</dt>
                    <dd>Move down in search results</dd>
                    <dt>↹</dt>
                    <dd>Switch tab</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "rustc_typeck";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>