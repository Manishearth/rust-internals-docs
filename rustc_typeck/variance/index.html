<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `variance` mod in crate `rustc_typeck`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, variance">

    <title>rustc_typeck::variance - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../../rustc_typeck/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='logo' width='100'></a>
        <p class='location'><a href='../index.html'>rustc_typeck</a></p><script>window.sidebarCurrent = {name: 'variance', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Module <a href='../index.html'>rustc_typeck</a>::<wbr><a class='mod' href=''>variance</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-11899' class='srclink' href='../../src/rustc_typeck/variance.rs.html#11-1250' title='goto source code'>[src]</a></span></h1>
<div class='stability'><em class='stab unstable'>Unstable (<code>rustc_private</code>)</em></div><div class='docblock'><p>This file infers the variance of type and lifetime parameters. The
algorithm is taken from Section 4 of the paper &quot;Taming the Wildcards:
Combining Definition- and Use-Site Variance&quot; published in PLDI&#39;11 and
written by Altidor et al., and hereafter referred to as The Paper.</p>

<p>This inference is explicitly designed <em>not</em> to consider the uses of
types within code. To determine the variance of type parameters
defined on type <code>X</code>, we only consider the definition of the type <code>X</code>
and the definitions of any types it references.</p>

<p>We only infer variance for type parameters found on <em>data types</em>
like structs and enums. In these cases, there is fairly straightforward
explanation for what variance means. The variance of the type
or lifetime parameters defines whether <code>T&lt;A&gt;</code> is a subtype of <code>T&lt;B&gt;</code>
(resp. <code>T&lt;&#39;a&gt;</code> and <code>T&lt;&#39;b&gt;</code>) based on the relationship of <code>A</code> and <code>B</code>
(resp. <code>&#39;a</code> and <code>&#39;b</code>).</p>

<p>We do not infer variance for type parameters found on traits, fns,
or impls. Variance on trait parameters can make indeed make sense
(and we used to compute it) but it is actually rather subtle in
meaning and not that useful in practice, so we removed it. See the
addendum for some details. Variances on fn/impl parameters, otoh,
doesn&#39;t make sense because these parameters are instantiated and
then forgotten, they don&#39;t persist in types or compiled
byproducts.</p>

<h3 id='the-algorithm' class='section-header'><a href='#the-algorithm'>The algorithm</a></h3>
<p>The basic idea is quite straightforward. We iterate over the types
defined and, for each use of a type parameter X, accumulate a
constraint indicating that the variance of X must be valid for the
variance of that use site. We then iteratively refine the variance of
X until all constraints are met. There is <em>always</em> a sol&#39;n, because at
the limit we can declare all type parameters to be invariant and all
constraints will be satisfied.</p>

<p>As a simple example, consider:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> { <span class='prelude-val'>Some</span>(<span class='ident'>A</span>), <span class='prelude-val'>None</span> }
<span class='kw'>enum</span> <span class='ident'>OptionalFn</span><span class='op'>&lt;</span><span class='ident'>B</span><span class='op'>&gt;</span> { <span class='prelude-val'>Some</span>(<span class='op'>|</span><span class='ident'>B</span><span class='op'>|</span>), <span class='prelude-val'>None</span> }
<span class='kw'>enum</span> <span class='ident'>OptionalMap</span><span class='op'>&lt;</span><span class='ident'>C</span><span class='op'>&gt;</span> { <span class='prelude-val'>Some</span>(<span class='op'>|</span><span class='ident'>C</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>C</span>), <span class='prelude-val'>None</span> }</pre>

<p>Here, we will generate the constraints:</p>
<pre class='rust rust-example-rendered'>
<span class='number'>1.</span> <span class='ident'>V</span>(<span class='ident'>A</span>) <span class='op'>&lt;=</span> <span class='op'>+</span>
<span class='number'>2.</span> <span class='ident'>V</span>(<span class='ident'>B</span>) <span class='op'>&lt;=</span> <span class='op'>-</span>
<span class='number'>3.</span> <span class='ident'>V</span>(<span class='ident'>C</span>) <span class='op'>&lt;=</span> <span class='op'>+</span>
<span class='number'>4.</span> <span class='ident'>V</span>(<span class='ident'>C</span>) <span class='op'>&lt;=</span> <span class='op'>-</span></pre>

<p>These indicate that (1) the variance of A must be at most covariant;
(2) the variance of B must be at most contravariant; and (3, 4) the
variance of C must be at most covariant <em>and</em> contravariant. All of these
results are based on a variance lattice defined as follows:</p>
<pre class='rust rust-example-rendered'>
  <span class='op'>*</span>      <span class='ident'>Top</span> (<span class='ident'>bivariant</span>)</pre>

<ul>
<li>    +
  o      Bottom (invariant)</li>
</ul>

<p>Based on this lattice, the solution V(A)=+, V(B)=-, V(C)=o is the
optimal solution. Note that there is always a naive solution which
just declares all variables to be invariant.</p>

<p>You may be wondering why fixed-point iteration is required. The reason
is that the variance of a use site may itself be a function of the
variance of other type parameters. In full generality, our constraints
take the form:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>V</span>(<span class='ident'>X</span>) <span class='op'>&lt;=</span> <span class='ident'>Term</span>
<span class='ident'>Term</span> :<span class='op'>=</span> <span class='op'>+</span> <span class='op'>|</span> <span class='op'>-</span> <span class='op'>|</span> <span class='op'>*</span> <span class='op'>|</span> <span class='ident'>o</span> <span class='op'>|</span> <span class='ident'>V</span>(<span class='ident'>X</span>) <span class='op'>|</span> <span class='ident'>Term</span> <span class='ident'>x</span> <span class='ident'>Term</span></pre>

<p>Here the notation V(X) indicates the variance of a type/region
parameter <code>X</code> with respect to its defining class. <code>Term x Term</code>
represents the &quot;variance transform&quot; as defined in the paper:</p>

<p>If the variance of a type variable <code>X</code> in type expression <code>E</code> is <code>V2</code>
  and the definition-site variance of the [corresponding] type parameter
  of a class <code>C</code> is <code>V1</code>, then the variance of <code>X</code> in the type expression
  <code>C&lt;E&gt;</code> is <code>V3 = V1.xform(V2)</code>.</p>

<h3 id='constraints' class='section-header'><a href='#constraints'>Constraints</a></h3>
<p>If I have a struct or enum with where clauses:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span>:<span class='ident'>Bar</span><span class='op'>&gt;</span> { ... }</pre>

<p>you might wonder whether the variance of <code>T</code> with respect to <code>Bar</code>
affects the variance <code>T</code> with respect to <code>Foo</code>. I claim no.  The
reason: assume that <code>T</code> is invariant w/r/t <code>Bar</code> but covariant w/r/t
<code>Foo</code>. And then we have a <code>Foo&lt;X&gt;</code> that is upcast to <code>Foo&lt;Y&gt;</code>, where
<code>X &lt;: Y</code>. However, while <code>X : Bar</code>, <code>Y : Bar</code> does not hold.  In that
case, the upcast will be illegal, but not because of a variance
failure, but rather because the target type <code>Foo&lt;Y&gt;</code> is itself just
not well-formed. Basically we get to assume well-formedness of all
types involved before considering variance.</p>

<h3 id='addendum-variance-on-traits' class='section-header'><a href='#addendum-variance-on-traits'>Addendum: Variance on traits</a></h3>
<p>As mentioned above, we used to permit variance on traits. This was
computed based on the appearance of trait type parameters in
method signatures and was used to represent the compatibility of
vtables in trait objects (and also &quot;virtual&quot; vtables or dictionary
in trait bounds). One complication was that variance for
associated types is less obvious, since they can be projected out
and put to myriad uses, so it&#39;s not clear when it is safe to allow
<code>X&lt;A&gt;::Bar</code> to vary (or indeed just what that means). Moreover (as
covered below) all inputs on any trait with an associated type had
to be invariant, limiting the applicability. Finally, the
annotations (<code>MarkerTrait</code>, <code>PhantomFn</code>) needed to ensure that all
trait type parameters had a variance were confusing and annoying
for little benefit.</p>

<p>Just for historical reference,I am going to preserve some text indicating
how one could interpret variance and trait matching.</p>

<h4 id='variance-and-object-types' class='section-header'><a href='#variance-and-object-types'>Variance and object types</a></h4>
<p>Just as with structs and enums, we can decide the subtyping
relationship between two object types <code>&amp;Trait&lt;A&gt;</code> and <code>&amp;Trait&lt;B&gt;</code>
based on the relationship of <code>A</code> and <code>B</code>. Note that for object
types we ignore the <code>Self</code> type parameter -- it is unknown, and
the nature of dynamic dispatch ensures that we will always call a
function that is expected the appropriate <code>Self</code> type. However, we
must be careful with the other type parameters, or else we could
end up calling a function that is expecting one type but provided
another.</p>

<p>To see what I mean, consider a trait like so:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>convertTo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>A</span>;
}</pre>

<p>Intuitively, If we had one object <code>O=&amp;ConvertTo&lt;Object&gt;</code> and another
<code>S=&amp;ConvertTo&lt;String&gt;</code>, then <code>S &lt;: O</code> because <code>String &lt;: Object</code>
(presuming Java-like &quot;string&quot; and &quot;object&quot; types, my go to examples
for subtyping). The actual algorithm would be to compare the
(explicit) type parameters pairwise respecting their variance: here,
the type parameter A is covariant (it appears only in a return
position), and hence we require that <code>String &lt;: Object</code>.</p>

<p>You&#39;ll note though that we did not consider the binding for the
(implicit) <code>Self</code> type parameter: in fact, it is unknown, so that&#39;s
good. The reason we can ignore that parameter is precisely because we
don&#39;t need to know its value until a call occurs, and at that time (as
you said) the dynamic nature of virtual dispatch means the code we run
will be correct for whatever value <code>Self</code> happens to be bound to for
the particular object whose method we called. <code>Self</code> is thus different
from <code>A</code>, because the caller requires that <code>A</code> be known in order to
know the return type of the method <code>convertTo()</code>. (As an aside, we
have rules preventing methods where <code>Self</code> appears outside of the
receiver position from being called via an object.)</p>

<h4 id='trait-variance-and-vtable-resolution' class='section-header'><a href='#trait-variance-and-vtable-resolution'>Trait variance and vtable resolution</a></h4>
<p>But traits aren&#39;t only used with objects. They&#39;re also used when
deciding whether a given impl satisfies a given trait bound. To set the
scene here, imagine I had a function:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>convertAll</span><span class='op'>&lt;</span><span class='ident'>A</span>,<span class='ident'>T</span>:<span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;&gt;</span>(<span class='ident'>v</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>]) {
    ...
}</pre>

<p>Now imagine that I have an implementation of <code>ConvertTo</code> for <code>Object</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Object</span> { ... }</pre>

<p>And I want to call <code>convertAll</code> on an array of strings. Suppose
further that for whatever reason I specifically supply the value of
<code>String</code> for the type parameter <code>T</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>vector</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;string&quot;</span>, ...];
<span class='ident'>convertAll</span>::<span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>String</span><span class='op'>&gt;</span>(<span class='ident'>vector</span>);</pre>

<p>Is this legal? To put another way, can we apply the <code>impl</code> for
<code>Object</code> to the type <code>String</code>? The answer is yes, but to see why
we have to expand out what will happen:</p>

<ul>
<li><code>convertAll</code> will create a pointer to one of the entries in the
vector, which will have type <code>&amp;String</code></li>
<li><p>It will then call the impl of <code>convertTo()</code> that is intended
for use with objects. This has the type:</p>

<p>fn(self: &amp;Object) -&gt; i32</p>

<p>It is ok to provide a value for <code>self</code> of type <code>&amp;String</code> because
<code>&amp;String &lt;: &amp;Object</code>.</p></li>
</ul>

<p>OK, so intuitively we want this to be legal, so let&#39;s bring this back
to variance and see whether we are computing the correct result. We
must first figure out how to phrase the question &quot;is an impl for
<code>Object,i32</code> usable where an impl for <code>String,i32</code> is expected?&quot;</p>

<p>Maybe it&#39;s helpful to think of a dictionary-passing implementation of
type classes. In that case, <code>convertAll()</code> takes an implicit parameter
representing the impl. In short, we <em>have</em> an impl of type:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>V_O</span> <span class='op'>=</span> <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Object</span></pre>

<p>and the function prototype expects an impl of type:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>V_S</span> <span class='op'>=</span> <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>String</span></pre>

<p>As with any argument, this is legal if the type of the value given
(<code>V_O</code>) is a subtype of the type expected (<code>V_S</code>). So is <code>V_O &lt;: V_S</code>?
The answer will depend on the variance of the various parameters. In
this case, because the <code>Self</code> parameter is contravariant and <code>A</code> is
covariant, it means that:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>V_O</span> <span class='op'>&lt;</span>: <span class='ident'>V_S</span> <span class='ident'>iff</span>
    <span class='ident'>i32</span> <span class='op'>&lt;</span>: <span class='ident'>i32</span>
    <span class='ident'>String</span> <span class='op'>&lt;</span>: <span class='ident'>Object</span></pre>

<p>These conditions are satisfied and so we are happy.</p>

<h4 id='variance-and-associated-types' class='section-header'><a href='#variance-and-associated-types'>Variance and associated types</a></h4>
<p>Traits with associated types -- or at minimum projection
expressions -- must be invariant with respect to all of their
inputs. To see why this makes sense, consider what subtyping for a
trait reference means:</p>

<p><T as Trait> &lt;: <U as Trait></p>

<p>means that if I know that <code>T as Trait</code>, I also know that <code>U as Trait</code>. Moreover, if you think of it as dictionary passing style,
it means that a dictionary for <code>&lt;T as Trait&gt;</code> is safe to use where
a dictionary for <code>&lt;U as Trait&gt;</code> is expected.</p>

<p>The problem is that when you can project types out from <code>&lt;T as Trait&gt;</code>, the relationship to types projected out of <code>&lt;U as Trait&gt;</code>
is completely unknown unless <code>T==U</code> (see #21726 for more
details). Making <code>Trait</code> invariant ensures that this is true.</p>

<p>Another related reason is that if we didn&#39;t make traits with
associated types invariant, then projection is no longer a
function with a single result. Consider:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Identity</span> { <span class='kw'>type</span> <span class='ident'>Out</span>; <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>); }
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Identity</span> <span class='kw'>for</span> <span class='ident'>T</span> { <span class='kw'>type</span> <span class='ident'>Out</span> <span class='op'>=</span> <span class='ident'>T</span>; ... }</pre>

<p>Now if I have <code>&lt;&amp;&#39;static () as Identity&gt;::Out</code>, this can be
validly derived as <code>&amp;&#39;a ()</code> for any <code>&#39;a</code>:</p>

<p>&lt;&amp;&#39;a () as Identity&gt; &lt;: &lt;&amp;&#39;static () as Identity&gt;
   if &amp;&#39;static () &lt; : &amp;&#39;a ()   -- Identity is contravariant in Self
   if &#39;static : &#39;a             -- Subtyping rules for relations</p>

<p>This change otoh means that <code>&lt;&#39;static () as Identity&gt;::Out</code> is
always <code>&amp;&#39;static ()</code> (which might then be upcast to <code>&#39;a ()</code>,
separately). This was helpful in solving #21750.</p>
</div><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr class='unstable module-item'>
                        <td><a class='fn' href='fn.infer_variance.html'
                               title='rustc_typeck::variance::infer_variance'>infer_variance</a></td>
                        <td class='docblock short'>
                            [<em class='stab unstable'>Unstable</em>] 
                        </td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "rustc_typeck";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script defer src="../../search-index.js"></script>
</body>
</html>