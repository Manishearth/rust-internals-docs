initSidebarItems({"enum":[["GenericKind",""],["IntVarValue",""],["LateBoundRegionConversionTime","Times when we replace late-bound regions with variables:"],["RegionVariableOrigin","Reasons to create a region inference variable"],["SubregionOrigin","The origin of a `r1 <= r2` constraint."],["TypeOrigin","Why did we require that the two types be related?"],["ValuePairs","See `error_reporting.rs` for more details"],["fixup_err",""]],"fn":[["can_mk_eqty",""],["can_mk_subty",""],["common_supertype","Computes the least upper-bound of `a` and `b`. If this is not possible, reports an error and returns ty::err."],["fixup_err_to_string",""],["mk_eqty",""],["mk_sub_poly_trait_refs",""],["mk_subr",""],["mk_subty",""],["new_infer_ctxt",""]],"mod":[["bivariate","Applies the \"bivariance relationship\" to two types and/or regions. If (A,B) are bivariant then either A <: B or B <: A. It occurs when type/lifetime parameters are unconstrained. Usually this is an error, but we permit it in the specific case where a type parameter is constrained in a where-clause via an associated type."],["combine",""],["equate",""],["error_reporting","Error Reporting Code for the inference engine"],["glb",""],["lattice","Lattice Variables"],["lub",""],["region_inference","See README.md"],["resolve",""],["sub",""],["type_variable",""],["unify_key",""]],"struct":[["CombinedSnapshot",""],["InferCtxt",""],["TypeFreshener",""],["TypeTrace","The trace designates the path through inference that we took to encounter an error or subtyping constraint."]],"type":[["Bound",""],["SkolemizationMap",""],["UnitResult",""],["fres",""]]});