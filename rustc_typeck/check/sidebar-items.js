initSidebarItems({"enum":[["Expectation","When type-checking an expression, we propagate downward whatever type hint we are able in the form of an `Expectation`."],["UnresolvedTypeAction","Whether `autoderef` requires types to resolve."]],"fn":[["check_bounds_are_used",""],["check_drop_impls",""],["check_enum_variants",""],["check_item_bodies",""],["check_item_body",""],["check_item_type",""],["check_item_types",""],["check_representable","Checks whether a type can be represented in memory. In particular, it identifies types that contain themselves without indirection through a pointer, which would mean their size is unbounded."],["check_simd",""],["check_struct",""],["check_wf_new",""],["compare_const_impl",""],["compare_impl_method","Checks that a method from an impl conforms to the signature of the same method as declared in the trait."],["may_break",""]],"mod":[["_match",""],["coercion","Type Coercion"],["demand",""],["dropck",""],["method","Method lookup: the secret sauce of Rust. See `README.md`."],["regionck","The region check is a final pass that runs over the AST after we have inferred the type constraints but before we have actually finalized the types.  Its purpose is to embed a variety of region constraints. Inserting these constraints as a separate pass is good because (1) it localizes the code that has to do with region inference and (2) often we cannot know what constraints are needed until the basic types have been inferred."],["writeback",""]],"struct":[["FnCtxt",""],["Inherited","closures defined within the function.  For example:"],["InheritedBuilder","Helper type of a temporary returned by ccx.inherited(...). Necessary because we can't write the following bound: F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Inherited<'b, 'gcx, 'tcx>)."],["UnsafetyState",""]]});