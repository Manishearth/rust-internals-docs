initSidebarItems({"enum":[["Expectation","When type-checking an expression, we propagate downward whatever type hint we are able in the form of an `Expectation`."],["UnresolvedTypeAction","Whether `autoderef` requires types to resolve."]],"fn":[["autoderef","Executes an autoderef loop for the type `t`. At each step, invokes `should_stop` to decide whether to terminate the loop. Returns the final type and number of derefs that it performed.Note: this method does not modify the adjustments table. The caller is responsible for inserting an AutoAdjustment record into the `fcx` using one of the suitable methods."],["blank_fn_ctxt",""],["check_block_no_value",""],["check_bounds_are_used",""],["check_decl_initializer",""],["check_decl_local",""],["check_drop_impls",""],["check_enum_variants",""],["check_expr_has_type",""],["check_item_bodies",""],["check_item_body",""],["check_item_type",""],["check_item_types",""],["check_representable","Checks whether a type can be represented in memory. In particular, it identifies types that contain themselves without indirection through a pointer, which would mean their size is unbounded."],["check_simd",""],["check_stmt",""],["check_struct",""],["check_wf_new",""],["compare_const_impl",""],["compare_impl_method","Checks that a method from an impl conforms to the signature of the same method as declared in the trait.Parametersimpl_m: type of the method we are checking impl_m_span: span to use for reporting errors impl_m_body_id: id of the method body trait_m: the method in the trait impl_trait_ref: the TraitRef corresponding to the trait implementation"],["impl_self_ty",""],["instantiate_path",""],["may_break",""],["resolve_ty_and_def_ufcs",""],["structurally_resolved_type",""]],"mod":[["_match",""],["coercion","Type CoercionUnder certain circumstances we will coerce from one type to another, for example by auto-borrowing.  This occurs in situations where the compiler has a firm 'expected type' that was supplied from the user, and where the actual type is similar to that expected type in purpose but not in representation (so actual subtyping is inappropriate).ReborrowingNote that if we are expecting a reference, we will *reborrow* even if the argument provided was already a reference.  This is useful for freezing mut/const things (that is, when the expected is &T but you have &const T or &mut T) and also for avoiding the linearity of mut things (when the expected is &mut T and you have &mut T).  See the various `src/test/run-pass/coerce-reborrow-*.rs` tests for examples of where this is useful.Subtle noteWhen deciding what type coercions to consider, we do not attempt to resolve any type variables we may encounter.  This is because `b` represents the expected type \"as the user wrote it\", meaning that if the user defined a generic function like   fn foo<A>(a: A, b: A) { ... }and then we wrote `foo(&1, @2)`, we will not auto-borrow either argument.  In older code we went to some lengths to resolve the `b` variable, which could mean that we'd auto-borrow later arguments but not earlier ones, which seems very confusing.Subtler noteHowever, right now, if the user manually specifies the values for the type variables, as so:   foo::<&int>(@1, @2)then we *will* auto-borrow, because we can't distinguish this from a function that declared `&int`.  This is inconsistent but it's easiest at the moment. The right thing to do, I think, is to consider the *unsubstituted* type when deciding whether to auto-borrow, but the *substituted* type when considering the bounds and so forth. But most of our methods don't give access to the unsubstituted type, and rightly so because they'd be error-prone.  So maybe the thing to do is to actually determine the kind of coercions that should occur separately and pass them in.  Or maybe it's ok as is.  Anyway, it's sort of a minor point so I've opted to leave it for later---after all we may want to adjust precisely when coercions occur."],["demand",""],["dropck",""],["method","Method lookup: the secret sauce of Rust. See `README.md`."],["regionck","The region check is a final pass that runs over the AST after we have inferred the type constraints but before we have actually finalized the types.  Its purpose is to embed a variety of region constraints. Inserting these constraints as a separate pass is good because (1) it localizes the code that has to do with region inference and (2) often we cannot know what constraints are needed until the basic types have been inferred.Interaction with the borrow checkerIn general, the job of the borrowck module (which runs later) is to check that all soundness criteria are met, given a particular set of regions. The job of *this* module is to anticipate the needs of the borrow checker and infer regions that will satisfy its requirements. It is generally true that the inference doesn't need to be sound, meaning that if there is a bug and we inferred bad regions, the borrow checker should catch it. This is not entirely true though; for example, the borrow checker doesn't check subtyping, and it doesn't check that region pointers are always live when they are used. It might be worthwhile to fix this so that borrowck serves as a kind of verification step -- that would add confidence in the overall correctness of the compiler, at the cost of duplicating some type checks and effort.Inferring the duration of borrows, automatic and otherwiseWhenever we introduce a borrowed pointer, for example as the result of a borrow expression `let x = &data`, the lifetime of the pointer `x` is always specified as a region inference variable. `regionck` has the job of adding constraints such that this inference variable is as narrow as possible while still accommodating all uses (that is, every dereference of the resulting pointer must be within the lifetime).ReborrowsGenerally speaking, `regionck` does NOT try to ensure that the data `data` will outlive the pointer `x`. That is the job of borrowck.  The one exception is when \"re-borrowing\" the contents of another borrowed pointer. For example, imagine you have a borrowed pointer `b` with lifetime L1 and you have an expression `&*b`. The result of this expression will be another borrowed pointer with lifetime L2 (which is an inference variable). The borrow checker is going to enforce the constraint that L2 < L1, because otherwise you are re-borrowing data for a lifetime larger than the original loan.  However, without the routines in this module, the region inferencer would not know of this dependency and thus it might infer the lifetime of L2 to be greater than L1 (issue #3148).There are a number of troublesome scenarios in the tests `region-dependent-*.rs`, but here is one example:Note that this comes up either with `&` expressions, `ref` bindings, and `autorefs`, which are the three ways to introduce a borrow.The key point here is that when you are borrowing a value that is \"guaranteed\" by a borrowed pointer, you must link the lifetime of that borrowed pointer (L1, here) to the lifetime of the borrow itself (L2).  What do I mean by \"guaranteed\" by a borrowed pointer? I mean any data that is reached by first dereferencing a borrowed pointer and then either traversing interior offsets or boxes.  We say that the guarantor of such data is the region of the borrowed pointer that was traversed.  This is essentially the same as the ownership relation, except that a borrowed pointer never owns its contents."],["writeback",""]],"struct":[["FnCtxt",""],["Inherited","closures defined within the function.  For example:Here, the function `foo()` and the closure passed to `bar()` will each have their own `FnCtxt`, but they will share the inherited fields."],["UnsafetyState",""]]});