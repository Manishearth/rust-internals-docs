initSidebarItems({"constant":[["ITEM_LIKE_SPACE",""],["REGULAR_SPACE",""]],"enum":[["DefPathData",""],["Node",""]],"fn":[["map_crate",""]],"mod":[["blocks","This module provides a simplified abstraction for working with code blocks identified by their integer node-id.  In particular, it captures a common set of attributes that all \"function-like things\" (represented by `FnLike` instances) share.  For example, all `FnLike` instances have a type signature (be it explicit or inferred).  And all `FnLike` instances have a body, i.e. the code that is run when the function-like thing it represents is invoked."],["definitions","For each definition, we track the following data.  A definition here is defined somewhat circularly as \"something with a def-id\", but it generally corresponds to things like structs, enums, etc. There are also some rather random cases (like const initializer expressions) that are mostly just leftovers."]],"struct":[["DefCollector","Creates def ids for nodes in the AST."],["DefKey","A unique identifier that we can use to lookup a definition precisely. It combines the index of the definition's parent (if any) with a `DisambiguatedDefPathData`."],["DefPath",""],["Definitions","The definition table containing node definitions. It holds the DefPathTable for local DefIds/DefPaths and it also stores a mapping from NodeIds to local DefIds."],["DisambiguatedDefPathData","Pair of `DefPathData` and an integer disambiguator. The integer is normally 0, but in the event that there are multiple defs with the same `parent` and `data`, we use this field to disambiguate between them. This introduces some artificial ordering dependency but means that if you have (e.g.) two impls for the same type in the same module, they do get distinct def-ids."],["Forest","Stores a crate and any number of inlined items from other crates."],["MacroInvocationData",""],["Map","Represents a mapping from Node IDs to AST elements and their parent Node IDs"],["NodesMatchingSuffix",""]]});