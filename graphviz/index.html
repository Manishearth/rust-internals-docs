<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `graphviz` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, graphviz">

    <title>graphviz - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../graphviz/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='logo' width='100'></a>
        <p class='location'>Crate graphviz</p><div class='block version'><p>Version 1.22.0-dev</p></div><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'graphviz', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>graphviz</a></span><span class='out-of-band'><span class='since' title='Stable since Rust version '></span><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/graphviz/lib.rs.html#11-1144' title='goto source code'>[src]</a></span></h1>
<div class='stability'><div class='stab unstable'><details><summary><span class=microscope>ðŸ”¬</span> This is a nightly-only experimental API.  (<code>rustc_private</code>)</summary><p>this crate is being loaded from the sysroot, an unstable location; did you mean to load this crate from crates.io via <code>Cargo.toml</code> instead?</p>
</details></div></div><div class='docblock'><p>Generate files suitable for use with <a href="http://www.graphviz.org/">Graphviz</a></p>

<p>The <code>render</code> function generates output (e.g. an <code>output.dot</code> file) for
use with <a href="http://www.graphviz.org/">Graphviz</a> by walking a labeled
graph. (Graphviz can then automatically lay out the nodes and edges
of the graph, and also optionally render the graph as an image or
other <a href="http://www.graphviz.org/content/output-formats">output formats</a>, such as SVG.)</p>

<p>Rather than impose some particular graph data structure on clients,
this library exposes two traits that clients can implement on their
own structs before handing them over to the rendering function.</p>

<p>Note: This library does not yet provide access to the full
expressiveness of the <a href="http://www.graphviz.org/doc/info/lang.html">DOT language</a>. For example, there are
many <a href="http://www.graphviz.org/content/attrs">attributes</a> related to
providing layout hints (e.g. left-to-right versus top-down, which
algorithm to use, etc). The current intention of this library is to
emit a human-readable .dot file with very regular structure suitable
for easy post-processing.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>The first example uses a very simple graph representation: a list of
pairs of ints, representing the edges (the node set is implicit).
Each node label is derived directly from the int representing the node,
while the edge labels are all empty strings.</p>

<p>This example also illustrates how to use <code>Cow&lt;[T]&gt;</code> to return
an owned vector or a borrowed slice as appropriate: we construct the
node vector from scratch, but borrow the edge list (rather than
constructing a copy of all the edges from scratch).</p>

<p>The output from this example renders five nodes, with the first four
forming a diamond-shaped acyclic graph and then pointing to the fifth
which is cyclic.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">rustc_private</span>)]</span>

<span class="kw">use</span> <span class="ident">graphviz</span>::<span class="ident">IntoCow</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Write</span>;
<span class="kw">use</span> <span class="ident">graphviz</span> <span class="kw">as</span> <span class="ident">dot</span>;

<span class="kw">type</span> <span class="ident">Nd</span> <span class="op">=</span> <span class="ident">isize</span>;
<span class="kw">type</span> <span class="ident">Ed</span> <span class="op">=</span> (<span class="ident">isize</span>,<span class="ident">isize</span>);
<span class="kw">struct</span> <span class="ident">Edges</span>(<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Ed</span><span class="op">&gt;</span>);

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">render_to</span><span class="op">&lt;</span><span class="ident">W</span>: <span class="ident">Write</span><span class="op">&gt;</span>(<span class="ident">output</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">W</span>) {
    <span class="kw">let</span> <span class="ident">edges</span> <span class="op">=</span> <span class="ident">Edges</span>(<span class="macro">vec</span><span class="macro">!</span>[(<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">2</span>), (<span class="number">1</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">3</span>), (<span class="number">3</span>,<span class="number">4</span>), (<span class="number">4</span>,<span class="number">4</span>)]);
    <span class="ident">dot</span>::<span class="ident">render</span>(<span class="kw-2">&amp;</span><span class="ident">edges</span>, <span class="ident">output</span>).<span class="ident">unwrap</span>()
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">dot</span>::<span class="ident">Labeller</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Edges</span> {
    <span class="kw">type</span> <span class="ident">Node</span> <span class="op">=</span> <span class="ident">Nd</span>;
    <span class="kw">type</span> <span class="ident">Edge</span> <span class="op">=</span> <span class="ident">Ed</span>;
    <span class="kw">fn</span> <span class="ident">graph_id</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Id</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> { <span class="ident">dot</span>::<span class="ident">Id</span>::<span class="ident">new</span>(<span class="string">&quot;example1&quot;</span>).<span class="ident">unwrap</span>() }

    <span class="kw">fn</span> <span class="ident">node_id</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>, <span class="ident">n</span>: <span class="kw-2">&amp;</span><span class="ident">Nd</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Id</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
        <span class="ident">dot</span>::<span class="ident">Id</span>::<span class="ident">new</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;N{}&quot;</span>, <span class="kw-2">*</span><span class="ident">n</span>)).<span class="ident">unwrap</span>()
    }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">dot</span>::<span class="ident">GraphWalk</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Edges</span> {
    <span class="kw">type</span> <span class="ident">Node</span> <span class="op">=</span> <span class="ident">Nd</span>;
    <span class="kw">type</span> <span class="ident">Edge</span> <span class="op">=</span> <span class="ident">Ed</span>;
    <span class="kw">fn</span> <span class="ident">nodes</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Nodes</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>,<span class="ident">Nd</span><span class="op">&gt;</span> {
        <span class="comment">// (assumes that |N| \approxeq |E|)</span>
        <span class="kw">let</span> <span class="kw-2">&amp;</span><span class="ident">Edges</span>(<span class="kw-2">ref</span> <span class="ident">v</span>) <span class="op">=</span> <span class="self">self</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">nodes</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="ident">v</span>.<span class="ident">len</span>());
        <span class="kw">for</span> <span class="kw-2">&amp;</span>(<span class="ident">s</span>,<span class="ident">t</span>) <span class="kw">in</span> <span class="ident">v</span> {
            <span class="ident">nodes</span>.<span class="ident">push</span>(<span class="ident">s</span>); <span class="ident">nodes</span>.<span class="ident">push</span>(<span class="ident">t</span>);
        }
        <span class="ident">nodes</span>.<span class="ident">sort</span>();
        <span class="ident">nodes</span>.<span class="ident">dedup</span>();
        <span class="ident">nodes</span>.<span class="ident">into_cow</span>()
    }

    <span class="kw">fn</span> <span class="ident">edges</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Edges</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>,<span class="ident">Ed</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="kw-2">&amp;</span><span class="ident">Edges</span>(<span class="kw-2">ref</span> <span class="ident">edges</span>) <span class="op">=</span> <span class="self">self</span>;
        (<span class="kw-2">&amp;</span><span class="ident">edges</span>[..]).<span class="ident">into_cow</span>()
    }

    <span class="kw">fn</span> <span class="ident">source</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">e</span>: <span class="kw-2">&amp;</span><span class="ident">Ed</span>) <span class="op">-&gt;</span> <span class="ident">Nd</span> { <span class="kw">let</span> <span class="kw-2">&amp;</span>(<span class="ident">s</span>,_) <span class="op">=</span> <span class="ident">e</span>; <span class="ident">s</span> }

    <span class="kw">fn</span> <span class="ident">target</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">e</span>: <span class="kw-2">&amp;</span><span class="ident">Ed</span>) <span class="op">-&gt;</span> <span class="ident">Nd</span> { <span class="kw">let</span> <span class="kw-2">&amp;</span>(_,<span class="ident">t</span>) <span class="op">=</span> <span class="ident">e</span>; <span class="ident">t</span> }
}
</pre>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">create</span>(<span class="string">&quot;example1.dot&quot;</span>).<span class="ident">unwrap</span>();
    <span class="ident">render_to</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">f</span>)
}</pre>

<p>Output from first example (in <code>example1.dot</code>):</p>

<pre><code class="language-dot">digraph example1 {
    N0[label=&quot;N0&quot;];
    N1[label=&quot;N1&quot;];
    N2[label=&quot;N2&quot;];
    N3[label=&quot;N3&quot;];
    N4[label=&quot;N4&quot;];
    N0 -&gt; N1[label=&quot;&quot;];
    N0 -&gt; N2[label=&quot;&quot;];
    N1 -&gt; N3[label=&quot;&quot;];
    N2 -&gt; N3[label=&quot;&quot;];
    N3 -&gt; N4[label=&quot;&quot;];
    N4 -&gt; N4[label=&quot;&quot;];
}
</code></pre>

<p>The second example illustrates using <code>node_label</code> and <code>edge_label</code> to
add labels to the nodes and edges in the rendered graph. The graph
here carries both <code>nodes</code> (the label text to use for rendering a
particular node), and <code>edges</code> (again a list of <code>(source,target)</code>
indices).</p>

<p>This example also illustrates how to use a type (in this case the edge
type) that shares substructure with the graph: the edge type here is a
direct reference to the <code>(source,target)</code> pair stored in the graph&#39;s
internal vector (rather than passing around a copy of the pair
itself). Note that this implies that <code>fn edges(&amp;&#39;a self)</code> must
construct a fresh <code>Vec&lt;&amp;&#39;a (usize,usize)&gt;</code> from the <code>Vec&lt;(usize,usize)&gt;</code>
edges stored in <code>self</code>.</p>

<p>Since both the set of nodes and the set of edges are always
constructed from scratch via iterators, we use the <code>collect()</code> method
from the <code>Iterator</code> trait to collect the nodes and edges into freshly
constructed growable <code>Vec</code> values (rather use the <code>into_cow</code>
from the <code>IntoCow</code> trait as was used in the first example
above).</p>

<p>The output from this example renders four nodes that make up the
Hasse-diagram for the subsets of the set <code>{x, y}</code>. Each edge is
labeled with the &sube; character (specified using the HTML character
entity <code>&amp;sube</code>).</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">rustc_private</span>)]</span>

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Write</span>;
<span class="kw">use</span> <span class="ident">graphviz</span> <span class="kw">as</span> <span class="ident">dot</span>;

<span class="kw">type</span> <span class="ident">Nd</span> <span class="op">=</span> <span class="ident">usize</span>;
<span class="kw">type</span> <span class="ident">Ed</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> (<span class="ident">usize</span>, <span class="ident">usize</span>);
<span class="kw">struct</span> <span class="ident">Graph</span> { <span class="ident">nodes</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>, <span class="ident">edges</span>: <span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">usize</span>,<span class="ident">usize</span>)<span class="op">&gt;</span> }

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">render_to</span><span class="op">&lt;</span><span class="ident">W</span>: <span class="ident">Write</span><span class="op">&gt;</span>(<span class="ident">output</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">W</span>) {
    <span class="kw">let</span> <span class="ident">nodes</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;{x,y}&quot;</span>,<span class="string">&quot;{x}&quot;</span>,<span class="string">&quot;{y}&quot;</span>,<span class="string">&quot;{}&quot;</span>];
    <span class="kw">let</span> <span class="ident">edges</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[(<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">2</span>), (<span class="number">1</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">3</span>)];
    <span class="kw">let</span> <span class="ident">graph</span> <span class="op">=</span> <span class="ident">Graph</span> { <span class="ident">nodes</span>: <span class="ident">nodes</span>, <span class="ident">edges</span>: <span class="ident">edges</span> };

    <span class="ident">dot</span>::<span class="ident">render</span>(<span class="kw-2">&amp;</span><span class="ident">graph</span>, <span class="ident">output</span>).<span class="ident">unwrap</span>()
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">dot</span>::<span class="ident">Labeller</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Graph</span> {
    <span class="kw">type</span> <span class="ident">Node</span> <span class="op">=</span> <span class="ident">Nd</span>;
    <span class="kw">type</span> <span class="ident">Edge</span> <span class="op">=</span> <span class="ident">Ed</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>;
    <span class="kw">fn</span> <span class="ident">graph_id</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Id</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> { <span class="ident">dot</span>::<span class="ident">Id</span>::<span class="ident">new</span>(<span class="string">&quot;example2&quot;</span>).<span class="ident">unwrap</span>() }
    <span class="kw">fn</span> <span class="ident">node_id</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>, <span class="ident">n</span>: <span class="kw-2">&amp;</span><span class="ident">Nd</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Id</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
        <span class="ident">dot</span>::<span class="ident">Id</span>::<span class="ident">new</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;N{}&quot;</span>, <span class="ident">n</span>)).<span class="ident">unwrap</span>()
    }
    <span class="kw">fn</span> <span class="ident">node_label</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="self">self</span>, <span class="ident">n</span>: <span class="kw-2">&amp;</span><span class="ident">Nd</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">LabelText</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span> {
        <span class="ident">dot</span>::<span class="ident">LabelText</span>::<span class="ident">LabelStr</span>(<span class="self">self</span>.<span class="ident">nodes</span>[<span class="kw-2">*</span><span class="ident">n</span>].<span class="ident">into</span>())
    }
    <span class="kw">fn</span> <span class="ident">edge_label</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="self">self</span>, _: <span class="kw-2">&amp;</span><span class="ident">Ed</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">LabelText</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span> {
        <span class="ident">dot</span>::<span class="ident">LabelText</span>::<span class="ident">LabelStr</span>(<span class="string">&quot;&amp;sube;&quot;</span>.<span class="ident">into</span>())
    }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">dot</span>::<span class="ident">GraphWalk</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Graph</span> {
    <span class="kw">type</span> <span class="ident">Node</span> <span class="op">=</span> <span class="ident">Nd</span>;
    <span class="kw">type</span> <span class="ident">Edge</span> <span class="op">=</span> <span class="ident">Ed</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>;
    <span class="kw">fn</span> <span class="ident">nodes</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Nodes</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>,<span class="ident">Nd</span><span class="op">&gt;</span> { (<span class="number">0</span>..<span class="self">self</span>.<span class="ident">nodes</span>.<span class="ident">len</span>()).<span class="ident">collect</span>() }
    <span class="kw">fn</span> <span class="ident">edges</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Edges</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>,<span class="ident">Ed</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;&gt;</span> { <span class="self">self</span>.<span class="ident">edges</span>.<span class="ident">iter</span>().<span class="ident">collect</span>() }
    <span class="kw">fn</span> <span class="ident">source</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">e</span>: <span class="kw-2">&amp;</span><span class="ident">Ed</span>) <span class="op">-&gt;</span> <span class="ident">Nd</span> { <span class="kw">let</span> <span class="op">&amp;</span> <span class="kw-2">&amp;</span>(<span class="ident">s</span>,_) <span class="op">=</span> <span class="ident">e</span>; <span class="ident">s</span> }
    <span class="kw">fn</span> <span class="ident">target</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">e</span>: <span class="kw-2">&amp;</span><span class="ident">Ed</span>) <span class="op">-&gt;</span> <span class="ident">Nd</span> { <span class="kw">let</span> <span class="op">&amp;</span> <span class="kw-2">&amp;</span>(_,<span class="ident">t</span>) <span class="op">=</span> <span class="ident">e</span>; <span class="ident">t</span> }
}
</pre>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">create</span>(<span class="string">&quot;example2.dot&quot;</span>).<span class="ident">unwrap</span>();
    <span class="ident">render_to</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">f</span>)
}</pre>

<p>The third example is similar to the second, except now each node and
edge now carries a reference to the string label for each node as well
as that node&#39;s index. (This is another illustration of how to share
structure with the graph itself, and why one might want to do so.)</p>

<p>The output from this example is the same as the second example: the
Hasse-diagram for the subsets of the set <code>{x, y}</code>.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">rustc_private</span>)]</span>

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Write</span>;
<span class="kw">use</span> <span class="ident">graphviz</span> <span class="kw">as</span> <span class="ident">dot</span>;

<span class="kw">type</span> <span class="ident">Nd</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="ident">usize</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span>);
<span class="kw">type</span> <span class="ident">Ed</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="ident">Nd</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>, <span class="ident">Nd</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>);
<span class="kw">struct</span> <span class="ident">Graph</span> { <span class="ident">nodes</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>, <span class="ident">edges</span>: <span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">usize</span>,<span class="ident">usize</span>)<span class="op">&gt;</span> }

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">render_to</span><span class="op">&lt;</span><span class="ident">W</span>: <span class="ident">Write</span><span class="op">&gt;</span>(<span class="ident">output</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">W</span>) {
    <span class="kw">let</span> <span class="ident">nodes</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;{x,y}&quot;</span>,<span class="string">&quot;{x}&quot;</span>,<span class="string">&quot;{y}&quot;</span>,<span class="string">&quot;{}&quot;</span>];
    <span class="kw">let</span> <span class="ident">edges</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[(<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">2</span>), (<span class="number">1</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">3</span>)];
    <span class="kw">let</span> <span class="ident">graph</span> <span class="op">=</span> <span class="ident">Graph</span> { <span class="ident">nodes</span>: <span class="ident">nodes</span>, <span class="ident">edges</span>: <span class="ident">edges</span> };

    <span class="ident">dot</span>::<span class="ident">render</span>(<span class="kw-2">&amp;</span><span class="ident">graph</span>, <span class="ident">output</span>).<span class="ident">unwrap</span>()
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">dot</span>::<span class="ident">Labeller</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Graph</span> {
    <span class="kw">type</span> <span class="ident">Node</span> <span class="op">=</span> <span class="ident">Nd</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>;
    <span class="kw">type</span> <span class="ident">Edge</span> <span class="op">=</span> <span class="ident">Ed</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>;
    <span class="kw">fn</span> <span class="ident">graph_id</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Id</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> { <span class="ident">dot</span>::<span class="ident">Id</span>::<span class="ident">new</span>(<span class="string">&quot;example3&quot;</span>).<span class="ident">unwrap</span>() }
    <span class="kw">fn</span> <span class="ident">node_id</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>, <span class="ident">n</span>: <span class="kw-2">&amp;</span><span class="ident">Nd</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Id</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
        <span class="ident">dot</span>::<span class="ident">Id</span>::<span class="ident">new</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;N{}&quot;</span>, <span class="ident">n</span>.<span class="number">0</span>)).<span class="ident">unwrap</span>()
    }
    <span class="kw">fn</span> <span class="ident">node_label</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="self">self</span>, <span class="ident">n</span>: <span class="kw-2">&amp;</span><span class="ident">Nd</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">LabelText</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="kw-2">&amp;</span>(<span class="ident">i</span>, _) <span class="op">=</span> <span class="ident">n</span>;
        <span class="ident">dot</span>::<span class="ident">LabelText</span>::<span class="ident">LabelStr</span>(<span class="self">self</span>.<span class="ident">nodes</span>[<span class="ident">i</span>].<span class="ident">into</span>())
    }
    <span class="kw">fn</span> <span class="ident">edge_label</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="self">self</span>, _: <span class="kw-2">&amp;</span><span class="ident">Ed</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">LabelText</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span><span class="op">&gt;</span> {
        <span class="ident">dot</span>::<span class="ident">LabelText</span>::<span class="ident">LabelStr</span>(<span class="string">&quot;&amp;sube;&quot;</span>.<span class="ident">into</span>())
    }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">dot</span>::<span class="ident">GraphWalk</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Graph</span> {
    <span class="kw">type</span> <span class="ident">Node</span> <span class="op">=</span> <span class="ident">Nd</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>;
    <span class="kw">type</span> <span class="ident">Edge</span> <span class="op">=</span> <span class="ident">Ed</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>;
    <span class="kw">fn</span> <span class="ident">nodes</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Nodes</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>,<span class="ident">Nd</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;&gt;</span> {
        <span class="self">self</span>.<span class="ident">nodes</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">s</span><span class="op">|</span> <span class="kw-2">&amp;</span><span class="ident">s</span>[..]).<span class="ident">enumerate</span>().<span class="ident">collect</span>()
    }
    <span class="kw">fn</span> <span class="ident">edges</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">dot</span>::<span class="ident">Edges</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>,<span class="ident">Ed</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;&gt;</span> {
        <span class="self">self</span>.<span class="ident">edges</span>.<span class="ident">iter</span>()
            .<span class="ident">map</span>(<span class="op">|</span><span class="kw-2">&amp;</span>(<span class="ident">i</span>,<span class="ident">j</span>)<span class="op">|</span>((<span class="ident">i</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">nodes</span>[<span class="ident">i</span>][..]),
                          (<span class="ident">j</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">nodes</span>[<span class="ident">j</span>][..])))
            .<span class="ident">collect</span>()
    }
    <span class="kw">fn</span> <span class="ident">source</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">e</span>: <span class="kw-2">&amp;</span><span class="ident">Ed</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Nd</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> { <span class="kw">let</span> <span class="kw-2">&amp;</span>(<span class="ident">s</span>,_) <span class="op">=</span> <span class="ident">e</span>; <span class="ident">s</span> }
    <span class="kw">fn</span> <span class="ident">target</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">e</span>: <span class="kw-2">&amp;</span><span class="ident">Ed</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Nd</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> { <span class="kw">let</span> <span class="kw-2">&amp;</span>(_,<span class="ident">t</span>) <span class="op">=</span> <span class="ident">e</span>; <span class="ident">t</span> }
}
</pre>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">create</span>(<span class="string">&quot;example3.dot&quot;</span>).<span class="ident">unwrap</span>();
    <span class="ident">render_to</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">f</span>)
}</pre>

<h1 id='references' class='section-header'><a href='#references'>References</a></h1>
<ul>
<li><p><a href="http://www.graphviz.org/">Graphviz</a></p></li>
<li><p><a href="http://www.graphviz.org/doc/info/lang.html">DOT language</a></p></li>
</ul>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class='unstable module-item'>
                           <td><a class="struct" href="struct.Id.html"
                                  title='struct graphviz::Id'>Id</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] <p><code>Id</code> is a Graphviz <code>ID</code>.</p>
                           </td>
                       </tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                       <tr class='unstable module-item'>
                           <td><a class="enum" href="enum.LabelText.html"
                                  title='enum graphviz::LabelText'>LabelText</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] <p>The text for a graphviz label on a node or edge.</p>
                           </td>
                       </tr>
                       <tr class='unstable module-item'>
                           <td><a class="enum" href="enum.RenderOption.html"
                                  title='enum graphviz::RenderOption'>RenderOption</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] 
                           </td>
                       </tr>
                       <tr class='unstable module-item'>
                           <td><a class="enum" href="enum.Style.html"
                                  title='enum graphviz::Style'>Style</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] <p>The style for a node or edge.
See <a href="http://www.graphviz.org/doc/info/attrs.html#k:style">http://www.graphviz.org/doc/info/attrs.html#k:style</a> for descriptions.
Note that some of these are not valid for edges.</p>
                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class='unstable module-item'>
                           <td><a class="trait" href="trait.GraphWalk.html"
                                  title='trait graphviz::GraphWalk'>GraphWalk</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] <p>GraphWalk is an abstraction over a directed graph = (nodes,edges)
made up of node handles <code>N</code> and edge handles <code>E</code>, where each <code>E</code>
can be mapped to its source and target nodes.</p>
                           </td>
                       </tr>
                       <tr class='unstable module-item'>
                           <td><a class="trait" href="trait.IntoCow.html"
                                  title='trait graphviz::IntoCow'>IntoCow</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] 
                           </td>
                       </tr>
                       <tr class='unstable module-item'>
                           <td><a class="trait" href="trait.Labeller.html"
                                  title='trait graphviz::Labeller'>Labeller</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] <p>Each instance of a type that implements <code>Label&lt;C&gt;</code> maps to a
unique identifier with respect to <code>C</code>, which is used to identify
it in the generated .dot file. They can also provide more
elaborate (and non-unique) label text that is used in the graphviz
rendered output.
The graph instance is responsible for providing the DOT compatible
identifiers for the nodes and (optionally) rendered labels for the nodes and
edges, as well as an identifier for the graph itself.</p>
                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class='unstable module-item'>
                           <td><a class="fn" href="fn.default_options.html"
                                  title='fn graphviz::default_options'>default_options</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] <p>Returns vec holding all the default render options.</p>
                           </td>
                       </tr>
                       <tr class='unstable module-item'>
                           <td><a class="fn" href="fn.escape_html.html"
                                  title='fn graphviz::escape_html'>escape_html</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] <p>Escape tags in such a way that it is suitable for inclusion in a
Graphviz HTML label.</p>
                           </td>
                       </tr>
                       <tr class='unstable module-item'>
                           <td><a class="fn" href="fn.render.html"
                                  title='fn graphviz::render'>render</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] <p>Renders directed graph <code>g</code> into the writer <code>w</code> in DOT syntax.
(Simple wrapper around <code>render_opts</code> that passes a default set of options.)</p>
                           </td>
                       </tr>
                       <tr class='unstable module-item'>
                           <td><a class="fn" href="fn.render_opts.html"
                                  title='fn graphviz::render_opts'>render_opts</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] <p>Renders directed graph <code>g</code> into the writer <code>w</code> in DOT syntax.
(Main entry point for the library.)</p>
                           </td>
                       </tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                       <tr class='unstable module-item'>
                           <td><a class="type" href="type.Edges.html"
                                  title='type graphviz::Edges'>Edges</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] 
                           </td>
                       </tr>
                       <tr class='unstable module-item'>
                           <td><a class="type" href="type.Nodes.html"
                                  title='type graphviz::Nodes'>Nodes</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] 
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>â†‘</dt>
                    <dd>Move up in search results</dd>
                    <dt>â†“</dt>
                    <dd>Move down in search results</dd>
                    <dt>â†¹</dt>
                    <dd>Switch tab</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "graphviz";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>