<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `DerefString` struct in crate `collections`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, DerefString">

    <title>collections::string::DerefString - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        <a href='../../collections/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../index.html'>collections</a>::<wbr><a href='index.html'>string</a></p><script>window.sidebarCurrent = {name: 'DerefString', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>collections</a>::<wbr><a href='index.html'>string</a>::<wbr><a class='struct' href=''>DerefString</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-29332' class='srclink' href='../../src/collections/string.rs.html#971-973' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct DerefString&lt;'a&gt; {
    // some fields omitted
}</pre><div class='stability'><em class='stab unstable'>Unstable</em></div><div class='docblock'><p>Wrapper type providing a <code>&amp;String</code> reference via <code>Deref</code>.</p>
</div><h2 id='deref-methods'>Methods from <a class='trait' href='../../core/ops/trait.Deref.html' title='core::ops::Deref'>Deref</a>&lt;Target=<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>&gt;</h2><div class='impl-items'><h4 id='method.into_bytes' class='method'><code>fn <a href='#method.into_bytes' class='fnname'>into_bytes</a>(self) -&gt; <a class='struct' href='../../collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a href='../../core/primitive.u8.html'>u8</a>&gt;</code></h4>
<div class='docblock'><p>Returns the underlying byte buffer, encoded as UTF-8.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let s = String::from(&quot;hello&quot;);
    let bytes = s.into_bytes();
    assert_eq!(bytes, [104, 101, 108, 108, 111]);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='kw'>let</span> <span class='ident'>bytes</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>into_bytes</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>bytes</span>, [<span class='number'>104</span>, <span class='number'>101</span>, <span class='number'>108</span>, <span class='number'>108</span>, <span class='number'>111</span>]);
</pre>
</div><h4 id='method.as_str' class='method'><code>fn <a href='#method.as_str' class='fnname'>as_str</a>(&amp;self) -&gt; &amp;<a href='../primitive.str.html'>str</a></code></h4>
<div class='stability'><em class='stab unstable'>Unstable<p>: waiting on RFC revision</p>
</em></div><div class='docblock'><p>Extracts a string slice containing the entire string.</p>
</div><h4 id='method.push_str' class='method'><code>fn <a href='#method.push_str' class='fnname'>push_str</a>(&amp;mut self, string: &amp;<a href='../primitive.str.html'>str</a>)</code></h4>
<div class='docblock'><p>Pushes the given string onto this string buffer.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
    assert_eq!(s, &quot;foobar&quot;);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;bar&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;foobar&quot;</span>);
</pre>
</div><h4 id='method.capacity' class='method'><code>fn <a href='#method.capacity' class='fnname'>capacity</a>(&amp;self) -&gt; <a href='../../core/primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Returns the number of bytes that this string buffer can hold without
reallocating.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let s = String::with_capacity(10);
    assert!(s.capacity() &gt;= 10);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>with_capacity</span>(<span class='number'>10</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>10</span>);
</pre>
</div><h4 id='method.reserve' class='method'><code>fn <a href='#method.reserve' class='fnname'>reserve</a>(&amp;mut self, additional: <a href='../../core/primitive.usize.html'>usize</a>)</code></h4>
<div class='docblock'><p>Reserves capacity for at least <code>additional</code> more bytes to be inserted
in the given <code>String</code>. The collection may reserve more space to avoid
frequent reallocations.</p>

<h1 id="panics" class='section-header'><a
                           href="#panics">Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::new();
    s.reserve(10);
    assert!(s.capacity() &gt;= 10);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='ident'>s</span>.<span class='ident'>reserve</span>(<span class='number'>10</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>10</span>);
</pre>
</div><h4 id='method.reserve_exact' class='method'><code>fn <a href='#method.reserve_exact' class='fnname'>reserve_exact</a>(&amp;mut self, additional: <a href='../../core/primitive.usize.html'>usize</a>)</code></h4>
<div class='docblock'><p>Reserves the minimum capacity for exactly <code>additional</code> more bytes to be
inserted in the given <code>String</code>. Does nothing if the capacity is already
sufficient.</p>

<p>Note that the allocator may give the collection more space than it
requests. Therefore capacity can not be relied upon to be precisely
minimal. Prefer <code>reserve</code> if future insertions are expected.</p>

<h1 id="panics" class='section-header'><a
                           href="#panics">Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::new();
    s.reserve_exact(10);
    assert!(s.capacity() &gt;= 10);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='ident'>s</span>.<span class='ident'>reserve_exact</span>(<span class='number'>10</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>10</span>);
</pre>
</div><h4 id='method.shrink_to_fit' class='method'><code>fn <a href='#method.shrink_to_fit' class='fnname'>shrink_to_fit</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Shrinks the capacity of this string buffer to match its length.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    s.reserve(100);
    assert!(s.capacity() &gt;= 100);
    s.shrink_to_fit();
    assert_eq!(s.capacity(), 3);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>reserve</span>(<span class='number'>100</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>100</span>);
<span class='ident'>s</span>.<span class='ident'>shrink_to_fit</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>(), <span class='number'>3</span>);
</pre>
</div><h4 id='method.push' class='method'><code>fn <a href='#method.push' class='fnname'>push</a>(&amp;mut self, ch: <a href='../../core/primitive.char.html'>char</a>)</code></h4>
<div class='docblock'><p>Adds the given character to the end of the string.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;abc&quot;);
    s.push(&#39;1&#39;);
    s.push(&#39;2&#39;);
    s.push(&#39;3&#39;);
    assert_eq!(s, &quot;abc123&quot;);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;abc&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>push</span>(<span class='string'>&#39;1&#39;</span>);
<span class='ident'>s</span>.<span class='ident'>push</span>(<span class='string'>&#39;2&#39;</span>);
<span class='ident'>s</span>.<span class='ident'>push</span>(<span class='string'>&#39;3&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;abc123&quot;</span>);
</pre>
</div><h4 id='method.as_bytes' class='method'><code>fn <a href='#method.as_bytes' class='fnname'>as_bytes</a>(&amp;self) -&gt; <a href='../primitive.slice.html'>&amp;[</a><a href='../../core/primitive.u8.html'>u8</a><a href='../primitive.slice.html'>]</a></code></h4>
<div class='docblock'><p>Works with the underlying buffer as a byte slice.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let s = String::from(&quot;hello&quot;);
    assert_eq!(s.as_bytes(), [104, 101, 108, 108, 111]);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>as_bytes</span>(), [<span class='number'>104</span>, <span class='number'>101</span>, <span class='number'>108</span>, <span class='number'>108</span>, <span class='number'>111</span>]);
</pre>
</div><h4 id='method.truncate' class='method'><code>fn <a href='#method.truncate' class='fnname'>truncate</a>(&amp;mut self, new_len: <a href='../../core/primitive.usize.html'>usize</a>)</code></h4>
<div class='docblock'><p>Shortens a string to the specified length.</p>

<h1 id="panics" class='section-header'><a
                           href="#panics">Panics</a></h1>
<p>Panics if <code>new_len</code> &gt; current length,
or if <code>new_len</code> is not a character boundary.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;hello&quot;);
    s.truncate(2);
    assert_eq!(s, &quot;he&quot;);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>truncate</span>(<span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;he&quot;</span>);
</pre>
</div><h4 id='method.pop' class='method'><code>fn <a href='#method.pop' class='fnname'>pop</a>(&amp;mut self) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a href='../../core/primitive.char.html'>char</a>&gt;</code></h4>
<div class='docblock'><p>Removes the last character from the string buffer and returns it.
Returns <code>None</code> if this string buffer is empty.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    assert_eq!(s.pop(), Some(&#39;o&#39;));
    assert_eq!(s.pop(), Some(&#39;o&#39;));
    assert_eq!(s.pop(), Some(&#39;f&#39;));
    assert_eq!(s.pop(), None);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='string'>&#39;o&#39;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='string'>&#39;o&#39;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='string'>&#39;f&#39;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>None</span>);
</pre>
</div><h4 id='method.remove' class='method'><code>fn <a href='#method.remove' class='fnname'>remove</a>(&amp;mut self, idx: <a href='../../core/primitive.usize.html'>usize</a>) -&gt; <a href='../../core/primitive.char.html'>char</a></code></h4>
<div class='docblock'><p>Removes the character from the string buffer at byte position <code>idx</code> and
returns it.</p>

<h1 id="warning" class='section-header'><a
                           href="#warning">Warning</a></h1>
<p>This is an O(n) operation as it requires copying every element in the
buffer.</p>

<h1 id="panics" class='section-header'><a
                           href="#panics">Panics</a></h1>
<p>If <code>idx</code> does not lie on a character boundary, or if it is out of
bounds, then this function will panic.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    assert_eq!(s.remove(0), &#39;f&#39;);
    assert_eq!(s.remove(1), &#39;o&#39;);
    assert_eq!(s.remove(0), &#39;o&#39;);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>remove</span>(<span class='number'>0</span>), <span class='string'>&#39;f&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>remove</span>(<span class='number'>1</span>), <span class='string'>&#39;o&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>remove</span>(<span class='number'>0</span>), <span class='string'>&#39;o&#39;</span>);
</pre>
</div><h4 id='method.insert' class='method'><code>fn <a href='#method.insert' class='fnname'>insert</a>(&amp;mut self, idx: <a href='../../core/primitive.usize.html'>usize</a>, ch: <a href='../../core/primitive.char.html'>char</a>)</code></h4>
<div class='docblock'><p>Inserts a character into the string buffer at byte position <code>idx</code>.</p>

<h1 id="warning" class='section-header'><a
                           href="#warning">Warning</a></h1>
<p>This is an O(n) operation as it requires copying every element in the
buffer.</p>

<h1 id="panics" class='section-header'><a
                           href="#panics">Panics</a></h1>
<p>If <code>idx</code> does not lie on a character boundary or is out of bounds, then
this function will panic.</p>
</div><h4 id='method.as_mut_vec' class='method'><code>unsafe fn <a href='#method.as_mut_vec' class='fnname'>as_mut_vec</a>(&amp;mut self) -&gt; &amp;mut <a class='struct' href='../../collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a href='../../core/primitive.u8.html'>u8</a>&gt;</code></h4>
<div class='docblock'><p>Views the string buffer as a mutable sequence of bytes.</p>

<p>This is unsafe because it does not check
to ensure that the resulting string will be valid UTF-8.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;hello&quot;);
    unsafe {
        let vec = s.as_mut_vec();
        assert!(vec == &amp;[104, 101, 108, 108, 111]);
        vec.reverse();
    }
    assert_eq!(s, &quot;olleh&quot;);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='kw'>unsafe</span> {
    <span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>as_mut_vec</span>();
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>vec</span> <span class='op'>==</span> <span class='kw-2'>&amp;</span>[<span class='number'>104</span>, <span class='number'>101</span>, <span class='number'>108</span>, <span class='number'>108</span>, <span class='number'>111</span>]);
    <span class='ident'>vec</span>.<span class='ident'>reverse</span>();
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;olleh&quot;</span>);
</pre>
</div><h4 id='method.len' class='method'><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a href='../../core/primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Returns the number of bytes in this string.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let a = &quot;foo&quot;.to_string();
    assert_eq!(a.len(), 3);
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>.<span class='ident'>to_string</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>len</span>(), <span class='number'>3</span>);
</pre>
</div><h4 id='method.is_empty' class='method'><code>fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a href='../../core/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if the string contains no bytes</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let mut v = String::new();
    assert!(v.is_empty());
    v.push(&#39;a&#39;);
    assert!(!v.is_empty());
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span>.<span class='ident'>is_empty</span>());
<span class='ident'>v</span>.<span class='ident'>push</span>(<span class='string'>&#39;a&#39;</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>v</span>.<span class='ident'>is_empty</span>());
</pre>
</div><h4 id='method.clear' class='method'><code>fn <a href='#method.clear' class='fnname'>clear</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Truncates the string, returning it to 0 length.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = &quot;foo&quot;.to_string();
    s.clear();
    assert!(s.is_empty());
    
}</span><pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>.<span class='ident'>to_string</span>();
<span class='ident'>s</span>.<span class='ident'>clear</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>is_empty</span>());
</pre>
</div><h4 id='method.drain' class='method'><code>fn <a href='#method.drain' class='fnname'>drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class='struct' href='../../collections/string/struct.Drain.html' title='collections::string::Drain'>Drain</a> <span class='where'>where R: <a class='trait' href='../../collections/range/trait.RangeArgument.html' title='collections::range::RangeArgument'>RangeArgument</a>&lt;<a href='../../core/primitive.usize.html'>usize</a>&gt;</span></code></h4>
<div class='stability'><em class='stab unstable'>Unstable<p>: recently added, matches RFC</p>
</em></div><div class='docblock'><p>Create a draining iterator that removes the specified range in the string
and yields the removed chars from start to end. The element range is
removed even if the iterator is not consumed until the end.</p>

<h1 id="panics" class='section-header'><a
                           href="#panics">Panics</a></h1>
<p>Panics if the starting point or end point are not on character boundaries,
or if they are out of bounds.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span class='rusttest'>#![feature(collections_drain)]

extern crate collections;
fn main() {
    let mut s = String::from(&quot;α is alpha, β is beta&quot;);
    let beta_offset = s.find(&#39;β&#39;).unwrap_or(s.len());
    
    // Remove the range up until the β from the string
    let t: String = s.drain(..beta_offset).collect();
    assert_eq!(t, &quot;α is alpha, &quot;);
    assert_eq!(s, &quot;β is beta&quot;);
    
    // A full range clears the string
    s.drain(..);
    assert_eq!(s, &quot;&quot;);
    
}</span><pre id='rust-example-rendered' class='rust '>

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;α is alpha, β is beta&quot;</span>);
<span class='kw'>let</span> <span class='ident'>beta_offset</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>find</span>(<span class='string'>&#39;β&#39;</span>).<span class='ident'>unwrap_or</span>(<span class='ident'>s</span>.<span class='ident'>len</span>());

<span class='comment'>// Remove the range up until the β from the string</span>
<span class='kw'>let</span> <span class='ident'>t</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>drain</span>(..<span class='ident'>beta_offset</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>t</span>, <span class='string'>&quot;α is alpha, &quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;β is beta&quot;</span>);

<span class='comment'>// A full range clears the string</span>
<span class='ident'>s</span>.<span class='ident'>drain</span>(..);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;&quot;</span>);
</pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../core/ops/trait.Deref.html' title='core::ops::Deref'>Deref</a> for <a class='struct' href='../../collections/string/struct.DerefString.html' title='collections::string::DerefString'>DerefString</a>&lt;'a&gt;</code></h3><div class='impl-items'><h4 id='assoc_type.Target' class='type'><code>type Target = <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
<h4 id='method.deref' class='method'><code>fn <a href='../../core/ops/trait.Deref.html#method.deref' class='fnname'>deref</a>&lt;'b&gt;(&amp;'b self) -&gt; &amp;'b <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
            <p>
                Search functions by type signature (e.g.
                <code>vec -> usize</code>)
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "collections";
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script src="../../playpen.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>