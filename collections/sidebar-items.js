initSidebarItems({"enum":[["Bound","An endpoint of a range of keys."]],"macro":[["format!","Use the syntax described in `std::fmt` to create a value of type `String`. See `std::fmt` for more information.Examples"],["vec!","Creates a `Vec` containing the arguments.`vec!` allows `Vec`s to be defined with the same syntax as array expressions. There are two forms of this macro:Create a `Vec` containing a given list of elements: Create a `Vec` from a given element and size: Note that unlike array expressions this syntax supports all elements which implement `Clone` and the number of elements doesn't have to be a constant.This will use `clone()` to duplicate an expression, so one should be careful using this with types having a nonstandard `Clone` implementation. For example, `vec![Rc::new(1); 5]` will create a vector of five references to the same boxed integer value, not five references pointing to independently boxed integers."]],"mod":[["binary_heap","A priority queue implemented with a binary heap.Insertion and popping the largest element have `O(log n)` time complexity. Checking the largest element is `O(1)`. Converting a vector to a binary heap can be done in-place, and has `O(n)` complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an `O(n log n)` in-place heapsort.ExamplesThis is a larger example that implements Dijkstra's algorithm to solve the shortest path problem on a directed graph. It shows how to use `BinaryHeap` with custom types."],["borrow","A module for working with borrowed data."],["boxed","A pointer type for heap allocation.`Box<T>`, casually referred to as a 'box', provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope.ExamplesCreating a box:Creating a recursive data structure:This will print `Cons(1, Cons(2, Nil))`.Recursive structures must be boxed, because if the definition of `Cons` looked like this:It wouldn't work. This is because the size of a `List` depends on how many elements are in the list, and so we don't know how much memory to allocate for a `Cons`. By introducing a `Box`, which has a defined size, we know how big `Cons` needs to be."],["btree_map",""],["btree_set",""],["enum_set","A structure for holding a set of enum variants.This module defines a container which uses an efficient bit mask representation to hold C-like enum variants."],["fmt","Utilities for formatting and printing stringsThis module contains the runtime support for the `format!` syntax extension. This macro is implemented in the compiler to emit calls to this module in order to format arguments at runtime into strings and streams.UsageThe `format!` macro is intended to be familiar to those coming from C's printf/fprintf functions or Python's `str.format` function. In its current revision, the `format!` macro returns a `String` type which is the result of the formatting. In the future it will also be able to pass in a stream to format arguments directly while performing minimal allocations.Some examples of the `format!` extension are:From these, you can see that the first argument is a format string. It is required by the compiler for this to be a string literal; it cannot be a variable passed in (in order to perform validity checking). The compiler will then parse the format string and determine if the list of arguments provided is suitable to pass to this format string.Positional parametersEach formatting argument is allowed to specify which value argument it's referencing, and if omitted it is assumed to be \"the next argument\". For example, the format string `{} {} {}` would take three parameters, and they would be formatted in the same order as they're given. The format string `{2} {1} {0}`, however, would format arguments in reverse order.Things can get a little tricky once you start intermingling the two types of positional specifiers. The \"next argument\" specifier can be thought of as an iterator over the argument. Each time a \"next argument\" specifier is seen, the iterator advances. This leads to behavior like this:The internal iterator over the argument has not been advanced by the time the first `{}` is seen, so it prints the first argument. Then upon reaching the second `{}`, the iterator has advanced forward to the second argument. Essentially, parameters which explicitly name their argument do not affect parameters which do not name an argument in terms of positional specifiers.A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string, although it must always be referred to with the same type.Named parametersRust itself does not have a Python-like equivalent of named parameters to a function, but the `format!` macro is a syntax extension which allows it to leverage named parameters. Named parameters are listed at the end of the argument list and have the syntax:For example, the following `format!` expressions all use named argument:It is not valid to put positional parameters (those without names) after arguments which have names. Like with positional parameters, it is not valid to provide named parameters that are unused by the format string.Argument typesEach argument's type is dictated by the format string. It is a requirement that every argument is only ever referred to by one type. For example, this is an invalid format string:This is invalid because the first argument is both referred to as a hexadecimal as well as an octal.There are various parameters which do require a particular type, however. Namely, the `{:.*}` syntax, which sets the number of numbers after the decimal in floating-point types:If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type `usize`. Although a `usize` can be printed with `{}`, it is invalid to reference an argument as such. For example this is another invalid format string:Formatting traitsWhen requesting that an argument be formatted with a particular type, you are actually requesting that an argument ascribes to a particular trait. This allows multiple actual types to be formatted via `{:x}` (like `i8` as well as `isize`).  The current mapping of types to traits is:*nothing* ⇒ `Display` `?` ⇒ `Debug` `o` ⇒ `Octal` `x` ⇒ `LowerHex` `X` ⇒ `UpperHex` `p` ⇒ `Pointer` `b` ⇒ `Binary` `e` ⇒ `LowerExp` `E` ⇒ `UpperExp` What this means is that any type of argument which implements the `fmt::Binary` trait can then be formatted with `{:b}`. Implementations are provided for these traits for a number of primitive types by the standard library as well. If no format is specified (as in `{}` or `{:6}`), then the format trait used is the `Display` trait.When implementing a format trait for your own type, you will have to implement a method of the signature:Your type will be passed as `self` by-reference, and then the function should emit output into the `f.buf` stream. It is up to each format trait implementation to correctly adhere to the requested formatting parameters. The values of these parameters will be listed in the fields of the `Formatter` struct. In order to help with this, the `Formatter` struct also provides some helper methods.Additionally, the return value of this function is `fmt::Result` which is a typedef to `Result<(), std::io::Error>` (also known as `std::io::Result<()>`). Formatting implementations should ensure that they return errors from `write!` correctly (propagating errors upward).An example of implementing the formatting traits would look like:`fmt::Display` vs `fmt::Debug`These two formatting traits have distinct purposes:`fmt::Display` implementations assert that the type can be faithfully represented as a UTF-8 string at all times. It is **not** expected that all types implement the `Display` trait. `fmt::Debug` implementations should be implemented for **all** public types. Output will typically represent the internal state as faithfully as possible. The purpose of the `Debug` trait is to facilitate debugging Rust code. In most cases, using `#[derive(Debug)]` is sufficient and recommended. Some examples of the output from both traits:Related macrosThere are a number of related macros in the `format!` family. The ones that are currently implemented are:`write!`This and `writeln` are two macros which are used to emit the format string to a specified stream. This is used to prevent intermediate allocations of format strings and instead directly write the output. Under the hood, this function is actually invoking the `write` function defined in this module. Example usage is:`print!`This and `println` emit their output to stdout. Similarly to the `write!` macro, the goal of these macros is to avoid intermediate allocations when printing output. Example usage is:`format_args!`This is a curious macro which is used to safely pass around an opaque object describing the format string. This object does not require any heap allocations to create, and it only references information on the stack. Under the hood, all of the related macros are implemented in terms of this. First off, some example usage is:The result of the `format_args!` macro is a value of type `fmt::Arguments`. This structure can then be passed to the `write` and `format` functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing formatting strings.For example, a logging library could use the standard formatting syntax, but it would internally pass around this structure until it has been determined where output should go to.SyntaxThe syntax for the formatting language used is drawn from other languages, so it should not be too alien. Arguments are formatted with python-like syntax, meaning that arguments are surrounded by `{}` instead of the C-like `%`. The actual grammar for the formatting syntax is:Formatting ParametersEach argument being formatted can be transformed by a number of formatting parameters (corresponding to `format_spec` in the syntax above). These parameters affect the string representation of what's being formatted. This syntax draws heavily from Python's, so it may seem a bit familiar.Fill/AlignmentThe fill character is provided normally in conjunction with the `width` parameter. This indicates that if the value being formatted is smaller than `width` some extra characters will be printed around it. The extra characters are specified by `fill`, and the alignment can be one of the following options:`<` - the argument is left-aligned in `width` columns `^` - the argument is center-aligned in `width` columns `>` - the argument is right-aligned in `width` columns Note that alignment may not be implemented by some types. A good way to ensure padding is applied is to format your input, then use this resulting string to pad your output.Sign/`#`/`0`These can all be interpreted as flags for a particular formatter.`+` - This is intended for numeric types and indicates that the sign     should always be printed. Positive signs are never printed by     default, and the negative sign is only printed by default for the     `Signed` trait. This flag indicates that the correct sign (`+` or `-`)     should always be printed. `-` - Currently not used `#` - This flag is indicates that the \"alternate\" form of printing should     be used. The alternate forms are: `#?` - pretty-print the `Debug` formatting `#x` - precedes the argument with a `0x` `#X` - precedes the argument with a `0x` `#b` - precedes the argument with a `0b` `#o` - precedes the argument with a `0o` `0` - This is used to indicate for integer formats that the padding should     both be done with a `0` character as well as be sign-aware. A format     like `{:08}` would yield `00000001` for the integer `1`, while the     same format would yield `-0000001` for the integer `-1`. Notice that     the negative version has one fewer zero than the positive version. WidthThis is a parameter for the \"minimum width\" that the format should take up. If the value's string does not fill up this many characters, then the padding specified by fill/alignment will be used to take up the required space.The default fill/alignment for non-numerics is a space and left-aligned. The defaults for numeric formatters is also a space but with right-alignment. If the `0` flag is specified for numerics, then the implicit fill character is `0`.The value for the width can also be provided as a `usize` in the list of parameters by using the `2$` syntax indicating that the second argument is a `usize` specifying the width.PrecisionFor non-numeric types, this can be considered a \"maximum width\". If the resulting string is longer than this width, then it is truncated down to this many characters and only those are emitted.For integral types, this is ignored.For floating-point types, this indicates how many digits after the decimal point should be printed.There are three possible ways to specify the desired `precision`:An integer `.N`:the integer `N` itself is the precision.An integer followed by dollar sign `.N$`:use format *argument* `N` (which must be a `usize`) as the precision.An asterisk `.*`:`.*` means that this `{...}` is associated with *two* format inputs rather than one: the first input holds the `usize` precision, and the second holds the value to print.  Note that in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers to the *value* to print, and the `precision` must come in the input preceding `<arg>`.For example, these:All print the same thing:While these:print two significantly different things:EscapingThe literal characters `{` and `}` may be included in a string by preceding them with the same character. For example, the `{` character is escaped with `{{` and the `}` character is escaped with `}}`."],["linked_list","A doubly-linked list with owned nodes.The `LinkedList` allows pushing and popping elements at either end and is thus efficiently usable as a double-ended queue."],["range","Range syntax."],["slice","A dynamically-sized view into a contiguous sequence, `[T]`.Slices are a view into a block of memory represented as a pointer and a length.Slices are either mutable or shared. The shared slice type is `&[T]`, while the mutable slice type is `&mut [T]`, where `T` represents the element type. For example, you can mutate the block of memory that a mutable slice points to:Here are some of the things this module contains:StructsThere are several structs that are useful for slices, such as `Iter`, which represents iteration over a slice.Trait ImplementationsThere are several implementations of common traits for slices. Some examples include:`Clone` `Eq`, `Ord` - for slices whose element type are `Eq` or `Ord`. `Hash` - for slices whose element type is `Hash` IterationThe slices implement `IntoIterator`. The iterator yields references to the slice elements.The mutable slice yields mutable references to the elements:This iterator yields mutable references to the slice's elements, so while the element type of the slice is `i32`, the element type of the iterator is `&mut i32`.`.iter()` and `.iter_mut()` are the explicit methods to return the default iterators. Further methods that return iterators are `.split()`, `.splitn()`, `.chunks()`, `.windows()` and more. *See also the slice primitive type.*"],["str","Unicode string slices*See also the `str` primitive type.*"],["string","A UTF-8 encoded, growable string.This module contains the `String` type, a trait for converting `ToString`s, and several error types that may result from working with `String`s.ExamplesThere are multiple ways to create a new `String` from a string literal:You can create a new `String` from an existing one by concatenating with `+`:If you have a vector of valid UTF-8 bytes, you can make a `String` out of it. You can do the reverse too."],["vec","A contiguous growable array type with heap-allocated contents, written `Vec<T>` but pronounced 'vector.'Vectors have `O(1)` indexing, amortized `O(1)` push (to the end) and `O(1)` pop (from the end).ExamplesYou can explicitly create a `Vec<T>` with `new()`:...or by using the `vec!` macro:You can `push` values onto the end of a vector (which will grow the vector as needed):Popping values works in much the same way:Vectors also support indexing (through the `Index` and `IndexMut` traits):"],["vec_deque","VecDeque is a double-ended queue, which is implemented with the help of a growing ring buffer.This queue has `O(1)` amortized inserts and removals from both ends of the container. It also has `O(1)` indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable."]],"struct":[["BTreeMap","A map based on a B-Tree.B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log<sub>2</sub>n). However, in practice the way this is done is *very* inefficient for modern computer architectures. In particular, every element is stored in its own individually heap-allocated node. This means that every single insertion triggers a heap-allocation, and every single comparison should be a cache-miss. Since these are both notably expensive things to do in practice, we are forced to at very least reconsider the BST strategy.A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do *more* comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i<sup>th</sup> element for some choice of i.Currently, our implementation simply performs naive linear search. This provides excellent performance on *small* nodes of elements which are cheap to compare. However in the future we would like to further explore choosing the optimal search strategy based on the choice of B, and possibly other factors. Using linear search, searching for a random element is expected to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice, however, performance is excellent.It is a logic error for a key to be modified in such a way that the key's ordering relative to any other key, as determined by the `Ord` trait, changes while it is in the map. This is normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code."],["BTreeSet","A set based on a B-Tree.See `BTreeMap`'s documentation for a detailed discussion of this collection's performance benefits and drawbacks.It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the `Ord` trait, changes while it is in the set. This is normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code."]]});